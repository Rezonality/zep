/* Amalgamated build - DO NOT EDIT */
/* Generated from janet version 1.26.0-c28df14 */
#define JANET_BUILD "c28df14"
#define JANET_AMALG

/* src/core/features.h */
#line 0 "src/core/features.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

/* Feature test macros */

#ifndef JANET_FEATURES_H_defined
#define JANET_FEATURES_H_defined

#if defined(__NetBSD__) || defined(__APPLE__) || defined(__OpenBSD__) \
    || defined(__bsdi__) || defined(__DragonFly__)
/* Use BSD source on any BSD systems, include OSX */
# define _BSD_SOURCE
#else
/* Use POSIX feature flags */
# ifndef _POSIX_C_SOURCE
# define _POSIX_C_SOURCE 200809L
# endif
#endif

/* Needed for sched.h for cpu count */
#ifdef __linux__
#define _GNU_SOURCE
#endif

#if defined(WIN32) || defined(_WIN32)
#define WIN32_LEAN_AND_MEAN
#endif

/* Needed for realpath on linux, as well as pthread rwlocks. */
#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif
#if _XOPEN_SOURCE < 600
#undef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif

/* Needed for timegm and other extensions when building with -std=c99.
 * It also defines realpath, etc, which would normally require
 * _XOPEN_SOURCE >= 500. */
#if !defined(_NETBSD_SOURCE) && defined(__NetBSD__)
#define _NETBSD_SOURCE
#endif

#endif

#include "janet.h"

/* src/core/state.h */
#line 0 "src/core/state.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_STATE_H_defined
#define JANET_STATE_H_defined

#include <stdint.h>

#ifdef JANET_EV
#ifndef JANET_WINDOWS
#include <pthread.h>
#endif
#endif

typedef int64_t JanetTimestamp;

typedef struct JanetScratch {
    JanetScratchFinalizer finalize;
    long long mem[]; /* for proper alignment */
} JanetScratch;

typedef struct {
    JanetGCObject *self;
    JanetGCObject *other;
    int32_t index;
    int32_t index2;
} JanetTraversalNode;

typedef struct {
    int32_t capacity;
    int32_t head;
    int32_t tail;
    void *data;
} JanetQueue;

typedef struct {
    JanetTimestamp when;
    JanetFiber *fiber;
    JanetFiber *curr_fiber;
    uint32_t sched_id;
    int is_error;
} JanetTimeout;

/* Registry table for C functions - containts metadata that can
 * be looked up by cfunction pointer. All strings here are pointing to
 * static memory not managed by Janet. */
typedef struct {
    JanetCFunction cfun;
    const char *name;
    const char *name_prefix;
    const char *source_file;
    int32_t source_line;
    /* int32_t min_arity; */
    /* int32_t max_arity; */
} JanetCFunRegistry;

struct JanetVM {
    /* Place for user data */
    void *user;

    /* Top level dynamic bindings */
    JanetTable *top_dyns;

    /* Cache the core environment */
    JanetTable *core_env;

    /* How many VM stacks have been entered */
    int stackn;

    /* If this flag is true, suspend on function calls and backwards jumps.
     * When this occurs, this flag will be reset to 0. */
    int auto_suspend;

    /* The current running fiber on the current thread.
     * Set and unset by janet_run. */
    JanetFiber *fiber;
    JanetFiber *root_fiber;

    /* The current pointer to the inner most jmp_buf. The current
     * return point for panics. */
    jmp_buf *signal_buf;
    Janet *return_reg;

    /* The global registry for c functions. Used to store meta-data
     * along with otherwise bare c function pointers. */
    JanetCFunRegistry *registry;
    size_t registry_cap;
    size_t registry_count;
    int registry_dirty;

    /* Registry for abstract abstract types that can be marshalled.
     * We need this to look up the constructors when unmarshalling. */
    JanetTable *abstract_registry;

    /* Immutable value cache */
    const uint8_t **cache;
    uint32_t cache_capacity;
    uint32_t cache_count;
    uint32_t cache_deleted;
    uint8_t gensym_counter[8];

    /* Garbage collection */
    void *blocks;
    size_t gc_interval;
    size_t next_collection;
    size_t block_count;
    int gc_suspend;

    /* GC roots */
    Janet *roots;
    size_t root_count;
    size_t root_capacity;

    /* Scratch memory */
    JanetScratch **scratch_mem;
    size_t scratch_cap;
    size_t scratch_len;

    /* Random number generator */
    JanetRNG rng;

    /* Traversal pointers */
    JanetTraversalNode *traversal;
    JanetTraversalNode *traversal_top;
    JanetTraversalNode *traversal_base;

    /* Event loop and scheduler globals */
#ifdef JANET_EV
    size_t tq_count;
    size_t tq_capacity;
    JanetQueue spawn;
    JanetTimeout *tq;
    JanetRNG ev_rng;
    JanetListenerState **listeners;
    size_t listener_count;
    size_t listener_cap;
    size_t extra_listeners;
    JanetTable threaded_abstracts; /* All abstract types that can be shared between threads (used in this thread) */
#ifdef JANET_WINDOWS
    void **iocp;
#elif defined(JANET_EV_EPOLL)
    pthread_attr_t new_thread_attr;
    JanetHandle selfpipe[2];
    int epoll;
    int timerfd;
    int timer_enabled;
#elif defined(JANET_EV_KQUEUE)
    pthread_attr_t new_thread_attr;
    JanetHandle selfpipe[2];
    int kq;
    int timer;
    int timer_enabled;
#else
    pthread_attr_t new_thread_attr;
    JanetHandle selfpipe[2];
    struct pollfd *fds;
#endif
#endif

};

extern JANET_THREAD_LOCAL JanetVM janet_vm;

#ifdef JANET_NET
void janet_net_init(void);
void janet_net_deinit(void);
#endif

#ifdef JANET_EV
void janet_ev_init(void);
void janet_ev_deinit(void);
#endif

#endif /* JANET_STATE_H_defined */


/* src/core/util.h */
#line 0 "src/core/util.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_UTIL_H_defined
#define JANET_UTIL_H_defined

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#endif

#include <stdio.h>
#include <errno.h>
#include <stddef.h>
#include <stdbool.h>

#ifdef JANET_EV
#ifndef JANET_WINDOWS
#include <pthread.h>
#endif
#endif

#if !defined(JANET_REDUCED_OS) || !defined(JANET_SINGLE_THREADED)
#include <time.h>
#define JANET_GETTIME
#endif

/* Handle runtime errors */
#ifndef JANET_EXIT
#include <stdio.h>
#define JANET_EXIT(m) do { \
    fprintf(stderr, "C runtime error at line %d in file %s: %s\n",\
        __LINE__,\
        __FILE__,\
        (m));\
    exit(1);\
} while (0)
#endif

#define JANET_MARSHAL_DECREF 0x40000

#define janet_assert(c, m) do { \
    if (!(c)) JANET_EXIT((m)); \
} while (0)

/* Utils */
uint32_t janet_hash_mix(uint32_t input, uint32_t more);
#define janet_maphash(cap, hash) ((uint32_t)(hash) & (cap - 1))
int janet_valid_utf8(const uint8_t *str, int32_t len);
int janet_is_symbol_char(uint8_t c);
extern const char janet_base64[65];
int32_t janet_array_calchash(const Janet *array, int32_t len);
int32_t janet_kv_calchash(const JanetKV *kvs, int32_t len);
int32_t janet_string_calchash(const uint8_t *str, int32_t len);
int32_t janet_tablen(int32_t n);
void safe_memcpy(void *dest, const void *src, size_t len);
void janet_buffer_push_types(JanetBuffer *buffer, int types);
const JanetKV *janet_dict_find(const JanetKV *buckets, int32_t cap, Janet key);
void janet_memempty(JanetKV *mem, int32_t count);
void *janet_memalloc_empty(int32_t count);
JanetTable *janet_get_core_table(const char *name);
void janet_def_addflags(JanetFuncDef *def);
const void *janet_strbinsearch(
    const void *tab,
    size_t tabcount,
    size_t itemsize,
    const uint8_t *key);
void janet_buffer_format(
    JanetBuffer *b,
    const char *strfrmt,
    int32_t argstart,
    int32_t argc,
    Janet *argv);
Janet janet_next_impl(Janet ds, Janet key, int is_interpreter);
JanetBinding janet_binding_from_entry(Janet entry);

/* Registry functions */
void janet_registry_put(
    JanetCFunction key,
    const char *name,
    const char *name_prefix,
    const char *source_file,
    int32_t source_line);
JanetCFunRegistry *janet_registry_get(JanetCFunction key);

/* Inside the janet core, defining globals is different
 * at bootstrap time and normal runtime */
#ifdef JANET_BOOTSTRAP
#define JANET_CORE_REG JANET_REG
#define JANET_CORE_FN JANET_FN
#define JANET_CORE_DEF JANET_DEF
#define janet_core_def_sm janet_def_sm
#define janet_core_cfuns_ext janet_cfuns_ext
#else
#define JANET_CORE_REG JANET_REG_S
#define JANET_CORE_FN JANET_FN_S
#define JANET_CORE_DEF(ENV, NAME, X, DOC) janet_core_def_sm(ENV, NAME, X, DOC, NULL, 0)
void janet_core_def_sm(JanetTable *env, const char *name, Janet x, const void *p, const void *sf, int32_t sl);
void janet_core_cfuns_ext(JanetTable *env, const char *regprefix, const JanetRegExt *cfuns);
#endif

/* Clock gettime */
#ifdef JANET_GETTIME
int janet_gettime(struct timespec *spec);
#endif

/* strdup */
#ifdef JANET_WINDOWS
#define strdup(x) _strdup(x)
#endif

/* Use LoadLibrary on windows or dlopen on posix to load dynamic libaries
 * with native code. */
#if defined(JANET_NO_DYNAMIC_MODULES)
typedef int Clib;
#define load_clib(name) ((void) name, 0)
#define symbol_clib(lib, sym) ((void) lib, (void) sym, NULL)
#define error_clib() "dynamic libraries not supported"
#define free_clib(c) ((void) (c), 0)
#elif defined(JANET_WINDOWS)
#include <windows.h>
typedef HINSTANCE Clib;
void *symbol_clib(Clib clib, const char *sym);
void free_clib(Clib clib);
Clib load_clib(const char *name);
char *error_clib(void);
#else
#include <dlfcn.h>
typedef void *Clib;
#define load_clib(name) dlopen((name), RTLD_NOW)
#define free_clib(lib) dlclose((lib))
#define symbol_clib(lib, sym) dlsym((lib), (sym))
#define error_clib() dlerror()
#endif
char *get_processed_name(const char *name);

#define RETRY_EINTR(RC, CALL) do { (RC) = CALL; } while((RC) < 0 && errno == EINTR)

/* Initialize builtin libraries */
void janet_lib_io(JanetTable *env);
void janet_lib_math(JanetTable *env);
void janet_lib_array(JanetTable *env);
void janet_lib_tuple(JanetTable *env);
void janet_lib_buffer(JanetTable *env);
void janet_lib_table(JanetTable *env);
void janet_lib_struct(JanetTable *env);
void janet_lib_fiber(JanetTable *env);
void janet_lib_os(JanetTable *env);
void janet_lib_string(JanetTable *env);
void janet_lib_marsh(JanetTable *env);
void janet_lib_parse(JanetTable *env);
#ifdef JANET_ASSEMBLER
void janet_lib_asm(JanetTable *env);
#endif
void janet_lib_compile(JanetTable *env);
void janet_lib_debug(JanetTable *env);
#ifdef JANET_PEG
void janet_lib_peg(JanetTable *env);
#endif
#ifdef JANET_TYPED_ARRAY
void janet_lib_typed_array(JanetTable *env);
#endif
#ifdef JANET_INT_TYPES
void janet_lib_inttypes(JanetTable *env);
#endif
#ifdef JANET_NET
void janet_lib_net(JanetTable *env);
extern const JanetAbstractType janet_address_type;
#endif
#ifdef JANET_EV
void janet_lib_ev(JanetTable *env);
void janet_ev_mark(void);
int janet_make_pipe(JanetHandle handles[2], int mode);
#endif
#ifdef JANET_FFI
void janet_lib_ffi(JanetTable *env);
#endif

#endif


/* src/core/gc.h */
#line 0 "src/core/gc.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_GC_H
#define JANET_GC_H

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#endif

/* The metadata header associated with an allocated block of memory */
#define janet_gc_header(mem) ((JanetGCObject *)(mem))

#define JANET_MEM_TYPEBITS 0xFF
#define JANET_MEM_REACHABLE 0x100
#define JANET_MEM_DISABLED 0x200

#define janet_gc_settype(m, t) ((janet_gc_header(m)->flags |= (0xFF & (t))))
#define janet_gc_type(m) (janet_gc_header(m)->flags & 0xFF)

#define janet_gc_mark(m) (janet_gc_header(m)->flags |= JANET_MEM_REACHABLE)
#define janet_gc_reachable(m) (janet_gc_header(m)->flags & JANET_MEM_REACHABLE)

/* Memory types for the GC. Different from JanetType to include funcenv and funcdef. */
enum JanetMemoryType {
    JANET_MEMORY_NONE,
    JANET_MEMORY_STRING,
    JANET_MEMORY_SYMBOL,
    JANET_MEMORY_ARRAY,
    JANET_MEMORY_TUPLE,
    JANET_MEMORY_TABLE,
    JANET_MEMORY_STRUCT,
    JANET_MEMORY_FIBER,
    JANET_MEMORY_BUFFER,
    JANET_MEMORY_FUNCTION,
    JANET_MEMORY_ABSTRACT,
    JANET_MEMORY_FUNCENV,
    JANET_MEMORY_FUNCDEF,
    JANET_MEMORY_THREADED_ABSTRACT,
};

/* To allocate collectable memory, one must call janet_alloc, initialize the memory,
 * and then call when janet_enablegc when it is initailize and reachable by the gc (on the JANET stack) */
void *janet_gcalloc(enum JanetMemoryType type, size_t size);

#endif


/* src/core/vector.h */
#line 0 "src/core/vector.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_VECTOR_H_defined
#define JANET_VECTOR_H_defined

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#endif

/*
 * vector code modified from
 * https://github.com/nothings/stb/blob/master/stretchy_buffer.h
*/

/* This is mainly used code such as the assembler or compiler, which
 * need vector like data structures that are only garbage collected in case
 * of an error, and normally rely on malloc/free. */

#define janet_v_free(v)         (((v) != NULL) ? (janet_sfree(janet_v__raw(v)), 0) : 0)
#define janet_v_push(v, x)      (janet_v__maybegrow(v, 1), (v)[janet_v__cnt(v)++] = (x))
#define janet_v_pop(v)          (janet_v_count(v) ? janet_v__cnt(v)-- : 0)
#define janet_v_count(v)        (((v) != NULL) ? janet_v__cnt(v) : 0)
#define janet_v_last(v)         ((v)[janet_v__cnt(v) - 1])
#define janet_v_empty(v)        (((v) != NULL) ? (janet_v__cnt(v) = 0) : 0)
#define janet_v_flatten(v)      (janet_v_flattenmem((v), sizeof(*(v))))

#define janet_v__raw(v) ((int32_t *)(v) - 2)
#define janet_v__cap(v) janet_v__raw(v)[0]
#define janet_v__cnt(v) janet_v__raw(v)[1]

#define janet_v__needgrow(v, n)  ((v) == NULL || janet_v__cnt(v) + (n) >= janet_v__cap(v))
#define janet_v__maybegrow(v, n) (janet_v__needgrow((v), (n)) ? janet_v__grow((v), (n)) : 0)
#define janet_v__grow(v, n)      ((v) = janet_v_grow((v), (n), sizeof(*(v))))

/* Actual functions defined in vector.c */
void *janet_v_grow(void *v, int32_t increment, int32_t itemsize);
void *janet_v_flattenmem(void *v, int32_t itemsize);

#endif


/* src/core/fiber.h */
#line 0 "src/core/fiber.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_FIBER_H_defined
#define JANET_FIBER_H_defined

#ifndef JANET_AMALG
#include <janet.h>
#endif

/* Fiber signal masks. */
#define JANET_FIBER_MASK_ERROR 2
#define JANET_FIBER_MASK_DEBUG 4
#define JANET_FIBER_MASK_YIELD 8

#define JANET_FIBER_MASK_USER0 (16 << 0)
#define JANET_FIBER_MASK_USER1 (16 << 1)
#define JANET_FIBER_MASK_USER2 (16 << 2)
#define JANET_FIBER_MASK_USER3 (16 << 3)
#define JANET_FIBER_MASK_USER4 (16 << 4)
#define JANET_FIBER_MASK_USER5 (16 << 5)
#define JANET_FIBER_MASK_USER6 (16 << 6)
#define JANET_FIBER_MASK_USER7 (16 << 7)
#define JANET_FIBER_MASK_USER8 (16 << 8)
#define JANET_FIBER_MASK_USER9 (16 << 9)

#define JANET_FIBER_MASK_USERN(N) (16 << (N))
#define JANET_FIBER_MASK_USER 0x3FF0

#define JANET_FIBER_STATUS_MASK 0x3F0000
#define JANET_FIBER_RESUME_SIGNAL 0x400000
#define JANET_FIBER_STATUS_OFFSET 16

#define JANET_FIBER_BREAKPOINT       0x1000000
#define JANET_FIBER_RESUME_NO_USEVAL 0x2000000
#define JANET_FIBER_RESUME_NO_SKIP   0x4000000
#define JANET_FIBER_DID_LONGJUMP     0x8000000
#define JANET_FIBER_FLAG_MASK        0xF000000

#define JANET_FIBER_EV_FLAG_CANCELED 0x10000
#define JANET_FIBER_EV_FLAG_SUSPENDED 0x20000
#define JANET_FIBER_FLAG_ROOT 0x40000

#define janet_fiber_set_status(f, s) do {\
    (f)->flags &= ~JANET_FIBER_STATUS_MASK;\
    (f)->flags |= (s) << JANET_FIBER_STATUS_OFFSET;\
} while (0)

#define janet_stack_frame(s) ((JanetStackFrame *)((s) - JANET_FRAME_SIZE))
#define janet_fiber_frame(f) janet_stack_frame((f)->data + (f)->frame)
void janet_fiber_setcapacity(JanetFiber *fiber, int32_t n);
void janet_fiber_push(JanetFiber *fiber, Janet x);
void janet_fiber_push2(JanetFiber *fiber, Janet x, Janet y);
void janet_fiber_push3(JanetFiber *fiber, Janet x, Janet y, Janet z);
void janet_fiber_pushn(JanetFiber *fiber, const Janet *arr, int32_t n);
int janet_fiber_funcframe(JanetFiber *fiber, JanetFunction *func);
int janet_fiber_funcframe_tail(JanetFiber *fiber, JanetFunction *func);
void janet_fiber_cframe(JanetFiber *fiber, JanetCFunction cfun);
void janet_fiber_popframe(JanetFiber *fiber);
void janet_env_maybe_detach(JanetFuncEnv *env);
int janet_env_valid(JanetFuncEnv *env);

#ifdef JANET_EV
void janet_fiber_did_resume(JanetFiber *fiber);
#endif

#endif


/* src/core/regalloc.h */
#line 0 "src/core/regalloc.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

/* Implements a simple first fit register allocator for the compiler. */

#ifndef JANET_REGALLOC_H
#define JANET_REGALLOC_H

#include <stdint.h>

/* Placeholder for allocating temporary registers */
typedef enum {
    JANETC_REGTEMP_0,
    JANETC_REGTEMP_1,
    JANETC_REGTEMP_2,
    JANETC_REGTEMP_3,
    JANETC_REGTEMP_4,
    JANETC_REGTEMP_5,
    JANETC_REGTEMP_6,
    JANETC_REGTEMP_7
} JanetcRegisterTemp;

typedef struct {
    uint32_t *chunks;
    int32_t count; /* number of chunks in chunks */
    int32_t capacity; /* amount allocated for chunks */
    int32_t max; /* The maximum allocated register so far */
    int32_t regtemps; /* Hold which temp. registers are allocated. */
} JanetcRegisterAllocator;

void janetc_regalloc_init(JanetcRegisterAllocator *ra);
void janetc_regalloc_deinit(JanetcRegisterAllocator *ra);

int32_t janetc_regalloc_1(JanetcRegisterAllocator *ra);
void janetc_regalloc_free(JanetcRegisterAllocator *ra, int32_t reg);
int32_t janetc_regalloc_temp(JanetcRegisterAllocator *ra, JanetcRegisterTemp nth);
void janetc_regalloc_freetemp(JanetcRegisterAllocator *ra, int32_t reg, JanetcRegisterTemp nth);
void janetc_regalloc_clone(JanetcRegisterAllocator *dest, JanetcRegisterAllocator *src);
void janetc_regalloc_touch(JanetcRegisterAllocator *ra, int32_t reg);

#endif


/* src/core/compile.h */
#line 0 "src/core/compile.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_COMPILE_H
#define JANET_COMPILE_H

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "regalloc.h"
#endif

/* Levels for compiler warnings */
typedef enum {
    JANET_C_LINT_RELAXED,
    JANET_C_LINT_NORMAL,
    JANET_C_LINT_STRICT
} JanetCompileLintLevel;

/* Tags for some functions for the prepared inliner */
#define JANET_FUN_DEBUG 1
#define JANET_FUN_ERROR 2
#define JANET_FUN_APPLY 3
#define JANET_FUN_YIELD 4
#define JANET_FUN_RESUME 5
#define JANET_FUN_IN 6
#define JANET_FUN_PUT 7
#define JANET_FUN_LENGTH 8
#define JANET_FUN_ADD 9
#define JANET_FUN_SUBTRACT 10
#define JANET_FUN_MULTIPLY 11
#define JANET_FUN_DIVIDE 12
#define JANET_FUN_BAND 13
#define JANET_FUN_BOR 14
#define JANET_FUN_BXOR 15
#define JANET_FUN_LSHIFT 16
#define JANET_FUN_RSHIFT 17
#define JANET_FUN_RSHIFTU 18
#define JANET_FUN_BNOT 19
#define JANET_FUN_GT 20
#define JANET_FUN_LT 21
#define JANET_FUN_GTE 22
#define JANET_FUN_LTE 23
#define JANET_FUN_EQ 24
#define JANET_FUN_NEQ 25
#define JANET_FUN_PROP 26
#define JANET_FUN_GET 27
#define JANET_FUN_NEXT 28
#define JANET_FUN_MODULO 29
#define JANET_FUN_REMAINDER 30
#define JANET_FUN_CMP 31
#define JANET_FUN_CANCEL 32

/* Compiler typedefs */
typedef struct JanetCompiler JanetCompiler;
typedef struct FormOptions FormOptions;
typedef struct SlotTracker SlotTracker;
typedef struct JanetScope JanetScope;
typedef struct JanetSlot JanetSlot;
typedef struct JanetFopts JanetFopts;
typedef struct JanetFunOptimizer JanetFunOptimizer;
typedef struct JanetSpecial JanetSpecial;

#define JANET_SLOT_CONSTANT 0x10000
#define JANET_SLOT_NAMED 0x20000
#define JANET_SLOT_MUTABLE 0x40000
#define JANET_SLOT_REF 0x80000
#define JANET_SLOT_RETURNED 0x100000
#define JANET_SLOT_DEP_NOTE 0x200000
#define JANET_SLOT_DEP_WARN 0x400000
#define JANET_SLOT_DEP_ERROR 0x800000
#define JANET_SLOT_SPLICED 0x1000000

#define JANET_SLOTTYPE_ANY 0xFFFF

/* A stack slot */
struct JanetSlot {
    Janet constant; /* If the slot has a constant value */
    int32_t index;
    int32_t envindex; /* 0 is local, positive number is an upvalue */
    uint32_t flags;
};

#define JANET_SCOPE_FUNCTION 1
#define JANET_SCOPE_ENV 2
#define JANET_SCOPE_TOP 4
#define JANET_SCOPE_UNUSED 8
#define JANET_SCOPE_CLOSURE 16
#define JANET_SCOPE_WHILE 32

/* A symbol and slot pair */
typedef struct SymPair {
    JanetSlot slot;
    const uint8_t *sym;
    int keep;
} SymPair;

/* A lexical scope during compilation */
struct JanetScope {

    /* For debugging */
    const char *name;

    /* Scopes are doubly linked list */
    JanetScope *parent;
    JanetScope *child;

    /* Constants for this funcdef */
    Janet *consts;

    /* Map of symbols to slots. Use a simple linear scan for symbols. */
    SymPair *syms;

    /* FuncDefs */
    JanetFuncDef **defs;

    /* Regsiter allocator */
    JanetcRegisterAllocator ra;

    /* Upvalue allocator */
    JanetcRegisterAllocator ua;

    /* Referenced closure environments. The values at each index correspond
     * to which index to get the environment from in the parent. The environment
     * that corresponds to the direct parent's stack will always have value 0. */
    int32_t *envs;

    int32_t bytecode_start;
    int flags;
};

/* Compilation state */
struct JanetCompiler {

    /* Pointer to current scope */
    JanetScope *scope;

    uint32_t *buffer;
    JanetSourceMapping *mapbuffer;

    /* Hold the environment */
    JanetTable *env;

    /* Name of source to attach to generated functions */
    const uint8_t *source;

    /* The result of compilation */
    JanetCompileResult result;

    /* Keep track of where we are in the source */
    JanetSourceMapping current_mapping;

    /* Prevent unbounded recursion */
    int recursion_guard;

    /* Collect linting results */
    JanetArray *lints;
};

#define JANET_FOPTS_TAIL 0x10000
#define JANET_FOPTS_HINT 0x20000
#define JANET_FOPTS_DROP 0x40000

/* Options for compiling a single form */
struct JanetFopts {
    JanetCompiler *compiler;
    JanetSlot hint;
    uint32_t flags; /* bit set of accepted primitive types */
};

/* Get the default form options */
JanetFopts janetc_fopts_default(JanetCompiler *c);

/* For optimizing builtin normal functions. */
struct JanetFunOptimizer {
    int (*can_optimize)(JanetFopts opts, JanetSlot *args);
    JanetSlot(*optimize)(JanetFopts opts, JanetSlot *args);
};

/* A grouping of a named special and the corresponding compiler fragment */
struct JanetSpecial {
    const char *name;
    JanetSlot(*compile)(JanetFopts opts, int32_t argn, const Janet *argv);
};

/****************************************************/

/* Get an optimizer if it exists, otherwise NULL */
const JanetFunOptimizer *janetc_funopt(uint32_t flags);

/* Get a special. Return NULL if none exists */
const JanetSpecial *janetc_special(const uint8_t *name);

void janetc_freeslot(JanetCompiler *c, JanetSlot s);
void janetc_nameslot(JanetCompiler *c, const uint8_t *sym, JanetSlot s);
JanetSlot janetc_farslot(JanetCompiler *c);

/* Throw away some code after checking that it is well formed. */
void janetc_throwaway(JanetFopts opts, Janet x);

/* Get a target slot for emitting an instruction. Will always return
 * a local slot. */
JanetSlot janetc_gettarget(JanetFopts opts);

/* Get a bunch of slots for function arguments */
JanetSlot *janetc_toslots(JanetCompiler *c, const Janet *vals, int32_t len);

/* Get a bunch of slots for function arguments */
JanetSlot *janetc_toslotskv(JanetCompiler *c, Janet ds);

/* Push slots load via janetc_toslots. */
int32_t janetc_pushslots(JanetCompiler *c, JanetSlot *slots);

/* Free slots loaded via janetc_toslots */
void janetc_freeslots(JanetCompiler *c, JanetSlot *slots);

/* Generate the return instruction for a slot. */
JanetSlot janetc_return(JanetCompiler *c, JanetSlot s);

/* Store an error */
void janetc_error(JanetCompiler *c, const uint8_t *m);
void janetc_cerror(JanetCompiler *c, const char *m);

/* Linting */
void janetc_lintf(JanetCompiler *C, JanetCompileLintLevel level, const char *format, ...);

/* Dispatch to correct form compiler */
JanetSlot janetc_value(JanetFopts opts, Janet x);

/* Push and pop from the scope stack */
void janetc_scope(JanetScope *s, JanetCompiler *c, int flags, const char *name);
void janetc_popscope(JanetCompiler *c);
void janetc_popscope_keepslot(JanetCompiler *c, JanetSlot retslot);
JanetFuncDef *janetc_pop_funcdef(JanetCompiler *c);

/* Create a destory slots */
JanetSlot janetc_cslot(Janet x);

/* Search for a symbol */
JanetSlot janetc_resolve(JanetCompiler *c, const uint8_t *sym);

#endif


/* src/core/emit.h */
#line 0 "src/core/emit.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_EMIT_H
#define JANET_EMIT_H

#ifndef JANET_AMALG
#include "compile.h"
#endif

void janetc_emit(JanetCompiler *c, uint32_t instr);

int32_t janetc_allocfar(JanetCompiler *c);
int32_t janetc_allocnear(JanetCompiler *c, JanetcRegisterTemp);

int32_t janetc_emit_s(JanetCompiler *c, uint8_t op, JanetSlot s, int wr);
int32_t janetc_emit_sl(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t label);
int32_t janetc_emit_st(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t tflags);
int32_t janetc_emit_si(JanetCompiler *c, uint8_t op, JanetSlot s, int16_t immediate, int wr);
int32_t janetc_emit_su(JanetCompiler *c, uint8_t op, JanetSlot s, uint16_t immediate, int wr);
int32_t janetc_emit_ss(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int wr);
int32_t janetc_emit_ssi(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int8_t immediate, int wr);
int32_t janetc_emit_ssu(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, uint8_t immediate, int wr);
int32_t janetc_emit_sss(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, JanetSlot s3, int wr);

/* Check if two slots are equivalent */
int janetc_sequal(JanetSlot x, JanetSlot y);

/* Move value from one slot to another. Cannot copy to constant slots. */
void janetc_copy(JanetCompiler *c, JanetSlot dest, JanetSlot src);

#endif


/* src/core/symcache.h */
#line 0 "src/core/symcache.h"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_SYMCACHE_H_defined
#define JANET_SYMCACHE_H_defined

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#endif

/* Initialize the cache (allocate cache memory) */
void janet_symcache_init(void);
void janet_symcache_deinit(void);
void janet_symbol_deinit(const uint8_t *sym);

#endif


/* Windows work around - winsock2 must be included before windows.h, especially in amalgamated build */
#if defined(JANET_WINDOWS) && defined(JANET_NET)
#include <winsock2.h>
#endif


/* src/core/abstract.c */
#line 0 "src/core/abstract.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#include "gc.h"
#include "state.h"
#endif

#ifdef JANET_EV
#ifdef JANET_WINDOWS
#include <windows.h>
#else
#include <stdatomic.h>
#endif
#endif

/* Create new userdata */
void *janet_abstract_begin(const JanetAbstractType *atype, size_t size) {
    JanetAbstractHead *header = janet_gcalloc(JANET_MEMORY_NONE,
                                sizeof(JanetAbstractHead) + size);
    header->size = size;
    header->type = atype;
    return (void *) & (header->data);
}

void *janet_abstract_end(void *x) {
    janet_gc_settype((void *)(janet_abstract_head(x)), JANET_MEMORY_ABSTRACT);
    return x;
}

void *janet_abstract(const JanetAbstractType *atype, size_t size) {
    return janet_abstract_end(janet_abstract_begin(atype, size));
}

#ifdef JANET_EV

/*
 * Threaded abstracts
 */

void *janet_abstract_begin_threaded(const JanetAbstractType *atype, size_t size) {
    JanetAbstractHead *header = janet_malloc(sizeof(JanetAbstractHead) + size);
    if (NULL == header) {
        JANET_OUT_OF_MEMORY;
    }
    janet_vm.next_collection += size + sizeof(JanetAbstractHead);
    header->gc.flags = JANET_MEMORY_THREADED_ABSTRACT;
    header->gc.data.next = NULL; /* Clear memory for address sanitizers */
    header->gc.data.refcount = 1;
    header->size = size;
    header->type = atype;
    void *abstract = (void *) & (header->data);
    janet_table_put(&janet_vm.threaded_abstracts, janet_wrap_abstract(abstract), janet_wrap_false());
    return abstract;
}

void *janet_abstract_end_threaded(void *x) {
    janet_gc_settype((void *)(janet_abstract_head(x)), JANET_MEMORY_THREADED_ABSTRACT);
    return x;
}

void *janet_abstract_threaded(const JanetAbstractType *atype, size_t size) {
    return janet_abstract_end_threaded(janet_abstract_begin_threaded(atype, size));
}

/* Refcounting primitives and sync primitives */

#ifdef JANET_WINDOWS

size_t janet_os_mutex_size(void) {
    return sizeof(CRITICAL_SECTION);
}

size_t janet_os_rwlock_size(void) {
    return sizeof(void *);
}

static int32_t janet_incref(JanetAbstractHead *ab) {
    return InterlockedIncrement(&ab->gc.data.refcount);
}

static int32_t janet_decref(JanetAbstractHead *ab) {
    return InterlockedDecrement(&ab->gc.data.refcount);
}

void janet_os_mutex_init(JanetOSMutex *mutex) {
    InitializeCriticalSection((CRITICAL_SECTION *) mutex);
}

void janet_os_mutex_deinit(JanetOSMutex *mutex) {
    DeleteCriticalSection((CRITICAL_SECTION *) mutex);
}

void janet_os_mutex_lock(JanetOSMutex *mutex) {
    EnterCriticalSection((CRITICAL_SECTION *) mutex);
}

void janet_os_mutex_unlock(JanetOSMutex *mutex) {
    /* error handling? May want to keep counter */
    LeaveCriticalSection((CRITICAL_SECTION *) mutex);
}

void janet_os_rwlock_init(JanetOSRWLock *rwlock) {
    InitializeSRWLock((PSRWLOCK) rwlock);
}

void janet_os_rwlock_deinit(JanetOSRWLock *rwlock) {
    /* no op? */
    (void) rwlock;
}

void janet_os_rwlock_rlock(JanetOSRWLock *rwlock) {
    AcquireSRWLockShared((PSRWLOCK) rwlock);
}

void janet_os_rwlock_wlock(JanetOSRWLock *rwlock) {
    AcquireSRWLockExclusive((PSRWLOCK) rwlock);
}

void janet_os_rwlock_runlock(JanetOSRWLock *rwlock) {
    ReleaseSRWLockShared((PSRWLOCK) rwlock);
}

void janet_os_rwlock_wunlock(JanetOSRWLock *rwlock) {
    ReleaseSRWLockExclusive((PSRWLOCK) rwlock);
}

#else

size_t janet_os_mutex_size(void) {
    return sizeof(pthread_mutex_t);
}

size_t janet_os_rwlock_size(void) {
    return sizeof(pthread_rwlock_t);
}

static int32_t janet_incref(JanetAbstractHead *ab) {
    return __atomic_add_fetch(&ab->gc.data.refcount, 1, __ATOMIC_RELAXED);
}

static int32_t janet_decref(JanetAbstractHead *ab) {
    return __atomic_add_fetch(&ab->gc.data.refcount, -1, __ATOMIC_RELAXED);
}

void janet_os_mutex_init(JanetOSMutex *mutex) {
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init((pthread_mutex_t *) mutex, &attr);
}

void janet_os_mutex_deinit(JanetOSMutex *mutex) {
    pthread_mutex_destroy((pthread_mutex_t *) mutex);
}

void janet_os_mutex_lock(JanetOSMutex *mutex) {
    pthread_mutex_lock((pthread_mutex_t *) mutex);
}

void janet_os_mutex_unlock(JanetOSMutex *mutex) {
    int ret = pthread_mutex_unlock((pthread_mutex_t *) mutex);
    if (ret) janet_panic("cannot release lock");
}

void janet_os_rwlock_init(JanetOSRWLock *rwlock) {
    pthread_rwlock_init((pthread_rwlock_t *) rwlock, NULL);
}

void janet_os_rwlock_deinit(JanetOSRWLock *rwlock) {
    pthread_rwlock_destroy((pthread_rwlock_t *) rwlock);
}

void janet_os_rwlock_rlock(JanetOSRWLock *rwlock) {
    pthread_rwlock_rdlock((pthread_rwlock_t *) rwlock);
}

void janet_os_rwlock_wlock(JanetOSRWLock *rwlock) {
    pthread_rwlock_wrlock((pthread_rwlock_t *) rwlock);
}

void janet_os_rwlock_runlock(JanetOSRWLock *rwlock) {
    pthread_rwlock_unlock((pthread_rwlock_t *) rwlock);
}

void janet_os_rwlock_wunlock(JanetOSRWLock *rwlock) {
    pthread_rwlock_unlock((pthread_rwlock_t *) rwlock);
}

#endif

int32_t janet_abstract_incref(void *abst) {
    return janet_incref(janet_abstract_head(abst));
}

int32_t janet_abstract_decref(void *abst) {
    return janet_decref(janet_abstract_head(abst));
}

#endif


/* src/core/array.c */
#line 0 "src/core/array.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include "state.h"
#endif

#include <string.h>

/* Creates a new array */
JanetArray *janet_array(int32_t capacity) {
    JanetArray *array = janet_gcalloc(JANET_MEMORY_ARRAY, sizeof(JanetArray));
    Janet *data = NULL;
    if (capacity > 0) {
        janet_vm.next_collection += capacity * sizeof(Janet);
        data = (Janet *) janet_malloc(sizeof(Janet) * (size_t) capacity);
        if (NULL == data) {
            JANET_OUT_OF_MEMORY;
        }
    }
    array->count = 0;
    array->capacity = capacity;
    array->data = data;
    return array;
}

/* Creates a new array from n elements. */
JanetArray *janet_array_n(const Janet *elements, int32_t n) {
    JanetArray *array = janet_gcalloc(JANET_MEMORY_ARRAY, sizeof(JanetArray));
    array->capacity = n;
    array->count = n;
    array->data = janet_malloc(sizeof(Janet) * (size_t) n);
    if (!array->data) {
        JANET_OUT_OF_MEMORY;
    }
    safe_memcpy(array->data, elements, sizeof(Janet) * n);
    return array;
}

/* Ensure the array has enough capacity for elements */
void janet_array_ensure(JanetArray *array, int32_t capacity, int32_t growth) {
    Janet *newData;
    Janet *old = array->data;
    if (capacity <= array->capacity) return;
    int64_t new_capacity = ((int64_t) capacity) * growth;
    if (new_capacity > INT32_MAX) new_capacity = INT32_MAX;
    capacity = (int32_t) new_capacity;
    newData = janet_realloc(old, capacity * sizeof(Janet));
    if (NULL == newData) {
        JANET_OUT_OF_MEMORY;
    }
    janet_vm.next_collection += (capacity - array->capacity) * sizeof(Janet);
    array->data = newData;
    array->capacity = capacity;
}

/* Set the count of an array. Extend with nil if needed. */
void janet_array_setcount(JanetArray *array, int32_t count) {
    if (count < 0)
        return;
    if (count > array->count) {
        int32_t i;
        janet_array_ensure(array, count, 1);
        for (i = array->count; i < count; i++) {
            array->data[i] = janet_wrap_nil();
        }
    }
    array->count = count;
}

/* Push a value to the top of the array */
void janet_array_push(JanetArray *array, Janet x) {
    if (array->count == INT32_MAX) {
        janet_panic("array overflow");
    }
    int32_t newcount = array->count + 1;
    janet_array_ensure(array, newcount, 2);
    array->data[array->count] = x;
    array->count = newcount;
}

/* Pop a value from the top of the array */
Janet janet_array_pop(JanetArray *array) {
    if (array->count) {
        return array->data[--array->count];
    } else {
        return janet_wrap_nil();
    }
}

/* Look at the last value in the array */
Janet janet_array_peek(JanetArray *array) {
    if (array->count) {
        return array->data[array->count - 1];
    } else {
        return janet_wrap_nil();
    }
}

/* C Functions */

JANET_CORE_FN(cfun_array_new,
              "(array/new capacity)",
              "Creates a new empty array with a pre-allocated capacity. The same as "
              "`(array)` but can be more efficient if the maximum size of an array is known.") {
    janet_fixarity(argc, 1);
    int32_t cap = janet_getinteger(argv, 0);
    JanetArray *array = janet_array(cap);
    return janet_wrap_array(array);
}

JANET_CORE_FN(cfun_array_new_filled,
              "(array/new-filled count &opt value)",
              "Creates a new array of `count` elements, all set to `value`, which defaults to nil. Returns the new array.") {
    janet_arity(argc, 1, 2);
    int32_t count = janet_getnat(argv, 0);
    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();
    JanetArray *array = janet_array(count);
    for (int32_t i = 0; i < count; i++) {
        array->data[i] = x;
    }
    array->count = count;
    return janet_wrap_array(array);
}

JANET_CORE_FN(cfun_array_fill,
              "(array/fill arr &opt value)",
              "Replace all elements of an array with `value` (defaulting to nil) without changing the length of the array. "
              "Returns the modified array.") {
    janet_arity(argc, 1, 2);
    JanetArray *array = janet_getarray(argv, 0);
    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();
    for (int32_t i = 0; i < array->count; i++) {
        array->data[i] = x;
    }
    return argv[0];
}

JANET_CORE_FN(cfun_array_pop,
              "(array/pop arr)",
              "Remove the last element of the array and return it. If the array is empty, will return nil. Modifies "
              "the input array.") {
    janet_fixarity(argc, 1);
    JanetArray *array = janet_getarray(argv, 0);
    return janet_array_pop(array);
}

JANET_CORE_FN(cfun_array_peek,
              "(array/peek arr)",
              "Returns the last element of the array. Does not modify the array.") {
    janet_fixarity(argc, 1);
    JanetArray *array = janet_getarray(argv, 0);
    return janet_array_peek(array);
}

JANET_CORE_FN(cfun_array_push,
              "(array/push arr x)",
              "Insert an element in the end of an array. Modifies the input array and returns it.") {
    janet_arity(argc, 1, -1);
    JanetArray *array = janet_getarray(argv, 0);
    if (INT32_MAX - argc + 1 <= array->count) {
        janet_panic("array overflow");
    }
    int32_t newcount = array->count - 1 + argc;
    janet_array_ensure(array, newcount, 2);
    if (argc > 1) memcpy(array->data + array->count, argv + 1, (size_t)(argc - 1) * sizeof(Janet));
    array->count = newcount;
    return argv[0];
}

JANET_CORE_FN(cfun_array_ensure,
              "(array/ensure arr capacity growth)",
              "Ensures that the memory backing the array is large enough for `capacity` "
              "items at the given rate of growth. `capacity` and `growth` must be integers. "
              "If the backing capacity is already enough, then this function does nothing. "
              "Otherwise, the backing memory will be reallocated so that there is enough space.") {
    janet_fixarity(argc, 3);
    JanetArray *array = janet_getarray(argv, 0);
    int32_t newcount = janet_getinteger(argv, 1);
    int32_t growth = janet_getinteger(argv, 2);
    if (newcount < 1) janet_panic("expected positive integer");
    janet_array_ensure(array, newcount, growth);
    return argv[0];
}

JANET_CORE_FN(cfun_array_slice,
              "(array/slice arrtup &opt start end)",
              "Takes a slice of array or tuple from `start` to `end`. The range is half open, "
              "[start, end). Indexes can also be negative, indicating indexing from the "
              "end of the array. By default, `start` is 0 and `end` is the length of the array. "
              "Note that index -1 is synonymous with index `(length arrtup)` to allow a full "
              "negative slice range. Returns a new array.") {
    JanetView view = janet_getindexed(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    JanetArray *array = janet_array(range.end - range.start);
    if (array->data)
        memcpy(array->data, view.items + range.start, sizeof(Janet) * (range.end - range.start));
    array->count = range.end - range.start;
    return janet_wrap_array(array);
}

JANET_CORE_FN(cfun_array_concat,
              "(array/concat arr & parts)",
              "Concatenates a variable number of arrays (and tuples) into the first argument, "
              "which must be an array. If any of the parts are arrays or tuples, their elements will "
              "be inserted into the array. Otherwise, each part in `parts` will be appended to `arr` in order. "
              "Return the modified array `arr`.") {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetArray *array = janet_getarray(argv, 0);
    for (i = 1; i < argc; i++) {
        switch (janet_type(argv[i])) {
            default:
                janet_array_push(array, argv[i]);
                break;
            case JANET_ARRAY:
            case JANET_TUPLE: {
                int32_t j, len = 0;
                const Janet *vals = NULL;
                janet_indexed_view(argv[i], &vals, &len);
                if (array->data == vals) {
                    int32_t newcount = array->count + len;
                    janet_array_ensure(array, newcount, 2);
                    janet_indexed_view(argv[i], &vals, &len);
                }
                for (j = 0; j < len; j++)
                    janet_array_push(array, vals[j]);
            }
            break;
        }
    }
    return janet_wrap_array(array);
}

JANET_CORE_FN(cfun_array_insert,
              "(array/insert arr at & xs)",
              "Insert all `xs` into array `arr` at index `at`. `at` should be an integer between "
              "0 and the length of the array. A negative value for `at` will index backwards from "
              "the end of the array, such that inserting at -1 appends to the array. "
              "Returns the array.") {
    size_t chunksize, restsize;
    janet_arity(argc, 2, -1);
    JanetArray *array = janet_getarray(argv, 0);
    int32_t at = janet_getinteger(argv, 1);
    if (at < 0) {
        at = array->count + at + 1;
    }
    if (at < 0 || at > array->count)
        janet_panicf("insertion index %d out of range [0,%d]", at, array->count);
    chunksize = (argc - 2) * sizeof(Janet);
    restsize = (array->count - at) * sizeof(Janet);
    if (INT32_MAX - (argc - 2) < array->count) {
        janet_panic("array overflow");
    }
    janet_array_ensure(array, array->count + argc - 2, 2);
    if (restsize) {
        memmove(array->data + at + argc - 2,
                array->data + at,
                restsize);
    }
    safe_memcpy(array->data + at, argv + 2, chunksize);
    array->count += (argc - 2);
    return argv[0];
}

JANET_CORE_FN(cfun_array_remove,
              "(array/remove arr at &opt n)",
              "Remove up to `n` elements starting at index `at` in array `arr`. `at` can index from "
              "the end of the array with a negative index, and `n` must be a non-negative integer. "
              "By default, `n` is 1. "
              "Returns the array.") {
    janet_arity(argc, 2, 3);
    JanetArray *array = janet_getarray(argv, 0);
    int32_t at = janet_getinteger(argv, 1);
    int32_t n = 1;
    if (at < 0) {
        at = array->count + at + 1;
    }
    if (at < 0 || at > array->count)
        janet_panicf("removal index %d out of range [0,%d]", at, array->count);
    if (argc == 3) {
        n = janet_getinteger(argv, 2);
        if (n < 0)
            janet_panicf("expected non-negative integer for argument n, got %v", argv[2]);
    }
    if (at + n > array->count) {
        n = array->count - at;
    }
    memmove(array->data + at,
            array->data + at + n,
            (array->count - at - n) * sizeof(Janet));
    array->count -= n;
    return argv[0];
}

JANET_CORE_FN(cfun_array_trim,
              "(array/trim arr)",
              "Set the backing capacity of an array to its current length. Returns the modified array.") {
    janet_fixarity(argc, 1);
    JanetArray *array = janet_getarray(argv, 0);
    if (array->count) {
        if (array->count < array->capacity) {
            Janet *newData = janet_realloc(array->data, array->count * sizeof(Janet));
            if (NULL == newData) {
                JANET_OUT_OF_MEMORY;
            }
            array->data = newData;
            array->capacity = array->count;
        }
    } else {
        array->capacity = 0;
        janet_free(array->data);
        array->data = NULL;
    }
    return argv[0];
}

JANET_CORE_FN(cfun_array_clear,
              "(array/clear arr)",
              "Empties an array, setting it's count to 0 but does not free the backing capacity. "
              "Returns the modified array.") {
    janet_fixarity(argc, 1);
    JanetArray *array = janet_getarray(argv, 0);
    array->count = 0;
    return argv[0];
}

/* Load the array module */
void janet_lib_array(JanetTable *env) {
    JanetRegExt array_cfuns[] = {
        JANET_CORE_REG("array/new", cfun_array_new),
        JANET_CORE_REG("array/new-filled", cfun_array_new_filled),
        JANET_CORE_REG("array/fill", cfun_array_fill),
        JANET_CORE_REG("array/pop", cfun_array_pop),
        JANET_CORE_REG("array/peek", cfun_array_peek),
        JANET_CORE_REG("array/push", cfun_array_push),
        JANET_CORE_REG("array/ensure", cfun_array_ensure),
        JANET_CORE_REG("array/slice", cfun_array_slice),
        JANET_CORE_REG("array/concat", cfun_array_concat),
        JANET_CORE_REG("array/insert", cfun_array_insert),
        JANET_CORE_REG("array/remove", cfun_array_remove),
        JANET_CORE_REG("array/trim", cfun_array_trim),
        JANET_CORE_REG("array/clear", cfun_array_clear),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, array_cfuns);
}


/* src/core/asm.c */
#line 0 "src/core/asm.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#include <setjmp.h>

/* Conditionally compile this file */
#ifdef JANET_ASSEMBLER

/* Definition for an instruction in the assembler */
typedef struct JanetInstructionDef JanetInstructionDef;
struct JanetInstructionDef {
    const char *name;
    enum JanetOpCode opcode;
};

/* Hold all state needed during assembly */
typedef struct JanetAssembler JanetAssembler;
struct JanetAssembler {
    JanetAssembler *parent;
    JanetFuncDef *def;
    jmp_buf on_error;
    const uint8_t *errmessage;
    int32_t errindex;

    int32_t environments_capacity;
    int32_t defs_capacity;
    int32_t bytecode_count; /* Used for calculating labels */

    Janet name;
    JanetTable labels; /* keyword -> bytecode index */
    JanetTable slots; /* symbol -> slot index */
    JanetTable envs; /* symbol -> environment index */
    JanetTable defs; /* symbol -> funcdefs index */
};

/* Janet opcode descriptions in lexicographic order. This
 * allows a binary search over the elements to find the
 * correct opcode given a name. This works in reasonable
 * time and is easier to setup statically than a hash table or
 * prefix tree. */
static const JanetInstructionDef janet_ops[] = {
    {"add", JOP_ADD},
    {"addim", JOP_ADD_IMMEDIATE},
    {"band", JOP_BAND},
    {"bnot", JOP_BNOT},
    {"bor", JOP_BOR},
    {"bxor", JOP_BXOR},
    {"call", JOP_CALL},
    {"clo", JOP_CLOSURE},
    {"cmp", JOP_COMPARE},
    {"cncl", JOP_CANCEL},
    {"div", JOP_DIVIDE},
    {"divim", JOP_DIVIDE_IMMEDIATE},
    {"eq", JOP_EQUALS},
    {"eqim", JOP_EQUALS_IMMEDIATE},
    {"err", JOP_ERROR},
    {"get", JOP_GET},
    {"geti", JOP_GET_INDEX},
    {"gt", JOP_GREATER_THAN},
    {"gte", JOP_GREATER_THAN_EQUAL},
    {"gtim", JOP_GREATER_THAN_IMMEDIATE},
    {"in", JOP_IN},
    {"jmp", JOP_JUMP},
    {"jmpif", JOP_JUMP_IF},
    {"jmpni", JOP_JUMP_IF_NIL},
    {"jmpnn", JOP_JUMP_IF_NOT_NIL},
    {"jmpno", JOP_JUMP_IF_NOT},
    {"ldc", JOP_LOAD_CONSTANT},
    {"ldf", JOP_LOAD_FALSE},
    {"ldi", JOP_LOAD_INTEGER},
    {"ldn", JOP_LOAD_NIL},
    {"lds", JOP_LOAD_SELF},
    {"ldt", JOP_LOAD_TRUE},
    {"ldu", JOP_LOAD_UPVALUE},
    {"len", JOP_LENGTH},
    {"lt", JOP_LESS_THAN},
    {"lte", JOP_LESS_THAN_EQUAL},
    {"ltim", JOP_LESS_THAN_IMMEDIATE},
    {"mkarr", JOP_MAKE_ARRAY},
    {"mkbtp", JOP_MAKE_BRACKET_TUPLE},
    {"mkbuf", JOP_MAKE_BUFFER},
    {"mkstr", JOP_MAKE_STRING},
    {"mkstu", JOP_MAKE_STRUCT},
    {"mktab", JOP_MAKE_TABLE},
    {"mktup", JOP_MAKE_TUPLE},
    {"mod", JOP_MODULO},
    {"movf", JOP_MOVE_FAR},
    {"movn", JOP_MOVE_NEAR},
    {"mul", JOP_MULTIPLY},
    {"mulim", JOP_MULTIPLY_IMMEDIATE},
    {"neq", JOP_NOT_EQUALS},
    {"neqim", JOP_NOT_EQUALS_IMMEDIATE},
    {"next", JOP_NEXT},
    {"noop", JOP_NOOP},
    {"prop", JOP_PROPAGATE},
    {"push", JOP_PUSH},
    {"push2", JOP_PUSH_2},
    {"push3", JOP_PUSH_3},
    {"pusha", JOP_PUSH_ARRAY},
    {"put", JOP_PUT},
    {"puti", JOP_PUT_INDEX},
    {"rem", JOP_REMAINDER},
    {"res", JOP_RESUME},
    {"ret", JOP_RETURN},
    {"retn", JOP_RETURN_NIL},
    {"setu", JOP_SET_UPVALUE},
    {"sig", JOP_SIGNAL},
    {"sl", JOP_SHIFT_LEFT},
    {"slim", JOP_SHIFT_LEFT_IMMEDIATE},
    {"sr", JOP_SHIFT_RIGHT},
    {"srim", JOP_SHIFT_RIGHT_IMMEDIATE},
    {"sru", JOP_SHIFT_RIGHT_UNSIGNED},
    {"sruim", JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE},
    {"sub", JOP_SUBTRACT},
    {"tcall", JOP_TAILCALL},
    {"tchck", JOP_TYPECHECK}
};

/* Typename aliases for tchck instruction */
typedef struct TypeAlias {
    const char *name;
    int32_t mask;
} TypeAlias;

static const TypeAlias type_aliases[] = {
    {"abstract", JANET_TFLAG_ABSTRACT},
    {"array", JANET_TFLAG_ARRAY},
    {"boolean", JANET_TFLAG_BOOLEAN},
    {"buffer", JANET_TFLAG_BUFFER},
    {"callable", JANET_TFLAG_CALLABLE},
    {"cfunction", JANET_TFLAG_CFUNCTION},
    {"dictionary", JANET_TFLAG_DICTIONARY},
    {"fiber", JANET_TFLAG_FIBER},
    {"function", JANET_TFLAG_FUNCTION},
    {"indexed", JANET_TFLAG_INDEXED},
    {"keyword", JANET_TFLAG_KEYWORD},
    {"nil", JANET_TFLAG_NIL},
    {"number", JANET_TFLAG_NUMBER},
    {"pointer", JANET_TFLAG_POINTER},
    {"string", JANET_TFLAG_STRING},
    {"struct", JANET_TFLAG_STRUCT},
    {"symbol", JANET_TFLAG_SYMBOL},
    {"table", JANET_TFLAG_TABLE},
    {"tuple", JANET_TFLAG_TUPLE}
};

/* Deinitialize an Assembler. Does not deinitialize the parents. */
static void janet_asm_deinit(JanetAssembler *a) {
    janet_table_deinit(&a->slots);
    janet_table_deinit(&a->labels);
    janet_table_deinit(&a->envs);
    janet_table_deinit(&a->defs);
}

static void janet_asm_longjmp(JanetAssembler *a) {
#if defined(JANET_BSD) || defined(JANET_APPLE)
    _longjmp(a->on_error, 1);
#else
    longjmp(a->on_error, 1);
#endif
}

/* Throw some kind of assembly error */
static void janet_asm_error(JanetAssembler *a, const char *message) {
    a->errmessage = janet_formatc("%s, instruction %d", message, a->errindex);
    janet_asm_longjmp(a);
}
#define janet_asm_assert(a, c, m) do { if (!(c)) janet_asm_error((a), (m)); } while (0)

/* Throw some kind of assembly error */
static void janet_asm_errorv(JanetAssembler *a, const uint8_t *m) {
    a->errmessage = m;
    janet_asm_longjmp(a);
}

/* Add a closure environment to the assembler. Sub funcdefs may need
 * to reference outer function environments, and may change the outer environment.
 * Returns the index of the environment in the assembler's environments, or -1
 * if not found. */
static int32_t janet_asm_addenv(JanetAssembler *a, Janet envname) {
    Janet check;
    JanetFuncDef *def = a->def;
    int32_t envindex;
    int32_t res;
    if (janet_equals(a->name, envname)) {
        return -1;
    }
    /* Check for memoized value */
    check = janet_table_get(&a->envs, envname);
    if (janet_checktype(check, JANET_NUMBER)) {
        return (int32_t) janet_unwrap_number(check);
    }
    if (NULL == a->parent) return -2;
    res = janet_asm_addenv(a->parent, envname);
    if (res < -1) {
        return res;
    }
    envindex = def->environments_length;
    janet_table_put(&a->envs, envname, janet_wrap_number(envindex));
    if (envindex >= a->environments_capacity) {
        int32_t newcap = 2 * envindex;
        def->environments = janet_realloc(def->environments, newcap * sizeof(int32_t));
        if (NULL == def->environments) {
            JANET_OUT_OF_MEMORY;
        }
        a->environments_capacity = newcap;
    }
    def->environments[envindex] = (int32_t) res;
    def->environments_length = envindex + 1;
    return envindex;
}

/* Parse an argument to an assembly instruction, and return the result as an
 * integer. This integer will need to be bounds checked. */
static int32_t doarg_1(
    JanetAssembler *a,
    enum JanetOpArgType argtype,
    Janet x) {
    int32_t ret = -1;
    JanetTable *c;
    switch (argtype) {
        default:
            c = NULL;
            break;
        case JANET_OAT_SLOT:
            c = &a->slots;
            break;
        case JANET_OAT_ENVIRONMENT:
            c = &a->envs;
            break;
        case JANET_OAT_LABEL:
            c = &a->labels;
            break;
        case JANET_OAT_FUNCDEF:
            c = &a->defs;
            break;
    }
    switch (janet_type(x)) {
        default:
            goto error;
            break;
        case JANET_NUMBER: {
            double y = janet_unwrap_number(x);
            if (janet_checkintrange(y)) {
                ret = (int32_t) y;
            } else {
                goto error;
            }
            break;
        }
        case JANET_TUPLE: {
            const Janet *t = janet_unwrap_tuple(x);
            if (argtype == JANET_OAT_TYPE) {
                int32_t i = 0;
                ret = 0;
                for (i = 0; i < janet_tuple_length(t); i++) {
                    ret |= doarg_1(a, JANET_OAT_SIMPLETYPE, t[i]);
                }
            } else {
                goto error;
            }
            break;
        }
        case JANET_KEYWORD: {
            if (NULL != c && argtype == JANET_OAT_LABEL) {
                Janet result = janet_table_get(c, x);
                if (janet_checktype(result, JANET_NUMBER)) {
                    ret = janet_unwrap_integer(result) - a->bytecode_count;
                } else {
                    goto error;
                }
            } else if (argtype == JANET_OAT_TYPE || argtype == JANET_OAT_SIMPLETYPE) {
                const TypeAlias *alias = janet_strbinsearch(
                                             &type_aliases,
                                             sizeof(type_aliases) / sizeof(TypeAlias),
                                             sizeof(TypeAlias),
                                             janet_unwrap_keyword(x));
                if (alias) {
                    ret = alias->mask;
                } else {
                    janet_asm_errorv(a, janet_formatc("unknown type %v", x));
                }
            } else {
                goto error;
            }
            break;
        }
        case JANET_SYMBOL: {
            if (NULL != c) {
                Janet result = janet_table_get(c, x);
                if (janet_checktype(result, JANET_NUMBER)) {
                    ret = (int32_t) janet_unwrap_number(result);
                } else {
                    janet_asm_errorv(a, janet_formatc("unknown name %v", x));
                }
            } else {
                goto error;
            }
            if (argtype == JANET_OAT_ENVIRONMENT && ret == -1) {
                /* Add a new env */
                ret = janet_asm_addenv(a, x);
                if (ret < -1) {
                    janet_asm_errorv(a, janet_formatc("unknown environment %v", x));
                }
            }
            break;
        }
    }
    if (argtype == JANET_OAT_SLOT && ret >= a->def->slotcount)
        a->def->slotcount = (int32_t) ret + 1;
    return ret;

error:
    janet_asm_errorv(a, janet_formatc("error parsing instruction argument %v", x));
    return 0;
}

/* Parse a single argument to an instruction. Trims it as well as
 * try to convert arguments to bit patterns */
static uint32_t doarg(
    JanetAssembler *a,
    enum JanetOpArgType argtype,
    int nth,
    int nbytes,
    int hassign,
    Janet x) {
    int32_t arg = doarg_1(a, argtype, x);
    /* Calculate the min and max values that can be stored given
     * nbytes, and whether or not the storage is signed */
    int32_t max = (1 << ((nbytes << 3) - hassign)) - 1;
    int32_t min = hassign ? -max - 1 : 0;
    if (arg < min)
        janet_asm_errorv(a, janet_formatc("instruction argument %v is too small, must be %d byte%s",
                                          x, nbytes, nbytes > 1 ? "s" : ""));
    if (arg > max)
        janet_asm_errorv(a, janet_formatc("instruction argument %v is too large, must be %d byte%s",
                                          x, nbytes, nbytes > 1 ? "s" : ""));
    return ((uint32_t) arg) << (nth << 3);
}

/* Provide parsing methods for the different kinds of arguments */
static uint32_t read_instruction(
    JanetAssembler *a,
    const JanetInstructionDef *idef,
    const Janet *argt) {
    uint32_t instr = idef->opcode;
    enum JanetInstructionType type = janet_instructions[idef->opcode];
    switch (type) {
        case JINT_0: {
            if (janet_tuple_length(argt) != 1)
                janet_asm_error(a, "expected 0 arguments: (op)");
            break;
        }
        case JINT_S: {
            if (janet_tuple_length(argt) != 2)
                janet_asm_error(a, "expected 1 argument: (op, slot)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 2, 0, argt[1]);
            break;
        }
        case JINT_L: {
            if (janet_tuple_length(argt) != 2)
                janet_asm_error(a, "expected 1 argument: (op, label)");
            instr |= doarg(a, JANET_OAT_LABEL, 1, 3, 1, argt[1]);
            break;
        }
        case JINT_SS: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, slot)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_SLOT, 2, 2, 0, argt[2]);
            break;
        }
        case JINT_SL: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, label)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_LABEL, 2, 2, 1, argt[2]);
            break;
        }
        case JINT_ST: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, type)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_TYPE, 2, 2, 0, argt[2]);
            break;
        }
        case JINT_SI:
        case JINT_SU: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, integer)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_INTEGER, 2, 2, type == JINT_SI, argt[2]);
            break;
        }
        case JINT_SD: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, funcdef)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_FUNCDEF, 2, 2, 0, argt[2]);
            break;
        }
        case JINT_SSS: {
            if (janet_tuple_length(argt) != 4)
                janet_asm_error(a, "expected 3 arguments: (op, slot, slot, slot)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_SLOT, 2, 1, 0, argt[2]);
            instr |= doarg(a, JANET_OAT_SLOT, 3, 1, 0, argt[3]);
            break;
        }
        case JINT_SSI:
        case JINT_SSU: {
            if (janet_tuple_length(argt) != 4)
                janet_asm_error(a, "expected 3 arguments: (op, slot, slot, integer)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_SLOT, 2, 1, 0, argt[2]);
            instr |= doarg(a, JANET_OAT_INTEGER, 3, 1, type == JINT_SSI, argt[3]);
            break;
        }
        case JINT_SES: {
            JanetAssembler *b = a;
            uint32_t env;
            if (janet_tuple_length(argt) != 4)
                janet_asm_error(a, "expected 3 arguments: (op, slot, environment, envslot)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            env = doarg(a, JANET_OAT_ENVIRONMENT, 0, 1, 0, argt[2]);
            instr |= env << 16;
            for (env += 1; env > 0; env--) {
                b = b->parent;
                if (NULL == b)
                    janet_asm_error(a, "invalid environment index");
            }
            instr |= doarg(b, JANET_OAT_SLOT, 3, 1, 0, argt[3]);
            break;
        }
        case JINT_SC: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, constant)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_CONSTANT, 2, 2, 0, argt[2]);
            break;
        }
    }
    return instr;
}

/* Helper to get from a structure */
static Janet janet_get1(Janet ds, Janet key) {
    switch (janet_type(ds)) {
        default:
            return janet_wrap_nil();
        case JANET_TABLE:
            return janet_table_get(janet_unwrap_table(ds), key);
        case JANET_STRUCT:
            return janet_struct_get(janet_unwrap_struct(ds), key);
    }
}

/* Helper to assembly. Return the assembly result */
static JanetAssembleResult janet_asm1(JanetAssembler *parent, Janet source, int flags) {
    JanetAssembleResult result;
    JanetAssembler a;
    Janet s = source;
    JanetFuncDef *def;
    int32_t count, i;
    const Janet *arr;
    Janet x;
    (void) flags;

    /* Initialize funcdef */
    def = janet_funcdef_alloc();

    /* Initialize Assembler */
    a.def = def;
    a.parent = parent;
    a.errmessage = NULL;
    a.errindex = 0;
    a.environments_capacity = 0;
    a.bytecode_count = 0;
    a.defs_capacity = 0;
    a.name = janet_wrap_nil();
    janet_table_init(&a.labels, 0);
    janet_table_init(&a.slots, 0);
    janet_table_init(&a.envs, 0);
    janet_table_init(&a.defs, 0);

    /* Set error jump */
#if defined(JANET_BSD) || defined(JANET_APPLE)
    if (_setjmp(a.on_error)) {
#else
    if (setjmp(a.on_error)) {
#endif
        if (NULL != a.parent) {
            janet_asm_deinit(&a);
            janet_asm_longjmp(a.parent);
        }
        result.funcdef = NULL;
        result.error = a.errmessage;
        result.status = JANET_ASSEMBLE_ERROR;
        janet_asm_deinit(&a);
        return result;
    }

    janet_asm_assert(&a,
                     janet_checktype(s, JANET_STRUCT) ||
                     janet_checktype(s, JANET_TABLE),
                     "expected struct or table for assembly source");

    /* Check for function name */
    a.name = janet_get1(s, janet_ckeywordv("name"));
    if (!janet_checktype(a.name, JANET_NIL)) {
        def->name = janet_to_string(a.name);
    }

    /* Set function arity */
    x = janet_get1(s, janet_ckeywordv("arity"));
    def->arity = janet_checkint(x) ? janet_unwrap_integer(x) : 0;
    janet_asm_assert(&a, def->arity >= 0, "arity must be non-negative");

    x = janet_get1(s, janet_ckeywordv("max-arity"));
    def->max_arity = janet_checkint(x) ? janet_unwrap_integer(x) : def->arity;
    janet_asm_assert(&a, def->max_arity >= def->arity, "max-arity must be greater than or equal to arity");

    x = janet_get1(s, janet_ckeywordv("min-arity"));
    def->min_arity = janet_checkint(x) ? janet_unwrap_integer(x) : def->arity;
    janet_asm_assert(&a, def->min_arity <= def->arity, "min-arity must be less than or equal to arity");

    /* Check vararg */
    x = janet_get1(s, janet_ckeywordv("vararg"));
    if (janet_truthy(x)) def->flags |= JANET_FUNCDEF_FLAG_VARARG;

    /* Check structarg */
    x = janet_get1(s, janet_ckeywordv("structarg"));
    if (janet_truthy(x)) def->flags |= JANET_FUNCDEF_FLAG_STRUCTARG;

    /* Check source */
    x = janet_get1(s, janet_ckeywordv("source"));
    if (janet_checktype(x, JANET_STRING)) def->source = janet_unwrap_string(x);

    /* Create slot aliases */
    x = janet_get1(s, janet_ckeywordv("slots"));
    if (janet_indexed_view(x, &arr, &count)) {
        for (i = 0; i < count; i++) {
            Janet v = arr[i];
            if (janet_checktype(v, JANET_TUPLE)) {
                const Janet *t = janet_unwrap_tuple(v);
                int32_t j;
                for (j = 0; j < janet_tuple_length(t); j++) {
                    if (!janet_checktype(t[j], JANET_SYMBOL))
                        janet_asm_error(&a, "slot names must be symbols");
                    janet_table_put(&a.slots, t[j], janet_wrap_integer(i));
                }
            } else if (janet_checktype(v, JANET_SYMBOL)) {
                janet_table_put(&a.slots, v, janet_wrap_integer(i));
            } else {
                janet_asm_error(&a, "slot names must be symbols or tuple of symbols");
            }
        }
    }

    /* Parse constants */
    x = janet_get1(s, janet_ckeywordv("constants"));
    if (janet_indexed_view(x, &arr, &count)) {
        def->constants_length = count;
        def->constants = janet_malloc(sizeof(Janet) * (size_t) count);
        if (NULL == def->constants) {
            JANET_OUT_OF_MEMORY;
        }
        for (i = 0; i < count; i++) {
            Janet ct = arr[i];
            def->constants[i] = ct;
        }
    } else {
        def->constants = NULL;
        def->constants_length = 0;
    }

    /* Parse sub funcdefs */
    x = janet_get1(s, janet_ckeywordv("closures"));
    if (janet_indexed_view(x, &arr, &count)) {
        int32_t i;
        for (i = 0; i < count; i++) {
            JanetAssembleResult subres;
            Janet subname;
            int32_t newlen;
            subres = janet_asm1(&a, arr[i], flags);
            if (subres.status != JANET_ASSEMBLE_OK) {
                janet_asm_errorv(&a, subres.error);
            }
            subname = janet_get1(arr[i], janet_ckeywordv("name"));
            if (!janet_checktype(subname, JANET_NIL)) {
                janet_table_put(&a.defs, subname, janet_wrap_integer(def->defs_length));
            }
            newlen = def->defs_length + 1;
            if (a.defs_capacity < newlen) {
                int32_t newcap = newlen;
                def->defs = janet_realloc(def->defs, newcap * sizeof(JanetFuncDef *));
                if (NULL == def->defs) {
                    JANET_OUT_OF_MEMORY;
                }
                a.defs_capacity = newcap;
            }
            def->defs[def->defs_length] = subres.funcdef;
            def->defs_length = newlen;
        }
    }

    /* Parse bytecode and labels */
    x = janet_get1(s, janet_ckeywordv("bytecode"));
    if (janet_indexed_view(x, &arr, &count)) {
        /* Do labels and find length */
        int32_t blength = 0;
        for (i = 0; i < count; ++i) {
            Janet instr = arr[i];
            if (janet_checktype(instr, JANET_KEYWORD)) {
                janet_table_put(&a.labels, instr, janet_wrap_integer(blength));
            } else if (janet_checktype(instr, JANET_TUPLE)) {
                blength++;
            } else {
                a.errindex = i;
                janet_asm_error(&a, "expected assembly instruction");
            }
        }
        /* Allocate bytecode array */
        def->bytecode_length = blength;
        def->bytecode = janet_malloc(sizeof(uint32_t) * (size_t) blength);
        if (NULL == def->bytecode) {
            JANET_OUT_OF_MEMORY;
        }
        /* Do bytecode */
        for (i = 0; i < count; ++i) {
            Janet instr = arr[i];
            if (janet_checktype(instr, JANET_KEYWORD)) {
                continue;
            } else {
                uint32_t op;
                const JanetInstructionDef *idef;
                const Janet *t;
                a.errindex = i;
                janet_asm_assert(&a, janet_checktype(instr, JANET_TUPLE), "expected tuple");
                t = janet_unwrap_tuple(instr);
                if (janet_tuple_length(t) == 0) {
                    op = 0;
                } else {
                    janet_asm_assert(&a, janet_checktype(t[0], JANET_SYMBOL),
                                     "expected symbol in assembly instruction");
                    idef = janet_strbinsearch(
                               &janet_ops,
                               sizeof(janet_ops) / sizeof(JanetInstructionDef),
                               sizeof(JanetInstructionDef),
                               janet_unwrap_symbol(t[0]));
                    if (NULL == idef)
                        janet_asm_errorv(&a, janet_formatc("unknown instruction %v", t[0]));
                    op = read_instruction(&a, idef, t);
                }
                def->bytecode[a.bytecode_count++] = op;
            }
        }
    } else {
        janet_asm_error(&a, "bytecode expected");
    }
    a.errindex = -1;

    /* Check for source mapping */
    x = janet_get1(s, janet_ckeywordv("sourcemap"));
    if (janet_indexed_view(x, &arr, &count)) {
        janet_asm_assert(&a, count == def->bytecode_length, "sourcemap must have the same length as the bytecode");
        def->sourcemap = janet_malloc(sizeof(JanetSourceMapping) * (size_t) count);
        if (NULL == def->sourcemap) {
            JANET_OUT_OF_MEMORY;
        }
        for (i = 0; i < count; i++) {
            const Janet *tup;
            Janet entry = arr[i];
            JanetSourceMapping mapping;
            if (!janet_checktype(entry, JANET_TUPLE)) {
                janet_asm_error(&a, "expected tuple");
            }
            tup = janet_unwrap_tuple(entry);
            if (!janet_checkint(tup[0])) {
                janet_asm_error(&a, "expected integer");
            }
            if (!janet_checkint(tup[1])) {
                janet_asm_error(&a, "expected integer");
            }
            mapping.line = janet_unwrap_integer(tup[0]);
            mapping.column = janet_unwrap_integer(tup[1]);
            def->sourcemap[i] = mapping;
        }
    }

    /* Set environments */
    def->environments =
        janet_realloc(def->environments, def->environments_length * sizeof(int32_t));
    if (NULL == def->environments) {
        JANET_OUT_OF_MEMORY;
    }

    /* Verify the func def */
    if (janet_verify(def)) {
        janet_asm_error(&a, "invalid assembly");
    }

    /* Add final flags */
    janet_def_addflags(def);

    /* Finish everything and return funcdef */
    janet_asm_deinit(&a);
    result.error = NULL;
    result.funcdef = def;
    result.status = JANET_ASSEMBLE_OK;
    return result;
}

/* Assemble a function */
JanetAssembleResult janet_asm(Janet source, int flags) {
    return janet_asm1(NULL, source, flags);
}

/* Disassembly */

/* Find the definition of an instruction given the instruction word. Return
 * NULL if not found. */
static const JanetInstructionDef *janet_asm_reverse_lookup(uint32_t instr) {
    size_t i;
    uint32_t opcode = instr & 0x7F;
    for (i = 0; i < sizeof(janet_ops) / sizeof(JanetInstructionDef); i++) {
        const JanetInstructionDef *def = janet_ops + i;
        if (def->opcode == opcode)
            return def;
    }
    return NULL;
}

/* Create some constant sized tuples */
static const Janet *tup1(Janet x) {
    Janet *tup = janet_tuple_begin(1);
    tup[0] = x;
    return janet_tuple_end(tup);
}
static const Janet *tup2(Janet x, Janet y) {
    Janet *tup = janet_tuple_begin(2);
    tup[0] = x;
    tup[1] = y;
    return janet_tuple_end(tup);
}
static const Janet *tup3(Janet x, Janet y, Janet z) {
    Janet *tup = janet_tuple_begin(3);
    tup[0] = x;
    tup[1] = y;
    tup[2] = z;
    return janet_tuple_end(tup);
}
static const Janet *tup4(Janet w, Janet x, Janet y, Janet z) {
    Janet *tup = janet_tuple_begin(4);
    tup[0] = w;
    tup[1] = x;
    tup[2] = y;
    tup[3] = z;
    return janet_tuple_end(tup);
}

/* Given an argument, convert it to the appropriate integer or symbol */
Janet janet_asm_decode_instruction(uint32_t instr) {
    const JanetInstructionDef *def = janet_asm_reverse_lookup(instr);
    Janet name;
    if (NULL == def) {
        return janet_wrap_integer((int32_t)instr);
    }
    name = janet_csymbolv(def->name);
    const Janet *ret = NULL;
#define oparg(shift, mask) ((instr >> ((shift) << 3)) & (mask))
    switch (janet_instructions[def->opcode]) {
        case JINT_0:
            ret = tup1(name);
            break;
        case JINT_S:
            ret = tup2(name, janet_wrap_integer(oparg(1, 0xFFFFFF)));
            break;
        case JINT_L:
            ret = tup2(name, janet_wrap_integer((int32_t)instr >> 8));
            break;
        case JINT_SS:
        case JINT_ST:
        case JINT_SC:
        case JINT_SU:
        case JINT_SD:
            ret = tup3(name,
                       janet_wrap_integer(oparg(1, 0xFF)),
                       janet_wrap_integer(oparg(2, 0xFFFF)));
            break;
        case JINT_SI:
        case JINT_SL:
            ret =  tup3(name,
                        janet_wrap_integer(oparg(1, 0xFF)),
                        janet_wrap_integer((int32_t)instr >> 16));
            break;
        case JINT_SSS:
        case JINT_SES:
        case JINT_SSU:
            ret = tup4(name,
                       janet_wrap_integer(oparg(1, 0xFF)),
                       janet_wrap_integer(oparg(2, 0xFF)),
                       janet_wrap_integer(oparg(3, 0xFF)));
            break;
        case JINT_SSI:
            ret = tup4(name,
                       janet_wrap_integer(oparg(1, 0xFF)),
                       janet_wrap_integer(oparg(2, 0xFF)),
                       janet_wrap_integer((int32_t)instr >> 24));
            break;
    }
#undef oparg
    if (ret) {
        /* Check if break point set */
        if (instr & 0x80) {
            janet_tuple_flag(ret) |= JANET_TUPLE_FLAG_BRACKETCTOR;
        }
        return janet_wrap_tuple(ret);
    }
    return janet_wrap_nil();
}

/*
 * Disasm sections
 */

static Janet janet_disasm_arity(JanetFuncDef *def) {
    return janet_wrap_integer(def->arity);
}

static Janet janet_disasm_min_arity(JanetFuncDef *def) {
    return janet_wrap_integer(def->min_arity);
}

static Janet janet_disasm_max_arity(JanetFuncDef *def) {
    return janet_wrap_integer(def->max_arity);
}

static Janet janet_disasm_slotcount(JanetFuncDef *def) {
    return janet_wrap_integer(def->slotcount);
}

static Janet janet_disasm_bytecode(JanetFuncDef *def) {
    JanetArray *bcode = janet_array(def->bytecode_length);
    for (int32_t i = 0; i < def->bytecode_length; i++) {
        bcode->data[i] = janet_asm_decode_instruction(def->bytecode[i]);
    }
    bcode->count = def->bytecode_length;
    return janet_wrap_array(bcode);
}

static Janet janet_disasm_source(JanetFuncDef *def) {
    if (def->source != NULL) return janet_wrap_string(def->source);
    return janet_wrap_nil();
}

static Janet janet_disasm_name(JanetFuncDef *def) {
    if (def->name != NULL) return janet_wrap_string(def->name);
    return janet_wrap_nil();
}

static Janet janet_disasm_vararg(JanetFuncDef *def) {
    return janet_wrap_boolean(def->flags & JANET_FUNCDEF_FLAG_VARARG);
}

static Janet janet_disasm_structarg(JanetFuncDef *def) {
    return janet_wrap_boolean(def->flags & JANET_FUNCDEF_FLAG_STRUCTARG);
}

static Janet janet_disasm_constants(JanetFuncDef *def) {
    JanetArray *constants = janet_array(def->constants_length);
    for (int32_t i = 0; i < def->constants_length; i++) {
        constants->data[i] = def->constants[i];
    }
    constants->count = def->constants_length;
    return janet_wrap_array(constants);
}

static Janet janet_disasm_sourcemap(JanetFuncDef *def) {
    if (NULL == def->sourcemap) return janet_wrap_nil();
    JanetArray *sourcemap = janet_array(def->bytecode_length);
    for (int32_t i = 0; i < def->bytecode_length; i++) {
        Janet *t = janet_tuple_begin(2);
        JanetSourceMapping mapping = def->sourcemap[i];
        t[0] = janet_wrap_integer(mapping.line);
        t[1] = janet_wrap_integer(mapping.column);
        sourcemap->data[i] = janet_wrap_tuple(janet_tuple_end(t));
    }
    sourcemap->count = def->bytecode_length;
    return janet_wrap_array(sourcemap);
}

static Janet janet_disasm_environments(JanetFuncDef *def) {
    JanetArray *envs = janet_array(def->environments_length);
    for (int32_t i = 0; i < def->environments_length; i++) {
        envs->data[i] = janet_wrap_integer(def->environments[i]);
    }
    envs->count = def->environments_length;
    return janet_wrap_array(envs);
}

static Janet janet_disasm_defs(JanetFuncDef *def) {
    JanetArray *defs = janet_array(def->defs_length);
    for (int32_t i = 0; i < def->defs_length; i++) {
        defs->data[i] = janet_disasm(def->defs[i]);
    }
    defs->count = def->defs_length;
    return janet_wrap_array(defs);
}

Janet janet_disasm(JanetFuncDef *def) {
    JanetTable *ret = janet_table(10);
    janet_table_put(ret, janet_ckeywordv("arity"), janet_disasm_arity(def));
    janet_table_put(ret, janet_ckeywordv("min-arity"), janet_disasm_min_arity(def));
    janet_table_put(ret, janet_ckeywordv("max-arity"), janet_disasm_max_arity(def));
    janet_table_put(ret, janet_ckeywordv("bytecode"), janet_disasm_bytecode(def));
    janet_table_put(ret, janet_ckeywordv("source"), janet_disasm_source(def));
    janet_table_put(ret, janet_ckeywordv("vararg"), janet_disasm_vararg(def));
    janet_table_put(ret, janet_ckeywordv("structarg"), janet_disasm_structarg(def));
    janet_table_put(ret, janet_ckeywordv("name"), janet_disasm_name(def));
    janet_table_put(ret, janet_ckeywordv("slotcount"), janet_disasm_slotcount(def));
    janet_table_put(ret, janet_ckeywordv("constants"), janet_disasm_constants(def));
    janet_table_put(ret, janet_ckeywordv("sourcemap"), janet_disasm_sourcemap(def));
    janet_table_put(ret, janet_ckeywordv("environments"), janet_disasm_environments(def));
    janet_table_put(ret, janet_ckeywordv("defs"), janet_disasm_defs(def));
    return janet_wrap_struct(janet_table_to_struct(ret));
}

JANET_CORE_FN(cfun_asm,
              "(asm assembly)",
              "Returns a new function that is the compiled result of the assembly.\n"
              "The syntax for the assembly can be found on the Janet website, and should correspond\n"
              "to the return value of disasm. Will throw an\n"
              "error on invalid assembly.") {
    janet_fixarity(argc, 1);
    JanetAssembleResult res;
    res = janet_asm(argv[0], 0);
    if (res.status != JANET_ASSEMBLE_OK) {
        janet_panics(res.error);
    }
    return janet_wrap_function(janet_thunk(res.funcdef));
}

JANET_CORE_FN(cfun_disasm,
              "(disasm func &opt field)",
              "Returns assembly that could be used to compile the given function. "
              "func must be a function, not a c function. Will throw on error on a badly "
              "typed argument. If given a field name, will only return that part of the function assembly. "
              "Possible fields are:\n\n"
              "* :arity - number of required and optional arguments.\n"
              "* :min-arity - minimum number of arguments function can be called with.\n"
              "* :max-arity - maximum number of arguments function can be called with.\n"
              "* :vararg - true if function can take a variable number of arguments.\n"
              "* :bytecode - array of parsed bytecode instructions. Each instruction is a tuple.\n"
              "* :source - name of source file that this function was compiled from.\n"
              "* :name - name of function.\n"
              "* :slotcount - how many virtual registers, or slots, this function uses. Corresponds to stack space used by function.\n"
              "* :constants - an array of constants referenced by this function.\n"
              "* :sourcemap - a mapping of each bytecode instruction to a line and column in the source file.\n"
              "* :environments - an internal mapping of which enclosing functions are referenced for bindings.\n"
              "* :defs - other function definitions that this function may instantiate.\n") {
    janet_arity(argc, 1, 2);
    JanetFunction *f = janet_getfunction(argv, 0);
    if (argc == 2) {
        JanetKeyword kw = janet_getkeyword(argv, 1);
        if (!janet_cstrcmp(kw, "arity")) return janet_disasm_arity(f->def);
        if (!janet_cstrcmp(kw, "min-arity")) return janet_disasm_min_arity(f->def);
        if (!janet_cstrcmp(kw, "max-arity")) return janet_disasm_max_arity(f->def);
        if (!janet_cstrcmp(kw, "bytecode")) return janet_disasm_bytecode(f->def);
        if (!janet_cstrcmp(kw, "source")) return janet_disasm_source(f->def);
        if (!janet_cstrcmp(kw, "name")) return janet_disasm_name(f->def);
        if (!janet_cstrcmp(kw, "vararg")) return janet_disasm_vararg(f->def);
        if (!janet_cstrcmp(kw, "structarg")) return janet_disasm_structarg(f->def);
        if (!janet_cstrcmp(kw, "slotcount")) return janet_disasm_slotcount(f->def);
        if (!janet_cstrcmp(kw, "constants")) return janet_disasm_constants(f->def);
        if (!janet_cstrcmp(kw, "sourcemap")) return janet_disasm_sourcemap(f->def);
        if (!janet_cstrcmp(kw, "environments")) return janet_disasm_environments(f->def);
        if (!janet_cstrcmp(kw, "defs")) return janet_disasm_defs(f->def);
        janet_panicf("unknown disasm key %v", argv[1]);
    } else {
        return janet_disasm(f->def);
    }
}

/* Load the library */
void janet_lib_asm(JanetTable *env) {
    JanetRegExt asm_cfuns[] = {
        JANET_CORE_REG("asm", cfun_asm),
        JANET_CORE_REG("disasm", cfun_disasm),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, asm_cfuns);
}

#endif


/* src/core/buffer.c */
#line 0 "src/core/buffer.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include "state.h"
#endif

/* Initialize a buffer */
JanetBuffer *janet_buffer_init(JanetBuffer *buffer, int32_t capacity) {
    uint8_t *data = NULL;
    if (capacity < 4) capacity = 4;
    janet_gcpressure(capacity);
    data = janet_malloc(sizeof(uint8_t) * (size_t) capacity);
    if (NULL == data) {
        JANET_OUT_OF_MEMORY;
    }
    buffer->count = 0;
    buffer->capacity = capacity;
    buffer->data = data;
    return buffer;
}

/* Deinitialize a buffer (free data memory) */
void janet_buffer_deinit(JanetBuffer *buffer) {
    janet_free(buffer->data);
}

/* Initialize a buffer */
JanetBuffer *janet_buffer(int32_t capacity) {
    JanetBuffer *buffer = janet_gcalloc(JANET_MEMORY_BUFFER, sizeof(JanetBuffer));
    return janet_buffer_init(buffer, capacity);
}

/* Ensure that the buffer has enough internal capacity */
void janet_buffer_ensure(JanetBuffer *buffer, int32_t capacity, int32_t growth) {
    uint8_t *new_data;
    uint8_t *old = buffer->data;
    if (capacity <= buffer->capacity) return;
    int64_t big_capacity = ((int64_t) capacity) * growth;
    capacity = big_capacity > INT32_MAX ? INT32_MAX : (int32_t) big_capacity;
    janet_gcpressure(capacity - buffer->capacity);
    new_data = janet_realloc(old, (size_t) capacity * sizeof(uint8_t));
    if (NULL == new_data) {
        JANET_OUT_OF_MEMORY;
    }
    buffer->data = new_data;
    buffer->capacity = capacity;
}

/* Ensure that the buffer has enough internal capacity */
void janet_buffer_setcount(JanetBuffer *buffer, int32_t count) {
    if (count < 0)
        return;
    if (count > buffer->count) {
        int32_t oldcount = buffer->count;
        janet_buffer_ensure(buffer, count, 1);
        memset(buffer->data + oldcount, 0, count - oldcount);
    }
    buffer->count = count;
}

/* Adds capacity for enough extra bytes to the buffer. Ensures that the
 * next n bytes pushed to the buffer will not cause a reallocation */
void janet_buffer_extra(JanetBuffer *buffer, int32_t n) {
    /* Check for buffer overflow */
    if ((int64_t)n + buffer->count > INT32_MAX) {
        janet_panic("buffer overflow");
    }
    int32_t new_size = buffer->count + n;
    if (new_size > buffer->capacity) {
        int32_t new_capacity = (new_size > (INT32_MAX / 2)) ? INT32_MAX : (new_size * 2);
        uint8_t *new_data = janet_realloc(buffer->data, new_capacity * sizeof(uint8_t));
        janet_gcpressure(new_capacity - buffer->capacity);
        if (NULL == new_data) {
            JANET_OUT_OF_MEMORY;
        }
        buffer->data = new_data;
        buffer->capacity = new_capacity;
    }
}

/* Push a cstring to buffer */
void janet_buffer_push_cstring(JanetBuffer *buffer, const char *cstring) {
    int32_t len = 0;
    while (cstring[len]) ++len;
    janet_buffer_push_bytes(buffer, (const uint8_t *) cstring, len);
}

/* Push multiple bytes into the buffer */
void janet_buffer_push_bytes(JanetBuffer *buffer, const uint8_t *string, int32_t length) {
    if (0 == length) return;
    janet_buffer_extra(buffer, length);
    memcpy(buffer->data + buffer->count, string, length);
    buffer->count += length;
}

void janet_buffer_push_string(JanetBuffer *buffer, const uint8_t *string) {
    janet_buffer_push_bytes(buffer, string, janet_string_length(string));
}

/* Push a single byte to the buffer */
void janet_buffer_push_u8(JanetBuffer *buffer, uint8_t byte) {
    janet_buffer_extra(buffer, 1);
    buffer->data[buffer->count] = byte;
    buffer->count++;
}

/* Push a 16 bit unsigned integer to the buffer */
void janet_buffer_push_u16(JanetBuffer *buffer, uint16_t x) {
    janet_buffer_extra(buffer, 2);
    buffer->data[buffer->count] = x & 0xFF;
    buffer->data[buffer->count + 1] = (x >> 8) & 0xFF;
    buffer->count += 2;
}

/* Push a 32 bit unsigned integer to the buffer */
void janet_buffer_push_u32(JanetBuffer *buffer, uint32_t x) {
    janet_buffer_extra(buffer, 4);
    buffer->data[buffer->count] = x & 0xFF;
    buffer->data[buffer->count + 1] = (x >> 8) & 0xFF;
    buffer->data[buffer->count + 2] = (x >> 16) & 0xFF;
    buffer->data[buffer->count + 3] = (x >> 24) & 0xFF;
    buffer->count += 4;
}

/* Push a 64 bit unsigned integer to the buffer */
void janet_buffer_push_u64(JanetBuffer *buffer, uint64_t x) {
    janet_buffer_extra(buffer, 8);
    buffer->data[buffer->count] = x & 0xFF;
    buffer->data[buffer->count + 1] = (x >> 8) & 0xFF;
    buffer->data[buffer->count + 2] = (x >> 16) & 0xFF;
    buffer->data[buffer->count + 3] = (x >> 24) & 0xFF;
    buffer->data[buffer->count + 4] = (x >> 32) & 0xFF;
    buffer->data[buffer->count + 5] = (x >> 40) & 0xFF;
    buffer->data[buffer->count + 6] = (x >> 48) & 0xFF;
    buffer->data[buffer->count + 7] = (x >> 56) & 0xFF;
    buffer->count += 8;
}

/* C functions */

JANET_CORE_FN(cfun_buffer_new,
              "(buffer/new capacity)",
              "Creates a new, empty buffer with enough backing memory for `capacity` bytes. "
              "Returns a new buffer of length 0.") {
    janet_fixarity(argc, 1);
    int32_t cap = janet_getinteger(argv, 0);
    JanetBuffer *buffer = janet_buffer(cap);
    return janet_wrap_buffer(buffer);
}

JANET_CORE_FN(cfun_buffer_new_filled,
              "(buffer/new-filled count &opt byte)",
              "Creates a new buffer of length `count` filled with `byte`. By default, `byte` is 0. "
              "Returns the new buffer.") {
    janet_arity(argc, 1, 2);
    int32_t count = janet_getinteger(argv, 0);
    if (count < 0) count = 0;
    int32_t byte = 0;
    if (argc == 2) {
        byte = janet_getinteger(argv, 1) & 0xFF;
    }
    JanetBuffer *buffer = janet_buffer(count);
    if (buffer->data && count > 0)
        memset(buffer->data, byte, count);
    buffer->count = count;
    return janet_wrap_buffer(buffer);
}

JANET_CORE_FN(cfun_buffer_fill,
              "(buffer/fill buffer &opt byte)",
              "Fill up a buffer with bytes, defaulting to 0s. Does not change the buffer's length. "
              "Returns the modified buffer.") {
    janet_arity(argc, 1, 2);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    int32_t byte = 0;
    if (argc == 2) {
        byte = janet_getinteger(argv, 1) & 0xFF;
    }
    if (buffer->count) {
        memset(buffer->data, byte, buffer->count);
    }
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_trim,
              "(buffer/trim buffer)",
              "Set the backing capacity of the buffer to the current length of the buffer. Returns the "
              "modified buffer.") {
    janet_fixarity(argc, 1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    if (buffer->count < buffer->capacity) {
        int32_t newcap = buffer->count > 4 ? buffer->count : 4;
        uint8_t *newData = janet_realloc(buffer->data, newcap);
        if (NULL == newData) {
            JANET_OUT_OF_MEMORY;
        }
        buffer->data = newData;
        buffer->capacity = newcap;
    }
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_u8,
              "(buffer/push-byte buffer & xs)",
              "Append bytes to a buffer. Will expand the buffer as necessary. "
              "Returns the modified buffer. Will throw an error if the buffer overflows.") {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    for (i = 1; i < argc; i++) {
        janet_buffer_push_u8(buffer, (uint8_t)(janet_getinteger(argv, i) & 0xFF));
    }
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_word,
              "(buffer/push-word buffer & xs)",
              "Append machine words to a buffer. The 4 bytes of the integer are appended "
              "in twos complement, little endian order, unsigned for all x. Returns the modified buffer. Will "
              "throw an error if the buffer overflows.") {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    for (i = 1; i < argc; i++) {
        double number = janet_getnumber(argv, i);
        uint32_t word = (uint32_t) number;
        if (word != number)
            janet_panicf("cannot convert %v to machine word", argv[i]);
        janet_buffer_push_u32(buffer, word);
    }
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_chars,
              "(buffer/push-string buffer & xs)",
              "Push byte sequences onto the end of a buffer. "
              "Will accept any of strings, keywords, symbols, and buffers. "
              "Returns the modified buffer. "
              "Will throw an error if the buffer overflows.") {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    for (i = 1; i < argc; i++) {
        JanetByteView view = janet_getbytes(argv, i);
        if (view.bytes == buffer->data) {
            janet_buffer_ensure(buffer, buffer->count + view.len, 2);
            view.bytes = buffer->data;
        }
        janet_buffer_push_bytes(buffer, view.bytes, view.len);
    }
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_push,
              "(buffer/push buffer & xs)",
              "Push both individual bytes and byte sequences to a buffer. For each x in xs, "
              "push the byte if x is an integer, otherwise push the bytesequence to the buffer. "
              "Thus, this function behaves like both `buffer/push-string` and `buffer/push-byte`. "
              "Returns the modified buffer. "
              "Will throw an error if the buffer overflows.") {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    for (i = 1; i < argc; i++) {
        if (janet_checktype(argv[i], JANET_NUMBER)) {
            janet_buffer_push_u8(buffer, (uint8_t)(janet_getinteger(argv, i) & 0xFF));
        } else {
            JanetByteView view = janet_getbytes(argv, i);
            if (view.bytes == buffer->data) {
                janet_buffer_ensure(buffer, buffer->count + view.len, 2);
                view.bytes = buffer->data;
            }
            janet_buffer_push_bytes(buffer, view.bytes, view.len);
        }
    }
    return argv[0];
}


JANET_CORE_FN(cfun_buffer_clear,
              "(buffer/clear buffer)",
              "Sets the size of a buffer to 0 and empties it. The buffer retains "
              "its memory so it can be efficiently refilled. Returns the modified buffer.") {
    janet_fixarity(argc, 1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    buffer->count = 0;
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_popn,
              "(buffer/popn buffer n)",
              "Removes the last `n` bytes from the buffer. Returns the modified buffer.") {
    janet_fixarity(argc, 2);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    int32_t n = janet_getinteger(argv, 1);
    if (n < 0) janet_panic("n must be non-negative");
    if (buffer->count < n) {
        buffer->count = 0;
    } else {
        buffer->count -= n;
    }
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_slice,
              "(buffer/slice bytes &opt start end)",
              "Takes a slice of a byte sequence from `start` to `end`. The range is half open, "
              "[start, end). Indexes can also be negative, indicating indexing from the end of the "
              "end of the array. By default, `start` is 0 and `end` is the length of the buffer. "
              "Returns a new buffer.") {
    JanetByteView view = janet_getbytes(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    JanetBuffer *buffer = janet_buffer(range.end - range.start);
    if (buffer->data)
        memcpy(buffer->data, view.bytes + range.start, range.end - range.start);
    buffer->count = range.end - range.start;
    return janet_wrap_buffer(buffer);
}

static void bitloc(int32_t argc, Janet *argv, JanetBuffer **b, int32_t *index, int *bit) {
    janet_fixarity(argc, 2);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    double x = janet_getnumber(argv, 1);
    int64_t bitindex = (int64_t) x;
    int64_t byteindex = bitindex >> 3;
    int which_bit = bitindex & 7;
    if (bitindex != x || bitindex < 0 || byteindex >= buffer->count)
        janet_panicf("invalid bit index %v", argv[1]);
    *b = buffer;
    *index = (int32_t) byteindex;
    *bit = which_bit;
}

JANET_CORE_FN(cfun_buffer_bitset,
              "(buffer/bit-set buffer index)",
              "Sets the bit at the given bit-index. Returns the buffer.") {
    int bit;
    int32_t index;
    JanetBuffer *buffer;
    bitloc(argc, argv, &buffer, &index, &bit);
    buffer->data[index] |= 1 << bit;
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_bitclear,
              "(buffer/bit-clear buffer index)",
              "Clears the bit at the given bit-index. Returns the buffer.") {
    int bit;
    int32_t index;
    JanetBuffer *buffer;
    bitloc(argc, argv, &buffer, &index, &bit);
    buffer->data[index] &= ~(1 << bit);
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_bitget,
              "(buffer/bit buffer index)",
              "Gets the bit at the given bit-index. Returns true if the bit is set, false if not.") {
    int bit;
    int32_t index;
    JanetBuffer *buffer;
    bitloc(argc, argv, &buffer, &index, &bit);
    return janet_wrap_boolean(buffer->data[index] & (1 << bit));
}

JANET_CORE_FN(cfun_buffer_bittoggle,
              "(buffer/bit-toggle buffer index)",
              "Toggles the bit at the given bit index in buffer. Returns the buffer.") {
    int bit;
    int32_t index;
    JanetBuffer *buffer;
    bitloc(argc, argv, &buffer, &index, &bit);
    buffer->data[index] ^= (1 << bit);
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_blit,
              "(buffer/blit dest src &opt dest-start src-start src-end)",
              "Insert the contents of `src` into `dest`. Can optionally take indices that "
              "indicate which part of `src` to copy into which part of `dest`. Indices can be "
              "negative in order to index from the end of `src` or `dest`. Returns `dest`.") {
    janet_arity(argc, 2, 5);
    JanetBuffer *dest = janet_getbuffer(argv, 0);
    JanetByteView src = janet_getbytes(argv, 1);
    int same_buf = src.bytes == dest->data;
    int32_t offset_dest = 0;
    int32_t offset_src = 0;
    if (argc > 2)
        offset_dest = janet_gethalfrange(argv, 2, dest->count, "dest-start");
    if (argc > 3)
        offset_src = janet_gethalfrange(argv, 3, src.len, "src-start");
    int32_t length_src;
    if (argc > 4) {
        int32_t src_end = janet_gethalfrange(argv, 4, src.len, "src-end");
        length_src = src_end - offset_src;
        if (length_src < 0) length_src = 0;
    } else {
        length_src = src.len - offset_src;
    }
    int64_t last = (int64_t) offset_dest + length_src;
    if (last > INT32_MAX)
        janet_panic("buffer blit out of range");
    int32_t last32 = (int32_t) last;
    janet_buffer_ensure(dest, last32, 2);
    if (last32 > dest->count) dest->count = last32;
    if (length_src) {
        if (same_buf) {
            /* janet_buffer_ensure may have invalidated src */
            src.bytes = dest->data;
            memmove(dest->data + offset_dest, src.bytes + offset_src, length_src);
        } else {
            memcpy(dest->data + offset_dest, src.bytes + offset_src, length_src);
        }
    }
    return argv[0];
}

JANET_CORE_FN(cfun_buffer_format,
              "(buffer/format buffer format & args)",
              "Snprintf like functionality for printing values into a buffer. Returns "
              " the modified buffer.") {
    janet_arity(argc, 2, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    const char *strfrmt = (const char *) janet_getstring(argv, 1);
    janet_buffer_format(buffer, strfrmt, 1, argc, argv);
    return argv[0];
}

void janet_lib_buffer(JanetTable *env) {
    JanetRegExt buffer_cfuns[] = {
        JANET_CORE_REG("buffer/new", cfun_buffer_new),
        JANET_CORE_REG("buffer/new-filled", cfun_buffer_new_filled),
        JANET_CORE_REG("buffer/fill", cfun_buffer_fill),
        JANET_CORE_REG("buffer/trim", cfun_buffer_trim),
        JANET_CORE_REG("buffer/push-byte", cfun_buffer_u8),
        JANET_CORE_REG("buffer/push-word", cfun_buffer_word),
        JANET_CORE_REG("buffer/push-string", cfun_buffer_chars),
        JANET_CORE_REG("buffer/push", cfun_buffer_push),
        JANET_CORE_REG("buffer/popn", cfun_buffer_popn),
        JANET_CORE_REG("buffer/clear", cfun_buffer_clear),
        JANET_CORE_REG("buffer/slice", cfun_buffer_slice),
        JANET_CORE_REG("buffer/bit-set", cfun_buffer_bitset),
        JANET_CORE_REG("buffer/bit-clear", cfun_buffer_bitclear),
        JANET_CORE_REG("buffer/bit", cfun_buffer_bitget),
        JANET_CORE_REG("buffer/bit-toggle", cfun_buffer_bittoggle),
        JANET_CORE_REG("buffer/blit", cfun_buffer_blit),
        JANET_CORE_REG("buffer/format", cfun_buffer_format),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, buffer_cfuns);
}


/* src/core/bytecode.c */
#line 0 "src/core/bytecode.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#endif

/* Look up table for instructions */
enum JanetInstructionType janet_instructions[JOP_INSTRUCTION_COUNT] = {
    JINT_0, /* JOP_NOOP, */
    JINT_S, /* JOP_ERROR, */
    JINT_ST, /* JOP_TYPECHECK, */
    JINT_S, /* JOP_RETURN, */
    JINT_0, /* JOP_RETURN_NIL, */
    JINT_SSI, /* JOP_ADD_IMMEDIATE, */
    JINT_SSS, /* JOP_ADD, */
    JINT_SSS, /* JOP_SUBTRACT, */
    JINT_SSI, /* JOP_MULTIPLY_IMMEDIATE, */
    JINT_SSS, /* JOP_MULTIPLY, */
    JINT_SSI, /* JOP_DIVIDE_IMMEDIATE, */
    JINT_SSS, /* JOP_DIVIDE, */
    JINT_SSS, /* JOP_MODULO, */
    JINT_SSS, /* JOP_REMAINDER, */
    JINT_SSS, /* JOP_BAND, */
    JINT_SSS, /* JOP_BOR, */
    JINT_SSS, /* JOP_BXOR, */
    JINT_SS, /* JOP_BNOT, */
    JINT_SSS, /* JOP_SHIFT_LEFT, */
    JINT_SSI, /* JOP_SHIFT_LEFT_IMMEDIATE, */
    JINT_SSS, /* JOP_SHIFT_RIGHT, */
    JINT_SSI, /* JOP_SHIFT_RIGHT_IMMEDIATE, */
    JINT_SSS, /* JOP_SHIFT_RIGHT_UNSIGNED, */
    JINT_SSU, /* JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE, */
    JINT_SS, /* JOP_MOVE_FAR, */
    JINT_SS, /* JOP_MOVE_NEAR, */
    JINT_L, /* JOP_JUMP, */
    JINT_SL, /* JOP_JUMP_IF, */
    JINT_SL, /* JOP_JUMP_IF_NOT, */
    JINT_SL, /* JOP_JUMP_IF_NIL, */
    JINT_SL, /* JOP_JUMP_IF_NOT_NIL, */
    JINT_SSS, /* JOP_GREATER_THAN, */
    JINT_SSI, /* JOP_GREATER_THAN_IMMEDIATE, */
    JINT_SSS, /* JOP_LESS_THAN, */
    JINT_SSI, /* JOP_LESS_THAN_IMMEDIATE, */
    JINT_SSS, /* JOP_EQUALS, */
    JINT_SSI, /* JOP_EQUALS_IMMEDIATE, */
    JINT_SSS, /* JOP_COMPARE, */
    JINT_S, /* JOP_LOAD_NIL, */
    JINT_S, /* JOP_LOAD_TRUE, */
    JINT_S, /* JOP_LOAD_FALSE, */
    JINT_SI, /* JOP_LOAD_INTEGER, */
    JINT_SC, /* JOP_LOAD_CONSTANT, */
    JINT_SES, /* JOP_LOAD_UPVALUE, */
    JINT_S, /* JOP_LOAD_SELF, */
    JINT_SES, /* JOP_SET_UPVALUE, */
    JINT_SD, /* JOP_CLOSURE, */
    JINT_S, /* JOP_PUSH, */
    JINT_SS, /* JOP_PUSH_2, */
    JINT_SSS, /* JOP_PUSH_3, */
    JINT_S, /* JOP_PUSH_ARRAY, */
    JINT_SS, /* JOP_CALL, */
    JINT_S, /* JOP_TAILCALL, */
    JINT_SSS, /* JOP_RESUME, */
    JINT_SSU, /* JOP_SIGNAL, */
    JINT_SSS, /* JOP_PROPAGATE */
    JINT_SSS, /* JOP_IN, */
    JINT_SSS, /* JOP_GET, */
    JINT_SSS, /* JOP_PUT, */
    JINT_SSU, /* JOP_GET_INDEX, */
    JINT_SSU, /* JOP_PUT_INDEX, */
    JINT_SS, /* JOP_LENGTH */
    JINT_S, /* JOP_MAKE_ARRAY */
    JINT_S, /* JOP_MAKE_BUFFER */
    JINT_S, /* JOP_MAKE_STRING */
    JINT_S, /* JOP_MAKE_STRUCT */
    JINT_S, /* JOP_MAKE_TABLE */
    JINT_S, /* JOP_MAKE_TUPLE */
    JINT_S, /* JOP_MAKE_BRACKET_TUPLE */
    JINT_SSS, /* JOP_GREATER_THAN_EQUAL */
    JINT_SSS, /* JOP_LESS_THAN_EQUAL */
    JINT_SSS, /* JOP_NEXT */
    JINT_SSS, /* JOP_NOT_EQUALS, */
    JINT_SSI, /* JOP_NOT_EQUALS_IMMEDIATE, */
    JINT_SSS /* JOP_CANCEL, */
};

/* Verify some bytecode */
int janet_verify(JanetFuncDef *def) {
    int vargs = !!(def->flags & JANET_FUNCDEF_FLAG_VARARG);
    int32_t i;
    int32_t maxslot = def->arity + vargs;
    int32_t sc = def->slotcount;

    if (def->bytecode_length == 0) return 1;

    if (maxslot > sc) return 2;

    /* Verify each instruction */
    for (i = 0; i < def->bytecode_length; i++) {
        uint32_t instr = def->bytecode[i];
        /* Check for invalid instructions */
        if ((instr & 0x7F) >= JOP_INSTRUCTION_COUNT) {
            return 3;
        }
        enum JanetInstructionType type = janet_instructions[instr & 0x7F];
        switch (type) {
            case JINT_0:
                continue;
            case JINT_S: {
                if ((int32_t)(instr >> 8) >= sc) return 4;
                continue;
            }
            case JINT_SI:
            case JINT_SU:
            case JINT_ST: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                continue;
            }
            case JINT_L: {
                int32_t jumpdest = i + (((int32_t)instr) >> 8);
                if (jumpdest < 0 || jumpdest >= def->bytecode_length) return 5;
                continue;
            }
            case JINT_SS: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc ||
                        (int32_t)(instr >> 16) >= sc) return 4;
                continue;
            }
            case JINT_SSI:
            case JINT_SSU: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc ||
                        (int32_t)((instr >> 16) & 0xFF) >= sc) return 4;
                continue;
            }
            case JINT_SL: {
                int32_t jumpdest = i + (((int32_t)instr) >> 16);
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                if (jumpdest < 0 || jumpdest >= def->bytecode_length) return 5;
                continue;
            }
            case JINT_SSS: {
                if (((int32_t)(instr >> 8) & 0xFF) >= sc ||
                        ((int32_t)(instr >> 16) & 0xFF) >= sc ||
                        ((int32_t)(instr >> 24) & 0xFF) >= sc) return 4;
                continue;
            }
            case JINT_SD: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                if ((int32_t)(instr >> 16) >= def->defs_length) return 6;
                continue;
            }
            case JINT_SC: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                if ((int32_t)(instr >> 16) >= def->constants_length) return 7;
                continue;
            }
            case JINT_SES: {
                /* How can we check the last slot index? We need info parent funcdefs. Resort
                 * to runtime checks for now. Maybe invalid upvalue references could be defaulted
                 * to nil? (don't commit to this in the long term, though) */
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                if ((int32_t)((instr >> 16) & 0xFF) >= def->environments_length) return 8;
                continue;
            }
        }
    }

    /* Verify last instruction is either a jump, return, return-nil, or tailcall. Eventually,
     * some real flow analysis would be ideal, but this should be very effective. Will completely
     * prevent running over the end of bytecode. However, valid functions with dead code will
     * be rejected. */
    {
        uint32_t lastop = def->bytecode[def->bytecode_length - 1] & 0xFF;
        switch (lastop) {
            default:
                return 9;
            case JOP_RETURN:
            case JOP_RETURN_NIL:
            case JOP_JUMP:
            case JOP_ERROR:
            case JOP_TAILCALL:
                break;
        }
    }

    return 0;
}

/* Allocate an empty funcdef. This function may have added functionality
 * as commonalities between asm and compile arise. */
JanetFuncDef *janet_funcdef_alloc(void) {
    JanetFuncDef *def = janet_gcalloc(JANET_MEMORY_FUNCDEF, sizeof(JanetFuncDef));
    def->environments = NULL;
    def->constants = NULL;
    def->bytecode = NULL;
    def->closure_bitset = NULL;
    def->flags = 0;
    def->slotcount = 0;
    def->arity = 0;
    def->min_arity = 0;
    def->max_arity = INT32_MAX;
    def->source = NULL;
    def->sourcemap = NULL;
    def->name = NULL;
    def->defs = NULL;
    def->defs_length = 0;
    def->constants_length = 0;
    def->bytecode_length = 0;
    def->environments_length = 0;
    return def;
}

/* Create a simple closure from a funcdef */
JanetFunction *janet_thunk(JanetFuncDef *def) {
    JanetFunction *func = janet_gcalloc(JANET_MEMORY_FUNCTION, sizeof(JanetFunction));
    func->def = def;
    janet_assert(def->environments_length == 0, "tried to create thunk that needs upvalues");
    return func;
}


/* src/core/capi.c */
#line 0 "src/core/capi.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "fiber.h"
#endif

#ifndef JANET_SINGLE_THREADED
#ifndef JANET_WINDOWS
#include <pthread.h>
#else
#include <windows.h>
#endif
#endif

JANET_NO_RETURN static void janet_top_level_signal(const char *msg) {
#ifdef JANET_TOP_LEVEL_SIGNAL
    JANET_TOP_LEVEL_SIGNAL(msg);
#else
    fputs(msg, stdout);
# ifdef JANET_SINGLE_THREADED
    exit(-1);
# elif defined(JANET_WINDOWS)
    ExitThread(-1);
# else
    pthread_exit(NULL);
# endif
#endif
}

void janet_signalv(JanetSignal sig, Janet message) {
    if (janet_vm.return_reg != NULL) {
        *janet_vm.return_reg = message;
        if (NULL != janet_vm.fiber) {
            janet_vm.fiber->flags |= JANET_FIBER_DID_LONGJUMP;
        }
#if defined(JANET_BSD) || defined(JANET_APPLE)
        _longjmp(*janet_vm.signal_buf, sig);
#else
        longjmp(*janet_vm.signal_buf, sig);
#endif
    } else {
        const char *str = (const char *)janet_formatc("janet top level signal - %v\n", message);
        janet_top_level_signal(str);
    }
}

void janet_panicv(Janet message) {
    janet_signalv(JANET_SIGNAL_ERROR, message);
}

void janet_panicf(const char *format, ...) {
    va_list args;
    const uint8_t *ret;
    JanetBuffer buffer;
    int32_t len = 0;
    while (format[len]) len++;
    janet_buffer_init(&buffer, len);
    va_start(args, format);
    janet_formatbv(&buffer, format, args);
    va_end(args);
    ret = janet_string(buffer.data, buffer.count);
    janet_buffer_deinit(&buffer);
    janet_panics(ret);
}

void janet_panic(const char *message) {
    janet_panicv(janet_cstringv(message));
}

void janet_panics(const uint8_t *message) {
    janet_panicv(janet_wrap_string(message));
}

void janet_panic_type(Janet x, int32_t n, int expected) {
    janet_panicf("bad slot #%d, expected %T, got %v", n, expected, x);
}

void janet_panic_abstract(Janet x, int32_t n, const JanetAbstractType *at) {
    janet_panicf("bad slot #%d, expected %s, got %v", n, at->name, x);
}

void janet_fixarity(int32_t arity, int32_t fix) {
    if (arity != fix)
        janet_panicf("arity mismatch, expected %d, got %d", fix, arity);
}

void janet_arity(int32_t arity, int32_t min, int32_t max) {
    if (min >= 0 && arity < min)
        janet_panicf("arity mismatch, expected at least %d, got %d", min, arity);
    if (max >= 0 && arity > max)
        janet_panicf("arity mismatch, expected at most %d, got %d", max, arity);
}

#define DEFINE_GETTER(name, NAME, type) \
type janet_get##name(const Janet *argv, int32_t n) { \
    Janet x = argv[n]; \
    if (!janet_checktype(x, JANET_##NAME)) { \
        janet_panic_type(x, n, JANET_TFLAG_##NAME); \
    } \
    return janet_unwrap_##name(x); \
}

#define DEFINE_OPT(name, NAME, type) \
type janet_opt##name(const Janet *argv, int32_t argc, int32_t n, type dflt) { \
    if (n >= argc) return dflt; \
    if (janet_checktype(argv[n], JANET_NIL)) return dflt; \
    return janet_get##name(argv, n); \
}

#define DEFINE_OPTLEN(name, NAME, type) \
type janet_opt##name(const Janet *argv, int32_t argc, int32_t n, int32_t dflt_len) { \
    if (n >= argc || janet_checktype(argv[n], JANET_NIL)) {\
        return janet_##name(dflt_len); \
    }\
    return janet_get##name(argv, n); \
}

int janet_getmethod(const uint8_t *method, const JanetMethod *methods, Janet *out) {
    while (methods->name) {
        if (!janet_cstrcmp(method, methods->name)) {
            *out = janet_wrap_cfunction(methods->cfun);
            return 1;
        }
        methods++;
    }
    return 0;
}

Janet janet_nextmethod(const JanetMethod *methods, Janet key) {
    if (!janet_checktype(key, JANET_NIL)) {
        while (methods->name) {
            if (janet_keyeq(key, methods->name)) {
                methods++;
                break;
            }
            methods++;
        }
    }
    if (methods->name) {
        return janet_ckeywordv(methods->name);
    } else {
        return janet_wrap_nil();
    }
}

DEFINE_GETTER(number, NUMBER, double)
DEFINE_GETTER(array, ARRAY, JanetArray *)
DEFINE_GETTER(tuple, TUPLE, const Janet *)
DEFINE_GETTER(table, TABLE, JanetTable *)
DEFINE_GETTER(struct, STRUCT, const JanetKV *)
DEFINE_GETTER(string, STRING, const uint8_t *)
DEFINE_GETTER(keyword, KEYWORD, const uint8_t *)
DEFINE_GETTER(symbol, SYMBOL, const uint8_t *)
DEFINE_GETTER(buffer, BUFFER, JanetBuffer *)
DEFINE_GETTER(fiber, FIBER, JanetFiber *)
DEFINE_GETTER(function, FUNCTION, JanetFunction *)
DEFINE_GETTER(cfunction, CFUNCTION, JanetCFunction)
DEFINE_GETTER(boolean, BOOLEAN, int)
DEFINE_GETTER(pointer, POINTER, void *)

DEFINE_OPT(number, NUMBER, double)
DEFINE_OPT(tuple, TUPLE, const Janet *)
DEFINE_OPT(struct, STRUCT, const JanetKV *)
DEFINE_OPT(string, STRING, const uint8_t *)
DEFINE_OPT(keyword, KEYWORD, const uint8_t *)
DEFINE_OPT(symbol, SYMBOL, const uint8_t *)
DEFINE_OPT(fiber, FIBER, JanetFiber *)
DEFINE_OPT(function, FUNCTION, JanetFunction *)
DEFINE_OPT(cfunction, CFUNCTION, JanetCFunction)
DEFINE_OPT(boolean, BOOLEAN, int)
DEFINE_OPT(pointer, POINTER, void *)

DEFINE_OPTLEN(buffer, BUFFER, JanetBuffer *)
DEFINE_OPTLEN(table, TABLE, JanetTable *)
DEFINE_OPTLEN(array, ARRAY, JanetArray *)

const char *janet_optcstring(const Janet *argv, int32_t argc, int32_t n, const char *dflt) {
    if (n >= argc || janet_checktype(argv[n], JANET_NIL)) {
        return dflt;
    }
    return janet_getcstring(argv, n);
}

#undef DEFINE_GETTER
#undef DEFINE_OPT
#undef DEFINE_OPTLEN

const char *janet_getcstring(const Janet *argv, int32_t n) {
    const uint8_t *jstr = janet_getstring(argv, n);
    const char *cstr = (const char *)jstr;
    if (strlen(cstr) != (size_t) janet_string_length(jstr)) {
        janet_panic("string contains embedded 0s");
    }
    return cstr;
}

int32_t janet_getnat(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    if (!janet_checkint(x)) goto bad;
    int32_t ret = janet_unwrap_integer(x);
    if (ret < 0) goto bad;
    return ret;
bad:
    janet_panicf("bad slot #%d, expected non-negative 32 bit signed integer, got %v", n, x);
}

JanetAbstract janet_checkabstract(Janet x, const JanetAbstractType *at) {
    if (!janet_checktype(x, JANET_ABSTRACT)) return NULL;
    JanetAbstract a = janet_unwrap_abstract(x);
    if (janet_abstract_type(a) != at) return NULL;
    return a;
}

static int janet_strlike_cmp(JanetType type, Janet x, const char *cstring) {
    if (janet_type(x) != type) return 0;
    return !janet_cstrcmp(janet_unwrap_string(x), cstring);
}

int janet_keyeq(Janet x, const char *cstring) {
    return janet_strlike_cmp(JANET_KEYWORD, x, cstring);
}

int janet_streq(Janet x, const char *cstring) {
    return janet_strlike_cmp(JANET_STRING, x, cstring);
}

int janet_symeq(Janet x, const char *cstring) {
    return janet_strlike_cmp(JANET_SYMBOL, x, cstring);
}

int32_t janet_getinteger(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    if (!janet_checkint(x)) {
        janet_panicf("bad slot #%d, expected 32 bit signed integer, got %v", n, x);
    }
    return janet_unwrap_integer(x);
}

int64_t janet_getinteger64(const Janet *argv, int32_t n) {
#ifdef JANET_INT_TYPES
    return janet_unwrap_s64(argv[n]);
#else
    Janet x = argv[n];
    if (!janet_checkint64(x)) {
        janet_panicf("bad slot #%d, expected 64 bit signed integer, got %v", n, x);
    }
    return (int64_t) janet_unwrap_number(x);
#endif
}

uint64_t janet_getuinteger64(const Janet *argv, int32_t n) {
#ifdef JANET_INT_TYPES
    return janet_unwrap_u64(argv[n]);
#else
    Janet x = argv[n];
    if (!janet_checkint64(x)) {
        janet_panicf("bad slot #%d, expected 64 bit unsigned integer, got %v", n, x);
    }
    return (uint64_t) janet_unwrap_number(x);
#endif
}

size_t janet_getsize(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    if (!janet_checksize(x)) {
        janet_panicf("bad slot #%d, expected size, got %v", n, x);
    }
    return (size_t) janet_unwrap_number(x);
}

int32_t janet_gethalfrange(const Janet *argv, int32_t n, int32_t length, const char *which) {
    int32_t raw = janet_getinteger(argv, n);
    int32_t not_raw = raw;
    if (not_raw < 0) not_raw += length + 1;
    if (not_raw < 0 || not_raw > length)
        janet_panicf("%s index %d out of range [%d,%d]", which, raw, -length - 1, length);
    return not_raw;
}

int32_t janet_getargindex(const Janet *argv, int32_t n, int32_t length, const char *which) {
    int32_t raw = janet_getinteger(argv, n);
    int32_t not_raw = raw;
    if (not_raw < 0) not_raw += length;
    if (not_raw < 0 || not_raw > length)
        janet_panicf("%s index %d out of range [%d,%d)", which, raw, -length, length);
    return not_raw;
}

JanetView janet_getindexed(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    JanetView view;
    if (!janet_indexed_view(x, &view.items, &view.len)) {
        janet_panic_type(x, n, JANET_TFLAG_INDEXED);
    }
    return view;
}

JanetByteView janet_getbytes(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    JanetByteView view;
    if (!janet_bytes_view(x, &view.bytes, &view.len)) {
        janet_panic_type(x, n, JANET_TFLAG_BYTES);
    }
    return view;
}

JanetDictView janet_getdictionary(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    JanetDictView view;
    if (!janet_dictionary_view(x, &view.kvs, &view.len, &view.cap)) {
        janet_panic_type(x, n, JANET_TFLAG_DICTIONARY);
    }
    return view;
}

void *janet_getabstract(const Janet *argv, int32_t n, const JanetAbstractType *at) {
    Janet x = argv[n];
    if (!janet_checktype(x, JANET_ABSTRACT)) {
        janet_panic_abstract(x, n, at);
    }
    void *abstractx = janet_unwrap_abstract(x);
    if (janet_abstract_type(abstractx) != at) {
        janet_panic_abstract(x, n, at);
    }
    return abstractx;
}

JanetRange janet_getslice(int32_t argc, const Janet *argv) {
    janet_arity(argc, 1, 3);
    JanetRange range;
    int32_t length = janet_length(argv[0]);
    if (argc == 1) {
        range.start = 0;
        range.end = length;
    } else if (argc == 2) {
        range.start = janet_checktype(argv[1], JANET_NIL)
                      ? 0
                      : janet_gethalfrange(argv, 1, length, "start");
        range.end = length;
    } else {
        range.start = janet_checktype(argv[1], JANET_NIL)
                      ? 0
                      : janet_gethalfrange(argv, 1, length, "start");
        range.end = janet_checktype(argv[2], JANET_NIL)
                    ? length
                    : janet_gethalfrange(argv, 2, length, "end");
        if (range.end < range.start)
            range.end = range.start;
    }
    return range;
}

Janet janet_dyn(const char *name) {
    if (!janet_vm.fiber) {
        if (!janet_vm.top_dyns) return janet_wrap_nil();
        return janet_table_get(janet_vm.top_dyns, janet_ckeywordv(name));
    }
    if (janet_vm.fiber->env) {
        return janet_table_get(janet_vm.fiber->env, janet_ckeywordv(name));
    } else {
        return janet_wrap_nil();
    }
}

void janet_setdyn(const char *name, Janet value) {
    if (!janet_vm.fiber) {
        if (!janet_vm.top_dyns) janet_vm.top_dyns = janet_table(10);
        janet_table_put(janet_vm.top_dyns, janet_ckeywordv(name), value);
    } else {
        if (!janet_vm.fiber->env) {
            janet_vm.fiber->env = janet_table(1);
        }
        janet_table_put(janet_vm.fiber->env, janet_ckeywordv(name), value);
    }
}

uint64_t janet_getflags(const Janet *argv, int32_t n, const char *flags) {
    uint64_t ret = 0;
    const uint8_t *keyw = janet_getkeyword(argv, n);
    int32_t klen = janet_string_length(keyw);
    int32_t flen = (int32_t) strlen(flags);
    if (flen > 64) {
        flen = 64;
    }
    for (int32_t j = 0; j < klen; j++) {
        for (int32_t i = 0; i < flen; i++) {
            if (((uint8_t) flags[i]) == keyw[j]) {
                ret |= 1ULL << i;
                goto found;
            }
        }
        janet_panicf("unexpected flag %c, expected one of \"%s\"", (char) keyw[j], flags);
    found:
        ;
    }
    return ret;
}

int32_t janet_optnat(const Janet *argv, int32_t argc, int32_t n, int32_t dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getnat(argv, n);
}

int32_t janet_optinteger(const Janet *argv, int32_t argc, int32_t n, int32_t dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getinteger(argv, n);
}

int64_t janet_optinteger64(const Janet *argv, int32_t argc, int32_t n, int64_t dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getinteger64(argv, n);
}

size_t janet_optsize(const Janet *argv, int32_t argc, int32_t n, size_t dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getsize(argv, n);
}

void *janet_optabstract(const Janet *argv, int32_t argc, int32_t n, const JanetAbstractType *at, void *dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getabstract(argv, n, at);
}

/* Some definitions for function-like macros */

JANET_API JanetStructHead *(janet_struct_head)(const JanetKV *st) {
    return janet_struct_head(st);
}

JANET_API JanetAbstractHead *(janet_abstract_head)(const void *abstract) {
    return janet_abstract_head(abstract);
}

JANET_API JanetStringHead *(janet_string_head)(const uint8_t *s) {
    return janet_string_head(s);
}

JANET_API JanetTupleHead *(janet_tuple_head)(const Janet *tuple) {
    return janet_tuple_head(tuple);
}


/* src/core/cfuns.c */
#line 0 "src/core/cfuns.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "compile.h"
#include "emit.h"
#include "vector.h"
#endif

static int arity1or2(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    int32_t arity = janet_v_count(args);
    return arity == 1 || arity == 2;
}
static int arity2or3(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    int32_t arity = janet_v_count(args);
    return arity == 2 || arity == 3;
}
static int fixarity1(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) == 1;
}
static int maxarity1(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) <= 1;
}
static int minarity2(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) >= 2;
}
static int fixarity2(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) == 2;
}
static int fixarity3(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) == 3;
}

/* Generic handling for $A = op $B */
static JanetSlot genericSS(JanetFopts opts, int op, JanetSlot s) {
    JanetSlot target = janetc_gettarget(opts);
    janetc_emit_ss(opts.compiler, op, target, s, 1);
    return target;
}

/* Generic handling for $A = $B op I */
static JanetSlot genericSSI(JanetFopts opts, int op, JanetSlot s, int32_t imm) {
    JanetSlot target = janetc_gettarget(opts);
    janetc_emit_ssi(opts.compiler, op, target, s, imm, 1);
    return target;
}

/* Emit an insruction that implements a form by itself. */
static JanetSlot opfunction(
    JanetFopts opts,
    JanetSlot *args,
    int op,
    Janet defaultArg2) {
    JanetCompiler *c = opts.compiler;
    int32_t len;
    len = janet_v_count(args);
    JanetSlot t;
    if (len == 1) {
        t = janetc_gettarget(opts);
        janetc_emit_sss(c, op, t, args[0], janetc_cslot(defaultArg2), 1);
        return t;
    } else {
        /* len == 2 */
        t = janetc_gettarget(opts);
        janetc_emit_sss(c, op, t, args[0], args[1], 1);
    }
    return t;
}

/* Check if a value can be coerced to an immediate value */
static int can_be_imm(Janet x, int8_t *out) {
    if (!janet_checkint(x)) return 0;
    int32_t integer = janet_unwrap_integer(x);
    if (integer > 127 || integer < -127) return 0;
    *out = (int8_t) integer;
    return 1;
}

/* Check if a slot can be coerced to an immediate value */
static int can_slot_be_imm(JanetSlot s, int8_t *out) {
    if (!(s.flags & JANET_SLOT_CONSTANT)) return 0;
    return can_be_imm(s.constant, out);
}

/* Emit a series of instructions instead of a function call to a math op */
static JanetSlot opreduce(
    JanetFopts opts,
    JanetSlot *args,
    int op,
    int opim,
    Janet nullary) {
    JanetCompiler *c = opts.compiler;
    int32_t i, len;
    int8_t imm = 0;
    int neg = opim < 0;
    if (opim < 0) opim = -opim;
    len = janet_v_count(args);
    JanetSlot t;
    if (len == 0) {
        return janetc_cslot(nullary);
    } else if (len == 1) {
        t = janetc_gettarget(opts);
        /* Special case subtract to be times -1 */
        if (op == JOP_SUBTRACT) {
            janetc_emit_ssi(c, JOP_MULTIPLY_IMMEDIATE, t, args[0], -1, 1);
        } else {
            janetc_emit_sss(c, op, t, janetc_cslot(nullary), args[0], 1);
        }
        return t;
    }
    t = janetc_gettarget(opts);
    if (opim && can_slot_be_imm(args[1], &imm)) {
        janetc_emit_ssi(c, opim, t, args[0], neg ? -imm : imm, 1);
    } else {
        janetc_emit_sss(c, op, t, args[0], args[1], 1);
    }
    for (i = 2; i < len; i++) {
        if (opim && can_slot_be_imm(args[i], &imm)) {
            janetc_emit_ssi(c, opim, t, t, neg ? -imm : imm, 1);
        } else {
            janetc_emit_sss(c, op, t, t, args[i], 1);
        }
    }
    return t;
}

/* Function optimizers */

static JanetSlot do_propagate(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_PROPAGATE, 0, janet_wrap_nil());
}
static JanetSlot do_error(JanetFopts opts, JanetSlot *args) {
    janetc_emit_s(opts.compiler, JOP_ERROR, args[0], 0);
    return janetc_cslot(janet_wrap_nil());
}
static JanetSlot do_debug(JanetFopts opts, JanetSlot *args) {
    (void)args;
    int32_t len = janet_v_count(args);
    JanetSlot t = janetc_gettarget(opts);
    janetc_emit_ssu(opts.compiler, JOP_SIGNAL, t,
                    (len == 1) ? args[0] : janetc_cslot(janet_wrap_nil()),
                    JANET_SIGNAL_DEBUG,
                    1);
    return t;
}
static JanetSlot do_in(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_IN, 0, janet_wrap_nil());
}
static JanetSlot do_get(JanetFopts opts, JanetSlot *args) {
    if (janet_v_count(args) == 3) {
        JanetCompiler *c = opts.compiler;
        JanetSlot t = janetc_gettarget(opts);
        int target_is_default = janetc_sequal(t, args[2]);
        JanetSlot dflt_slot = args[2];
        if (target_is_default) {
            dflt_slot = janetc_farslot(c);
            janetc_copy(c, dflt_slot, t);
        }
        janetc_emit_sss(c, JOP_GET, t, args[0], args[1], 1);
        int32_t label = janetc_emit_si(c, JOP_JUMP_IF_NOT_NIL, t, 0, 0);
        janetc_copy(c, t, dflt_slot);
        if (target_is_default) janetc_freeslot(c, dflt_slot);
        int32_t current = janet_v_count(c->buffer);
        c->buffer[label] |= (current - label) << 16;
        return t;
    } else {
        return opreduce(opts, args, JOP_GET, 0, janet_wrap_nil());
    }
}
static JanetSlot do_next(JanetFopts opts, JanetSlot *args) {
    return opfunction(opts, args, JOP_NEXT, janet_wrap_nil());
}
static JanetSlot do_modulo(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_MODULO, 0, janet_wrap_nil());
}
static JanetSlot do_remainder(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_REMAINDER, 0, janet_wrap_nil());
}
static JanetSlot do_cmp(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_COMPARE, 0, janet_wrap_nil());
}
static JanetSlot do_put(JanetFopts opts, JanetSlot *args) {
    if (opts.flags & JANET_FOPTS_DROP) {
        janetc_emit_sss(opts.compiler, JOP_PUT, args[0], args[1], args[2], 0);
        return janetc_cslot(janet_wrap_nil());
    } else {
        JanetSlot t = janetc_gettarget(opts);
        janetc_copy(opts.compiler, t, args[0]);
        janetc_emit_sss(opts.compiler, JOP_PUT, t, args[1], args[2], 0);
        return t;
    }
}
static JanetSlot do_length(JanetFopts opts, JanetSlot *args) {
    return genericSS(opts, JOP_LENGTH, args[0]);
}
static JanetSlot do_yield(JanetFopts opts, JanetSlot *args) {
    if (janet_v_count(args) == 0) {
        return genericSSI(opts, JOP_SIGNAL, janetc_cslot(janet_wrap_nil()), 3);
    } else {
        return genericSSI(opts, JOP_SIGNAL, args[0], 3);
    }
}
static JanetSlot do_resume(JanetFopts opts, JanetSlot *args) {
    return opfunction(opts, args, JOP_RESUME, janet_wrap_nil());
}
static JanetSlot do_cancel(JanetFopts opts, JanetSlot *args) {
    return opfunction(opts, args, JOP_CANCEL, janet_wrap_nil());
}
static JanetSlot do_apply(JanetFopts opts, JanetSlot *args) {
    /* Push phase */
    JanetCompiler *c = opts.compiler;
    int32_t i;
    for (i = 1; i < janet_v_count(args) - 3; i += 3)
        janetc_emit_sss(c, JOP_PUSH_3, args[i], args[i + 1], args[i + 2], 0);
    if (i == janet_v_count(args) - 3)
        janetc_emit_ss(c, JOP_PUSH_2, args[i], args[i + 1], 0);
    else if (i == janet_v_count(args) - 2)
        janetc_emit_s(c, JOP_PUSH, args[i], 0);
    /* Push array phase */
    janetc_emit_s(c, JOP_PUSH_ARRAY, janet_v_last(args), 0);
    /* Call phase */
    JanetSlot target;
    if (opts.flags & JANET_FOPTS_TAIL) {
        janetc_emit_s(c, JOP_TAILCALL, args[0], 0);
        target = janetc_cslot(janet_wrap_nil());
        target.flags |= JANET_SLOT_RETURNED;
    } else {
        target = janetc_gettarget(opts);
        janetc_emit_ss(c, JOP_CALL, target, args[0], 1);
    }
    return target;
}

/* Variadic operators specialization */

static JanetSlot do_add(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_ADD, JOP_ADD_IMMEDIATE, janet_wrap_integer(0));
}
static JanetSlot do_sub(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_SUBTRACT, -JOP_ADD_IMMEDIATE, janet_wrap_integer(0));
}
static JanetSlot do_mul(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_MULTIPLY, JOP_MULTIPLY_IMMEDIATE, janet_wrap_integer(1));
}
static JanetSlot do_div(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_DIVIDE, JOP_DIVIDE_IMMEDIATE, janet_wrap_integer(1));
}
static JanetSlot do_band(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_BAND, 0, janet_wrap_integer(-1));
}
static JanetSlot do_bor(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_BOR, 0, janet_wrap_integer(0));
}
static JanetSlot do_bxor(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_BXOR, 0, janet_wrap_integer(0));
}
static JanetSlot do_lshift(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_SHIFT_LEFT, JOP_SHIFT_LEFT_IMMEDIATE, janet_wrap_integer(1));
}
static JanetSlot do_rshift(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_SHIFT_RIGHT, JOP_SHIFT_RIGHT_IMMEDIATE, janet_wrap_integer(1));
}
static JanetSlot do_rshiftu(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_SHIFT_RIGHT_UNSIGNED, JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE, janet_wrap_integer(1));
}
static JanetSlot do_bnot(JanetFopts opts, JanetSlot *args) {
    return genericSS(opts, JOP_BNOT, args[0]);
}

/* Specialization for comparators */
static JanetSlot compreduce(
    JanetFopts opts,
    JanetSlot *args,
    int op,
    int opim,
    int invert) {
    JanetCompiler *c = opts.compiler;
    int32_t i, len;
    int8_t imm = 0;
    len = janet_v_count(args);
    int32_t *labels = NULL;
    JanetSlot t;
    if (len < 2) {
        return invert
               ? janetc_cslot(janet_wrap_false())
               : janetc_cslot(janet_wrap_true());
    }
    t = janetc_gettarget(opts);
    for (i = 1; i < len; i++) {
        if (opim && can_slot_be_imm(args[i], &imm)) {
            janetc_emit_ssi(c, opim, t, args[i - 1], imm, 1);
        } else {
            janetc_emit_sss(c, op, t, args[i - 1], args[i], 1);
        }
        if (i != (len - 1)) {
            int32_t label = janetc_emit_si(c, invert ? JOP_JUMP_IF : JOP_JUMP_IF_NOT, t, 0, 1);
            janet_v_push(labels, label);
        }
    }
    int32_t end = janet_v_count(c->buffer);
    for (i = 0; i < janet_v_count(labels); i++) {
        int32_t label = labels[i];
        c->buffer[label] |= ((end - label) << 16);
    }
    janet_v_free(labels);
    return t;
}

static JanetSlot do_gt(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_GREATER_THAN, JOP_GREATER_THAN_IMMEDIATE, 0);
}
static JanetSlot do_lt(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_LESS_THAN, JOP_LESS_THAN_IMMEDIATE, 0);
}
static JanetSlot do_gte(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_GREATER_THAN_EQUAL, 0, 0);
}
static JanetSlot do_lte(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_LESS_THAN_EQUAL, 0, 0);
}
static JanetSlot do_eq(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_EQUALS, JOP_EQUALS_IMMEDIATE, 0);
}
static JanetSlot do_neq(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_NOT_EQUALS, JOP_NOT_EQUALS_IMMEDIATE, 1);
}

/* Arranged by tag */
static const JanetFunOptimizer optimizers[] = {
    {maxarity1, do_debug},
    {fixarity1, do_error},
    {minarity2, do_apply},
    {maxarity1, do_yield},
    {arity1or2, do_resume},
    {fixarity2, do_in},
    {fixarity3, do_put},
    {fixarity1, do_length},
    {NULL, do_add},
    {NULL, do_sub},
    {NULL, do_mul},
    {NULL, do_div},
    {NULL, do_band},
    {NULL, do_bor},
    {NULL, do_bxor},
    {NULL, do_lshift},
    {NULL, do_rshift},
    {NULL, do_rshiftu},
    {fixarity1, do_bnot},
    {NULL, do_gt},
    {NULL, do_lt},
    {NULL, do_gte},
    {NULL, do_lte},
    {NULL, do_eq},
    {NULL, do_neq},
    {fixarity2, do_propagate},
    {arity2or3, do_get},
    {arity1or2, do_next},
    {fixarity2, do_modulo},
    {fixarity2, do_remainder},
    {fixarity2, do_cmp},
    {fixarity2, do_cancel},
};

const JanetFunOptimizer *janetc_funopt(uint32_t flags) {
    uint32_t tag = flags & JANET_FUNCDEF_FLAG_TAG;
    if (tag == 0)
        return NULL;
    uint32_t index = tag - 1;
    if (index >= (sizeof(optimizers) / sizeof(optimizers[0])))
        return NULL;
    return optimizers + index;
}



/* src/core/compile.c */
#line 0 "src/core/compile.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "compile.h"
#include "emit.h"
#include "vector.h"
#include "util.h"
#include "state.h"
#endif

JanetFopts janetc_fopts_default(JanetCompiler *c) {
    JanetFopts ret;
    ret.compiler = c;
    ret.flags = 0;
    ret.hint = janetc_cslot(janet_wrap_nil());
    return ret;
}

/* Throw an error with a janet string. */
void janetc_error(JanetCompiler *c, const uint8_t *m) {
    /* Don't override first error */
    if (c->result.status == JANET_COMPILE_ERROR) {
        return;
    }
    c->result.status = JANET_COMPILE_ERROR;
    c->result.error = m;
}

/* Throw an error with a message in a cstring */
void janetc_cerror(JanetCompiler *c, const char *m) {
    janetc_error(c, janet_cstring(m));
}

static const char *janet_lint_level_names[] = {
    "relaxed",
    "normal",
    "strict"
};

/* Emit compiler linter messages */
void janetc_lintf(JanetCompiler *c, JanetCompileLintLevel level, const char *format, ...) {
    if (NULL != c->lints) {
        /* format message */
        va_list args;
        JanetBuffer buffer;
        int32_t len = 0;
        while (format[len]) len++;
        janet_buffer_init(&buffer, len);
        va_start(args, format);
        janet_formatbv(&buffer, format, args);
        va_end(args);
        const uint8_t *str = janet_string(buffer.data, buffer.count);
        janet_buffer_deinit(&buffer);
        /* construct linting payload */
        Janet *payload = janet_tuple_begin(4);
        payload[0] = janet_ckeywordv(janet_lint_level_names[level]);
        payload[1] = c->current_mapping.line == -1 ? janet_wrap_nil() : janet_wrap_integer(c->current_mapping.line);
        payload[2] = c->current_mapping.column == -1 ? janet_wrap_nil() : janet_wrap_integer(c->current_mapping.column);
        payload[3] = janet_wrap_string(str);
        janet_array_push(c->lints, janet_wrap_tuple(janet_tuple_end(payload)));
    }
}

/* Free a slot */
void janetc_freeslot(JanetCompiler *c, JanetSlot s) {
    if (s.flags & (JANET_SLOT_CONSTANT | JANET_SLOT_REF | JANET_SLOT_NAMED)) return;
    if (s.envindex >= 0) return;
    janetc_regalloc_free(&c->scope->ra, s.index);
}

/* Add a slot to a scope with a symbol associated with it (def or var). */
void janetc_nameslot(JanetCompiler *c, const uint8_t *sym, JanetSlot s) {
    SymPair sp;
    sp.sym = sym;
    sp.slot = s;
    sp.keep = 0;
    sp.slot.flags |= JANET_SLOT_NAMED;
    janet_v_push(c->scope->syms, sp);
}

/* Create a slot with a constant */
JanetSlot janetc_cslot(Janet x) {
    JanetSlot ret;
    ret.flags = (1 << janet_type(x)) | JANET_SLOT_CONSTANT;
    ret.index = -1;
    ret.constant = x;
    ret.envindex = -1;
    return ret;
}

/* Get a local slot */
JanetSlot janetc_farslot(JanetCompiler *c) {
    JanetSlot ret;
    ret.flags = JANET_SLOTTYPE_ANY;
    ret.index = janetc_allocfar(c);
    ret.constant = janet_wrap_nil();
    ret.envindex = -1;
    return ret;
}

/* Enter a new scope */
void janetc_scope(JanetScope *s, JanetCompiler *c, int flags, const char *name) {
    JanetScope scope;
    scope.name = name;
    scope.child = NULL;
    scope.consts = NULL;
    scope.syms = NULL;
    scope.envs = NULL;
    scope.defs = NULL;
    scope.bytecode_start = janet_v_count(c->buffer);
    scope.flags = flags;
    scope.parent = c->scope;
    janetc_regalloc_init(&scope.ua);
    /* Inherit slots */
    if ((!(flags & JANET_SCOPE_FUNCTION)) && c->scope) {
        janetc_regalloc_clone(&scope.ra, &(c->scope->ra));
    } else {
        janetc_regalloc_init(&scope.ra);
    }
    /* Link parent and child and update pointer */
    if (c->scope)
        c->scope->child = s;
    c->scope = s;
    *s = scope;
}

/* Leave a scope. */
void janetc_popscope(JanetCompiler *c) {
    JanetScope *oldscope = c->scope;
    JanetScope *newscope = oldscope->parent;
    /* Move free slots to parent scope if not a new function.
     * We need to know the total number of slots used when compiling the function. */
    if (!(oldscope->flags & (JANET_SCOPE_FUNCTION | JANET_SCOPE_UNUSED)) && newscope) {
        /* Parent scopes inherit child's closure flag. Needed
         * for while loops. (if a while loop creates a closure, it
         * is compiled to a tail recursive iife) */
        if (oldscope->flags & JANET_SCOPE_CLOSURE) {
            newscope->flags |= JANET_SCOPE_CLOSURE;
        }
        if (newscope->ra.max < oldscope->ra.max)
            newscope->ra.max = oldscope->ra.max;

        /* Keep upvalue slots */
        for (int32_t i = 0; i < janet_v_count(oldscope->syms); i++) {
            SymPair pair = oldscope->syms[i];
            if (pair.keep) {
                /* The variable should not be lexically accessible */
                pair.sym = NULL;
                janet_v_push(newscope->syms, pair);
                janetc_regalloc_touch(&newscope->ra, pair.slot.index);
            }
        }

    }
    /* Free the old scope */
    janet_v_free(oldscope->consts);
    janet_v_free(oldscope->syms);
    janet_v_free(oldscope->envs);
    janet_v_free(oldscope->defs);
    janetc_regalloc_deinit(&oldscope->ra);
    janetc_regalloc_deinit(&oldscope->ua);
    /* Update pointer */
    if (newscope)
        newscope->child = NULL;
    c->scope = newscope;
}

/* Leave a scope but keep a slot allocated. */
void janetc_popscope_keepslot(JanetCompiler *c, JanetSlot retslot) {
    JanetScope *scope;
    janetc_popscope(c);
    scope = c->scope;
    if (scope && retslot.envindex < 0 && retslot.index >= 0) {
        janetc_regalloc_touch(&scope->ra, retslot.index);
    }
}

static int lookup_missing(
    JanetCompiler *c,
    const uint8_t *sym,
    JanetFunction *handler,
    JanetBinding *out) {
    int32_t minar = handler->def->min_arity;
    int32_t maxar = handler->def->max_arity;
    if (minar > 1 || maxar < 1) {
        janetc_error(c, janet_cstring("missing symbol lookup handler must take 1 argument"));
        return 0;
    }
    Janet args[1] = { janet_wrap_symbol(sym) };
    JanetFiber *fiberp = janet_fiber(handler, 64, 1, args);
    if (NULL == fiberp) {
        janetc_error(c, janet_cstring("failed to call missing symbol lookup handler"));
        return 0;
    }
    fiberp->env = c->env;
    int lock = janet_gclock();
    Janet tempOut;
    JanetSignal status = janet_continue(fiberp, janet_wrap_nil(), &tempOut);
    janet_gcunlock(lock);
    if (status != JANET_SIGNAL_OK) {
        janetc_error(c, janet_formatc("(lookup) %V", tempOut));
        return 0;
    }

    /* Convert return value as entry. */
    /* Alternative could use janet_resolve_ext(c->env, sym) to read result from environment. */
    *out = janet_binding_from_entry(tempOut);
    return 1;
}

/* Allow searching for symbols. Return information about the symbol */
JanetSlot janetc_resolve(
    JanetCompiler *c,
    const uint8_t *sym) {

    JanetSlot ret = janetc_cslot(janet_wrap_nil());
    JanetScope *scope = c->scope;
    SymPair *pair;
    int foundlocal = 1;
    int unused = 0;

    /* Search scopes for symbol, starting from top */
    while (scope) {
        int32_t i, len;
        if (scope->flags & JANET_SCOPE_UNUSED)
            unused = 1;
        len = janet_v_count(scope->syms);
        /* Search in reverse order */
        for (i = len - 1; i >= 0; i--) {
            pair = scope->syms + i;
            if (pair->sym == sym) {
                ret = pair->slot;
                goto found;
            }
        }
        if (scope->flags & JANET_SCOPE_FUNCTION)
            foundlocal = 0;
        scope = scope->parent;
    }

    /* Symbol not found - check for global */
    {
        JanetBinding binding = janet_resolve_ext(c->env, sym);
        if (binding.type == JANET_BINDING_NONE) {
            Janet handler = janet_table_get(c->env, janet_ckeywordv("missing-symbol"));
            switch (janet_type(handler)) {
                case JANET_NIL:
                    break;
                case JANET_FUNCTION:
                    if (!lookup_missing(c, sym, janet_unwrap_function(handler), &binding))
                        return janetc_cslot(janet_wrap_nil());
                    break;
                default:
                    janetc_error(c, janet_formatc("invalid lookup handler %V", handler));
                    return janetc_cslot(janet_wrap_nil());
            }
        }

        switch (binding.type) {
            default:
            case JANET_BINDING_NONE:
                janetc_error(c, janet_formatc("unknown symbol %q", janet_wrap_symbol(sym)));
                return janetc_cslot(janet_wrap_nil());
            case JANET_BINDING_DEF:
            case JANET_BINDING_MACRO: /* Macro should function like defs when not in calling pos */
                ret = janetc_cslot(binding.value);
                break;
            case JANET_BINDING_DYNAMIC_DEF:
            case JANET_BINDING_DYNAMIC_MACRO:
                ret = janetc_cslot(binding.value);
                ret.flags |= JANET_SLOT_REF | JANET_SLOT_NAMED | JANET_SLOTTYPE_ANY;
                ret.flags &= ~JANET_SLOT_CONSTANT;
                break;
            case JANET_BINDING_VAR: {
                ret = janetc_cslot(binding.value);
                ret.flags |= JANET_SLOT_REF | JANET_SLOT_NAMED | JANET_SLOT_MUTABLE | JANET_SLOTTYPE_ANY;
                ret.flags &= ~JANET_SLOT_CONSTANT;
                break;
            }
        }
        JanetCompileLintLevel depLevel = JANET_C_LINT_RELAXED;
        switch (binding.deprecation) {
            case JANET_BINDING_DEP_NONE:
                break;
            case JANET_BINDING_DEP_RELAXED:
                depLevel = JANET_C_LINT_RELAXED;
                break;
            case JANET_BINDING_DEP_NORMAL:
                depLevel = JANET_C_LINT_NORMAL;
                break;
            case JANET_BINDING_DEP_STRICT:
                depLevel = JANET_C_LINT_STRICT;
                break;
        }
        if (binding.deprecation != JANET_BINDING_DEP_NONE) {
            janetc_lintf(c, depLevel, "%q is deprecated", janet_wrap_symbol(sym));
        }
        return ret;
    }

    /* Symbol was found */
found:

    /* Constants can be returned immediately (they are stateless) */
    if (ret.flags & (JANET_SLOT_CONSTANT | JANET_SLOT_REF))
        return ret;

    /* Unused references and locals shouldn't add captured envs. */
    if (unused || foundlocal) {
        ret.envindex = -1;
        return ret;
    }

    /* non-local scope needs to expose its environment */
    pair->keep = 1;
    while (scope && !(scope->flags & JANET_SCOPE_FUNCTION))
        scope = scope->parent;
    janet_assert(scope, "invalid scopes");
    scope->flags |= JANET_SCOPE_ENV;

    /* In the function scope, allocate the slot as an upvalue */
    janetc_regalloc_touch(&scope->ua, ret.index);

    /* Iterate through child scopes and make sure environment is propagated */
    scope = scope->child;

    /* Propagate env up to current scope */
    int32_t envindex = -1;
    while (scope) {
        if (scope->flags & JANET_SCOPE_FUNCTION) {
            int32_t j, len;
            int scopefound = 0;
            /* Check if scope already has env. If so, break */
            len = janet_v_count(scope->envs);
            for (j = 0; j < len; j++) {
                if (scope->envs[j] == envindex) {
                    scopefound = 1;
                    envindex = j;
                    break;
                }
            }
            /* Add the environment if it is not already referenced */
            if (!scopefound) {
                len = janet_v_count(scope->envs);
                janet_v_push(scope->envs, envindex);
                envindex = len;
            }
        }
        scope = scope->child;
    }

    ret.envindex = envindex;
    return ret;
}

/* Generate the return instruction for a slot. */
JanetSlot janetc_return(JanetCompiler *c, JanetSlot s) {
    if (!(s.flags & JANET_SLOT_RETURNED)) {
        if (s.flags & JANET_SLOT_CONSTANT && janet_checktype(s.constant, JANET_NIL))
            janetc_emit(c, JOP_RETURN_NIL);
        else
            janetc_emit_s(c, JOP_RETURN, s, 0);
        s.flags |= JANET_SLOT_RETURNED;
    }
    return s;
}

/* Get a target slot for emitting an instruction. */
JanetSlot janetc_gettarget(JanetFopts opts) {
    JanetSlot slot;
    if ((opts.flags & JANET_FOPTS_HINT) &&
            (opts.hint.envindex < 0) &&
            (opts.hint.index >= 0 && opts.hint.index <= 0xFF)) {
        slot = opts.hint;
    } else {
        slot.envindex = -1;
        slot.constant = janet_wrap_nil();
        slot.flags = 0;
        slot.index = janetc_allocfar(opts.compiler);
    }
    return slot;
}

/* Get a bunch of slots for function arguments */
JanetSlot *janetc_toslots(JanetCompiler *c, const Janet *vals, int32_t len) {
    int32_t i;
    JanetSlot *ret = NULL;
    JanetFopts subopts = janetc_fopts_default(c);
    for (i = 0; i < len; i++) {
        janet_v_push(ret, janetc_value(subopts, vals[i]));
    }
    return ret;
}

/* Get a bunch of slots for function arguments */
JanetSlot *janetc_toslotskv(JanetCompiler *c, Janet ds) {
    JanetSlot *ret = NULL;
    JanetFopts subopts = janetc_fopts_default(c);
    const JanetKV *kvs = NULL;
    int32_t cap = 0, len = 0;
    janet_dictionary_view(ds, &kvs, &len, &cap);
    for (int32_t i = 0; i < cap; i++) {
        if (janet_checktype(kvs[i].key, JANET_NIL)) continue;
        janet_v_push(ret, janetc_value(subopts, kvs[i].key));
        janet_v_push(ret, janetc_value(subopts, kvs[i].value));
    }
    return ret;
}

/* Push slots loaded via janetc_toslots. Return the minimum number of slots pushed,
 * or -1 - min_arity if there is a splice. (if there is no splice, min_arity is also
 * the maximum possible arity). */
int32_t janetc_pushslots(JanetCompiler *c, JanetSlot *slots) {
    int32_t i;
    int32_t count = janet_v_count(slots);
    int32_t min_arity = 0;
    int has_splice = 0;
    for (i = 0; i < count;) {
        if (slots[i].flags & JANET_SLOT_SPLICED) {
            janetc_emit_s(c, JOP_PUSH_ARRAY, slots[i], 0);
            i++;
            has_splice = 1;
        } else if (i + 1 == count) {
            janetc_emit_s(c, JOP_PUSH, slots[i], 0);
            i++;
            min_arity++;
        } else if (slots[i + 1].flags & JANET_SLOT_SPLICED) {
            janetc_emit_s(c, JOP_PUSH, slots[i], 0);
            janetc_emit_s(c, JOP_PUSH_ARRAY, slots[i + 1], 0);
            i += 2;
            min_arity++;
            has_splice = 1;
        } else if (i + 2 == count) {
            janetc_emit_ss(c, JOP_PUSH_2, slots[i], slots[i + 1], 0);
            i += 2;
            min_arity += 2;
        } else if (slots[i + 2].flags & JANET_SLOT_SPLICED) {
            janetc_emit_ss(c, JOP_PUSH_2, slots[i], slots[i + 1], 0);
            janetc_emit_s(c, JOP_PUSH_ARRAY, slots[i + 2], 0);
            i += 3;
            min_arity += 2;
            has_splice = 1;
        } else {
            janetc_emit_sss(c, JOP_PUSH_3, slots[i], slots[i + 1], slots[i + 2], 0);
            i += 3;
            min_arity += 3;
        }
    }
    return has_splice ? (-1 - min_arity) : min_arity;
}

/* Check if a list of slots has any spliced slots */
static int has_spliced(JanetSlot *slots) {
    int32_t i;
    for (i = 0; i < janet_v_count(slots); i++) {
        if (slots[i].flags & JANET_SLOT_SPLICED)
            return 1;
    }
    return 0;
}

/* Free slots loaded via janetc_toslots */
void janetc_freeslots(JanetCompiler *c, JanetSlot *slots) {
    int32_t i;
    for (i = 0; i < janet_v_count(slots); i++) {
        janetc_freeslot(c, slots[i]);
    }
    janet_v_free(slots);
}

/* Compile some code that will be thrown away. Used to ensure
 * that dead code is well formed without including it in the final
 * bytecode. */
void janetc_throwaway(JanetFopts opts, Janet x) {
    JanetCompiler *c = opts.compiler;
    JanetScope unusedScope;
    int32_t bufstart = janet_v_count(c->buffer);
    int32_t mapbufstart = janet_v_count(c->mapbuffer);
    janetc_scope(&unusedScope, c, JANET_SCOPE_UNUSED, "unusued");
    janetc_value(opts, x);
    janetc_lintf(c, JANET_C_LINT_STRICT, "dead code, consider removing %.2q", x);
    janetc_popscope(c);
    if (c->buffer) {
        janet_v__cnt(c->buffer) = bufstart;
        if (c->mapbuffer)
            janet_v__cnt(c->mapbuffer) = mapbufstart;
    }
}

/* Compile a call or tailcall instruction */
static JanetSlot janetc_call(JanetFopts opts, JanetSlot *slots, JanetSlot fun) {
    JanetSlot retslot;
    JanetCompiler *c = opts.compiler;
    int specialized = 0;
    if (fun.flags & JANET_SLOT_CONSTANT && !has_spliced(slots)) {
        if (janet_checktype(fun.constant, JANET_FUNCTION)) {
            JanetFunction *f = janet_unwrap_function(fun.constant);
            const JanetFunOptimizer *o = janetc_funopt(f->def->flags);
            if (o && (!o->can_optimize || o->can_optimize(opts, slots))) {
                specialized = 1;
                retslot = o->optimize(opts, slots);
            }
        }
        /* TODO janet function inlining (no c functions)*/
    }
    if (!specialized) {
        int32_t min_arity = janetc_pushslots(c, slots);
        /* Check for provably incorrect function calls */
        if (fun.flags & JANET_SLOT_CONSTANT) {

            /* Check for bad arity type if fun is a constant */
            switch (janet_type(fun.constant)) {
                case JANET_FUNCTION: {
                    JanetFunction *f = janet_unwrap_function(fun.constant);
                    int32_t min = f->def->min_arity;
                    int32_t max = f->def->max_arity;
                    if (min_arity < 0) {
                        /* Call has splices */
                        min_arity = -1 - min_arity;
                        if (min_arity > max && max >= 0) {
                            const uint8_t *es = janet_formatc(
                                                    "%v expects at most %d argument%s, got at least %d",
                                                    fun.constant, max, max == 1 ? "" : "s", min_arity);
                            janetc_error(c, es);
                        }
                    } else {
                        /* Call has no splices */
                        if (min_arity > max && max >= 0) {
                            const uint8_t *es = janet_formatc(
                                                    "%v expects at most %d argument%s, got %d",
                                                    fun.constant, max, max == 1 ? "" : "s", min_arity);
                            janetc_error(c, es);
                        }
                        if (min_arity < min) {
                            const uint8_t *es = janet_formatc(
                                                    "%v expects at least %d argument%s, got %d",
                                                    fun.constant, min, min == 1 ? "" : "s", min_arity);
                            janetc_error(c, es);
                        }
                    }
                }
                break;
                case JANET_CFUNCTION:
                case JANET_ABSTRACT:
                case JANET_NIL:
                    break;
                case JANET_KEYWORD:
                    if (min_arity == 0) {
                        const uint8_t *es = janet_formatc("%v expects at least 1 argument, got 0",
                                                          fun.constant);
                        janetc_error(c, es);
                    }
                    break;
                default:
                    if (min_arity > 1 || min_arity == 0) {
                        const uint8_t *es = janet_formatc("%v expects 1 argument, got %d",
                                                          fun.constant, min_arity);
                        janetc_error(c, es);
                    }
                    if (min_arity < -2) {
                        const uint8_t *es = janet_formatc("%v expects 1 argument, got at least %d",
                                                          fun.constant, -1 - min_arity);
                        janetc_error(c, es);
                    }
                    break;
            }
        }

        if ((opts.flags & JANET_FOPTS_TAIL) &&
                /* Prevent top level tail calls for better errors */
                !(c->scope->flags & JANET_SCOPE_TOP)) {
            janetc_emit_s(c, JOP_TAILCALL, fun, 0);
            retslot = janetc_cslot(janet_wrap_nil());
            retslot.flags = JANET_SLOT_RETURNED;
        } else {
            retslot = janetc_gettarget(opts);
            janetc_emit_ss(c, JOP_CALL, retslot, fun, 1);
        }
    }
    janetc_freeslots(c, slots);
    return retslot;
}

static JanetSlot janetc_maker(JanetFopts opts, JanetSlot *slots, int op) {
    JanetCompiler *c = opts.compiler;
    JanetSlot retslot;

    /* Check if this structure is composed entirely of constants */
    int can_inline = 1;
    for (int32_t i = 0; i < janet_v_count(slots); i++) {
        if (!(slots[i].flags & JANET_SLOT_CONSTANT) ||
                (slots[i].flags & JANET_SLOT_SPLICED)) {
            can_inline = 0;
            break;
        }
    }

    if (can_inline && (op == JOP_MAKE_STRUCT)) {
        JanetKV *st = janet_struct_begin(janet_v_count(slots) / 2);
        for (int32_t i = 0; i < janet_v_count(slots); i += 2) {
            Janet k = slots[i].constant;
            Janet v = slots[i + 1].constant;
            janet_struct_put(st, k, v);
        }
        retslot = janetc_cslot(janet_wrap_struct(janet_struct_end(st)));
        janetc_freeslots(c, slots);
    } else if (can_inline && (op == JOP_MAKE_TUPLE)) {
        Janet *tup = janet_tuple_begin(janet_v_count(slots));
        for (int32_t i = 0; i < janet_v_count(slots); i++) {
            tup[i] = slots[i].constant;
        }
        retslot = janetc_cslot(janet_wrap_tuple(janet_tuple_end(tup)));
        janetc_freeslots(c, slots);
    } else {
        janetc_pushslots(c, slots);
        janetc_freeslots(c, slots);
        retslot = janetc_gettarget(opts);
        janetc_emit_s(c, op, retslot, 1);
    }

    return retslot;
}

static JanetSlot janetc_array(JanetFopts opts, Janet x) {
    JanetCompiler *c = opts.compiler;
    JanetArray *a = janet_unwrap_array(x);
    return janetc_maker(opts,
                        janetc_toslots(c, a->data, a->count),
                        JOP_MAKE_ARRAY);
}

static JanetSlot janetc_tuple(JanetFopts opts, Janet x) {
    JanetCompiler *c = opts.compiler;
    const Janet *t = janet_unwrap_tuple(x);
    return janetc_maker(opts,
                        janetc_toslots(c, t, janet_tuple_length(t)),
                        JOP_MAKE_TUPLE);
}

static JanetSlot janetc_tablector(JanetFopts opts, Janet x, int op) {
    JanetCompiler *c = opts.compiler;
    return janetc_maker(opts,
                        janetc_toslotskv(c, x),
                        op);
}

static JanetSlot janetc_bufferctor(JanetFopts opts, Janet x) {
    JanetCompiler *c = opts.compiler;
    JanetBuffer *b = janet_unwrap_buffer(x);
    Janet onearg = janet_stringv(b->data, b->count);
    return janetc_maker(opts,
                        janetc_toslots(c, &onearg, 1),
                        JOP_MAKE_BUFFER);
}

/* Expand a macro one time. Also get the special form compiler if we
 * find that instead. */
static int macroexpand1(
    JanetCompiler *c,
    Janet x,
    Janet *out,
    const JanetSpecial **spec) {
    if (!janet_checktype(x, JANET_TUPLE))
        return 0;
    const Janet *form = janet_unwrap_tuple(x);
    if (janet_tuple_length(form) == 0)
        return 0;
    /* Source map - only set when we get a tuple */
    if (janet_tuple_sm_line(form) >= 0) {
        c->current_mapping.line = janet_tuple_sm_line(form);
        c->current_mapping.column = janet_tuple_sm_column(form);
    }
    /* Bracketed tuples are not specials or macros! */
    if (janet_tuple_flag(form) & JANET_TUPLE_FLAG_BRACKETCTOR)
        return 0;
    if (!janet_checktype(form[0], JANET_SYMBOL))
        return 0;
    const uint8_t *name = janet_unwrap_symbol(form[0]);
    const JanetSpecial *s = janetc_special(name);
    if (s) {
        *spec = s;
        return 0;
    }
    Janet macroval;
    JanetBindingType btype = janet_resolve(c->env, name, &macroval);
    if (!(btype == JANET_BINDING_MACRO || btype == JANET_BINDING_DYNAMIC_MACRO) ||
            !janet_checktype(macroval, JANET_FUNCTION))
        return 0;

    /* Evaluate macro */
    JanetFunction *macro = janet_unwrap_function(macroval);
    int32_t arity = janet_tuple_length(form) - 1;
    JanetFiber *fiberp = janet_fiber(macro, 64, arity, form + 1);
    if (NULL == fiberp) {
        int32_t minar = macro->def->min_arity;
        int32_t maxar = macro->def->max_arity;
        const uint8_t *es = NULL;
        if (minar >= 0 && arity < minar)
            es = janet_formatc("macro arity mismatch, expected at least %d, got %d", minar, arity);
        if (maxar >= 0 && arity > maxar)
            es = janet_formatc("macro arity mismatch, expected at most %d, got %d", maxar, arity);
        c->result.macrofiber = NULL;
        janetc_error(c, es);
        return 0;
    }
    /* Set env */
    fiberp->env = c->env;
    int lock = janet_gclock();
    Janet mf_kw = janet_ckeywordv("macro-form");
    janet_table_put(c->env, mf_kw, x);
    Janet tempOut;
    JanetSignal status = janet_continue(fiberp, janet_wrap_nil(), &tempOut);
    janet_table_put(c->env, mf_kw, janet_wrap_nil());
    if (c->lints) {
        janet_table_put(c->env, janet_ckeywordv("macro-lints"), janet_wrap_array(c->lints));
    }
    janet_gcunlock(lock);
    if (status != JANET_SIGNAL_OK) {
        const uint8_t *es = janet_formatc("(macro) %V", tempOut);
        c->result.macrofiber = fiberp;
        janetc_error(c, es);
        return 0;
    } else {
        *out = tempOut;
    }

    return 1;
}

/* Compile a single value */
JanetSlot janetc_value(JanetFopts opts, Janet x) {
    JanetSlot ret;
    JanetCompiler *c = opts.compiler;
    JanetSourceMapping last_mapping = c->current_mapping;
    c->recursion_guard--;

    /* Guard against previous errors and unbounded recursion */
    if (c->result.status == JANET_COMPILE_ERROR) return janetc_cslot(janet_wrap_nil());
    if (c->recursion_guard <= 0) {
        janetc_cerror(c, "recursed too deeply");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Macro expand. Also gets possible special form and
     * refines source mapping cursor if possible. */
    const JanetSpecial *spec = NULL;
    int macroi = JANET_MAX_MACRO_EXPAND;
    while (macroi &&
            c->result.status != JANET_COMPILE_ERROR &&
            macroexpand1(c, x, &x, &spec))
        macroi--;
    if (macroi == 0) {
        janetc_cerror(c, "recursed too deeply in macro expansion");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Special forms */
    if (spec) {
        const Janet *tup = janet_unwrap_tuple(x);
        ret = spec->compile(opts, janet_tuple_length(tup) - 1, tup + 1);
    } else {
        switch (janet_type(x)) {
            case JANET_TUPLE: {
                JanetFopts subopts = janetc_fopts_default(c);
                const Janet *tup = janet_unwrap_tuple(x);
                /* Empty tuple is tuple literal */
                if (janet_tuple_length(tup) == 0) {
                    ret = janetc_cslot(janet_wrap_tuple(janet_tuple_n(NULL, 0)));
                } else if (janet_tuple_flag(tup) & JANET_TUPLE_FLAG_BRACKETCTOR) { /* [] tuples are not function call */
                    ret = janetc_tuple(opts, x);
                } else {
                    JanetSlot head = janetc_value(subopts, tup[0]);
                    subopts.flags = JANET_FUNCTION | JANET_CFUNCTION;
                    ret = janetc_call(opts, janetc_toslots(c, tup + 1, janet_tuple_length(tup) - 1), head);
                    janetc_freeslot(c, head);
                }
                ret.flags &= ~JANET_SLOT_SPLICED;
            }
            break;
            case JANET_SYMBOL:
                ret = janetc_resolve(c, janet_unwrap_symbol(x));
                break;
            case JANET_ARRAY:
                ret = janetc_array(opts, x);
                break;
            case JANET_STRUCT:
                ret = janetc_tablector(opts, x, JOP_MAKE_STRUCT);
                break;
            case JANET_TABLE:
                ret = janetc_tablector(opts, x, JOP_MAKE_TABLE);
                break;
            case JANET_BUFFER:
                ret = janetc_bufferctor(opts, x);
                break;
            default:
                ret = janetc_cslot(x);
                break;
        }
    }

    if (c->result.status == JANET_COMPILE_ERROR)
        return janetc_cslot(janet_wrap_nil());
    if (opts.flags & JANET_FOPTS_TAIL)
        ret = janetc_return(c, ret);
    if (opts.flags & JANET_FOPTS_HINT) {
        janetc_copy(c, opts.hint, ret);
        ret = opts.hint;
    }
    c->current_mapping = last_mapping;
    c->recursion_guard++;
    return ret;
}

/* Add function flags to janet functions */
void janet_def_addflags(JanetFuncDef *def) {
    int32_t set_flags = 0;
    int32_t unset_flags = 0;
    /* pos checks */
    if (def->name)            set_flags |= JANET_FUNCDEF_FLAG_HASNAME;
    if (def->source)          set_flags |= JANET_FUNCDEF_FLAG_HASSOURCE;
    if (def->defs)            set_flags |= JANET_FUNCDEF_FLAG_HASDEFS;
    if (def->environments)    set_flags |= JANET_FUNCDEF_FLAG_HASENVS;
    if (def->sourcemap)       set_flags |= JANET_FUNCDEF_FLAG_HASSOURCEMAP;
    if (def->closure_bitset)  set_flags |= JANET_FUNCDEF_FLAG_HASCLOBITSET;
    /* negative checks */
    if (!def->name)           unset_flags |= JANET_FUNCDEF_FLAG_HASNAME;
    if (!def->source)         unset_flags |= JANET_FUNCDEF_FLAG_HASSOURCE;
    if (!def->defs)           unset_flags |= JANET_FUNCDEF_FLAG_HASDEFS;
    if (!def->environments)   unset_flags |= JANET_FUNCDEF_FLAG_HASENVS;
    if (!def->sourcemap)      unset_flags |= JANET_FUNCDEF_FLAG_HASSOURCEMAP;
    if (!def->closure_bitset) unset_flags |= JANET_FUNCDEF_FLAG_HASCLOBITSET;
    /* Update flags */
    def->flags |= set_flags;
    def->flags &= ~unset_flags;
}

/* Compile a funcdef */
/* Once the various other settings of the FuncDef have been tweaked,
 * call janet_def_addflags to set the proper flags for the funcdef */
JanetFuncDef *janetc_pop_funcdef(JanetCompiler *c) {
    JanetScope *scope = c->scope;
    JanetFuncDef *def = janet_funcdef_alloc();
    def->slotcount = scope->ra.max + 1;

    janet_assert(scope->flags & JANET_SCOPE_FUNCTION, "expected function scope");

    /* Copy envs */
    def->environments_length = janet_v_count(scope->envs);
    def->environments = janet_v_flatten(scope->envs);

    def->constants_length = janet_v_count(scope->consts);
    def->constants = janet_v_flatten(scope->consts);

    def->defs_length = janet_v_count(scope->defs);
    def->defs = janet_v_flatten(scope->defs);

    /* Copy bytecode (only last chunk) */
    def->bytecode_length = janet_v_count(c->buffer) - scope->bytecode_start;
    if (def->bytecode_length) {
        size_t s = sizeof(int32_t) * (size_t) def->bytecode_length;
        def->bytecode = janet_malloc(s);
        if (NULL == def->bytecode) {
            JANET_OUT_OF_MEMORY;
        }
        safe_memcpy(def->bytecode, c->buffer + scope->bytecode_start, s);
        janet_v__cnt(c->buffer) = scope->bytecode_start;
        if (NULL != c->mapbuffer && c->source) {
            size_t s = sizeof(JanetSourceMapping) * (size_t) def->bytecode_length;
            def->sourcemap = janet_malloc(s);
            if (NULL == def->sourcemap) {
                JANET_OUT_OF_MEMORY;
            }
            safe_memcpy(def->sourcemap, c->mapbuffer + scope->bytecode_start, s);
            janet_v__cnt(c->mapbuffer) = scope->bytecode_start;
        }
    }

    /* Get source from parser */
    def->source = c->source;

    def->arity = 0;
    def->min_arity = 0;
    def->flags = 0;
    if (scope->flags & JANET_SCOPE_ENV) {
        def->flags |= JANET_FUNCDEF_FLAG_NEEDSENV;
    }

    /* Copy upvalue bitset */
    if (scope->ua.count) {
        /* Number of u32s we need to create a bitmask for all slots */
        int32_t slotchunks = (def->slotcount + 31) >> 5;
        /* numchunks is min of slotchunks and scope->ua.count */
        int32_t numchunks = slotchunks > scope->ua.count ? scope->ua.count : slotchunks;
        uint32_t *chunks = janet_calloc(sizeof(uint32_t), slotchunks);
        if (NULL == chunks) {
            JANET_OUT_OF_MEMORY;
        }
        memcpy(chunks, scope->ua.chunks, sizeof(uint32_t) * numchunks);
        /* Register allocator preallocates some registers [240-255, high 16 bits of chunk index 7], we can ignore those. */
        if (scope->ua.count > 7) chunks[7] &= 0xFFFFU;
        def->closure_bitset = chunks;
    }

    /* Pop the scope */
    janetc_popscope(c);

    return def;
}

/* Initialize a compiler */
static void janetc_init(JanetCompiler *c, JanetTable *env, const uint8_t *where, JanetArray *lints) {
    c->scope = NULL;
    c->buffer = NULL;
    c->mapbuffer = NULL;
    c->recursion_guard = JANET_RECURSION_GUARD;
    c->env = env;
    c->source = where;
    c->current_mapping.line = -1;
    c->current_mapping.column = -1;
    c->lints = lints;
    /* Init result */
    c->result.error = NULL;
    c->result.status = JANET_COMPILE_OK;
    c->result.funcdef = NULL;
    c->result.macrofiber = NULL;
    c->result.error_mapping.line = -1;
    c->result.error_mapping.column = -1;
}

/* Deinitialize a compiler struct */
static void janetc_deinit(JanetCompiler *c) {
    janet_v_free(c->buffer);
    janet_v_free(c->mapbuffer);
    c->env = NULL;
}

/* Compile a form. */
JanetCompileResult janet_compile_lint(Janet source,
                                      JanetTable *env, const uint8_t *where, JanetArray *lints) {
    JanetCompiler c;
    JanetScope rootscope;
    JanetFopts fopts;

    janetc_init(&c, env, where, lints);

    /* Push a function scope */
    janetc_scope(&rootscope, &c, JANET_SCOPE_FUNCTION | JANET_SCOPE_TOP, "root");

    /* Set initial form options */
    fopts.compiler = &c;
    fopts.flags = JANET_FOPTS_TAIL | JANET_SLOTTYPE_ANY;
    fopts.hint = janetc_cslot(janet_wrap_nil());

    /* Compile the value */
    janetc_value(fopts, source);

    if (c.result.status == JANET_COMPILE_OK) {
        JanetFuncDef *def = janetc_pop_funcdef(&c);
        def->name = janet_cstring("_thunk");
        janet_def_addflags(def);
        c.result.funcdef = def;
    } else {
        c.result.error_mapping = c.current_mapping;
        janetc_popscope(&c);
    }

    janetc_deinit(&c);

    return c.result;
}

JanetCompileResult janet_compile(Janet source, JanetTable *env, const uint8_t *where) {
    return janet_compile_lint(source, env, where, NULL);
}

/* C Function for compiling */
JANET_CORE_FN(cfun_compile,
              "(compile ast &opt env source lints)",
              "Compiles an Abstract Syntax Tree (ast) into a function. "
              "Pair the compile function with parsing functionality to implement "
              "eval. Returns a new function and does not modify ast. Returns an error "
              "struct with keys :line, :column, and :error if compilation fails. "
              "If a `lints` array is given, linting messages will be appended to the array. "
              "Each message will be a tuple of the form `(level line col message)`.") {
    janet_arity(argc, 1, 4);
    JanetTable *env = (argc > 1 && !janet_checktype(argv[1], JANET_NIL))
                      ? janet_gettable(argv, 1) : janet_vm.fiber->env;
    if (NULL == env) {
        env = janet_table(0);
        janet_vm.fiber->env = env;
    }
    const uint8_t *source = NULL;
    if (argc >= 3) {
        Janet x = argv[2];
        if (janet_checktype(x, JANET_STRING)) {
            source = janet_unwrap_string(x);
        } else if (janet_checktype(x, JANET_KEYWORD)) {
            source = janet_unwrap_keyword(x);
        } else if (!janet_checktype(x, JANET_NIL)) {
            janet_panic_type(x, 2, JANET_TFLAG_STRING | JANET_TFLAG_KEYWORD);
        }
    }
    JanetArray *lints = (argc >= 4 && !janet_checktype(argv[3], JANET_NIL))
                        ? janet_getarray(argv, 3) : NULL;
    JanetCompileResult res = janet_compile_lint(argv[0], env, source, lints);
    if (res.status == JANET_COMPILE_OK) {
        return janet_wrap_function(janet_thunk(res.funcdef));
    } else {
        JanetTable *t = janet_table(4);
        janet_table_put(t, janet_ckeywordv("error"), janet_wrap_string(res.error));
        if (res.error_mapping.line > 0) {
            janet_table_put(t, janet_ckeywordv("line"), janet_wrap_integer(res.error_mapping.line));
        }
        if (res.error_mapping.column > 0) {
            janet_table_put(t, janet_ckeywordv("column"), janet_wrap_integer(res.error_mapping.column));
        }
        if (res.macrofiber) {
            janet_table_put(t, janet_ckeywordv("fiber"), janet_wrap_fiber(res.macrofiber));
        }
        return janet_wrap_table(t);
    }
}

void janet_lib_compile(JanetTable *env) {
    JanetRegExt cfuns[] = {
        JANET_CORE_REG("compile", cfun_compile),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, cfuns);
}


/* src/core/corelib.c */
#line 0 "src/core/corelib.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include <math.h>
#include "compile.h"
#include "state.h"
#include "util.h"
#endif

/* Generated bytes */
#ifndef JANET_BOOTSTRAP
extern const unsigned char *janet_core_image;
extern size_t janet_core_image_size;
#endif

/* Docstrings should only exist during bootstrap */
#ifdef JANET_BOOTSTRAP
#define JDOC(x) (x)
#else
#define JDOC(x) NULL
#endif

JanetModule janet_native(const char *name, const uint8_t **error) {
    char *processed_name = get_processed_name(name);
    Clib lib = load_clib(processed_name);
    JanetModule init;
    JanetModconf getter;
    if (name != processed_name) janet_free(processed_name);
    if (!lib) {
        *error = janet_cstring(error_clib());
        return NULL;
    }
    init = (JanetModule) symbol_clib(lib, "_janet_init");
    if (!init) {
        *error = janet_cstring("could not find the _janet_init symbol");
        return NULL;
    }
    getter = (JanetModconf) symbol_clib(lib, "_janet_mod_config");
    if (!getter) {
        *error = janet_cstring("could not find the _janet_mod_config symbol");
        return NULL;
    }
    JanetBuildConfig modconf = getter();
    JanetBuildConfig host = janet_config_current();
    if (host.major != modconf.major ||
            host.minor < modconf.minor ||
            host.bits != modconf.bits) {
        char errbuf[128];
        sprintf(errbuf, "config mismatch - host %d.%.d.%d(%.4x) vs. module %d.%d.%d(%.4x)",
                host.major,
                host.minor,
                host.patch,
                host.bits,
                modconf.major,
                modconf.minor,
                modconf.patch,
                modconf.bits);
        *error = janet_cstring(errbuf);
        return NULL;
    }
    return init;
}

static const char *janet_dyncstring(const char *name, const char *dflt) {
    Janet x = janet_dyn(name);
    if (janet_checktype(x, JANET_NIL)) return dflt;
    if (!janet_checktype(x, JANET_STRING)) {
        janet_panicf("expected string, got %v", x);
    }
    const uint8_t *jstr = janet_unwrap_string(x);
    const char *cstr = (const char *)jstr;
    if (strlen(cstr) != (size_t) janet_string_length(jstr)) {
        janet_panicf("string %v contains embedded 0s", x);
    }
    return cstr;
}

static int is_path_sep(char c) {
#ifdef JANET_WINDOWS
    if (c == '\\') return 1;
#endif
    return c == '/';
}

/* Used for module system. */
JANET_CORE_FN(janet_core_expand_path,
              "(module/expand-path path template)",
              "Expands a path template as found in `module/paths` for `module/find`. "
              "This takes in a path (the argument to require) and a template string, "
              "to expand the path to a path that can be "
              "used for importing files. The replacements are as follows:\n\n"
              "* :all: -- the value of path verbatim.\n\n"
              "* :@all: -- Same as :all:, but if `path` starts with the @ character,\n"
              "           the first path segment is replaced with a dynamic binding\n"
              "           `(dyn <first path segment as keyword>)`.\n\n"
              "* :cur: -- the current file, or (dyn :current-file)\n\n"
              "* :dir: -- the directory containing the current file\n\n"
              "* :name: -- the name component of path, with extension if given\n\n"
              "* :native: -- the extension used to load natives, .so or .dll\n\n"
              "* :sys: -- the system path, or (dyn :syspath)") {
    janet_fixarity(argc, 2);
    const char *input = janet_getcstring(argv, 0);
    const char *template = janet_getcstring(argv, 1);
    const char *curfile = janet_dyncstring("current-file", "");
    const char *syspath = janet_dyncstring("syspath", "");
    JanetBuffer *out = janet_buffer(0);
    size_t tlen = strlen(template);

    /* Calculate name */
    const char *name = input + strlen(input);
    while (name > input) {
        if (is_path_sep(*(name - 1))) break;
        name--;
    }

    /* Calculate dirpath from current file */
    const char *curname = curfile + strlen(curfile);
    while (curname > curfile) {
        if (is_path_sep(*curname)) break;
        curname--;
    }
    const char *curdir;
    int32_t curlen;
    if (curname == curfile) {
        /* Current file has one or zero path segments, so
         * we are in the . directory. */
        curdir = ".";
        curlen = 1;
    } else {
        /* Current file has 2 or more segments, so we
         * can cut off the last segment. */
        curdir = curfile;
        curlen = (int32_t)(curname - curfile);
    }

    for (size_t i = 0; i < tlen; i++) {
        if (template[i] == ':') {
            if (strncmp(template + i, ":all:", 5) == 0) {
                janet_buffer_push_cstring(out, input);
                i += 4;
            } else if (strncmp(template + i, ":@all:", 6) == 0) {
                if (input[0] == '@') {
                    const char *p = input;
                    while (*p && !is_path_sep(*p)) p++;
                    size_t len = p - input - 1;
                    char *str = janet_smalloc(len + 1);
                    memcpy(str, input + 1, len);
                    str[len] = '\0';
                    janet_formatb(out, "%V", janet_dyn(str));
                    janet_sfree(str);
                    janet_buffer_push_cstring(out, p);
                } else {
                    janet_buffer_push_cstring(out, input);
                }
                i += 5;
            } else if (strncmp(template + i, ":cur:", 5) == 0) {
                janet_buffer_push_bytes(out, (const uint8_t *)curdir, curlen);
                i += 4;
            } else if (strncmp(template + i, ":dir:", 5) == 0) {
                janet_buffer_push_bytes(out, (const uint8_t *)input,
                                        (int32_t)(name - input));
                i += 4;
            } else if (strncmp(template + i, ":sys:", 5) == 0) {
                janet_buffer_push_cstring(out, syspath);
                i += 4;
            } else if (strncmp(template + i, ":name:", 6) == 0) {
                janet_buffer_push_cstring(out, name);
                i += 5;
            } else if (strncmp(template + i, ":native:", 8) == 0) {
#ifdef JANET_WINDOWS
                janet_buffer_push_cstring(out, ".dll");
#else
                janet_buffer_push_cstring(out, ".so");
#endif
                i += 7;
            } else {
                janet_buffer_push_u8(out, (uint8_t) template[i]);
            }
        } else {
            janet_buffer_push_u8(out, (uint8_t) template[i]);
        }
    }

    /* Normalize */
    uint8_t *scan = out->data;
    uint8_t *print = scan;
    uint8_t *scanend = scan + out->count;
    int normal_section_count = 0;
    int dot_count = 0;
    while (scan < scanend) {
        if (*scan == '.') {
            if (dot_count >= 0) {
                dot_count++;
            } else {
                *print++ = '.';
            }
        } else if (is_path_sep(*scan)) {
            if (dot_count == 1) {
                ;
            } else if (dot_count == 2) {
                if (normal_section_count > 0) {
                    /* unprint last separator */
                    print--;
                    /* unprint last section */
                    while (print > out->data && !is_path_sep(*(print - 1)))
                        print--;
                    normal_section_count--;
                } else {
                    *print++ = '.';
                    *print++ = '.';
                    *print++ = '/';
                }
            } else if (scan == out->data || dot_count != 0) {
                while (dot_count > 0) {
                    --dot_count;
                    *print++ = '.';
                }
                if (scan > out->data) {
                    normal_section_count++;
                }
                *print++ = '/';
            }
            dot_count = 0;
        } else {
            while (dot_count > 0) {
                --dot_count;
                *print++ = '.';
            }
            dot_count = -1;
            *print++ = *scan;
        }
        scan++;
    }
    out->count = (int32_t)(print - out->data);
    return janet_wrap_buffer(out);
}

JANET_CORE_FN(janet_core_dyn,
              "(dyn key &opt default)",
              "Get a dynamic binding. Returns the default value (or nil) if no binding found.") {
    janet_arity(argc, 1, 2);
    Janet value;
    if (janet_vm.fiber->env) {
        value = janet_table_get(janet_vm.fiber->env, argv[0]);
    } else {
        value = janet_wrap_nil();
    }
    if (argc == 2 && janet_checktype(value, JANET_NIL)) {
        return argv[1];
    }
    return value;
}

JANET_CORE_FN(janet_core_setdyn,
              "(setdyn key value)",
              "Set a dynamic binding. Returns value.") {
    janet_fixarity(argc, 2);
    if (!janet_vm.fiber->env) {
        janet_vm.fiber->env = janet_table(2);
    }
    janet_table_put(janet_vm.fiber->env, argv[0], argv[1]);
    return argv[1];
}

JANET_CORE_FN(janet_core_native,
              "(native path &opt env)",
              "Load a native module from the given path. The path "
              "must be an absolute or relative path on the file system, and is "
              "usually a .so file on Unix systems, and a .dll file on Windows. "
              "Returns an environment table that contains functions and other values "
              "from the native module.") {
    JanetModule init;
    janet_arity(argc, 1, 2);
    const uint8_t *path = janet_getstring(argv, 0);
    const uint8_t *error = NULL;
    JanetTable *env;
    if (argc == 2) {
        env = janet_gettable(argv, 1);
    } else {
        env = janet_table(0);
    }
    init = janet_native((const char *)path, &error);
    if (!init) {
        janet_panicf("could not load native %S: %S", path, error);
    }
    init(env);
    janet_table_put(env, janet_ckeywordv("native"), argv[0]);
    return janet_wrap_table(env);
}

JANET_CORE_FN(janet_core_describe,
              "(describe x)",
              "Returns a string that is a human-readable description of `x`. "
              "For recursive data structures, the string returned contains a "
              "pointer value from which the identity of `x` "
              "can be determined.") {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_description_b(b, argv[i]);
    return janet_stringv(b->data, b->count);
}

JANET_CORE_FN(janet_core_string,
              "(string & xs)",
              "Creates a string by concatenating the elements of `xs` together. If an "
              "element is not a byte sequence, it is converted to bytes via `describe`. "
              "Returns the new string.") {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_to_string_b(b, argv[i]);
    return janet_stringv(b->data, b->count);
}

JANET_CORE_FN(janet_core_symbol,
              "(symbol & xs)",
              "Creates a symbol by concatenating the elements of `xs` together. If an "
              "element is not a byte sequence, it is converted to bytes via `describe`. "
              "Returns the new symbol.") {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_to_string_b(b, argv[i]);
    return janet_symbolv(b->data, b->count);
}

JANET_CORE_FN(janet_core_keyword,
              "(keyword & xs)",
              "Creates a keyword by concatenating the elements of `xs` together. If an "
              "element is not a byte sequence, it is converted to bytes via `describe`. "
              "Returns the new keyword.") {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_to_string_b(b, argv[i]);
    return janet_keywordv(b->data, b->count);
}

JANET_CORE_FN(janet_core_buffer,
              "(buffer & xs)",
              "Creates a buffer by concatenating the elements of `xs` together. If an "
              "element is not a byte sequence, it is converted to bytes via `describe`. "
              "Returns the new buffer.") {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_to_string_b(b, argv[i]);
    return janet_wrap_buffer(b);
}

JANET_CORE_FN(janet_core_is_abstract,
              "(abstract? x)",
              "Check if x is an abstract type.") {
    janet_fixarity(argc, 1);
    return janet_wrap_boolean(janet_checktype(argv[0], JANET_ABSTRACT));
}

JANET_CORE_FN(janet_core_scannumber,
              "(scan-number str &opt base)",
              "Parse a number from a byte sequence and return that number, either an integer "
              "or a real. The number "
              "must be in the same format as numbers in janet source code. Will return nil "
              "on an invalid number. Optionally provide a base - if a base is provided, no "
              "radix specifier is expected at the beginning of the number.") {
    double number;
    janet_arity(argc, 1, 2);
    JanetByteView view = janet_getbytes(argv, 0);
    int32_t base = janet_optinteger(argv, argc, 1, 0);
    int valid = base == 0 || (base >= 2 && base <= 36);
    if (!valid) {
        janet_panicf("expected base between 2 and 36, got %d", base);
    }
    if (janet_scan_number_base(view.bytes, view.len, base, &number))
        return janet_wrap_nil();
    return janet_wrap_number(number);
}

JANET_CORE_FN(janet_core_tuple,
              "(tuple & items)",
              "Creates a new tuple that contains items. Returns the new tuple.") {
    return janet_wrap_tuple(janet_tuple_n(argv, argc));
}

JANET_CORE_FN(janet_core_array,
              "(array & items)",
              "Create a new array that contains items. Returns the new array.") {
    JanetArray *array = janet_array(argc);
    array->count = argc;
    safe_memcpy(array->data, argv, argc * sizeof(Janet));
    return janet_wrap_array(array);
}

JANET_CORE_FN(janet_core_slice,
              "(slice x &opt start end)",
              "Extract a sub-range of an indexed data structure or byte sequence.") {
    JanetRange range;
    JanetByteView bview;
    JanetView iview;
    if (janet_bytes_view(argv[0], &bview.bytes, &bview.len)) {
        range = janet_getslice(argc, argv);
        return janet_stringv(bview.bytes + range.start, range.end - range.start);
    } else if (janet_indexed_view(argv[0], &iview.items, &iview.len)) {
        range = janet_getslice(argc, argv);
        return janet_wrap_tuple(janet_tuple_n(iview.items + range.start, range.end - range.start));
    } else {
        janet_panic_type(argv[0], 0, JANET_TFLAG_BYTES | JANET_TFLAG_INDEXED);
    }
}

JANET_CORE_FN(janet_core_table,
              "(table & kvs)",
              "Creates a new table from a variadic number of keys and values. "
              "kvs is a sequence k1, v1, k2, v2, k3, v3, ... If kvs has "
              "an odd number of elements, an error will be thrown. Returns the "
              "new table.") {
    int32_t i;
    if (argc & 1)
        janet_panic("expected even number of arguments");
    JanetTable *table = janet_table(argc >> 1);
    for (i = 0; i < argc; i += 2) {
        janet_table_put(table, argv[i], argv[i + 1]);
    }
    return janet_wrap_table(table);
}

JANET_CORE_FN(janet_core_getproto,
              "(getproto x)",
              "Get the prototype of a table or struct. Will return nil if `x` has no prototype.") {
    janet_fixarity(argc, 1);
    if (janet_checktype(argv[0], JANET_TABLE)) {
        JanetTable *t = janet_unwrap_table(argv[0]);
        return t->proto
               ? janet_wrap_table(t->proto)
               : janet_wrap_nil();
    }
    if (janet_checktype(argv[0], JANET_STRUCT)) {
        JanetStruct st = janet_unwrap_struct(argv[0]);
        return janet_struct_proto(st)
               ? janet_wrap_struct(janet_struct_proto(st))
               : janet_wrap_nil();
    }
    janet_panicf("expected struct|table, got %v", argv[0]);
}

JANET_CORE_FN(janet_core_struct,
              "(struct & kvs)",
              "Create a new struct from a sequence of key value pairs. "
              "kvs is a sequence k1, v1, k2, v2, k3, v3, ... If kvs has "
              "an odd number of elements, an error will be thrown. Returns the "
              "new struct.") {
    int32_t i;
    if (argc & 1) {
        janet_panic("expected even number of arguments");
    }
    JanetKV *st = janet_struct_begin(argc >> 1);
    for (i = 0; i < argc; i += 2) {
        janet_struct_put(st, argv[i], argv[i + 1]);
    }
    return janet_wrap_struct(janet_struct_end(st));
}

JANET_CORE_FN(janet_core_gensym,
              "(gensym)",
              "Returns a new symbol that is unique across the runtime. This means it "
              "will not collide with any already created symbols during compilation, so "
              "it can be used in macros to generate automatic bindings.") {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_symbol(janet_symbol_gen());
}

JANET_CORE_FN(janet_core_gccollect,
              "(gccollect)",
              "Run garbage collection. You should probably not call this manually.") {
    (void) argv;
    (void) argc;
    janet_collect();
    return janet_wrap_nil();
}

JANET_CORE_FN(janet_core_gcsetinterval,
              "(gcsetinterval interval)",
              "Set an integer number of bytes to allocate before running garbage collection. "
              "Low values for interval will be slower but use less memory. "
              "High values will be faster but use more memory.") {
    janet_fixarity(argc, 1);
    size_t s = janet_getsize(argv, 0);
    /* limit interval to 48 bits */
#ifdef JANET_64
    if (s >> 48) {
        janet_panic("interval too large");
    }
#endif
    janet_vm.gc_interval = s;
    return janet_wrap_nil();
}

JANET_CORE_FN(janet_core_gcinterval,
              "(gcinterval)",
              "Returns the integer number of bytes to allocate before running an iteration "
              "of garbage collection.") {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_number((double) janet_vm.gc_interval);
}

JANET_CORE_FN(janet_core_type,
              "(type x)",
              "Returns the type of `x` as a keyword. `x` is one of:\n\n"
              "* :nil\n\n"
              "* :boolean\n\n"
              "* :number\n\n"
              "* :array\n\n"
              "* :tuple\n\n"
              "* :table\n\n"
              "* :struct\n\n"
              "* :string\n\n"
              "* :buffer\n\n"
              "* :symbol\n\n"
              "* :keyword\n\n"
              "* :function\n\n"
              "* :cfunction\n\n"
              "* :fiber\n\n"
              "or another keyword for an abstract type.") {
    janet_fixarity(argc, 1);
    JanetType t = janet_type(argv[0]);
    if (t == JANET_ABSTRACT) {
        return janet_ckeywordv(janet_abstract_type(janet_unwrap_abstract(argv[0]))->name);
    } else {
        return janet_ckeywordv(janet_type_names[t]);
    }
}

JANET_CORE_FN(janet_core_hash,
              "(hash value)",
              "Gets a hash for any value. The hash is an integer can be used "
              "as a cheap hash function for all values. If two values are strictly equal, "
              "then they will have the same hash value.") {
    janet_fixarity(argc, 1);
    return janet_wrap_number(janet_hash(argv[0]));
}

JANET_CORE_FN(janet_core_getline,
              "(getline &opt prompt buf env)",
              "Reads a line of input into a buffer, including the newline character, using a prompt. "
              "An optional environment table can be provided for auto-complete. "
              "Returns the modified buffer. "
              "Use this function to implement a simple interface for a terminal program.") {
    FILE *in = janet_dynfile("in", stdin);
    FILE *out = janet_dynfile("out", stdout);
    janet_arity(argc, 0, 3);
    JanetBuffer *buf = (argc >= 2) ? janet_getbuffer(argv, 1) : janet_buffer(10);
    if (argc >= 1) {
        const char *prompt = (const char *) janet_getstring(argv, 0);
        fprintf(out, "%s", prompt);
        fflush(out);
    }
    {
        buf->count = 0;
        int c;
        for (;;) {
            c = fgetc(in);
            if (feof(in) || c < 0) {
                break;
            }
            janet_buffer_push_u8(buf, (uint8_t) c);
            if (c == '\n') break;
        }
    }
    return janet_wrap_buffer(buf);
}

JANET_CORE_FN(janet_core_trace,
              "(trace func)",
              "Enable tracing on a function. Returns the function.") {
    janet_fixarity(argc, 1);
    JanetFunction *func = janet_getfunction(argv, 0);
    func->gc.flags |= JANET_FUNCFLAG_TRACE;
    return argv[0];
}

JANET_CORE_FN(janet_core_untrace,
              "(untrace func)",
              "Disables tracing on a function. Returns the function.") {
    janet_fixarity(argc, 1);
    JanetFunction *func = janet_getfunction(argv, 0);
    func->gc.flags &= ~JANET_FUNCFLAG_TRACE;
    return argv[0];
}

JANET_CORE_FN(janet_core_check_int,
              "(int? x)",
              "Check if x can be exactly represented as a 32 bit signed two's complement integer.") {
    janet_fixarity(argc, 1);
    if (!janet_checktype(argv[0], JANET_NUMBER)) goto ret_false;
    double num = janet_unwrap_number(argv[0]);
    return janet_wrap_boolean(num == (double)((int32_t)num));
ret_false:
    return janet_wrap_false();
}

JANET_CORE_FN(janet_core_check_nat,
              "(nat? x)",
              "Check if x can be exactly represented as a non-negative 32 bit signed two's complement integer.") {
    janet_fixarity(argc, 1);
    if (!janet_checktype(argv[0], JANET_NUMBER)) goto ret_false;
    double num = janet_unwrap_number(argv[0]);
    return janet_wrap_boolean(num >= 0 && (num == (double)((int32_t)num)));
ret_false:
    return janet_wrap_false();
}

JANET_CORE_FN(janet_core_signal,
              "(signal what x)",
              "Raise a signal with payload x. ") {
    janet_arity(argc, 1, 2);
    Janet payload = argc == 2 ? argv[1] : janet_wrap_nil();
    if (janet_checkint(argv[0])) {
        int32_t s = janet_unwrap_integer(argv[0]);
        if (s < 0 || s > 9) {
            janet_panicf("expected user signal between 0 and 9, got %d", s);
        }
        janet_signalv(JANET_SIGNAL_USER0 + s, payload);
    } else {
        JanetKeyword kw = janet_getkeyword(argv, 0);
        for (unsigned i = 0; i < sizeof(janet_signal_names) / sizeof(char *); i++) {
            if (!janet_cstrcmp(kw, janet_signal_names[i])) {
                janet_signalv((JanetSignal) i, payload);
            }
        }
    }
    janet_panicf("unknown signal %v", argv[0]);
}

JANET_CORE_FN(janet_core_memcmp,
              "(memcmp a b &opt len offset-a offset-b)",
              "Compare memory. Takes to byte sequences `a` and `b`, and "
              "return 0 if they have identical contents, a negative integer if a is less than b, "
              "and a positive integer if a is greather than b. Optionally take a length and offsets "
              "to compare slices of the bytes sequences.") {
    janet_arity(argc, 2, 5);
    JanetByteView a = janet_getbytes(argv, 0);
    JanetByteView b = janet_getbytes(argv, 1);
    int32_t len = janet_optnat(argv, argc, 2, a.len < b.len ? a.len : b.len);
    int32_t offset_a = janet_optnat(argv, argc, 3, 0);
    int32_t offset_b = janet_optnat(argv, argc, 4, 0);
    if (offset_a + len > a.len) janet_panicf("invalid offset-a: %d", offset_a);
    if (offset_b + len > b.len) janet_panicf("invalid offset-b: %d", offset_b);
    return janet_wrap_integer(memcmp(a.bytes + offset_a, b.bytes + offset_b, (size_t) len));
}

#ifdef JANET_BOOTSTRAP

/* Utility for inline assembly */
static void janet_quick_asm(
    JanetTable *env,
    int32_t flags,
    const char *name,
    int32_t arity,
    int32_t min_arity,
    int32_t max_arity,
    int32_t slots,
    const uint32_t *bytecode,
    size_t bytecode_size,
    const char *doc) {
    JanetFuncDef *def = janet_funcdef_alloc();
    def->arity = arity;
    def->min_arity = min_arity;
    def->max_arity = max_arity;
    def->flags = flags;
    def->slotcount = slots;
    def->bytecode = janet_malloc(bytecode_size);
    def->bytecode_length = (int32_t)(bytecode_size / sizeof(uint32_t));
    def->name = janet_cstring(name);
    if (!def->bytecode) {
        JANET_OUT_OF_MEMORY;
    }
    memcpy(def->bytecode, bytecode, bytecode_size);
    janet_def_addflags(def);
    janet_def(env, name, janet_wrap_function(janet_thunk(def)), doc);
}

/* Macros for easier inline assembly */
#define SSS(op, a, b, c) ((op) | ((a) << 8) | ((b) << 16) | ((c) << 24))
#define SS(op, a, b) ((op) | ((a) << 8) | ((b) << 16))
#define SSI(op, a, b, I) ((op) | ((a) << 8) | ((b) << 16) | ((uint32_t)(I) << 24))
#define S(op, a) ((op) | ((a) << 8))
#define SI(op, a, I) ((op) | ((a) << 8) | ((uint32_t)(I) << 16))

/* Templatize a varop */
static void templatize_varop(
    JanetTable *env,
    int32_t flags,
    const char *name,
    int32_t nullary,
    int32_t unary,
    uint32_t op,
    const char *doc) {

    /* Variadic operator assembly. Must be templatized for each different opcode. */
    /* Reg 0: Argument tuple (args) */
    /* Reg 1: Argument count (argn) */
    /* Reg 2: Jump flag (jump?) */
    /* Reg 3: Accumulator (accum) */
    /* Reg 4: Next operand (operand) */
    /* Reg 5: Loop iterator (i) */
    uint32_t varop_asm[] = {
        SS(JOP_LENGTH, 1, 0), /* Put number of arguments in register 1 -> argn = count(args) */

        /* Check nullary */
        SSS(JOP_EQUALS_IMMEDIATE, 2, 1, 0), /* Check if numargs equal to 0 */
        SI(JOP_JUMP_IF_NOT, 2, 3), /* If not 0, jump to next check */
        /* Nullary */
        SI(JOP_LOAD_INTEGER, 3, nullary),  /* accum = nullary value */
        S(JOP_RETURN, 3), /* return accum */

        /* Check unary */
        SSI(JOP_EQUALS_IMMEDIATE, 2, 1, 1), /* Check if numargs equal to 1 */
        SI(JOP_JUMP_IF_NOT, 2, 5), /* If not 1, jump to next check */
        /* Unary */
        SI(JOP_LOAD_INTEGER, 3, unary), /* accum = unary value */
        SSI(JOP_GET_INDEX, 4, 0, 0), /* operand = args[0] */
        SSS(op, 3, 3, 4), /* accum = accum op operand */
        S(JOP_RETURN, 3), /* return accum */

        /* Mutli (2 or more) arity */
        /* Prime loop */
        SSI(JOP_GET_INDEX, 3, 0, 0), /* accum = args[0] */
        SI(JOP_LOAD_INTEGER, 5, 1), /* i = 1 */
        /* Main loop */
        SSS(JOP_IN, 4, 0, 5), /* operand = args[i] */
        SSS(op, 3, 3, 4), /* accum = accum op operand */
        SSI(JOP_ADD_IMMEDIATE, 5, 5, 1), /* i++ */
        SSI(JOP_EQUALS, 2, 5, 1), /* jump? = (i == argn) */
        SI(JOP_JUMP_IF_NOT, 2, -4), /* if not jump? go back 4 */

        /* Done, do last and return accumulator */
        S(JOP_RETURN, 3) /* return accum */
    };

    janet_quick_asm(
        env,
        flags | JANET_FUNCDEF_FLAG_VARARG,
        name,
        0,
        0,
        INT32_MAX,
        6,
        varop_asm,
        sizeof(varop_asm),
        doc);
}

/* Templatize variadic comparators */
static void templatize_comparator(
    JanetTable *env,
    int32_t flags,
    const char *name,
    int invert,
    uint32_t op,
    const char *doc) {

    /* Reg 0: Argument tuple (args) */
    /* Reg 1: Argument count (argn) */
    /* Reg 2: Jump flag (jump?) */
    /* Reg 3: Last value (last) */
    /* Reg 4: Next operand (next) */
    /* Reg 5: Loop iterator (i) */
    uint32_t comparator_asm[] = {
        SS(JOP_LENGTH, 1, 0), /* Put number of arguments in register 1 -> argn = count(args) */
        SSS(JOP_LESS_THAN_IMMEDIATE, 2, 1, 2), /* Check if numargs less than 2 */
        SI(JOP_JUMP_IF, 2, 10), /* If numargs < 2, jump to done */

        /* Prime loop */
        SSI(JOP_GET_INDEX, 3, 0, 0), /* last = args[0] */
        SI(JOP_LOAD_INTEGER, 5, 1), /* i = 1 */

        /* Main loop */
        SSS(JOP_IN, 4, 0, 5), /* next = args[i] */
        SSS(op, 2, 3, 4), /* jump? = last compare next */
        SI(JOP_JUMP_IF_NOT, 2, 7), /* if not jump? goto fail (return false) */
        SSI(JOP_ADD_IMMEDIATE, 5, 5, 1), /* i++ */
        SS(JOP_MOVE_NEAR, 3, 4), /* last = next */
        SSI(JOP_EQUALS, 2, 5, 1), /* jump? = (i == argn) */
        SI(JOP_JUMP_IF_NOT, 2, -6), /* if not jump? go back 6 */

        /* Done, return true */
        S(invert ? JOP_LOAD_FALSE : JOP_LOAD_TRUE, 3),
        S(JOP_RETURN, 3),

        /* Failed, return false */
        S(invert ? JOP_LOAD_TRUE : JOP_LOAD_FALSE, 3),
        S(JOP_RETURN, 3)
    };

    janet_quick_asm(
        env,
        flags | JANET_FUNCDEF_FLAG_VARARG,
        name,
        0,
        0,
        INT32_MAX,
        6,
        comparator_asm,
        sizeof(comparator_asm),
        doc);
}

/* Make the apply function */
static void make_apply(JanetTable *env) {
    /* Reg 0: Function (fun) */
    /* Reg 1: Argument tuple (args) */
    /* Reg 2: Argument count (argn) */
    /* Reg 3: Jump flag (jump?) */
    /* Reg 4: Loop iterator (i) */
    /* Reg 5: Loop values (x) */
    uint32_t apply_asm[] = {
        SS(JOP_LENGTH, 2, 1),
        SSS(JOP_EQUALS_IMMEDIATE, 3, 2, 0), /* Immediate tail call if no args */
        SI(JOP_JUMP_IF, 3, 9),

        /* Prime loop */
        SI(JOP_LOAD_INTEGER, 4, 0), /* i = 0 */

        /* Main loop */
        SSS(JOP_IN, 5, 1, 4), /* x = args[i] */
        SSI(JOP_ADD_IMMEDIATE, 4, 4, 1), /* i++ */
        SSI(JOP_EQUALS, 3, 4, 2), /* jump? = (i == argn) */
        SI(JOP_JUMP_IF, 3, 3), /* if jump? go forward 3 */
        S(JOP_PUSH, 5),
        (JOP_JUMP | ((uint32_t)(-5) << 8)),

        /* Push the array */
        S(JOP_PUSH_ARRAY, 5),

        /* Call the funciton */
        S(JOP_TAILCALL, 0)
    };
    janet_quick_asm(env, JANET_FUN_APPLY | JANET_FUNCDEF_FLAG_VARARG,
                    "apply", 1, 1, INT32_MAX, 6, apply_asm, sizeof(apply_asm),
                    JDOC("(apply f & args)\n\n"
                         "Applies a function to a variable number of arguments. Each element in args "
                         "is used as an argument to f, except the last element in args, which is expected to "
                         "be an array-like. Each element in this last argument is then also pushed as an argument to "
                         "f. For example:\n\n"
                         "\t(apply + 1000 (range 10))\n\n"
                         "sums the first 10 integers and 1000."));
}

static const uint32_t error_asm[] = {
    JOP_ERROR
};
static const uint32_t debug_asm[] = {
    JOP_SIGNAL | (2 << 24),
    JOP_RETURN
};
static const uint32_t yield_asm[] = {
    JOP_SIGNAL | (3 << 24),
    JOP_RETURN
};
static const uint32_t resume_asm[] = {
    JOP_RESUME | (1 << 24),
    JOP_RETURN
};
static const uint32_t cancel_asm[] = {
    JOP_CANCEL | (1 << 24),
    JOP_RETURN
};
static const uint32_t in_asm[] = {
    JOP_IN | (1 << 24),
    JOP_LOAD_NIL | (3 << 8),
    JOP_EQUALS | (3 << 8) | (3 << 24),
    JOP_JUMP_IF | (3 << 8) | (2 << 16),
    JOP_RETURN,
    JOP_RETURN | (2 << 8)
};
static const uint32_t get_asm[] = {
    JOP_GET | (1 << 24),
    JOP_LOAD_NIL | (3 << 8),
    JOP_EQUALS | (3 << 8) | (3 << 24),
    JOP_JUMP_IF | (3 << 8) | (2 << 16),
    JOP_RETURN,
    JOP_RETURN | (2 << 8)
};
static const uint32_t put_asm[] = {
    JOP_PUT | (1 << 16) | (2 << 24),
    JOP_RETURN
};
static const uint32_t length_asm[] = {
    JOP_LENGTH,
    JOP_RETURN
};
static const uint32_t bnot_asm[] = {
    JOP_BNOT,
    JOP_RETURN
};
static const uint32_t propagate_asm[] = {
    JOP_PROPAGATE | (1 << 24),
    JOP_RETURN
};
static const uint32_t next_asm[] = {
    JOP_NEXT | (1 << 24),
    JOP_RETURN
};
static const uint32_t modulo_asm[] = {
    JOP_MODULO | (1 << 24),
    JOP_RETURN
};
static const uint32_t remainder_asm[] = {
    JOP_REMAINDER | (1 << 24),
    JOP_RETURN
};
static const uint32_t cmp_asm[] = {
    JOP_COMPARE | (1 << 24),
    JOP_RETURN
};
#endif /* ifdef JANET_BOOTSTRAP */

/*
 * Setup Environment
 */

static void janet_load_libs(JanetTable *env) {
    JanetRegExt corelib_cfuns[] = {
        JANET_CORE_REG("native", janet_core_native),
        JANET_CORE_REG("describe", janet_core_describe),
        JANET_CORE_REG("string", janet_core_string),
        JANET_CORE_REG("symbol", janet_core_symbol),
        JANET_CORE_REG("keyword", janet_core_keyword),
        JANET_CORE_REG("buffer", janet_core_buffer),
        JANET_CORE_REG("abstract?", janet_core_is_abstract),
        JANET_CORE_REG("table", janet_core_table),
        JANET_CORE_REG("array", janet_core_array),
        JANET_CORE_REG("scan-number", janet_core_scannumber),
        JANET_CORE_REG("tuple", janet_core_tuple),
        JANET_CORE_REG("struct", janet_core_struct),
        JANET_CORE_REG("gensym", janet_core_gensym),
        JANET_CORE_REG("gccollect", janet_core_gccollect),
        JANET_CORE_REG("gcsetinterval", janet_core_gcsetinterval),
        JANET_CORE_REG("gcinterval", janet_core_gcinterval),
        JANET_CORE_REG("type", janet_core_type),
        JANET_CORE_REG("hash", janet_core_hash),
        JANET_CORE_REG("getline", janet_core_getline),
        JANET_CORE_REG("dyn", janet_core_dyn),
        JANET_CORE_REG("setdyn", janet_core_setdyn),
        JANET_CORE_REG("trace", janet_core_trace),
        JANET_CORE_REG("untrace", janet_core_untrace),
        JANET_CORE_REG("module/expand-path", janet_core_expand_path),
        JANET_CORE_REG("int?", janet_core_check_int),
        JANET_CORE_REG("nat?", janet_core_check_nat),
        JANET_CORE_REG("slice", janet_core_slice),
        JANET_CORE_REG("signal", janet_core_signal),
        JANET_CORE_REG("memcmp", janet_core_memcmp),
        JANET_CORE_REG("getproto", janet_core_getproto),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, corelib_cfuns);
    janet_lib_io(env);
    janet_lib_math(env);
    janet_lib_array(env);
    janet_lib_tuple(env);
    janet_lib_buffer(env);
    janet_lib_table(env);
    janet_lib_struct(env);
    janet_lib_fiber(env);
    janet_lib_os(env);
    janet_lib_parse(env);
    janet_lib_compile(env);
    janet_lib_debug(env);
    janet_lib_string(env);
    janet_lib_marsh(env);
#ifdef JANET_PEG
    janet_lib_peg(env);
#endif
#ifdef JANET_ASSEMBLER
    janet_lib_asm(env);
#endif
#ifdef JANET_INT_TYPES
    janet_lib_inttypes(env);
#endif
#ifdef JANET_EV
    janet_lib_ev(env);
#endif
#ifdef JANET_NET
    janet_lib_net(env);
#endif
#ifdef JANET_FFI
    janet_lib_ffi(env);
#endif
}

#ifdef JANET_BOOTSTRAP

JanetTable *janet_core_env(JanetTable *replacements) {
    JanetTable *env = (NULL != replacements) ? replacements : janet_table(0);
    janet_quick_asm(env, JANET_FUN_MODULO,
                    "mod", 2, 2, 2, 2, modulo_asm, sizeof(modulo_asm),
                    JDOC("(mod dividend divisor)\n\n"
                         "Returns the modulo of dividend / divisor."));
    janet_quick_asm(env, JANET_FUN_REMAINDER,
                    "%", 2, 2, 2, 2, remainder_asm, sizeof(remainder_asm),
                    JDOC("(% dividend divisor)\n\n"
                         "Returns the remainder of dividend / divisor."));
    janet_quick_asm(env, JANET_FUN_CMP,
                    "cmp", 2, 2, 2, 2, cmp_asm, sizeof(cmp_asm),
                    JDOC("(cmp x y)\n\n"
                         "Returns -1 if x is strictly less than y, 1 if y is strictly greater "
                         "than x, and 0 otherwise. To return 0, x and y must be the exact same type."));
    janet_quick_asm(env, JANET_FUN_NEXT,
                    "next", 2, 1, 2, 2, next_asm, sizeof(next_asm),
                    JDOC("(next ds &opt key)\n\n"
                         "Gets the next key in a data structure. Can be used to iterate through "
                         "the keys of a data structure in an unspecified order. Keys are guaranteed "
                         "to be seen only once per iteration if they data structure is not mutated "
                         "during iteration. If key is nil, next returns the first key. If next "
                         "returns nil, there are no more keys to iterate through."));
    janet_quick_asm(env, JANET_FUN_PROP,
                    "propagate", 2, 2, 2, 2, propagate_asm, sizeof(propagate_asm),
                    JDOC("(propagate x fiber)\n\n"
                         "Propagate a signal from a fiber to the current fiber. The resulting "
                         "stack trace from the current fiber will include frames from fiber. If "
                         "fiber is in a state that can be resumed, resuming the current fiber will "
                         "first resume fiber. This function can be used to re-raise an error without "
                         "losing the original stack trace."));
    janet_quick_asm(env, JANET_FUN_DEBUG,
                    "debug", 1, 0, 1, 1, debug_asm, sizeof(debug_asm),
                    JDOC("(debug &opt x)\n\n"
                         "Throws a debug signal that can be caught by a parent fiber and used to inspect "
                         "the running state of the current fiber. Returns the value passed in by resume."));
    janet_quick_asm(env, JANET_FUN_ERROR,
                    "error", 1, 1, 1, 1, error_asm, sizeof(error_asm),
                    JDOC("(error e)\n\n"
                         "Throws an error e that can be caught and handled by a parent fiber."));
    janet_quick_asm(env, JANET_FUN_YIELD,
                    "yield", 1, 0, 1, 2, yield_asm, sizeof(yield_asm),
                    JDOC("(yield &opt x)\n\n"
                         "Yield a value to a parent fiber. When a fiber yields, its execution is paused until "
                         "another thread resumes it. The fiber will then resume, and the last yield call will "
                         "return the value that was passed to resume."));
    janet_quick_asm(env, JANET_FUN_CANCEL,
                    "cancel", 2, 2, 2, 2, cancel_asm, sizeof(cancel_asm),
                    JDOC("(cancel fiber err)\n\n"
                         "Resume a fiber but have it immediately raise an error. This lets a programmer unwind a pending fiber. "
                         "Returns the same result as resume."));
    janet_quick_asm(env, JANET_FUN_RESUME,
                    "resume", 2, 1, 2, 2, resume_asm, sizeof(resume_asm),
                    JDOC("(resume fiber &opt x)\n\n"
                         "Resume a new or suspended fiber and optionally pass in a value to the fiber that "
                         "will be returned to the last yield in the case of a pending fiber, or the argument to "
                         "the dispatch function in the case of a new fiber. Returns either the return result of "
                         "the fiber's dispatch function, or the value from the next yield call in fiber."));
    janet_quick_asm(env, JANET_FUN_IN,
                    "in", 3, 2, 3, 4, in_asm, sizeof(in_asm),
                    JDOC("(in ds key &opt dflt)\n\n"
                         "Get value in ds at key, works on associative data structures. Arrays, tuples, tables, structs, "
                         "strings, symbols, and buffers are all associative and can be used. Arrays, tuples, strings, buffers, "
                         "and symbols must use integer keys that are in bounds or an error is raised. Structs and tables can "
                         "take any value as a key except nil and will return nil or dflt if not found."));
    janet_quick_asm(env, JANET_FUN_GET,
                    "get", 3, 2, 3, 4, get_asm, sizeof(in_asm),
                    JDOC("(get ds key &opt dflt)\n\n"
                         "Get the value mapped to key in data structure ds, and return dflt or nil if not found. "
                         "Similar to in, but will not throw an error if the key is invalid for the data structure "
                         "unless the data structure is an abstract type. In that case, the abstract type getter may throw "
                         "an error."));
    janet_quick_asm(env, JANET_FUN_PUT,
                    "put", 3, 3, 3, 3, put_asm, sizeof(put_asm),
                    JDOC("(put ds key value)\n\n"
                         "Associate a key with a value in any mutable associative data structure. Indexed data structures "
                         "(arrays and buffers) only accept non-negative integer keys, and will expand if an out of bounds "
                         "value is provided. In an array, extra space will be filled with nils, and in a buffer, extra "
                         "space will be filled with 0 bytes. In a table, putting a key that is contained in the table prototype "
                         "will hide the association defined by the prototype, but will not mutate the prototype table. Putting "
                         "a value nil into a table will remove the key from the table. Returns the data structure ds."));
    janet_quick_asm(env, JANET_FUN_LENGTH,
                    "length", 1, 1, 1, 1, length_asm, sizeof(length_asm),
                    JDOC("(length ds)\n\n"
                         "Returns the length or count of a data structure in constant time as an integer. For "
                         "structs and tables, returns the number of key-value pairs in the data structure."));
    janet_quick_asm(env, JANET_FUN_BNOT,
                    "bnot", 1, 1, 1, 1, bnot_asm, sizeof(bnot_asm),
                    JDOC("(bnot x)\n\nReturns the bit-wise inverse of integer x."));
    make_apply(env);

    /* Variadic ops */
    templatize_varop(env, JANET_FUN_ADD, "+", 0, 0, JOP_ADD,
                     JDOC("(+ & xs)\n\n"
                          "Returns the sum of all xs. xs must be integers or real numbers only. If xs is empty, return 0."));
    templatize_varop(env, JANET_FUN_SUBTRACT, "-", 0, 0, JOP_SUBTRACT,
                     JDOC("(- & xs)\n\n"
                          "Returns the difference of xs. If xs is empty, returns 0. If xs has one element, returns the "
                          "negative value of that element. Otherwise, returns the first element in xs minus the sum of "
                          "the rest of the elements."));
    templatize_varop(env, JANET_FUN_MULTIPLY, "*", 1, 1, JOP_MULTIPLY,
                     JDOC("(* & xs)\n\n"
                          "Returns the product of all elements in xs. If xs is empty, returns 1."));
    templatize_varop(env, JANET_FUN_DIVIDE, "/", 1, 1, JOP_DIVIDE,
                     JDOC("(/ & xs)\n\n"
                          "Returns the quotient of xs. If xs is empty, returns 1. If xs has one value x, returns "
                          "the reciprocal of x. Otherwise return the first value of xs repeatedly divided by the remaining "
                          "values."));
    templatize_varop(env, JANET_FUN_BAND, "band", -1, -1, JOP_BAND,
                     JDOC("(band & xs)\n\n"
                          "Returns the bit-wise and of all values in xs. Each x in xs must be an integer."));
    templatize_varop(env, JANET_FUN_BOR, "bor", 0, 0, JOP_BOR,
                     JDOC("(bor & xs)\n\n"
                          "Returns the bit-wise or of all values in xs. Each x in xs must be an integer."));
    templatize_varop(env, JANET_FUN_BXOR, "bxor", 0, 0, JOP_BXOR,
                     JDOC("(bxor & xs)\n\n"
                          "Returns the bit-wise xor of all values in xs. Each in xs must be an integer."));
    templatize_varop(env, JANET_FUN_LSHIFT, "blshift", 1, 1, JOP_SHIFT_LEFT,
                     JDOC("(blshift x & shifts)\n\n"
                          "Returns the value of x bit shifted left by the sum of all values in shifts. x "
                          "and each element in shift must be an integer."));
    templatize_varop(env, JANET_FUN_RSHIFT, "brshift", 1, 1, JOP_SHIFT_RIGHT,
                     JDOC("(brshift x & shifts)\n\n"
                          "Returns the value of x bit shifted right by the sum of all values in shifts. x "
                          "and each element in shift must be an integer."));
    templatize_varop(env, JANET_FUN_RSHIFTU, "brushift", 1, 1, JOP_SHIFT_RIGHT_UNSIGNED,
                     JDOC("(brushift x & shifts)\n\n"
                          "Returns the value of x bit shifted right by the sum of all values in shifts. x "
                          "and each element in shift must be an integer. The sign of x is not preserved, so "
                          "for positive shifts the return value will always be positive."));

    /* Variadic comparators */
    templatize_comparator(env, JANET_FUN_GT, ">", 0, JOP_GREATER_THAN,
                          JDOC("(> & xs)\n\n"
                               "Check if xs is in descending order. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_LT, "<", 0, JOP_LESS_THAN,
                          JDOC("(< & xs)\n\n"
                               "Check if xs is in ascending order. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_GTE, ">=", 0, JOP_GREATER_THAN_EQUAL,
                          JDOC("(>= & xs)\n\n"
                               "Check if xs is in non-ascending order. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_LTE, "<=", 0, JOP_LESS_THAN_EQUAL,
                          JDOC("(<= & xs)\n\n"
                               "Check if xs is in non-descending order. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_EQ, "=", 0, JOP_EQUALS,
                          JDOC("(= & xs)\n\n"
                               "Check if all values in xs are equal. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_NEQ, "not=", 1, JOP_EQUALS,
                          JDOC("(not= & xs)\n\n"
                               "Check if any values in xs are not equal. Returns a boolean."));

    /* Platform detection */
    janet_def(env, "janet/version", janet_cstringv(JANET_VERSION),
              JDOC("The version number of the running janet program."));
    janet_def(env, "janet/build", janet_cstringv(JANET_BUILD),
              JDOC("The build identifier of the running janet program."));
    janet_def(env, "janet/config-bits", janet_wrap_integer(JANET_CURRENT_CONFIG_BITS),
              JDOC("The flag set of config options from janetconf.h which is used to check "
                   "if native modules are compatible with the host program."));

    /* Allow references to the environment */
    janet_def(env, "root-env", janet_wrap_table(env),
              JDOC("The root environment used to create environments with (make-env)."));

    janet_load_libs(env);
    janet_gcroot(janet_wrap_table(env));
    return env;
}

#else

JanetTable *janet_core_env(JanetTable *replacements) {
    /* Memoize core env, ignoring replacements the second time around. */
    if (NULL != janet_vm.core_env) {
        return janet_vm.core_env;
    }

    JanetTable *dict = janet_core_lookup_table(replacements);

    /* Unmarshal bytecode */
    Janet marsh_out = janet_unmarshal(
                          janet_core_image,
                          janet_core_image_size,
                          0,
                          dict,
                          NULL);

    /* Memoize */
    janet_gcroot(marsh_out);
    JanetTable *env = janet_unwrap_table(marsh_out);
    janet_vm.core_env = env;

    /* Invert image dict manually here. We can't do this in boot.janet as it
     * breaks deterministic builds */
    Janet lidv, midv;
    lidv = midv = janet_wrap_nil();
    janet_resolve(env, janet_csymbol("load-image-dict"), &lidv);
    janet_resolve(env, janet_csymbol("make-image-dict"), &midv);
    JanetTable *lid = janet_unwrap_table(lidv);
    JanetTable *mid = janet_unwrap_table(midv);
    for (int32_t i = 0; i < lid->capacity; i++) {
        const JanetKV *kv = lid->data + i;
        if (!janet_checktype(kv->key, JANET_NIL)) {
            janet_table_put(mid, kv->value, kv->key);
        }
    }

    return env;
}

#endif

JanetTable *janet_core_lookup_table(JanetTable *replacements) {
    JanetTable *dict = janet_table(512);
    janet_load_libs(dict);

    /* Add replacements */
    if (replacements != NULL) {
        for (int32_t i = 0; i < replacements->capacity; i++) {
            JanetKV kv = replacements->data[i];
            if (!janet_checktype(kv.key, JANET_NIL)) {
                janet_table_put(dict, kv.key, kv.value);
                /* Add replacement functions to registry? */
            }
        }
    }

    return dict;
}


/* src/core/debug.c */
#line 0 "src/core/debug.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "state.h"
#include "util.h"
#include "vector.h"
#endif

/* Implements functionality to build a debugger from within janet.
 * The repl should also be able to serve as pretty featured debugger
 * out of the box. */

/* Add a break point to a function */
void janet_debug_break(JanetFuncDef *def, int32_t pc) {
    if (pc >= def->bytecode_length || pc < 0)
        janet_panic("invalid bytecode offset");
    def->bytecode[pc] |= 0x80;
}

/* Remove a break point from a function */
void janet_debug_unbreak(JanetFuncDef *def, int32_t pc) {
    if (pc >= def->bytecode_length || pc < 0)
        janet_panic("invalid bytecode offset");
    def->bytecode[pc] &= ~((uint32_t)0x80);
}

/*
 * Find a location for a breakpoint given a source file an
 * location.
 */
void janet_debug_find(
    JanetFuncDef **def_out, int32_t *pc_out,
    const uint8_t *source, int32_t sourceLine, int32_t sourceColumn) {
    /* Scan the heap for right func def */
    JanetGCObject *current = janet_vm.blocks;
    /* Keep track of the best source mapping we have seen so far */
    int32_t besti = -1;
    int32_t best_line = -1;
    int32_t best_column = -1;
    JanetFuncDef *best_def = NULL;
    while (NULL != current) {
        if ((current->flags & JANET_MEM_TYPEBITS) == JANET_MEMORY_FUNCDEF) {
            JanetFuncDef *def = (JanetFuncDef *)(current);
            if (def->sourcemap &&
                    def->source &&
                    !janet_string_compare(source, def->source)) {
                /* Correct source file, check mappings. The chosen
                 * pc index is the instruction closest to the given line column, but
                 * not after. */
                int32_t i;
                for (i = 0; i < def->bytecode_length; i++) {
                    int32_t line = def->sourcemap[i].line;
                    int32_t column = def->sourcemap[i].column;
                    if (line <= sourceLine && line >= best_line) {
                        if (column <= sourceColumn &&
                                (line > best_line || column > best_column)) {
                            best_line = line;
                            best_column = column;
                            besti = i;
                            best_def = def;
                        }
                    }
                }
            }
        }
        current = current->data.next;
    }
    if (best_def) {
        *def_out = best_def;
        *pc_out = besti;
    } else {
        janet_panic("could not find breakpoint");
    }
}

void janet_stacktrace(JanetFiber *fiber, Janet err) {
    const char *prefix = janet_checktype(err, JANET_NIL) ? NULL : "";
    janet_stacktrace_ext(fiber, err, prefix);
}

/* Error reporting. This can be emulated from within Janet, but for
 * consitency with the top level code it is defined once. */
void janet_stacktrace_ext(JanetFiber *fiber, Janet err, const char *prefix) {

    int32_t fi;
    const char *errstr = (const char *)janet_to_string(err);
    JanetFiber **fibers = NULL;
    int wrote_error = !prefix;

    int print_color = janet_truthy(janet_dyn("err-color"));
    if (print_color) janet_eprintf("\x1b[31m");

    while (fiber) {
        janet_v_push(fibers, fiber);
        fiber = fiber->child;
    }

    for (fi = janet_v_count(fibers) - 1; fi >= 0; fi--) {
        fiber = fibers[fi];
        int32_t i = fiber->frame;
        while (i > 0) {
            JanetCFunRegistry *reg = NULL;
            JanetStackFrame *frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
            JanetFuncDef *def = NULL;
            i = frame->prevframe;

            /* Print prelude to stack frame */
            if (!wrote_error) {
                JanetFiberStatus status = janet_fiber_status(fiber);
                janet_eprintf("%s%s: %s\n",
                              prefix,
                              janet_status_names[status],
                              errstr);
                wrote_error = 1;
            }

            janet_eprintf("  in");

            if (frame->func) {
                def = frame->func->def;
                janet_eprintf(" %s", def->name ? (const char *)def->name : "<anonymous>");
                if (def->source) {
                    janet_eprintf(" [%s]", (const char *)def->source);
                }
            } else {
                JanetCFunction cfun = (JanetCFunction)(frame->pc);
                if (cfun) {
                    reg = janet_registry_get(cfun);
                    if (NULL != reg && NULL != reg->name) {
                        if (reg->name_prefix) {
                            janet_eprintf(" %s/%s", reg->name_prefix, reg->name);
                        } else {
                            janet_eprintf(" %s", reg->name);
                        }
                        if (NULL != reg->source_file) {
                            janet_eprintf(" [%s]", reg->source_file);
                        }
                    } else {
                        janet_eprintf(" <cfunction>");
                    }
                }
            }
            if (frame->flags & JANET_STACKFRAME_TAILCALL)
                janet_eprintf(" (tailcall)");
            if (frame->func && frame->pc) {
                int32_t off = (int32_t)(frame->pc - def->bytecode);
                if (def->sourcemap) {
                    JanetSourceMapping mapping = def->sourcemap[off];
                    janet_eprintf(" on line %d, column %d", mapping.line, mapping.column);
                } else {
                    janet_eprintf(" pc=%d", off);
                }
            } else if (NULL != reg) {
                /* C Function */
                if (reg->source_line > 0) {
                    janet_eprintf(" on line %d", (long) reg->source_line);
                }
            }
            janet_eprintf("\n");
        }
    }

    if (print_color) janet_eprintf("\x1b[0m");

    janet_v_free(fibers);
}

/*
 * CFuns
 */

/* Helper to find funcdef and bytecode offset to insert or remove breakpoints.
 * Takes a source file name and byte offset. */
static void helper_find(int32_t argc, Janet *argv, JanetFuncDef **def, int32_t *bytecode_offset) {
    janet_fixarity(argc, 3);
    const uint8_t *source = janet_getstring(argv, 0);
    int32_t line = janet_getinteger(argv, 1);
    int32_t col = janet_getinteger(argv, 2);
    janet_debug_find(def, bytecode_offset, source, line, col);
}

/* Helper to find funcdef and bytecode offset to insert or remove breakpoints.
 * Takes a function and byte offset*/
static void helper_find_fun(int32_t argc, Janet *argv, JanetFuncDef **def, int32_t *bytecode_offset) {
    janet_arity(argc, 1, 2);
    JanetFunction *func = janet_getfunction(argv, 0);
    int32_t offset = (argc == 2) ? janet_getinteger(argv, 1) : 0;
    *def = func->def;
    *bytecode_offset = offset;
}

JANET_CORE_FN(cfun_debug_break,
              "(debug/break source line col)",
              "Sets a breakpoint in `source` at a given line and column. "
              "Will throw an error if the breakpoint location "
              "cannot be found. For example\n\n"
              "\t(debug/break \"core.janet\" 10 4)\n\n"
              "will set a breakpoint at line 10, 4th column of the file core.janet.") {
    JanetFuncDef *def;
    int32_t offset;
    helper_find(argc, argv, &def, &offset);
    janet_debug_break(def, offset);
    return janet_wrap_nil();
}

JANET_CORE_FN(cfun_debug_unbreak,
              "(debug/unbreak source line column)",
              "Remove a breakpoint with a source key at a given line and column. "
              "Will throw an error if the breakpoint "
              "cannot be found.") {
    JanetFuncDef *def;
    int32_t offset = 0;
    helper_find(argc, argv, &def, &offset);
    janet_debug_unbreak(def, offset);
    return janet_wrap_nil();
}

JANET_CORE_FN(cfun_debug_fbreak,
              "(debug/fbreak fun &opt pc)",
              "Set a breakpoint in a given function. pc is an optional offset, which "
              "is in bytecode instructions. fun is a function value. Will throw an error "
              "if the offset is too large or negative.") {
    JanetFuncDef *def;
    int32_t offset = 0;
    helper_find_fun(argc, argv, &def, &offset);
    janet_debug_break(def, offset);
    return janet_wrap_nil();
}

JANET_CORE_FN(cfun_debug_unfbreak,
              "(debug/unfbreak fun &opt pc)",
              "Unset a breakpoint set with debug/fbreak.") {
    JanetFuncDef *def;
    int32_t offset;
    helper_find_fun(argc, argv, &def, &offset);
    janet_debug_unbreak(def, offset);
    return janet_wrap_nil();
}

JANET_CORE_FN(cfun_debug_lineage,
              "(debug/lineage fib)",
              "Returns an array of all child fibers from a root fiber. This function "
              "is useful when a fiber signals or errors to an ancestor fiber. Using this function, "
              "the fiber handling the error can see which fiber raised the signal. This function should "
              "be used mostly for debugging purposes.") {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    JanetArray *array = janet_array(0);
    while (fiber) {
        janet_array_push(array, janet_wrap_fiber(fiber));
        fiber = fiber->child;
    }
    return janet_wrap_array(array);
}

/* Extract info from one stack frame */
static Janet doframe(JanetStackFrame *frame) {
    int32_t off;
    JanetTable *t = janet_table(3);
    JanetFuncDef *def = NULL;
    if (frame->func) {
        janet_table_put(t, janet_ckeywordv("function"), janet_wrap_function(frame->func));
        def = frame->func->def;
        if (def->name) {
            janet_table_put(t, janet_ckeywordv("name"), janet_wrap_string(def->name));
        }
    } else {
        JanetCFunction cfun = (JanetCFunction)(frame->pc);
        if (cfun) {
            JanetCFunRegistry *reg = janet_registry_get(cfun);
            if (NULL != reg->name) {
                if (NULL != reg->name_prefix) {
                    janet_table_put(t, janet_ckeywordv("name"), janet_wrap_string(janet_formatc("%s/%s", reg->name_prefix, reg->name)));
                } else {
                    janet_table_put(t, janet_ckeywordv("name"), janet_cstringv(reg->name));
                }
                if (NULL != reg->source_file) {
                    janet_table_put(t, janet_ckeywordv("source"), janet_cstringv(reg->source_file));
                }
                if (reg->source_line > 0) {
                    janet_table_put(t, janet_ckeywordv("source-line"), janet_wrap_integer(reg->source_line));
                    janet_table_put(t, janet_ckeywordv("source-column"), janet_wrap_integer(1));
                }
            }
        }
        janet_table_put(t, janet_ckeywordv("c"), janet_wrap_true());
    }
    if (frame->flags & JANET_STACKFRAME_TAILCALL) {
        janet_table_put(t, janet_ckeywordv("tail"), janet_wrap_true());
    }
    if (frame->func && frame->pc) {
        Janet *stack = (Janet *)frame + JANET_FRAME_SIZE;
        JanetArray *slots;
        off = (int32_t)(frame->pc - def->bytecode);
        janet_table_put(t, janet_ckeywordv("pc"), janet_wrap_integer(off));
        if (def->sourcemap) {
            JanetSourceMapping mapping = def->sourcemap[off];
            janet_table_put(t, janet_ckeywordv("source-line"), janet_wrap_integer(mapping.line));
            janet_table_put(t, janet_ckeywordv("source-column"), janet_wrap_integer(mapping.column));
        }
        if (def->source) {
            janet_table_put(t, janet_ckeywordv("source"), janet_wrap_string(def->source));
        }
        /* Add stack arguments */
        slots = janet_array(def->slotcount);
        safe_memcpy(slots->data, stack, sizeof(Janet) * def->slotcount);
        slots->count = def->slotcount;
        janet_table_put(t, janet_ckeywordv("slots"), janet_wrap_array(slots));
    }
    return janet_wrap_table(t);
}

JANET_CORE_FN(cfun_debug_stack,
              "(debug/stack fib)",
              "Gets information about the stack as an array of tables. Each table "
              "in the array contains information about a stack frame. The top-most, current "
              "stack frame is the first table in the array, and the bottom-most stack frame "
              "is the last value. Each stack frame contains some of the following attributes:\n\n"
              "* :c - true if the stack frame is a c function invocation\n\n"
              "* :source-column - the current source column of the stack frame\n\n"
              "* :function - the function that the stack frame represents\n\n"
              "* :source-line - the current source line of the stack frame\n\n"
              "* :name - the human-friendly name of the function\n\n"
              "* :pc - integer indicating the location of the program counter\n\n"
              "* :source - string with the file path or other identifier for the source code\n\n"
              "* :slots - array of all values in each slot\n\n"
              "* :tail - boolean indicating a tail call") {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    JanetArray *array = janet_array(0);
    {
        int32_t i = fiber->frame;
        JanetStackFrame *frame;
        while (i > 0) {
            frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
            janet_array_push(array, doframe(frame));
            i = frame->prevframe;
        }
    }
    return janet_wrap_array(array);
}

JANET_CORE_FN(cfun_debug_stacktrace,
              "(debug/stacktrace fiber &opt err prefix)",
              "Prints a nice looking stacktrace for a fiber. Can optionally provide "
              "an error value to print the stack trace with. If `err` is nil or not "
              "provided, and no prefix is given, will skip the error line. Returns the fiber.") {
    janet_arity(argc, 1, 3);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    Janet x = argc == 1 ? janet_wrap_nil() : argv[1];
    const char *prefix = janet_optcstring(argv, argc, 2, NULL);
    janet_stacktrace_ext(fiber, x, prefix);
    return argv[0];
}

JANET_CORE_FN(cfun_debug_argstack,
              "(debug/arg-stack fiber)",
              "Gets all values currently on the fiber's argument stack. Normally, "
              "this should be empty unless the fiber signals while pushing arguments "
              "to make a function call. Returns a new array.") {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    JanetArray *array = janet_array(fiber->stacktop - fiber->stackstart);
    memcpy(array->data, fiber->data + fiber->stackstart, array->capacity * sizeof(Janet));
    array->count = array->capacity;
    return janet_wrap_array(array);
}

JANET_CORE_FN(cfun_debug_step,
              "(debug/step fiber &opt x)",
              "Run a fiber for one virtual instruction of the Janet machine. Can optionally "
              "pass in a value that will be passed as the resuming value. Returns the signal value, "
              "which will usually be nil, as breakpoints raise nil signals.") {
    janet_arity(argc, 1, 2);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    Janet out = janet_wrap_nil();
    janet_step(fiber, argc == 1 ? janet_wrap_nil() : argv[1], &out);
    return out;
}

/* Module entry point */
void janet_lib_debug(JanetTable *env) {
    JanetRegExt debug_cfuns[] = {
        JANET_CORE_REG("debug/break", cfun_debug_break),
        JANET_CORE_REG("debug/unbreak", cfun_debug_unbreak),
        JANET_CORE_REG("debug/fbreak", cfun_debug_fbreak),
        JANET_CORE_REG("debug/unfbreak", cfun_debug_unfbreak),
        JANET_CORE_REG("debug/arg-stack", cfun_debug_argstack),
        JANET_CORE_REG("debug/stack", cfun_debug_stack),
        JANET_CORE_REG("debug/stacktrace", cfun_debug_stacktrace),
        JANET_CORE_REG("debug/lineage", cfun_debug_lineage),
        JANET_CORE_REG("debug/step", cfun_debug_step),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, debug_cfuns);
}


/* src/core/emit.c */
#line 0 "src/core/emit.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "emit.h"
#include "vector.h"
#include "regalloc.h"
#endif

/* Get a register */
int32_t janetc_allocfar(JanetCompiler *c) {
    int32_t reg = janetc_regalloc_1(&c->scope->ra);
    if (reg > 0xFFFF) {
        janetc_cerror(c, "ran out of internal registers");
    }
    return reg;
}

/* Get a register less than 256 for temporary use. */
int32_t janetc_allocnear(JanetCompiler *c, JanetcRegisterTemp tag) {
    return janetc_regalloc_temp(&c->scope->ra, tag);
}

/* Emit a raw instruction with source mapping. */
void janetc_emit(JanetCompiler *c, uint32_t instr) {
    janet_v_push(c->buffer, instr);
    janet_v_push(c->mapbuffer, c->current_mapping);
}

/* Add a constant to the current scope. Return the index of the constant. */
static int32_t janetc_const(JanetCompiler *c, Janet x) {
    JanetScope *scope = c->scope;
    int32_t i, len;
    /* Get the topmost function scope */
    while (scope) {
        if (scope->flags & JANET_SCOPE_FUNCTION)
            break;
        scope = scope->parent;
    }
    /* Check if already added */
    len = janet_v_count(scope->consts);
    for (i = 0; i < len; i++) {
        if (janet_equals(x, scope->consts[i]))
            return i;
    }
    /* Ensure not too many constants. */
    if (len >= 0xFFFF) {
        janetc_cerror(c, "too many constants");
        return 0;
    }
    janet_v_push(scope->consts, x);
    return len;
}

/* Load a constant into a local register */
static void janetc_loadconst(JanetCompiler *c, Janet k, int32_t reg) {
    switch (janet_type(k)) {
        case JANET_NIL:
            janetc_emit(c, (reg << 8) | JOP_LOAD_NIL);
            break;
        case JANET_BOOLEAN:
            janetc_emit(c, (reg << 8) |
                        (janet_unwrap_boolean(k) ? JOP_LOAD_TRUE : JOP_LOAD_FALSE));
            break;
        case JANET_NUMBER: {
            double dval = janet_unwrap_number(k);
            if (dval < INT16_MIN || dval > INT16_MAX)
                goto do_constant;
            int32_t i = (int32_t) dval;
            if (dval != i)
                goto do_constant;
            uint32_t iu = (uint32_t)i;
            janetc_emit(c,
                        (iu << 16) |
                        (reg << 8) |
                        JOP_LOAD_INTEGER);
            break;
        }
        default:
        do_constant: {
                int32_t cindex = janetc_const(c, k);
                janetc_emit(c,
                            (cindex << 16) |
                            (reg << 8) |
                            JOP_LOAD_CONSTANT);
                break;
            }
    }
}

/* Move a slot to a near register */
static void janetc_movenear(JanetCompiler *c,
                            int32_t dest,
                            JanetSlot src) {
    if (src.flags & (JANET_SLOT_CONSTANT | JANET_SLOT_REF)) {
        janetc_loadconst(c, src.constant, dest);
        /* If we also are a reference, deref the one element array */
        if (src.flags & JANET_SLOT_REF) {
            janetc_emit(c,
                        (dest << 16) |
                        (dest << 8) |
                        JOP_GET_INDEX);
        }
    } else if (src.envindex >= 0) {
        janetc_emit(c,
                    ((uint32_t)(src.index) << 24) |
                    ((uint32_t)(src.envindex) << 16) |
                    ((uint32_t)(dest) << 8) |
                    JOP_LOAD_UPVALUE);
    } else if (src.index > 0xFF || src.index != dest) {
        janetc_emit(c,
                    ((uint32_t)(src.index) << 16) |
                    ((uint32_t)(dest) << 8) |
                    JOP_MOVE_NEAR);
    }
}

/* Move a near register to a Slot. */
static void janetc_moveback(JanetCompiler *c,
                            JanetSlot dest,
                            int32_t src) {
    if (dest.flags & JANET_SLOT_REF) {
        int32_t refreg = janetc_regalloc_temp(&c->scope->ra, JANETC_REGTEMP_5);
        janetc_loadconst(c, dest.constant, refreg);
        janetc_emit(c,
                    (src << 16) |
                    (refreg << 8) |
                    JOP_PUT_INDEX);
        janetc_regalloc_freetemp(&c->scope->ra, refreg, JANETC_REGTEMP_5);
    } else if (dest.envindex >= 0) {
        janetc_emit(c,
                    ((uint32_t)(dest.index) << 24) |
                    ((uint32_t)(dest.envindex) << 16) |
                    ((uint32_t)(src) << 8) |
                    JOP_SET_UPVALUE);
    } else if (dest.index != src) {
        janetc_emit(c,
                    ((uint32_t)(dest.index) << 16) |
                    ((uint32_t)(src) << 8) |
                    JOP_MOVE_FAR);
    }
}

/* Call this to release a register after emitting the instruction. */
static void janetc_free_regnear(JanetCompiler *c, JanetSlot s, int32_t reg, JanetcRegisterTemp tag) {
    if (reg != s.index ||
            s.envindex >= 0 ||
            s.flags & (JANET_SLOT_CONSTANT | JANET_SLOT_REF)) {
        /* We need to free the temporary slot */
        janetc_regalloc_freetemp(&c->scope->ra, reg, tag);
    }
}

/* Convert a slot to a two byte register */
static int32_t janetc_regfar(JanetCompiler *c, JanetSlot s, JanetcRegisterTemp tag) {
    /* check if already near register */
    if (s.envindex < 0 && s.index >= 0) {
        return s.index;
    }
    int32_t reg;
    int32_t nearreg = janetc_regalloc_temp(&c->scope->ra, tag);
    janetc_movenear(c, nearreg, s);
    if (nearreg >= 0xF0) {
        reg = janetc_allocfar(c);
        janetc_emit(c, JOP_MOVE_FAR | (nearreg << 8) | (reg << 16));
        janetc_regalloc_freetemp(&c->scope->ra, nearreg, tag);
    } else {
        reg = nearreg;
        janetc_regalloc_freetemp(&c->scope->ra, nearreg, tag);
        janetc_regalloc_touch(&c->scope->ra, reg);
    }
    return reg;
}

/* Convert a slot to a temporary 1 byte register */
static int32_t janetc_regnear(JanetCompiler *c, JanetSlot s, JanetcRegisterTemp tag) {
    /* check if already near register */
    if (s.envindex < 0 && s.index >= 0 && s.index <= 0xFF) {
        return s.index;
    }
    int32_t reg = janetc_regalloc_temp(&c->scope->ra, tag);
    janetc_movenear(c, reg, s);
    return reg;
}

/* Check if two slots are equal */
int janetc_sequal(JanetSlot lhs, JanetSlot rhs) {
    if ((lhs.flags & ~JANET_SLOTTYPE_ANY) == (rhs.flags & ~JANET_SLOTTYPE_ANY) &&
            lhs.index == rhs.index &&
            lhs.envindex == rhs.envindex) {
        if (lhs.flags & (JANET_SLOT_REF | JANET_SLOT_CONSTANT)) {
            return janet_equals(lhs.constant, rhs.constant);
        } else {
            return 1;
        }
    }
    return 0;
}

/* Move values from one slot to another. The destination must
 * be writeable (not a literal). */
void janetc_copy(
    JanetCompiler *c,
    JanetSlot dest,
    JanetSlot src) {
    if (dest.flags & JANET_SLOT_CONSTANT) {
        janetc_cerror(c, "cannot write to constant");
        return;
    }
    if (janetc_sequal(dest, src)) return;
    /* If dest is a near register */
    if (dest.envindex < 0 && dest.index >= 0 && dest.index <= 0xFF) {
        janetc_movenear(c, dest.index, src);
        return;
    }
    /* If src is a near register */
    if (src.envindex < 0 && src.index >= 0 && src.index <= 0xFF) {
        janetc_moveback(c, dest, src.index);
        return;
    }
    /* Process: src -> near -> dest */
    int32_t nearreg = janetc_allocnear(c, JANETC_REGTEMP_3);
    janetc_movenear(c, nearreg, src);
    janetc_moveback(c, dest, nearreg);
    /* Cleanup */
    janetc_regalloc_freetemp(&c->scope->ra, nearreg, JANETC_REGTEMP_3);
}

/* Instruction templated emitters */

static int32_t emit1s(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t rest, int wr) {
    int32_t reg = janetc_regnear(c, s, JANETC_REGTEMP_0);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg << 8) | ((uint32_t)rest << 16));
    if (wr)
        janetc_moveback(c, s, reg);
    janetc_free_regnear(c, s, reg, JANETC_REGTEMP_0);
    return label;
}

int32_t janetc_emit_s(JanetCompiler *c, uint8_t op, JanetSlot s, int wr) {
    int32_t reg = janetc_regfar(c, s, JANETC_REGTEMP_0);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg << 8));
    if (wr)
        janetc_moveback(c, s, reg);
    janetc_free_regnear(c, s, reg, JANETC_REGTEMP_0);
    return label;
}

int32_t janetc_emit_sl(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t label) {
    int32_t current = janet_v_count(c->buffer) - 1;
    int32_t jump = label - current;
    if (jump < INT16_MIN || jump > INT16_MAX) {
        janetc_cerror(c, "jump is too far");
    }
    return emit1s(c, op, s, jump, 0);
}

int32_t janetc_emit_st(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t tflags) {
    return emit1s(c, op, s, tflags, 0);
}

int32_t janetc_emit_si(JanetCompiler *c, uint8_t op, JanetSlot s, int16_t immediate, int wr) {
    return emit1s(c, op, s, immediate, wr);
}

int32_t janetc_emit_su(JanetCompiler *c, uint8_t op, JanetSlot s, uint16_t immediate, int wr) {
    return emit1s(c, op, s, (int32_t) immediate, wr);
}

static int32_t emit2s(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int32_t rest, int wr) {
    int32_t reg1 = janetc_regnear(c, s1, JANETC_REGTEMP_0);
    int32_t reg2 = janetc_regnear(c, s2, JANETC_REGTEMP_1);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg1 << 8) | (reg2 << 16) | ((uint32_t)rest << 24));
    janetc_free_regnear(c, s2, reg2, JANETC_REGTEMP_1);
    if (wr)
        janetc_moveback(c, s1, reg1);
    janetc_free_regnear(c, s1, reg1, JANETC_REGTEMP_0);
    return label;
}

int32_t janetc_emit_ss(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int wr) {
    int32_t reg1 = janetc_regnear(c, s1, JANETC_REGTEMP_0);
    int32_t reg2 = janetc_regfar(c, s2, JANETC_REGTEMP_1);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg1 << 8) | (reg2 << 16));
    janetc_free_regnear(c, s2, reg2, JANETC_REGTEMP_1);
    if (wr)
        janetc_moveback(c, s1, reg1);
    janetc_free_regnear(c, s1, reg1, JANETC_REGTEMP_0);
    return label;
}

int32_t janetc_emit_ssi(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int8_t immediate, int wr) {
    return emit2s(c, op, s1, s2, immediate, wr);
}

int32_t janetc_emit_ssu(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, uint8_t immediate, int wr) {
    return emit2s(c, op, s1, s2, (int32_t) immediate, wr);
}

int32_t janetc_emit_sss(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, JanetSlot s3, int wr) {
    int32_t reg1 = janetc_regnear(c, s1, JANETC_REGTEMP_0);
    int32_t reg2 = janetc_regnear(c, s2, JANETC_REGTEMP_1);
    int32_t reg3 = janetc_regnear(c, s3, JANETC_REGTEMP_2);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg1 << 8) | (reg2 << 16) | ((uint32_t)reg3 << 24));
    janetc_free_regnear(c, s2, reg2, JANETC_REGTEMP_1);
    janetc_free_regnear(c, s3, reg3, JANETC_REGTEMP_2);
    if (wr)
        janetc_moveback(c, s1, reg1);
    janetc_free_regnear(c, s1, reg1, JANETC_REGTEMP_0);
    return label;
}


/* src/core/ev.c */
#line 0 "src/core/ev.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/


#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#include "gc.h"
#include "state.h"
#include "fiber.h"
#endif

#ifdef JANET_EV

#include <math.h>
#ifdef JANET_WINDOWS
#include <winsock2.h>
#include <windows.h>
#else
#include <pthread.h>
#include <limits.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/wait.h>
#ifdef JANET_EV_EPOLL
#include <sys/epoll.h>
#include <sys/timerfd.h>
#endif
#ifdef JANET_EV_KQUEUE
#include <sys/event.h>
#endif
#endif

typedef struct {
    JanetVM *thread;
    JanetFiber *fiber;
    uint32_t sched_id;
    enum {
        JANET_CP_MODE_READ,
        JANET_CP_MODE_WRITE,
        JANET_CP_MODE_CHOICE_READ,
        JANET_CP_MODE_CHOICE_WRITE,
        JANET_CP_MODE_CLOSE
    } mode;
} JanetChannelPending;

typedef struct {
    JanetQueue items;
    JanetQueue read_pending;
    JanetQueue write_pending;
    int32_t limit;
    int closed;
    int is_threaded;
#ifdef JANET_WINDOWS
    CRITICAL_SECTION lock;
#else
    pthread_mutex_t lock;
#endif
} JanetChannel;

typedef struct {
    JanetFiber *fiber;
    Janet value;
    JanetSignal sig;
    uint32_t expected_sched_id; /* If the fiber has been rescheduled this loop, don't run first scheduling. */
} JanetTask;

/* Wrap return value by pairing it with the callback used to handle it
 * in the main thread */
typedef struct {
    JanetEVGenericMessage msg;
    JanetThreadedCallback cb;
} JanetSelfPipeEvent;

/* Structure used to initialize threads in the thread pool
 * (same head structure as self pipe event)*/
typedef struct {
    JanetEVGenericMessage msg;
    JanetThreadedCallback cb;
    JanetThreadedSubroutine subr;
    JanetHandle write_pipe;
} JanetEVThreadInit;

#define JANET_MAX_Q_CAPACITY 0x7FFFFFF

static void janet_q_init(JanetQueue *q) {
    q->data = NULL;
    q->head = 0;
    q->tail = 0;
    q->capacity = 0;
}

static void janet_q_deinit(JanetQueue *q) {
    janet_free(q->data);
}

static int32_t janet_q_count(JanetQueue *q) {
    return (q->head > q->tail)
           ? (q->tail + q->capacity - q->head)
           : (q->tail - q->head);
}

static int janet_q_push(JanetQueue *q, void *item, size_t itemsize) {
    int32_t count = janet_q_count(q);
    /* Resize if needed */
    if (count + 1 >= q->capacity) {
        if (count + 1 >= JANET_MAX_Q_CAPACITY) return 1;
        int32_t newcap = (count + 2) * 2;
        if (newcap > JANET_MAX_Q_CAPACITY) newcap = JANET_MAX_Q_CAPACITY;
        q->data = janet_realloc(q->data, itemsize * newcap);
        if (NULL == q->data) {
            JANET_OUT_OF_MEMORY;
        }
        if (q->head > q->tail) {
            /* Two segments, fix 2nd seg. */
            int32_t newhead = q->head + (newcap - q->capacity);
            size_t seg1 = (size_t)(q->capacity - q->head);
            if (seg1 > 0) {
                memmove((char *) q->data + (newhead * itemsize),
                        (char *) q->data + (q->head * itemsize),
                        seg1 * itemsize);
            }
            q->head = newhead;
        }
        q->capacity = newcap;
    }
    memcpy((char *) q->data + itemsize * q->tail, item, itemsize);
    q->tail = q->tail + 1 < q->capacity ? q->tail + 1 : 0;
    return 0;
}

static int janet_q_pop(JanetQueue *q, void *out, size_t itemsize) {
    if (q->head == q->tail) return 1;
    memcpy(out, (char *) q->data + itemsize * q->head, itemsize);
    q->head = q->head + 1 < q->capacity ? q->head + 1 : 0;
    return 0;
}

/* Forward declaration */
static void janet_unlisten(JanetListenerState *state, int is_gc);

/* Get current timestamp (millisecond precision) */
static JanetTimestamp ts_now(void);

/* Get current timestamp + an interval (millisecond precision) */
static JanetTimestamp ts_delta(JanetTimestamp ts, double delta) {
    ts += (int64_t)round(delta * 1000);
    return ts;
}

/* Look at the next timeout value without
 * removing it. */
static int peek_timeout(JanetTimeout *out) {
    if (janet_vm.tq_count == 0) return 0;
    *out = janet_vm.tq[0];
    return 1;
}

/* Remove the next timeout from the priority queue */
static void pop_timeout(size_t index) {
    if (janet_vm.tq_count <= index) return;
    janet_vm.tq[index] = janet_vm.tq[--janet_vm.tq_count];
    for (;;) {
        size_t left = (index << 1) + 1;
        size_t right = left + 1;
        size_t smallest = index;
        if (left < janet_vm.tq_count &&
                (janet_vm.tq[left].when < janet_vm.tq[smallest].when))
            smallest = left;
        if (right < janet_vm.tq_count &&
                (janet_vm.tq[right].when < janet_vm.tq[smallest].when))
            smallest = right;
        if (smallest == index) return;
        JanetTimeout temp = janet_vm.tq[index];
        janet_vm.tq[index] = janet_vm.tq[smallest];
        janet_vm.tq[smallest] = temp;
        index = smallest;
    }
}

/* Add a timeout to the timeout min heap */
static void add_timeout(JanetTimeout to) {
    size_t oldcount = janet_vm.tq_count;
    size_t newcount = oldcount + 1;
    if (newcount > janet_vm.tq_capacity) {
        size_t newcap = 2 * newcount;
        JanetTimeout *tq = janet_realloc(janet_vm.tq, newcap * sizeof(JanetTimeout));
        if (NULL == tq) {
            JANET_OUT_OF_MEMORY;
        }
        janet_vm.tq = tq;
        janet_vm.tq_capacity = newcap;
    }
    /* Append */
    janet_vm.tq_count = (int32_t) newcount;
    janet_vm.tq[oldcount] = to;
    /* Heapify */
    size_t index = oldcount;
    while (index > 0) {
        size_t parent = (index - 1) >> 1;
        if (janet_vm.tq[parent].when <= janet_vm.tq[index].when) break;
        /* Swap */
        JanetTimeout tmp = janet_vm.tq[index];
        janet_vm.tq[index] = janet_vm.tq[parent];
        janet_vm.tq[parent] = tmp;
        /* Next */
        index = parent;
    }
}

/* Create a new event listener */
static JanetListenerState *janet_listen_impl(JanetStream *stream, JanetListener behavior, int mask, size_t size, void *user) {
    if (stream->flags & JANET_STREAM_CLOSED) {
        janet_panic("cannot listen on closed stream");
    }
    if (stream->_mask & mask) {
        janet_panic("cannot listen for duplicate event on stream");
    }
    if (janet_vm.root_fiber->waiting != NULL) {
        janet_panic("current fiber is already waiting for event");
    }
    if (size < sizeof(JanetListenerState))
        size = sizeof(JanetListenerState);
    JanetListenerState *state = janet_malloc(size);
    if (NULL == state) {
        JANET_OUT_OF_MEMORY;
    }
    state->machine = behavior;
    state->fiber = janet_vm.root_fiber;
    janet_vm.root_fiber->waiting = state;
    state->stream = stream;
    state->_mask = mask;
    stream->_mask |= mask;
    state->_next = stream->state;
    stream->state = state;

    /* Keep track of a listener for GC purposes */
    int resize = janet_vm.listener_cap == janet_vm.listener_count;
    if (resize) {
        size_t newcap = janet_vm.listener_count ? janet_vm.listener_cap * 2 : 16;
        janet_vm.listeners = janet_realloc(janet_vm.listeners, newcap * sizeof(JanetListenerState *));
        if (NULL == janet_vm.listeners) {
            JANET_OUT_OF_MEMORY;
        }
        janet_vm.listener_cap = newcap;
    }
    size_t index = janet_vm.listener_count++;
    janet_vm.listeners[index] = state;
    state->_index = index;

    /* Emit INIT event for convenience */
    state->event = user;
    state->machine(state, JANET_ASYNC_EVENT_INIT);
    return state;
}

/* Indicate we are no longer listening for an event. This
 * frees the memory of the state machine as well. */
static void janet_unlisten_impl(JanetListenerState *state, int is_gc) {
    state->machine(state, JANET_ASYNC_EVENT_DEINIT);
    /* Remove state machine from poll list */
    JanetListenerState **iter = &(state->stream->state);
    while (*iter && *iter != state)
        iter = &((*iter)->_next);
    janet_assert(*iter, "failed to remove listener");
    *iter = state->_next;
    /* Remove mask */
    state->stream->_mask &= ~(state->_mask);
    /* Ensure fiber does not reference this state */
    if (!is_gc) {
        JanetFiber *fiber = state->fiber;
        if (NULL != fiber && fiber->waiting == state) {
            fiber->waiting = NULL;
        }
    }
    /* Untrack a listener for gc purposes */
    size_t index = state->_index;
    janet_vm.listeners[index] = janet_vm.listeners[--janet_vm.listener_count];
    janet_vm.listeners[index]->_index = index;
    janet_free(state);
}

static const JanetMethod ev_default_stream_methods[] = {
    {"close", janet_cfun_stream_close},
    {"read", janet_cfun_stream_read},
    {"chunk", janet_cfun_stream_chunk},
    {"write", janet_cfun_stream_write},
    {NULL, NULL}
};

/* Create a stream*/
JanetStream *janet_stream(JanetHandle handle, uint32_t flags, const JanetMethod *methods) {
    JanetStream *stream = janet_abstract(&janet_stream_type, sizeof(JanetStream));
    stream->handle = handle;
    stream->flags = flags;
    stream->state = NULL;
    stream->_mask = 0;
    if (methods == NULL) methods = ev_default_stream_methods;
    stream->methods = methods;
    return stream;
}

/* Close a stream */
static void janet_stream_close_impl(JanetStream *stream, int is_gc) {
    if (stream->flags & JANET_STREAM_CLOSED) return;
    JanetListenerState *state = stream->state;
    while (NULL != state) {
        if (!is_gc) {
            state->machine(state, JANET_ASYNC_EVENT_CLOSE);
        }
        JanetListenerState *next_state = state->_next;
        janet_unlisten(state, is_gc);
        state = next_state;
    }
    stream->state = NULL;
    stream->flags |= JANET_STREAM_CLOSED;
#ifdef JANET_WINDOWS
#ifdef JANET_NET
    if (stream->flags & JANET_STREAM_SOCKET) {
        closesocket((SOCKET) stream->handle);
    } else
#endif
    {
        CloseHandle(stream->handle);
    }
    stream->handle = INVALID_HANDLE_VALUE;
#else
    close(stream->handle);
    stream->handle = -1;
#endif
}

void janet_stream_close(JanetStream *stream) {
    janet_stream_close_impl(stream, 0);
}


/* Called to clean up a stream */
static int janet_stream_gc(void *p, size_t s) {
    (void) s;
    JanetStream *stream = (JanetStream *)p;
    janet_stream_close_impl(stream, 1);
    return 0;
}

/* Mark a stream for GC */
static int janet_stream_mark(void *p, size_t s) {
    (void) s;
    JanetStream *stream = (JanetStream *) p;
    JanetListenerState *state = stream->state;
    while (NULL != state) {
        if (NULL != state->fiber) {
            janet_mark(janet_wrap_fiber(state->fiber));
        }
        (state->machine)(state, JANET_ASYNC_EVENT_MARK);
        state = state->_next;
    }
    return 0;
}

static int janet_stream_getter(void *p, Janet key, Janet *out) {
    JanetStream *stream = (JanetStream *)p;
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    const JanetMethod *stream_methods = stream->methods;
    return janet_getmethod(janet_unwrap_keyword(key), stream_methods, out);
}

static void janet_stream_marshal(void *p, JanetMarshalContext *ctx) {
    JanetStream *s = p;
    if (!(ctx->flags & JANET_MARSHAL_UNSAFE)) {
        janet_panic("can only marshal stream with unsafe flag");
    }
    janet_marshal_abstract(ctx, p);
    janet_marshal_int(ctx, (int32_t) s->flags);
    janet_marshal_int64(ctx, (intptr_t) s->methods);
#ifdef JANET_WINDOWS
    /* TODO - ref counting to avoid situation where a handle is closed or GCed
     * while in transit, and it's value gets reused. DuplicateHandle does not work
     * for network sockets, and in general for winsock it is better to nipt duplicate
     * unless there is a need to. */
    HANDLE duph = INVALID_HANDLE_VALUE;
    if (s->flags & JANET_STREAM_SOCKET) {
        duph = s->handle;
    } else {
        DuplicateHandle(
            GetCurrentProcess(),
            s->handle,
            GetCurrentProcess(),
            &duph,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);
    }
    janet_marshal_int64(ctx, (int64_t)(duph));
#else
    /* Marshal after dup becuse it is easier than maintaining our own ref counting. */
    int duph = dup(s->handle);
    if (duph < 0) janet_panicf("failed to duplicate stream handle: %V", janet_ev_lasterr());
    janet_marshal_int(ctx, (int32_t)(duph));
#endif
}

static void *janet_stream_unmarshal(JanetMarshalContext *ctx) {
    if (!(ctx->flags & JANET_MARSHAL_UNSAFE)) {
        janet_panic("can only unmarshal stream with unsafe flag");
    }
    JanetStream *p = janet_unmarshal_abstract(ctx, sizeof(JanetStream));
    /* Can't share listening state and such across threads */
    p->_mask = 0;
    p->state = NULL;
    p->flags = (uint32_t) janet_unmarshal_int(ctx);
    p->methods = (void *) janet_unmarshal_int64(ctx);
#ifdef JANET_WINDOWS
    p->handle = (JanetHandle) janet_unmarshal_int64(ctx);
#else
    p->handle = (JanetHandle) janet_unmarshal_int(ctx);
#endif
    return p;
}

static Janet janet_stream_next(void *p, Janet key) {
    JanetStream *stream = (JanetStream *)p;
    return janet_nextmethod(stream->methods, key);
}

const JanetAbstractType janet_stream_type = {
    "core/stream",
    janet_stream_gc,
    janet_stream_mark,
    janet_stream_getter,
    NULL,
    janet_stream_marshal,
    janet_stream_unmarshal,
    NULL,
    NULL,
    NULL,
    janet_stream_next,
    JANET_ATEND_NEXT
};

/* Register a fiber to resume with value */
void janet_schedule_signal(JanetFiber *fiber, Janet value, JanetSignal sig) {
    if (fiber->gc.flags & JANET_FIBER_EV_FLAG_CANCELED) return;
    fiber->gc.flags |= JANET_FIBER_FLAG_ROOT;
    JanetTask t = { fiber, value, sig, ++fiber->sched_id };
    if (sig == JANET_SIGNAL_ERROR) fiber->gc.flags |= JANET_FIBER_EV_FLAG_CANCELED;
    janet_q_push(&janet_vm.spawn, &t, sizeof(t));
}

void janet_cancel(JanetFiber *fiber, Janet value) {
    janet_schedule_signal(fiber, value, JANET_SIGNAL_ERROR);
}

void janet_schedule(JanetFiber *fiber, Janet value) {
    janet_schedule_signal(fiber, value, JANET_SIGNAL_OK);
}

void janet_fiber_did_resume(JanetFiber *fiber) {
    /* Cancel any pending fibers */
    if (fiber->waiting) {
        fiber->waiting->machine(fiber->waiting, JANET_ASYNC_EVENT_CANCEL);
        janet_unlisten(fiber->waiting, 0);
    }
}

/* Mark all pending tasks */
void janet_ev_mark(void) {

    /* Pending tasks */
    JanetTask *tasks = janet_vm.spawn.data;
    if (janet_vm.spawn.head <= janet_vm.spawn.tail) {
        for (int32_t i = janet_vm.spawn.head; i < janet_vm.spawn.tail; i++) {
            janet_mark(janet_wrap_fiber(tasks[i].fiber));
            janet_mark(tasks[i].value);
        }
    } else {
        for (int32_t i = janet_vm.spawn.head; i < janet_vm.spawn.capacity; i++) {
            janet_mark(janet_wrap_fiber(tasks[i].fiber));
            janet_mark(tasks[i].value);
        }
        for (int32_t i = 0; i < janet_vm.spawn.tail; i++) {
            janet_mark(janet_wrap_fiber(tasks[i].fiber));
            janet_mark(tasks[i].value);
        }
    }

    /* Pending timeouts */
    for (size_t i = 0; i < janet_vm.tq_count; i++) {
        janet_mark(janet_wrap_fiber(janet_vm.tq[i].fiber));
        if (janet_vm.tq[i].curr_fiber != NULL) {
            janet_mark(janet_wrap_fiber(janet_vm.tq[i].curr_fiber));
        }
    }

    /* Pending listeners */
    for (size_t i = 0; i < janet_vm.listener_count; i++) {
        JanetListenerState *state = janet_vm.listeners[i];
        if (NULL != state->fiber) {
            janet_mark(janet_wrap_fiber(state->fiber));
        }
        janet_stream_mark(state->stream, sizeof(JanetStream));
        (state->machine)(state, JANET_ASYNC_EVENT_MARK);
    }
}

static int janet_channel_push(JanetChannel *channel, Janet x, int mode);
static int janet_channel_pop(JanetChannel *channel, Janet *item, int is_choice);

static Janet make_supervisor_event(const char *name, JanetFiber *fiber, int threaded) {
    Janet tup[3];
    tup[0] = janet_ckeywordv(name);
    tup[1] = threaded ? fiber->last_value : janet_wrap_fiber(fiber) ;
    if (fiber->env != NULL) {
        tup[2] = janet_table_get(fiber->env, janet_ckeywordv("task-id"));
    } else {
        tup[2] = janet_wrap_nil();
    }
    return janet_wrap_tuple(janet_tuple_n(tup, 3));
}

/* Common init code */
void janet_ev_init_common(void) {
    janet_q_init(&janet_vm.spawn);
    janet_vm.listener_count = 0;
    janet_vm.listener_cap = 0;
    janet_vm.listeners = NULL;
    janet_vm.tq = NULL;
    janet_vm.tq_count = 0;
    janet_vm.tq_capacity = 0;
    janet_table_init_raw(&janet_vm.threaded_abstracts, 0);
    janet_rng_seed(&janet_vm.ev_rng, 0);
#ifndef JANET_WINDOWS
    pthread_attr_init(&janet_vm.new_thread_attr);
    pthread_attr_setdetachstate(&janet_vm.new_thread_attr, PTHREAD_CREATE_DETACHED);
#endif
}

/* Common deinit code */
void janet_ev_deinit_common(void) {
    janet_q_deinit(&janet_vm.spawn);
    janet_free(janet_vm.tq);
    janet_free(janet_vm.listeners);
    janet_vm.listeners = NULL;
    janet_table_deinit(&janet_vm.threaded_abstracts);
#ifndef JANET_WINDOWS
    pthread_attr_destroy(&janet_vm.new_thread_attr);
#endif
}

/* Short hand to yield to event loop */
void janet_await(void) {
    janet_signalv(JANET_SIGNAL_EVENT, janet_wrap_nil());
}

/* Set timeout for the current root fiber */
void janet_addtimeout(double sec) {
    JanetFiber *fiber = janet_vm.root_fiber;
    JanetTimeout to;
    to.when = ts_delta(ts_now(), sec);
    to.fiber = fiber;
    to.curr_fiber = NULL;
    to.sched_id = fiber->sched_id;
    to.is_error = 1;
    add_timeout(to);
}

void janet_ev_inc_refcount(void) {
    janet_vm.extra_listeners++;
}

void janet_ev_dec_refcount(void) {
    janet_vm.extra_listeners--;
}

/* Channels */

#define JANET_MAX_CHANNEL_CAPACITY 0xFFFFFF

static inline int janet_chan_is_threaded(JanetChannel *chan) {
    return chan->is_threaded;
}

static int janet_chan_pack(JanetChannel *chan, Janet *x) {
    if (!janet_chan_is_threaded(chan)) return 0;
    switch (janet_type(*x)) {
        default: {
            JanetBuffer *buf = janet_malloc(sizeof(JanetBuffer));
            if (NULL == buf) {
                JANET_OUT_OF_MEMORY;
            }
            janet_buffer_init(buf, 10);
            janet_marshal(buf, *x, NULL, JANET_MARSHAL_UNSAFE);
            *x = janet_wrap_buffer(buf);
            return 0;
        }
        case JANET_NIL:
        case JANET_NUMBER:
        case JANET_POINTER:
        case JANET_BOOLEAN:
        case JANET_CFUNCTION:
            return 0;
    }
}

static int janet_chan_unpack(JanetChannel *chan, Janet *x, int is_cleanup) {
    if (!janet_chan_is_threaded(chan)) return 0;
    switch (janet_type(*x)) {
        default:
            return 1;
        case JANET_BUFFER: {
            JanetBuffer *buf = janet_unwrap_buffer(*x);
            int flags = is_cleanup ? (JANET_MARSHAL_UNSAFE | JANET_MARSHAL_DECREF) : JANET_MARSHAL_UNSAFE;
            *x = janet_unmarshal(buf->data, buf->count, flags, NULL, NULL);
            janet_buffer_deinit(buf);
            janet_free(buf);
            return 0;
        }
        case JANET_NIL:
        case JANET_NUMBER:
        case JANET_POINTER:
        case JANET_BOOLEAN:
        case JANET_CFUNCTION:
            return 0;
    }
}

static void janet_chan_init(JanetChannel *chan, int32_t limit, int threaded) {
    chan->limit = limit;
    chan->closed = 0;
    chan->is_threaded = threaded;
    janet_q_init(&chan->items);
    janet_q_init(&chan->read_pending);
    janet_q_init(&chan->write_pending);
    janet_os_mutex_init((JanetOSMutex *) &chan->lock);
}

static void janet_chan_deinit(JanetChannel *chan) {
    janet_q_deinit(&chan->read_pending);
    janet_q_deinit(&chan->write_pending);
    if (janet_chan_is_threaded(chan)) {
        Janet item;
        while (!janet_q_pop(&chan->items, &item, sizeof(item))) {
            janet_chan_unpack(chan, &item, 1);
        }
    }
    janet_q_deinit(&chan->items);
    janet_os_mutex_deinit((JanetOSMutex *) &chan->lock);
}

static void janet_chan_lock(JanetChannel *chan) {
    if (!janet_chan_is_threaded(chan)) return;
    janet_os_mutex_lock((JanetOSMutex *) &chan->lock);
}

static void janet_chan_unlock(JanetChannel *chan) {
    if (!janet_chan_is_threaded(chan)) return;
    janet_os_mutex_unlock((JanetOSMutex *) &chan->lock);
}

/*
 * Janet Channel abstract type
 */

static Janet janet_wrap_channel(JanetChannel *channel) {
    return janet_wrap_abstract(channel);
}

static int janet_chanat_gc(void *p, size_t s) {
    (void) s;
    JanetChannel *channel = p;
    janet_chan_deinit(channel);
    return 0;
}

static void janet_chanat_mark_fq(JanetQueue *fq) {
    JanetChannelPending *pending = fq->data;
    if (fq->head <= fq->tail) {
        for (int32_t i = fq->head; i < fq->tail; i++)
            janet_mark(janet_wrap_fiber(pending[i].fiber));
    } else {
        for (int32_t i = fq->head; i < fq->capacity; i++)
            janet_mark(janet_wrap_fiber(pending[i].fiber));
        for (int32_t i = 0; i < fq->tail; i++)
            janet_mark(janet_wrap_fiber(pending[i].fiber));
    }
}

static int janet_chanat_mark(void *p, size_t s) {
    (void) s;
    JanetChannel *chan = p;
    janet_chanat_mark_fq(&chan->read_pending);
    janet_chanat_mark_fq(&chan->write_pending);
    JanetQueue *items = &chan->items;
    Janet *data = chan->items.data;
    if (items->head <= items->tail) {
        for (int32_t i = items->head; i < items->tail; i++)
            janet_mark(data[i]);
    } else {
        for (int32_t i = items->head; i < items->capacity; i++)
            janet_mark(data[i]);
        for (int32_t i = 0; i < items->tail; i++)
            janet_mark(data[i]);
    }
    return 0;
}

static Janet make_write_result(JanetChannel *channel) {
    Janet *tup = janet_tuple_begin(2);
    tup[0] = janet_ckeywordv("give");
    tup[1] = janet_wrap_channel(channel);
    return janet_wrap_tuple(janet_tuple_end(tup));
}

static Janet make_read_result(JanetChannel *channel, Janet x) {
    Janet *tup = janet_tuple_begin(3);
    tup[0] = janet_ckeywordv("take");
    tup[1] = janet_wrap_channel(channel);
    tup[2] = x;
    return janet_wrap_tuple(janet_tuple_end(tup));
}

static Janet make_close_result(JanetChannel *channel) {
    Janet *tup = janet_tuple_begin(2);
    tup[0] = janet_ckeywordv("close");
    tup[1] = janet_wrap_channel(channel);
    return janet_wrap_tuple(janet_tuple_end(tup));
}

/* Callback to use for scheduling a fiber from another thread. */
static void janet_thread_chan_cb(JanetEVGenericMessage msg) {
    uint32_t sched_id = (uint32_t) msg.argi;
    JanetFiber *fiber = msg.fiber;
    int mode = msg.tag;
    JanetChannel *channel = (JanetChannel *) msg.argp;
    Janet x = msg.argj;
    if (fiber->sched_id == sched_id) {
        if (mode == JANET_CP_MODE_CHOICE_READ) {
            janet_assert(!janet_chan_unpack(channel, &x, 0), "packing error");
            janet_schedule(fiber, make_read_result(channel, x));
        } else if (mode == JANET_CP_MODE_CHOICE_WRITE) {
            janet_schedule(fiber, make_write_result(channel));
        } else if (mode == JANET_CP_MODE_READ) {
            janet_assert(!janet_chan_unpack(channel, &x, 0), "packing error");
            janet_schedule(fiber, x);
        } else if (mode == JANET_CP_MODE_WRITE) {
            janet_schedule(fiber, janet_wrap_channel(channel));
        } else { /* (mode == JANET_CP_MODE_CLOSE) */
            janet_schedule(fiber, janet_wrap_nil());
        }
    } else if (mode != JANET_CP_MODE_CLOSE) {
        /* Fiber has already been cancelled or resumed. */
        /* Resend event to another waiting thread, depending on mode */
        int is_read = (mode == JANET_CP_MODE_CHOICE_READ) || (mode == JANET_CP_MODE_READ);
        if (is_read) {
            JanetChannelPending reader;
            janet_chan_lock(channel);
            if (!janet_q_pop(&channel->read_pending, &reader, sizeof(reader))) {
                JanetVM *vm = reader.thread;
                JanetEVGenericMessage msg;
                msg.tag = reader.mode;
                msg.fiber = reader.fiber;
                msg.argi = (int32_t) reader.sched_id;
                msg.argp = channel;
                msg.argj = x;
                janet_ev_post_event(vm, janet_thread_chan_cb, msg);
            }
            janet_chan_unlock(channel);
        } else {
            JanetChannelPending writer;
            janet_chan_lock(channel);
            if (!janet_q_pop(&channel->write_pending, &writer, sizeof(writer))) {
                JanetVM *vm = writer.thread;
                JanetEVGenericMessage msg;
                msg.tag = writer.mode;
                msg.fiber = writer.fiber;
                msg.argi = (int32_t) writer.sched_id;
                msg.argp = channel;
                msg.argj = janet_wrap_nil();
                janet_ev_post_event(vm, janet_thread_chan_cb, msg);
            }
            janet_chan_unlock(channel);
        }
    }
}

/* Push a value to a channel, and return 1 if channel should block, zero otherwise.
 * If the push would block, will add to the write_pending queue in the channel.
 * Handles both threaded and unthreaded channels. */
static int janet_channel_push(JanetChannel *channel, Janet x, int mode) {
    JanetChannelPending reader;
    int is_empty;
    if (janet_chan_pack(channel, &x)) {
        janet_panicf("failed to pack value for channel: %v", x);
    }
    janet_chan_lock(channel);
    if (channel->closed) {
        janet_chan_unlock(channel);
        janet_panic("cannot write to closed channel");
    }
    int is_threaded = janet_chan_is_threaded(channel);
    if (is_threaded) {
        /* don't dereference fiber from another thread */
        is_empty = janet_q_pop(&channel->read_pending, &reader, sizeof(reader));
    } else {
        do {
            is_empty = janet_q_pop(&channel->read_pending, &reader, sizeof(reader));
        } while (!is_empty && (reader.sched_id != reader.fiber->sched_id));
    }
    if (is_empty) {
        /* No pending reader */
        if (janet_q_push(&channel->items, &x, sizeof(Janet))) {
            janet_chan_unlock(channel);
            janet_panicf("channel overflow: %v", x);
        } else if (janet_q_count(&channel->items) > channel->limit) {
            /* No root fiber, we are in completion on a root fiber. Don't block. */
            if (mode == 2) {
                janet_chan_unlock(channel);
                return 0;
            }
            /* Pushed successfully, but should block. */
            JanetChannelPending pending;
            pending.thread = &janet_vm;
            pending.fiber = janet_vm.root_fiber,
            pending.sched_id = janet_vm.root_fiber->sched_id,
            pending.mode = mode ? JANET_CP_MODE_CHOICE_WRITE : JANET_CP_MODE_WRITE;
            janet_q_push(&channel->write_pending, &pending, sizeof(pending));
            janet_chan_unlock(channel);
            if (is_threaded) {
                janet_gcroot(janet_wrap_fiber(pending.fiber));
            }
            return 1;
        }
    } else {
        /* Pending reader */
        if (is_threaded) {
            JanetVM *vm = reader.thread;
            JanetEVGenericMessage msg;
            msg.tag = reader.mode;
            msg.fiber = reader.fiber;
            msg.argi = (int32_t) reader.sched_id;
            msg.argp = channel;
            msg.argj = x;
            janet_ev_post_event(vm, janet_thread_chan_cb, msg);
        } else {
            if (reader.mode == JANET_CP_MODE_CHOICE_READ) {
                janet_schedule(reader.fiber, make_read_result(channel, x));
            } else {
                janet_schedule(reader.fiber, x);
            }
        }
    }
    janet_chan_unlock(channel);
    return 0;
}

/* Pop from a channel - returns 1 if item was obtained, 0 otherwise. The item
 * is returned by reference. If the pop would block, will add to the read_pending
 * queue in the channel. */
static int janet_channel_pop(JanetChannel *channel, Janet *item, int is_choice) {
    JanetChannelPending writer;
    janet_chan_lock(channel);
    if (channel->closed) {
        janet_chan_unlock(channel);
        *item = janet_wrap_nil();
        return 1;
    }
    int is_threaded = janet_chan_is_threaded(channel);
    if (janet_q_pop(&channel->items, item, sizeof(Janet))) {
        /* Queue empty */
        JanetChannelPending pending;
        pending.thread = &janet_vm;
        pending.fiber = janet_vm.root_fiber,
        pending.sched_id = janet_vm.root_fiber->sched_id;
        pending.mode = is_choice ? JANET_CP_MODE_CHOICE_READ : JANET_CP_MODE_READ;
        janet_q_push(&channel->read_pending, &pending, sizeof(pending));
        janet_chan_unlock(channel);
        if (is_threaded) {
            janet_gcroot(janet_wrap_fiber(pending.fiber));
        }
        return 0;
    }
    janet_assert(!janet_chan_unpack(channel, item, 0), "bad channel packing");
    if (!janet_q_pop(&channel->write_pending, &writer, sizeof(writer))) {
        /* Pending writer */
        if (is_threaded) {
            JanetVM *vm = writer.thread;
            JanetEVGenericMessage msg;
            msg.tag = writer.mode;
            msg.fiber = writer.fiber;
            msg.argi = (int32_t) writer.sched_id;
            msg.argp = channel;
            msg.argj = janet_wrap_nil();
            janet_ev_post_event(vm, janet_thread_chan_cb, msg);
        } else {
            if (writer.mode == JANET_CP_MODE_CHOICE_WRITE) {
                janet_schedule(writer.fiber, make_write_result(channel));
            } else {
                janet_schedule(writer.fiber, janet_wrap_abstract(channel));
            }
        }
    }
    janet_chan_unlock(channel);
    return 1;
}

JanetChannel *janet_channel_unwrap(void *abstract) {
    return abstract;
}

JanetChannel *janet_getchannel(const Janet *argv, int32_t n) {
    return janet_channel_unwrap(janet_getabstract(argv, n, &janet_channel_type));
}

JanetChannel *janet_optchannel(const Janet *argv, int32_t argc, int32_t n, JanetChannel *dflt) {
    if (argc > n && !janet_checktype(argv[n], JANET_NIL)) {
        return janet_getchannel(argv, n);
    } else {
        return dflt;
    }
}

/* Channel Methods */

JANET_CORE_FN(cfun_channel_push,
              "(ev/give channel value)",
              "Write a value to a channel, suspending the current fiber if the channel is full. "
              "Returns the channel if the write succeeded, nil otherwise.") {
    janet_fixarity(argc, 2);
    JanetChannel *channel = janet_getchannel(argv, 0);
    if (janet_channel_push(channel, argv[1], 0)) {
        janet_await();
    }
    return argv[0];
}

JANET_CORE_FN(cfun_channel_pop,
              "(ev/take channel)",
              "Read from a channel, suspending the current fiber if no value is available.") {
    janet_fixarity(argc, 1);
    JanetChannel *channel = janet_getchannel(argv, 0);
    Janet item;
    if (janet_channel_pop(channel, &item, 0)) {
        janet_schedule(janet_vm.root_fiber, item);
    }
    janet_await();
}

JANET_CORE_FN(cfun_channel_choice,
              "(ev/select & clauses)",
              "Block until the first of several channel operations occur. Returns a tuple of the form [:give chan], [:take chan x], or [:close chan], where "
              "a :give tuple is the result of a write and :take tuple is the result of a read. Each clause must be either a channel (for "
              "a channel take operation) or a tuple [channel x] for a channel give operation. Operations are tried in order, such that the first "
              "clauses will take precedence over later clauses. Both and give and take operations can return a [:close chan] tuple, which indicates that "
              "the specified channel was closed while waiting, or that the channel was already closed.") {
    janet_arity(argc, 1, -1);
    int32_t len;
    const Janet *data;

    /* Check channels for immediate reads and writes */
    for (int32_t i = 0; i < argc; i++) {
        if (janet_indexed_view(argv[i], &data, &len) && len == 2) {
            /* Write */
            JanetChannel *chan = janet_getchannel(data, 0);
            janet_chan_lock(chan);
            if (chan->closed) {
                janet_chan_unlock(chan);
                return make_close_result(chan);
            }
            if (janet_q_count(&chan->items) < chan->limit) {
                janet_chan_unlock(chan);
                janet_channel_push(chan, data[1], 1);
                return make_write_result(chan);
            }
            janet_chan_unlock(chan);
        } else {
            /* Read */
            JanetChannel *chan = janet_getchannel(argv, i);
            janet_chan_lock(chan);
            if (chan->closed) {
                janet_chan_unlock(chan);
                return make_close_result(chan);
            }
            if (chan->items.head != chan->items.tail) {
                Janet item;
                janet_chan_unlock(chan);
                janet_channel_pop(chan, &item, 1);
                return make_read_result(chan, item);
            }
            janet_chan_unlock(chan);
        }
    }

    /* Wait for all readers or writers */
    for (int32_t i = 0; i < argc; i++) {
        if (janet_indexed_view(argv[i], &data, &len) && len == 2) {
            /* Write */
            JanetChannel *chan = janet_getchannel(data, 0);
            janet_channel_push(chan, data[1], 1);
        } else {
            /* Read */
            Janet item;
            JanetChannel *chan = janet_getchannel(argv, i);
            janet_channel_pop(chan, &item, 1);
        }
    }

    janet_await();
}

JANET_CORE_FN(cfun_channel_full,
              "(ev/full channel)",
              "Check if a channel is full or not.") {
    janet_fixarity(argc, 1);
    JanetChannel *channel = janet_getchannel(argv, 0);
    janet_chan_lock(channel);
    Janet ret = janet_wrap_boolean(janet_q_count(&channel->items) >= channel->limit);
    janet_chan_unlock(channel);
    return ret;
}

JANET_CORE_FN(cfun_channel_capacity,
              "(ev/capacity channel)",
              "Get the number of items a channel will store before blocking writers.") {
    janet_fixarity(argc, 1);
    JanetChannel *channel = janet_getchannel(argv, 0);
    janet_chan_lock(channel);
    Janet ret = janet_wrap_integer(channel->limit);
    janet_chan_unlock(channel);
    return ret;
}

JANET_CORE_FN(cfun_channel_count,
              "(ev/count channel)",
              "Get the number of items currently waiting in a channel.") {
    janet_fixarity(argc, 1);
    JanetChannel *channel = janet_getchannel(argv, 0);
    janet_chan_lock(channel);
    Janet ret = janet_wrap_integer(janet_q_count(&channel->items));
    janet_chan_unlock(channel);
    return ret;
}

/* Fisher yates shuffle of arguments to get fairness */
static void fisher_yates_args(int32_t argc, Janet *argv) {
    for (int32_t i = argc; i > 1; i--) {
        int32_t swap_index = janet_rng_u32(&janet_vm.ev_rng) % i;
        Janet temp = argv[swap_index];
        argv[swap_index] = argv[i - 1];
        argv[i - 1] = temp;
    }
}

JANET_CORE_FN(cfun_channel_rchoice,
              "(ev/rselect & clauses)",
              "Similar to ev/select, but will try clauses in a random order for fairness.") {
    fisher_yates_args(argc, argv);
    return cfun_channel_choice(argc, argv);
}

JANET_CORE_FN(cfun_channel_new,
              "(ev/chan &opt capacity)",
              "Create a new channel. capacity is the number of values to queue before "
              "blocking writers, defaults to 0 if not provided. Returns a new channel.") {
    janet_arity(argc, 0, 1);
    int32_t limit = janet_optnat(argv, argc, 0, 0);
    JanetChannel *channel = janet_abstract(&janet_channel_type, sizeof(JanetChannel));
    janet_chan_init(channel, limit, 0);
    return janet_wrap_abstract(channel);
}

JANET_CORE_FN(cfun_channel_new_threaded,
              "(ev/thread-chan &opt limit)",
              "Create a threaded channel. A threaded channel is a channel that can be shared between threads and "
              "used to communicate between any number of operating system threads.") {
    janet_arity(argc, 0, 1);
    int32_t limit = janet_optnat(argv, argc, 0, 0);
    JanetChannel *tchan = janet_abstract_threaded(&janet_channel_type, sizeof(JanetChannel));
    janet_chan_init(tchan, limit, 1);
    return janet_wrap_abstract(tchan);
}

JANET_CORE_FN(cfun_channel_close,
              "(ev/chan-close chan)",
              "Close a channel. A closed channel will cause all pending reads and writes to return nil. "
              "Returns the channel.") {
    janet_fixarity(argc, 1);
    JanetChannel *channel = janet_getchannel(argv, 0);
    janet_chan_lock(channel);
    if (!channel->closed) {
        channel->closed = 1;
        JanetChannelPending writer;
        while (!janet_q_pop(&channel->write_pending, &writer, sizeof(writer))) {
            if (writer.thread != &janet_vm) {
                JanetVM *vm = writer.thread;
                JanetEVGenericMessage msg;
                msg.fiber = writer.fiber;
                msg.argp = channel;
                msg.tag = JANET_CP_MODE_CLOSE;
                msg.argi = (int32_t) writer.sched_id;
                msg.argj = janet_wrap_nil();
                janet_ev_post_event(vm, janet_thread_chan_cb, msg);
            } else {
                if (writer.mode == JANET_CP_MODE_CHOICE_WRITE) {
                    janet_schedule(writer.fiber, janet_wrap_nil());
                } else {
                    janet_schedule(writer.fiber, make_close_result(channel));
                }
            }
        }
        JanetChannelPending reader;
        while (!janet_q_pop(&channel->read_pending, &reader, sizeof(reader))) {
            if (reader.thread != &janet_vm) {
                JanetVM *vm = reader.thread;
                JanetEVGenericMessage msg;
                msg.fiber = reader.fiber;
                msg.argp = channel;
                msg.tag = JANET_CP_MODE_CLOSE;
                msg.argi = (int32_t) reader.sched_id;
                msg.argj = janet_wrap_nil();
                janet_ev_post_event(vm, janet_thread_chan_cb, msg);
            } else {
                if (reader.mode == JANET_CP_MODE_CHOICE_READ) {
                    janet_schedule(reader.fiber, janet_wrap_nil());
                } else {
                    janet_schedule(reader.fiber, make_close_result(channel));
                }
            }
        }
    }
    janet_chan_unlock(channel);
    return argv[0];
}

static const JanetMethod ev_chanat_methods[] = {
    {"select", cfun_channel_choice},
    {"rselect", cfun_channel_rchoice},
    {"count", cfun_channel_count},
    {"take", cfun_channel_pop},
    {"give", cfun_channel_push},
    {"capacity", cfun_channel_capacity},
    {"full", cfun_channel_full},
    {"close", cfun_channel_close},
    {NULL, NULL}
};

static int janet_chanat_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    return janet_getmethod(janet_unwrap_keyword(key), ev_chanat_methods, out);
}

static Janet janet_chanat_next(void *p, Janet key) {
    (void) p;
    return janet_nextmethod(ev_chanat_methods, key);
}

static void janet_chanat_marshal(void *p, JanetMarshalContext *ctx) {
    JanetChannel *channel = (JanetChannel *)p;
    janet_marshal_byte(ctx, channel->closed);
    janet_marshal_int(ctx, channel->limit);
    int32_t count = janet_q_count(&channel->items);
    janet_marshal_int(ctx, count);
    JanetQueue *items = &channel->items;
    Janet *data = channel->items.data;
    if (items->head <= items->tail) {
        for (int32_t i = items->head; i < items->tail; i++)
            janet_marshal_janet(ctx, data[i]);
    } else {
        for (int32_t i = items->head; i < items->capacity; i++)
            janet_marshal_janet(ctx, data[i]);
        for (int32_t i = 0; i < items->tail; i++)
            janet_marshal_janet(ctx, data[i]);
    }
}

static void *janet_chanat_unmarshal(JanetMarshalContext *ctx) {
    JanetChannel *abst = janet_unmarshal_abstract(ctx, sizeof(JanetChannel));
    uint8_t is_closed = janet_unmarshal_byte(ctx);
    int32_t limit = janet_unmarshal_int(ctx);
    int32_t count = janet_unmarshal_int(ctx);
    if (count < 0) janet_panic("invalid negative channel count");
    janet_chan_init(abst, limit, 0);
    abst->closed = !!is_closed;
    for (int32_t i = 0; i < count; i++) {
        Janet item = janet_unmarshal_janet(ctx);
        janet_q_push(&abst->items, &item, sizeof(item));
    }
    return abst;
}

const JanetAbstractType janet_channel_type = {
    "core/channel",
    janet_chanat_gc,
    janet_chanat_mark,
    janet_chanat_get,
    NULL, /* put */
    janet_chanat_marshal,
    janet_chanat_unmarshal,
    NULL, /* tostring */
    NULL, /* compare */
    NULL, /* hash */
    janet_chanat_next,
    JANET_ATEND_NEXT
};

/* Main event loop */

void janet_loop1_impl(int has_timeout, JanetTimestamp timeout);

int janet_loop_done(void) {
    return !(janet_vm.listener_count ||
             (janet_vm.spawn.head != janet_vm.spawn.tail) ||
             janet_vm.tq_count ||
             janet_vm.extra_listeners);
}

JanetFiber *janet_loop1(void) {
    /* Schedule expired timers */
    JanetTimeout to;
    JanetTimestamp now = ts_now();
    while (peek_timeout(&to) && to.when <= now) {
        pop_timeout(0);
        if (to.curr_fiber != NULL) {
            /* This is a deadline (for a fiber, not a function call) */
            JanetFiberStatus s = janet_fiber_status(to.curr_fiber);
            int isFinished = (s == JANET_STATUS_DEAD ||
                              s == JANET_STATUS_ERROR ||
                              s == JANET_STATUS_USER0 ||
                              s == JANET_STATUS_USER1 ||
                              s == JANET_STATUS_USER2 ||
                              s == JANET_STATUS_USER3 ||
                              s == JANET_STATUS_USER4);
            if (!isFinished) {
                janet_cancel(to.fiber, janet_cstringv("deadline expired"));
            }
        } else {
            /* This is a timeout (for a function call, not a whole fiber) */
            if (to.fiber->sched_id == to.sched_id) {
                if (to.is_error) {
                    janet_cancel(to.fiber, janet_cstringv("timeout"));
                } else {
                    janet_schedule(to.fiber, janet_wrap_nil());
                }
            }
        }
    }

    /* Run scheduled fibers */
    while (janet_vm.spawn.head != janet_vm.spawn.tail) {
        JanetTask task = {NULL, janet_wrap_nil(), JANET_SIGNAL_OK, 0};
        janet_q_pop(&janet_vm.spawn, &task, sizeof(task));
        if (task.fiber->gc.flags & JANET_FIBER_EV_FLAG_SUSPENDED) janet_ev_dec_refcount();
        task.fiber->gc.flags &= ~(JANET_FIBER_EV_FLAG_CANCELED | JANET_FIBER_EV_FLAG_SUSPENDED);
        if (task.expected_sched_id != task.fiber->sched_id) continue;
        Janet res;
        JanetSignal sig = janet_continue_signal(task.fiber, task.value, &res, task.sig);
        void *sv = task.fiber->supervisor_channel;
        int is_suspended = sig == JANET_SIGNAL_EVENT || sig == JANET_SIGNAL_YIELD || sig == JANET_SIGNAL_INTERRUPT;
        if (is_suspended) {
            task.fiber->gc.flags |= JANET_FIBER_EV_FLAG_SUSPENDED;
            janet_ev_inc_refcount();
        }
        if (NULL == sv) {
            if (!is_suspended) {
                janet_stacktrace_ext(task.fiber, res, "");
            }
        } else if (sig == JANET_SIGNAL_OK || (task.fiber->flags & (1 << sig))) {
            JanetChannel *chan = janet_channel_unwrap(sv);
            janet_channel_push(chan, make_supervisor_event(janet_signal_names[sig],
                               task.fiber, chan->is_threaded), 2);
        } else if (!is_suspended) {
            janet_stacktrace_ext(task.fiber, res, "");
        }
        if (sig == JANET_SIGNAL_INTERRUPT) {
            /* On interrupts, return the interrupted fiber immediately */
            return task.fiber;
        }
    }

    /* Poll for events */
    if (janet_vm.listener_count || janet_vm.tq_count || janet_vm.extra_listeners) {
        JanetTimeout to;
        memset(&to, 0, sizeof(to));
        int has_timeout;
        /* Drop timeouts that are no longer needed */
        while ((has_timeout = peek_timeout(&to))) {
            if (to.curr_fiber != NULL) {
                JanetFiberStatus s = janet_fiber_status(to.curr_fiber);
                int is_finished = (s == JANET_STATUS_DEAD ||
                                   s == JANET_STATUS_ERROR ||
                                   s == JANET_STATUS_USER0 ||
                                   s == JANET_STATUS_USER1 ||
                                   s == JANET_STATUS_USER2 ||
                                   s == JANET_STATUS_USER3 ||
                                   s == JANET_STATUS_USER4);
                if (is_finished) {
                    pop_timeout(0);
                    continue;
                }
            } else if (to.fiber->sched_id != to.sched_id) {
                pop_timeout(0);
                continue;
            }
            break;
        }
        /* Run polling implementation only if pending timeouts or pending events */
        if (janet_vm.tq_count || janet_vm.listener_count || janet_vm.extra_listeners) {
            janet_loop1_impl(has_timeout, to.when);
        }
    }

    /* No fiber was interrupted */
    return NULL;
}

/* Same as janet_interpreter_interrupt, but will also
 * break out of the event loop if waiting for an event
 * (say, waiting for ev/sleep to finish). Does this by pushing
 * an empty event to the event loop. */
void janet_loop1_interrupt(JanetVM *vm) {
    janet_interpreter_interrupt(vm);
    JanetEVGenericMessage msg = {0};
    JanetCallback cb = NULL;
    janet_ev_post_event(vm, cb, msg);
}

void janet_loop(void) {
    while (!janet_loop_done()) {
        JanetFiber *interrupted_fiber = janet_loop1();
        if (NULL != interrupted_fiber) {
            janet_schedule(interrupted_fiber, janet_wrap_nil());
        }
    }
}

/*
 * Self-pipe handling code.
 */

#ifdef JANET_WINDOWS

/* On windows, use PostQueuedCompletionStatus instead for
 * custom events */

#else

static void janet_ev_setup_selfpipe(void) {
    if (janet_make_pipe(janet_vm.selfpipe, 0)) {
        JANET_EXIT("failed to initialize self pipe in event loop");
    }
}

/* Handle events from the self pipe inside the event loop */
static void janet_ev_handle_selfpipe(void) {
    JanetSelfPipeEvent response;
    while (read(janet_vm.selfpipe[0], &response, sizeof(response)) > 0) {
        if (NULL != response.cb) {
            response.cb(response.msg);
        }
    }
}

static void janet_ev_cleanup_selfpipe(void) {
    close(janet_vm.selfpipe[0]);
    close(janet_vm.selfpipe[1]);
}

#endif

#ifdef JANET_WINDOWS

static JanetTimestamp ts_now(void) {
    return (JanetTimestamp) GetTickCount64();
}

void janet_ev_init(void) {
    janet_ev_init_common();
    janet_vm.iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
    if (NULL == janet_vm.iocp) janet_panic("could not create io completion port");
}

void janet_ev_deinit(void) {
    janet_ev_deinit_common();
    CloseHandle(janet_vm.iocp);
}

JanetListenerState *janet_listen(JanetStream *stream, JanetListener behavior, int mask, size_t size, void *user) {
    /* Add the handle to the io completion port if not already added */
    JanetListenerState *state = janet_listen_impl(stream, behavior, mask, size, user);
    if (!(stream->flags & JANET_STREAM_IOCP)) {
        if (NULL == CreateIoCompletionPort(stream->handle, janet_vm.iocp, (ULONG_PTR) stream, 0)) {
            janet_panicf("failed to listen for events: %V", janet_ev_lasterr());
        }
        stream->flags |= JANET_STREAM_IOCP;
    }
    return state;
}


static void janet_unlisten(JanetListenerState *state, int is_gc) {
    janet_unlisten_impl(state, is_gc);
}

void janet_loop1_impl(int has_timeout, JanetTimestamp to) {
    ULONG_PTR completionKey = 0;
    DWORD num_bytes_transfered = 0;
    LPOVERLAPPED overlapped = NULL;

    /* Calculate how long to wait before timeout */
    uint64_t waittime;
    if (has_timeout) {
        JanetTimestamp now = ts_now();
        if (now > to) {
            waittime = 0;
        } else {
            waittime = (uint64_t)(to - now);
        }
    } else {
        waittime = INFINITE;
    }
    BOOL result = GetQueuedCompletionStatus(janet_vm.iocp, &num_bytes_transfered, &completionKey, &overlapped, (DWORD) waittime);

    if (result || overlapped) {
        if (0 == completionKey) {
            /* Custom event */
            JanetSelfPipeEvent *response = (JanetSelfPipeEvent *)(overlapped);
            if (NULL != response->cb) {
                response->cb(response->msg);
            }
            janet_free(response);
        } else {
            /* Normal event */
            JanetStream *stream = (JanetStream *) completionKey;
            JanetListenerState *state = stream->state;
            while (state != NULL) {
                if (state->tag == overlapped) {
                    state->event = overlapped;
                    state->bytes = num_bytes_transfered;
                    JanetAsyncStatus status = state->machine(state, JANET_ASYNC_EVENT_COMPLETE);
                    if (status == JANET_ASYNC_STATUS_DONE) {
                        janet_unlisten(state, 0);
                    }
                    break;
                } else {
                    state = state->_next;
                }
            }
        }
    }
}

#elif defined(JANET_EV_EPOLL)

static JanetTimestamp ts_now(void) {
    struct timespec now;
    janet_assert(-1 != clock_gettime(CLOCK_MONOTONIC, &now), "failed to get time");
    uint64_t res = 1000 * now.tv_sec;
    res += now.tv_nsec / 1000000;
    return res;
}

static int make_epoll_events(int mask) {
    int events = 0;
    if (mask & JANET_ASYNC_LISTEN_READ)
        events |= EPOLLIN;
    if (mask & JANET_ASYNC_LISTEN_WRITE)
        events |= EPOLLOUT;
    return events;
}

static void janet_epoll_sync_callback(JanetEVGenericMessage msg) {
    JanetListenerState *state = msg.argp;
    JanetAsyncStatus status1 = JANET_ASYNC_STATUS_NOT_DONE;
    JanetAsyncStatus status2 = JANET_ASYNC_STATUS_NOT_DONE;
    if (state->stream->_mask & JANET_ASYNC_LISTEN_WRITE)
        status1 = state->machine(state, JANET_ASYNC_EVENT_WRITE);
    if (state->stream->_mask & JANET_ASYNC_LISTEN_READ)
        status2 = state->machine(state, JANET_ASYNC_EVENT_READ);
    if (status1 == JANET_ASYNC_STATUS_DONE ||
            status2 == JANET_ASYNC_STATUS_DONE) {
        janet_unlisten(state, 0);
    } else {
        /* Repost event */
        janet_ev_post_event(NULL, janet_epoll_sync_callback, msg);
    }
}

/* Wait for the next event */
JanetListenerState *janet_listen(JanetStream *stream, JanetListener behavior, int mask, size_t size, void *user) {
    int is_first = !(stream->state);
    int op = is_first ? EPOLL_CTL_ADD : EPOLL_CTL_MOD;
    JanetListenerState *state = janet_listen_impl(stream, behavior, mask, size, user);
    struct epoll_event ev;
    ev.events = make_epoll_events(state->stream->_mask);
    ev.data.ptr = stream;
    int status;
    do {
        status = epoll_ctl(janet_vm.epoll, op, stream->handle, &ev);
    } while (status == -1 && errno == EINTR);
    if (status == -1) {
        if (errno == EPERM) {
            /* Couldn't add to event loop, so assume that it completes
             * synchronously. In that case, fire the completion
             * event manually, since this should be a read or write
             * event to a file. So we just post a custom event to do the read/write
             * asap. */
            /* Use flag to indicate state is not registered in epoll */
            state->_mask |= (1 << JANET_ASYNC_EVENT_COMPLETE);
            JanetEVGenericMessage msg = {0};
            msg.argp = state;
            janet_ev_post_event(NULL, janet_epoll_sync_callback, msg);
        } else {
            /* Unexpected error */
            janet_unlisten_impl(state, 0);
            janet_panicv(janet_ev_lasterr());
        }
    }
    return state;
}

/* Tell system we are done listening for a certain event */
static void janet_unlisten(JanetListenerState *state, int is_gc) {
    JanetStream *stream = state->stream;
    if (!(stream->flags & JANET_STREAM_CLOSED)) {
        /* Use flag to indicate state is not registered in epoll */
        if (!(state->_mask & (1 << JANET_ASYNC_EVENT_COMPLETE))) {
            int is_last = (state->_next == NULL && stream->state == state);
            int op = is_last ? EPOLL_CTL_DEL : EPOLL_CTL_MOD;
            struct epoll_event ev;
            ev.events = make_epoll_events(stream->_mask & ~state->_mask);
            ev.data.ptr = stream;
            int status;
            do {
                status = epoll_ctl(janet_vm.epoll, op, stream->handle, &ev);
            } while (status == -1 && errno == EINTR);
            if (status == -1) {
                janet_panicv(janet_ev_lasterr());
            }
        }
    }
    /* Destroy state machine and free memory */
    janet_unlisten_impl(state, is_gc);
}

#define JANET_EPOLL_MAX_EVENTS 64
void janet_loop1_impl(int has_timeout, JanetTimestamp timeout) {
    struct itimerspec its;
    if (janet_vm.timer_enabled || has_timeout) {
        memset(&its, 0, sizeof(its));
        if (has_timeout) {
            its.it_value.tv_sec = timeout / 1000;
            its.it_value.tv_nsec = (timeout % 1000) * 1000000;
        }
        timerfd_settime(janet_vm.timerfd, TFD_TIMER_ABSTIME, &its, NULL);
    }
    janet_vm.timer_enabled = has_timeout;

    /* Poll for events */
    struct epoll_event events[JANET_EPOLL_MAX_EVENTS];
    int ready;
    do {
        ready = epoll_wait(janet_vm.epoll, events, JANET_EPOLL_MAX_EVENTS, -1);
    } while (ready == -1 && errno == EINTR);
    if (ready == -1) {
        JANET_EXIT("failed to poll events");
    }

    /* Step state machines */
    for (int i = 0; i < ready; i++) {
        void *p = events[i].data.ptr;
        if (&janet_vm.timerfd == p) {
            /* Timer expired, ignore */;
        } else if (janet_vm.selfpipe == p) {
            /* Self-pipe handling */
            janet_ev_handle_selfpipe();
        } else {
            JanetStream *stream = p;
            int mask = events[i].events;
            JanetListenerState *state = stream->state;
            while (NULL != state) {
                state->event = events + i;
                JanetListenerState *next_state = state->_next;
                JanetAsyncStatus status1 = JANET_ASYNC_STATUS_NOT_DONE;
                JanetAsyncStatus status2 = JANET_ASYNC_STATUS_NOT_DONE;
                JanetAsyncStatus status3 = JANET_ASYNC_STATUS_NOT_DONE;
                JanetAsyncStatus status4 = JANET_ASYNC_STATUS_NOT_DONE;
                if (mask & EPOLLOUT)
                    status1 = state->machine(state, JANET_ASYNC_EVENT_WRITE);
                if (mask & EPOLLIN)
                    status2 = state->machine(state, JANET_ASYNC_EVENT_READ);
                if (mask & EPOLLERR)
                    status3 = state->machine(state, JANET_ASYNC_EVENT_ERR);
                if ((mask & EPOLLHUP) && !(mask & (EPOLLOUT | EPOLLIN)))
                    status4 = state->machine(state, JANET_ASYNC_EVENT_HUP);
                if (status1 == JANET_ASYNC_STATUS_DONE ||
                        status2 == JANET_ASYNC_STATUS_DONE ||
                        status3 == JANET_ASYNC_STATUS_DONE ||
                        status4 == JANET_ASYNC_STATUS_DONE)
                    janet_unlisten(state, 0);
                state = next_state;
            }
        }
    }
}

void janet_ev_init(void) {
    janet_ev_init_common();
    janet_ev_setup_selfpipe();
    janet_vm.epoll = epoll_create1(EPOLL_CLOEXEC);
    janet_vm.timerfd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC | TFD_NONBLOCK);
    janet_vm.timer_enabled = 0;
    if (janet_vm.epoll == -1 || janet_vm.timerfd == -1) goto error;
    struct epoll_event ev;
    ev.events = EPOLLIN | EPOLLET;
    ev.data.ptr = &janet_vm.timerfd;
    if (-1 == epoll_ctl(janet_vm.epoll, EPOLL_CTL_ADD, janet_vm.timerfd, &ev)) goto error;
    ev.events = EPOLLIN | EPOLLET;
    ev.data.ptr = janet_vm.selfpipe;
    if (-1 == epoll_ctl(janet_vm.epoll, EPOLL_CTL_ADD, janet_vm.selfpipe[0], &ev)) goto error;
    return;
error:
    JANET_EXIT("failed to initialize event loop");
}

void janet_ev_deinit(void) {
    janet_ev_deinit_common();
    close(janet_vm.epoll);
    close(janet_vm.timerfd);
    janet_ev_cleanup_selfpipe();
    janet_vm.epoll = 0;
}

/*
 * End epoll implementation
 */

#elif defined(JANET_EV_KQUEUE)
/* Definition from:
 *   https://github.com/wahern/cqueues/blob/master/src/lib/kpoll.c
 * NetBSD uses intptr_t while others use void * for .udata */
#define EV_SETx(ev, a, b, c, d, e, f) EV_SET((ev), (a), (b), (c), (d), (e), ((__typeof__((ev)->udata))(f)))
#define JANET_KQUEUE_TF (EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT)
#define JANET_KQUEUE_MIN_INTERVAL 0

/* NOTE:
 * NetBSD and OpenBSD expect things are always intervals, and FreeBSD doesn't
 * like an ABSTIME in the past so just use intervals always. Introduces a
 * calculation to determine the minimum timeout per timeout requested of
 * kqueue. Also note that NetBSD doesn't accept timeout intervals less than 1
 * millisecond, so correct all intervals on that platform to be at least 1
 * millisecond.*/
JanetTimestamp to_interval(const JanetTimestamp ts) {
    return ts >= JANET_KQUEUE_MIN_INTERVAL ? ts : JANET_KQUEUE_MIN_INTERVAL;
}
#define JANET_KQUEUE_INTERVAL(timestamp) (to_interval((timestamp - ts_now())))

static JanetTimestamp ts_now(void) {
    struct timespec now;
    janet_assert(-1 != clock_gettime(CLOCK_MONOTONIC, &now), "failed to get time");
    uint64_t res = 1000 * now.tv_sec;
    res += now.tv_nsec / 1000000;
    return res;
}

/* NOTE: Assumes Janet's timestamp precision is in milliseconds. */
static void timestamp2timespec(struct timespec *t, JanetTimestamp ts) {
    t->tv_sec = ts == 0 ? 0 : ts / 1000;
    t->tv_nsec = ts == 0 ? 0 : (ts % 1000) * 1000000;
}

void add_kqueue_events(const struct kevent *events, int length) {
    /* NOTE: Status should be equal to the amount of events added, which isn't
     * always known since deletions or modifications occur. Can't use the
     * eventlist argument for it to report to us what failed otherwise we may
     * poll in events to handle! This code assumes atomicity, that kqueue can
     * either succeed or fail, but never partially (which is seemingly how it
     * works in practice). When encountering an "inbetween" state we currently
     * just panic!
     *
     * The FreeBSD man page kqueue(2) shows a check through the change list to
     * check if kqueue had an error with any of the events being pushed to
     * change. Maybe we should do this, even tho the man page also doesn't
     * note that kqueue actually does this. We do not do this at this time.  */
    int status;
    status = kevent(janet_vm.kq, events, length, NULL, 0, NULL);
    if (status == -1 && errno != EINTR)
        janet_panicv(janet_ev_lasterr());
}

JanetListenerState *janet_listen(JanetStream *stream, JanetListener behavior, int mask, size_t size, void *user) {
    JanetListenerState *state = janet_listen_impl(stream, behavior, mask, size, user);
    struct kevent kev[2];

    int length = 0;
    if (state->stream->_mask & JANET_ASYNC_LISTEN_READ) {
        EV_SETx(&kev[length], stream->handle, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, stream);
        length++;
    }
    if (state->stream->_mask & JANET_ASYNC_LISTEN_WRITE) {
        EV_SETx(&kev[length], stream->handle, EVFILT_WRITE, EV_ADD | EV_ENABLE, 0, 0, stream);
        length++;
    }

    if (length > 0) {
        add_kqueue_events(kev, length);
    }

    return state;
}

static void janet_unlisten(JanetListenerState *state, int is_gc) {
    JanetStream *stream = state->stream;
    if (!(stream->flags & JANET_STREAM_CLOSED)) {
        /* Use flag to indicate state is not registered in kqueue */
        if (!(state->_mask & (1 << JANET_ASYNC_EVENT_COMPLETE))) {
            int is_last = (state->_next == NULL && stream->state == state);
            int op = is_last ? EV_DELETE : EV_DISABLE | EV_ADD;
            struct kevent kev[2];
            EV_SETx(&kev[1], stream->handle, EVFILT_WRITE, op, 0, 0, stream);

            int length = 0;
            if (stream->_mask & JANET_ASYNC_EVENT_WRITE) {
                EV_SETx(&kev[length], stream->handle, EVFILT_WRITE, op, 0, 0, stream);
                length++;
            }
            if (stream->_mask & JANET_ASYNC_EVENT_READ) {
                EV_SETx(&kev[length], stream->handle, EVFILT_READ, op, 0, 0, stream);
                length++;
            }

            add_kqueue_events(kev, length);
        }
    }
    janet_unlisten_impl(state, is_gc);
}

#define JANET_KQUEUE_MAX_EVENTS 64

void janet_loop1_impl(int has_timeout, JanetTimestamp timeout) {
    /* Poll for events */
    /* NOTE:
     * We calculate the timeout interval per iteration. When the interval
     * drops to 0 or negative, we effect a timeout of 0. Effecting a timeout
     * of infinity will not work and could make other fibers with timeouts
     * miss their timeouts if we did so.
     * JANET_KQUEUE_INTERVAL insures we have a timeout of no less than 0. */
    int status;
    struct timespec ts;
    struct kevent events[JANET_KQUEUE_MAX_EVENTS];
    do {
        if (janet_vm.timer_enabled || has_timeout) {
            timestamp2timespec(&ts, JANET_KQUEUE_INTERVAL(timeout));
            status = kevent(janet_vm.kq, NULL, 0, events,
                            JANET_KQUEUE_MAX_EVENTS, &ts);
        } else {
            status = kevent(janet_vm.kq, NULL, 0, events,
                            JANET_KQUEUE_MAX_EVENTS, NULL);
        }
    } while (status == -1 && errno == EINTR);
    if (status == -1)
        JANET_EXIT("failed to poll events");

    /* Make sure timer is set accordingly. */
    janet_vm.timer_enabled = has_timeout;

    /* Step state machines */
    for (int i = 0; i < status; i++) {
        void *p = (void *) events[i].udata;
        if (janet_vm.selfpipe == p) {
            /* Self-pipe handling */
            janet_ev_handle_selfpipe();
        } else {
            JanetStream *stream = p;
            JanetListenerState *state = stream->state;
            while (NULL != state) {
                JanetListenerState *next_state = state->_next;
                state->event = events + i;
                JanetAsyncStatus statuses[4];
                for (int i = 0; i < 4; i++)
                    statuses[i] = JANET_ASYNC_STATUS_NOT_DONE;

                if (!(events[i].flags & EV_ERROR)) {
                    if (events[i].filter == EVFILT_WRITE)
                        statuses[0] = state->machine(state, JANET_ASYNC_EVENT_WRITE);
                    if (events[i].filter == EVFILT_READ)
                        statuses[1] = state->machine(state, JANET_ASYNC_EVENT_READ);
                    if ((events[i].flags & EV_EOF) && !(events[i].data > 0))
                        statuses[3] = state->machine(state, JANET_ASYNC_EVENT_HUP);
                } else {
                    statuses[2] = state->machine(state, JANET_ASYNC_EVENT_ERR);
                }
                if (statuses[0] == JANET_ASYNC_STATUS_DONE ||
                        statuses[1] == JANET_ASYNC_STATUS_DONE ||
                        statuses[2] == JANET_ASYNC_STATUS_DONE ||
                        statuses[3] == JANET_ASYNC_STATUS_DONE)
                    janet_unlisten(state, 0);

                state = next_state;
            }
        }
    }
}

void janet_ev_init(void) {
    janet_ev_init_common();
    janet_ev_setup_selfpipe();
    janet_vm.kq = kqueue();
    janet_vm.timer_enabled = 0;
    if (janet_vm.kq == -1) goto error;
    struct kevent event;
    EV_SETx(&event, janet_vm.selfpipe[0], EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, janet_vm.selfpipe);
    add_kqueue_events(&event, 1);
    return;
error:
    JANET_EXIT("failed to initialize event loop");
}

void janet_ev_deinit(void) {
    janet_ev_deinit_common();
    close(janet_vm.kq);
    janet_ev_cleanup_selfpipe();
    janet_vm.kq = 0;
}

#else

#include <poll.h>

static JanetTimestamp ts_now(void) {
    struct timespec now;
    janet_assert(-1 != clock_gettime(CLOCK_REALTIME, &now), "failed to get time");
    uint64_t res = 1000 * now.tv_sec;
    res += now.tv_nsec / 1000000;
    return res;
}

static int make_poll_events(int mask) {
    int events = 0;
    if (mask & JANET_ASYNC_LISTEN_READ)
        events |= POLLIN;
    if (mask & JANET_ASYNC_LISTEN_WRITE)
        events |= POLLOUT;
    return events;
}

/* Wait for the next event */
JanetListenerState *janet_listen(JanetStream *stream, JanetListener behavior, int mask, size_t size, void *user) {
    size_t oldsize = janet_vm.listener_cap;
    JanetListenerState *state = janet_listen_impl(stream, behavior, mask, size, user);
    size_t newsize = janet_vm.listener_cap;
    if (newsize > oldsize) {
        janet_vm.fds = janet_realloc(janet_vm.fds, (newsize + 1) * sizeof(struct pollfd));
        if (NULL == janet_vm.fds) {
            JANET_OUT_OF_MEMORY;
        }
    }
    struct pollfd ev;
    ev.fd = stream->handle;
    ev.events = make_poll_events(state->stream->_mask);
    ev.revents = 0;
    janet_vm.fds[state->_index + 1] = ev;
    return state;
}

static void janet_unlisten(JanetListenerState *state, int is_gc) {
    janet_vm.fds[state->_index + 1] = janet_vm.fds[janet_vm.listener_count];
    janet_unlisten_impl(state, is_gc);
}

void janet_loop1_impl(int has_timeout, JanetTimestamp timeout) {
    /* Poll for events */
    int ready;
    do {
        int to = -1;
        if (has_timeout) {
            JanetTimestamp now = ts_now();
            to = now > timeout ? 0 : (int)(timeout - now);
        }
        ready = poll(janet_vm.fds, janet_vm.listener_count + 1, to);
    } while (ready == -1 && errno == EINTR);
    if (ready == -1) {
        JANET_EXIT("failed to poll events");
    }

    /* Check selfpipe */
    if (janet_vm.fds[0].revents & POLLIN) {
        janet_vm.fds[0].revents = 0;
        janet_ev_handle_selfpipe();
    }

    /* Step state machines */
    for (size_t i = 0; i < janet_vm.listener_count; i++) {
        struct pollfd *pfd = janet_vm.fds + i + 1;
        /* Skip fds where nothing interesting happened */
        JanetListenerState *state = janet_vm.listeners[i];
        /* Normal event */
        int mask = pfd->revents;
        JanetAsyncStatus status1 = JANET_ASYNC_STATUS_NOT_DONE;
        JanetAsyncStatus status2 = JANET_ASYNC_STATUS_NOT_DONE;
        JanetAsyncStatus status3 = JANET_ASYNC_STATUS_NOT_DONE;
        JanetAsyncStatus status4 = JANET_ASYNC_STATUS_NOT_DONE;
        state->event = pfd;
        if (mask & POLLOUT)
            status1 = state->machine(state, JANET_ASYNC_EVENT_WRITE);
        if (mask & POLLIN)
            status2 = state->machine(state, JANET_ASYNC_EVENT_READ);
        if (mask & POLLERR)
            status3 = state->machine(state, JANET_ASYNC_EVENT_ERR);
        if ((mask & POLLHUP) && !(mask & (POLLIN | POLLOUT)))
            status4 = state->machine(state, JANET_ASYNC_EVENT_HUP);
        if (status1 == JANET_ASYNC_STATUS_DONE ||
                status2 == JANET_ASYNC_STATUS_DONE ||
                status3 == JANET_ASYNC_STATUS_DONE ||
                status4 == JANET_ASYNC_STATUS_DONE)
            janet_unlisten(state, 0);
    }
}

void janet_ev_init(void) {
    janet_ev_init_common();
    janet_vm.fds = NULL;
    janet_ev_setup_selfpipe();
    janet_vm.fds = janet_malloc(sizeof(struct pollfd));
    if (NULL == janet_vm.fds) {
        JANET_OUT_OF_MEMORY;
    }
    janet_vm.fds[0].fd = janet_vm.selfpipe[0];
    janet_vm.fds[0].events = POLLIN;
    janet_vm.fds[0].revents = 0;
    return;
}

void janet_ev_deinit(void) {
    janet_ev_deinit_common();
    janet_ev_cleanup_selfpipe();
    janet_free(janet_vm.fds);
    janet_vm.fds = NULL;
}

#endif

/*
 * End poll implementation
 */

/*
 * Generic Callback system. Post a function pointer + data to the event loop (from another
 * thread or even a signal handler). Allows posting events from another thread or signal handler.
 */
void janet_ev_post_event(JanetVM *vm, JanetCallback cb, JanetEVGenericMessage msg) {
    vm = vm ? vm : &janet_vm;
#ifdef JANET_WINDOWS
    JanetHandle iocp = vm->iocp;
    JanetSelfPipeEvent *event = janet_malloc(sizeof(JanetSelfPipeEvent));
    if (NULL == event) {
        JANET_OUT_OF_MEMORY;
    }
    event->msg = msg;
    event->cb = cb;
    janet_assert(PostQueuedCompletionStatus(iocp,
                                            sizeof(JanetSelfPipeEvent),
                                            0,
                                            (LPOVERLAPPED) event),
                 "failed to post completion event");
#else
    JanetSelfPipeEvent event;
    memset(&event, 0, sizeof(event));
    event.msg = msg;
    event.cb = cb;
    int fd = vm->selfpipe[1];
    /* handle a bit of back pressure before giving up. */
    int tries = 4;
    while (tries > 0) {
        int status;
        do {
            status = write(fd, &event, sizeof(event));
        } while (status == -1 && errno == EINTR);
        if (status > 0) break;
        sleep(0);
        tries--;
    }
    janet_assert(tries > 0, "failed to write event to self-pipe");
#endif
}

/*
 * Threaded calls
 */

#ifdef JANET_WINDOWS
static DWORD WINAPI janet_thread_body(LPVOID ptr) {
    JanetEVThreadInit *init = (JanetEVThreadInit *)ptr;
    JanetEVGenericMessage msg = init->msg;
    JanetThreadedSubroutine subr = init->subr;
    JanetThreadedCallback cb = init->cb;
    JanetHandle iocp = init->write_pipe;
    /* Reuse memory from thread init for returning data */
    init->msg = subr(msg);
    init->cb = cb;
    janet_assert(PostQueuedCompletionStatus(iocp,
                                            sizeof(JanetSelfPipeEvent),
                                            0,
                                            (LPOVERLAPPED) init),
                 "failed to post completion event");
    return 0;
}
#else
static void *janet_thread_body(void *ptr) {
    JanetEVThreadInit *init = (JanetEVThreadInit *)ptr;
    JanetEVGenericMessage msg = init->msg;
    JanetThreadedSubroutine subr = init->subr;
    JanetThreadedCallback cb = init->cb;
    int fd = init->write_pipe;
    janet_free(init);
    JanetSelfPipeEvent response;
    memset(&response, 0, sizeof(response));
    response.msg = subr(msg);
    response.cb = cb;
    /* handle a bit of back pressure before giving up. */
    int tries = 4;
    while (tries > 0) {
        int status;
        do {
            status = write(fd, &response, sizeof(response));
        } while (status == -1 && errno == EINTR);
        if (status > 0) break;
        sleep(1);
        tries--;
    }
    return NULL;
}
#endif

void janet_ev_threaded_call(JanetThreadedSubroutine fp, JanetEVGenericMessage arguments, JanetThreadedCallback cb) {
    JanetEVThreadInit *init = janet_malloc(sizeof(JanetEVThreadInit));
    if (NULL == init) {
        JANET_OUT_OF_MEMORY;
    }
    init->msg = arguments;
    init->subr = fp;
    init->cb = cb;

#ifdef JANET_WINDOWS
    init->write_pipe = janet_vm.iocp;
    HANDLE thread_handle = CreateThread(NULL, 0, janet_thread_body, init, 0, NULL);
    if (NULL == thread_handle) {
        janet_free(init);
        janet_panic("failed to create thread");
    }
    CloseHandle(thread_handle); /* detach from thread */
#else
    init->write_pipe = janet_vm.selfpipe[1];
    pthread_t waiter_thread;
    int err = pthread_create(&waiter_thread, &janet_vm.new_thread_attr, janet_thread_body, init);
    if (err) {
        janet_free(init);
        janet_panicf("%s", strerror(err));
    }
#endif

    /* Increment ev refcount so we don't quit while waiting for a subprocess */
    janet_ev_inc_refcount();
}

/* Default callback for janet_ev_threaded_await. */
void janet_ev_default_threaded_callback(JanetEVGenericMessage return_value) {
    janet_ev_dec_refcount();
    if (return_value.fiber == NULL) {
        return;
    }
    switch (return_value.tag) {
        default:
        case JANET_EV_TCTAG_NIL:
            janet_schedule(return_value.fiber, janet_wrap_nil());
            break;
        case JANET_EV_TCTAG_INTEGER:
            janet_schedule(return_value.fiber, janet_wrap_integer(return_value.argi));
            break;
        case JANET_EV_TCTAG_STRING:
        case JANET_EV_TCTAG_STRINGF:
            janet_schedule(return_value.fiber, janet_cstringv((const char *) return_value.argp));
            if (return_value.tag == JANET_EV_TCTAG_STRINGF) janet_free(return_value.argp);
            break;
        case JANET_EV_TCTAG_KEYWORD:
            janet_schedule(return_value.fiber, janet_ckeywordv((const char *) return_value.argp));
            break;
        case JANET_EV_TCTAG_ERR_STRING:
        case JANET_EV_TCTAG_ERR_STRINGF:
            janet_cancel(return_value.fiber, janet_cstringv((const char *) return_value.argp));
            if (return_value.tag == JANET_EV_TCTAG_STRINGF) janet_free(return_value.argp);
            break;
        case JANET_EV_TCTAG_ERR_KEYWORD:
            janet_cancel(return_value.fiber, janet_ckeywordv((const char *) return_value.argp));
            break;
        case JANET_EV_TCTAG_BOOLEAN:
            janet_schedule(return_value.fiber, janet_wrap_boolean(return_value.argi));
            break;
    }
    janet_gcunroot(janet_wrap_fiber(return_value.fiber));
}


/* Convenience method for common case */
JANET_NO_RETURN
void janet_ev_threaded_await(JanetThreadedSubroutine fp, int tag, int argi, void *argp) {
    JanetEVGenericMessage arguments;
    memset(&arguments, 0, sizeof(arguments));
    arguments.tag = tag;
    arguments.argi = argi;
    arguments.argp = argp;
    arguments.fiber = janet_root_fiber();
    janet_gcroot(janet_wrap_fiber(arguments.fiber));
    janet_ev_threaded_call(fp, arguments, janet_ev_default_threaded_callback);
    janet_await();
}

/*
 * C API helpers for reading and writing from streams.
 * There is some networking code in here as well as generic
 * reading and writing primitives.
 */

void janet_stream_flags(JanetStream *stream, uint32_t flags) {
    if (stream->flags & JANET_STREAM_CLOSED) {
        janet_panic("stream is closed");
    }
    if ((stream->flags & flags) != flags) {
        const char *rmsg = "", *wmsg = "", *amsg = "", *dmsg = "", *smsg = "stream";
        if (flags & JANET_STREAM_READABLE) rmsg = "readable ";
        if (flags & JANET_STREAM_WRITABLE) wmsg = "writable ";
        if (flags & JANET_STREAM_ACCEPTABLE) amsg = "server ";
        if (flags & JANET_STREAM_UDPSERVER) dmsg = "datagram ";
        if (flags & JANET_STREAM_SOCKET) smsg = "socket";
        janet_panicf("bad stream, expected %s%s%s%s%s", rmsg, wmsg, amsg, dmsg, smsg);
    }
}

/* When there is an IO error, we need to be able to convert it to a Janet
 * string to raise a Janet error. */
#ifdef JANET_WINDOWS
#define JANET_EV_CHUNKSIZE 4096
Janet janet_ev_lasterr(void) {
    int code = GetLastError();
    char msgbuf[256];
    msgbuf[0] = '\0';
    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                  NULL,
                  code,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  msgbuf,
                  sizeof(msgbuf),
                  NULL);
    if (!*msgbuf) sprintf(msgbuf, "%d", code);
    char *c = msgbuf;
    while (*c) {
        if (*c == '\n' || *c == '\r') {
            *c = '\0';
            break;
        }
        c++;
    }
    return janet_cstringv(msgbuf);
}
#else
Janet janet_ev_lasterr(void) {
    return janet_cstringv(strerror(errno));
}
#endif

/* State machine for read/recv/recvfrom */

typedef enum {
    JANET_ASYNC_READMODE_READ,
    JANET_ASYNC_READMODE_RECV,
    JANET_ASYNC_READMODE_RECVFROM
} JanetReadMode;

typedef struct {
    JanetListenerState head;
    int32_t bytes_left;
    int32_t bytes_read;
    JanetBuffer *buf;
    int is_chunk;
    JanetReadMode mode;
#ifdef JANET_WINDOWS
    OVERLAPPED overlapped;
#ifdef JANET_NET
    WSABUF wbuf;
    DWORD flags;
    struct sockaddr from;
    int fromlen;
#endif
    uint8_t chunk_buf[JANET_EV_CHUNKSIZE];
#else
    int flags;
#endif
} StateRead;

JanetAsyncStatus ev_machine_read(JanetListenerState *s, JanetAsyncEvent event) {
    StateRead *state = (StateRead *) s;
    switch (event) {
        default:
            break;
        case JANET_ASYNC_EVENT_MARK:
            janet_mark(janet_wrap_buffer(state->buf));
            break;
        case JANET_ASYNC_EVENT_CLOSE:
            janet_schedule(s->fiber, janet_wrap_nil());
            return JANET_ASYNC_STATUS_DONE;
#ifdef JANET_WINDOWS
        case JANET_ASYNC_EVENT_COMPLETE: {
            /* Called when read finished */
            state->bytes_read += s->bytes;
            if (state->bytes_read == 0 && (state->mode != JANET_ASYNC_READMODE_RECVFROM)) {
                janet_schedule(s->fiber, janet_wrap_nil());
                return JANET_ASYNC_STATUS_DONE;
            }

            janet_buffer_push_bytes(state->buf, state->chunk_buf, s->bytes);
            state->bytes_left -= s->bytes;

            if (state->bytes_left == 0 || !state->is_chunk || s->bytes == 0) {
                Janet resume_val;
#ifdef JANET_NET
                if (state->mode == JANET_ASYNC_READMODE_RECVFROM) {
                    void *abst = janet_abstract(&janet_address_type, state->fromlen);
                    memcpy(abst, &state->from, state->fromlen);
                    resume_val = janet_wrap_abstract(abst);
                } else
#endif
                {
                    resume_val = janet_wrap_buffer(state->buf);
                }
                janet_schedule(s->fiber, resume_val);
                return JANET_ASYNC_STATUS_DONE;
            }
        }

        /* fallthrough */
        case JANET_ASYNC_EVENT_USER: {
            int32_t chunk_size = state->bytes_left > JANET_EV_CHUNKSIZE ? JANET_EV_CHUNKSIZE : state->bytes_left;
            s->tag = &state->overlapped;
            memset(&(state->overlapped), 0, sizeof(OVERLAPPED));
            int status;
#ifdef JANET_NET
            if (state->mode == JANET_ASYNC_READMODE_RECVFROM) {
                state->wbuf.len = (ULONG) chunk_size;
                state->wbuf.buf = state->chunk_buf;
                status = WSARecvFrom((SOCKET) s->stream->handle, &state->wbuf, 1,
                                     NULL, &state->flags, &state->from, &state->fromlen, &state->overlapped, NULL);
                if (status && (WSA_IO_PENDING != WSAGetLastError())) {
                    janet_cancel(s->fiber, janet_ev_lasterr());
                    return JANET_ASYNC_STATUS_DONE;
                }
            } else
#endif
            {
                /* Some handles (not all) read from the offset in lopOverlapped
                 * if its not set before calling `ReadFile` these streams will always read from offset 0 */
                state->overlapped.Offset = (DWORD) state->bytes_read;

                status = ReadFile(s->stream->handle, state->chunk_buf, chunk_size, NULL, &state->overlapped);
                if (!status && (ERROR_IO_PENDING != WSAGetLastError())) {
                    if (WSAGetLastError() == ERROR_BROKEN_PIPE) {
                        if (state->bytes_read) {
                            janet_schedule(s->fiber, janet_wrap_buffer(state->buf));
                        } else {
                            janet_schedule(s->fiber, janet_wrap_nil());
                        }
                    } else {
                        janet_cancel(s->fiber, janet_ev_lasterr());
                    }
                    return JANET_ASYNC_STATUS_DONE;
                }
            }
        }
        break;
#else
        case JANET_ASYNC_EVENT_ERR: {
            if (state->bytes_read) {
                janet_schedule(s->fiber, janet_wrap_buffer(state->buf));
            } else {
                janet_schedule(s->fiber, janet_wrap_nil());
            }
            return JANET_ASYNC_STATUS_DONE;
        }
        case JANET_ASYNC_EVENT_HUP:
        case JANET_ASYNC_EVENT_READ: {
            JanetBuffer *buffer = state->buf;
            int32_t bytes_left = state->bytes_left;
            int32_t read_limit = state->is_chunk ? (bytes_left > 4096 ? 4096 : bytes_left) : bytes_left;
            janet_buffer_extra(buffer, read_limit);
            ssize_t nread;
#ifdef JANET_NET
            char saddr[256];
            socklen_t socklen = sizeof(saddr);
#endif
            do {
#ifdef JANET_NET
                if (state->mode == JANET_ASYNC_READMODE_RECVFROM) {
                    nread = recvfrom(s->stream->handle, buffer->data + buffer->count, read_limit, state->flags,
                                     (struct sockaddr *)&saddr, &socklen);
                } else if (state->mode == JANET_ASYNC_READMODE_RECV) {
                    nread = recv(s->stream->handle, buffer->data + buffer->count, read_limit, state->flags);
                } else
#endif
                {
                    nread = read(s->stream->handle, buffer->data + buffer->count, read_limit);
                }
            } while (nread == -1 && errno == EINTR);

            /* Check for errors - special case errors that can just be waited on to fix */
            if (nread == -1) {
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                    return JANET_ASYNC_STATUS_NOT_DONE;
                }
                /* In stream protocols, a pipe error is end of stream */
                if (errno == EPIPE && (state->mode != JANET_ASYNC_READMODE_RECVFROM)) {
                    nread = 0;
                } else {
                    janet_cancel(s->fiber, janet_ev_lasterr());
                    return JANET_ASYNC_STATUS_DONE;
                }
            }

            /* Only allow 0-length packets in recv-from. In stream protocols, a zero length packet is EOS. */
            state->bytes_read += nread;
            if (state->bytes_read == 0 && (state->mode != JANET_ASYNC_READMODE_RECVFROM)) {
                janet_schedule(s->fiber, janet_wrap_nil());
                return JANET_ASYNC_STATUS_DONE;
            }

            /* Increment buffer counts */
            buffer->count += nread;
            bytes_left -= nread;
            state->bytes_left = bytes_left;

            /* Resume if done */
            if (!state->is_chunk || bytes_left == 0 || nread == 0) {
                Janet resume_val;
#ifdef JANET_NET
                if (state->mode == JANET_ASYNC_READMODE_RECVFROM) {
                    void *abst = janet_abstract(&janet_address_type, socklen);
                    memcpy(abst, &saddr, socklen);
                    resume_val = janet_wrap_abstract(abst);
                } else
#endif
                {
                    resume_val = janet_wrap_buffer(buffer);
                }
                janet_schedule(s->fiber, resume_val);
                return JANET_ASYNC_STATUS_DONE;
            }
        }
        break;
#endif
    }
    return JANET_ASYNC_STATUS_NOT_DONE;
}

static void janet_ev_read_generic(JanetStream *stream, JanetBuffer *buf, int32_t nbytes, int is_chunked, JanetReadMode mode, int flags) {
    StateRead *state = (StateRead *) janet_listen(stream, ev_machine_read,
                       JANET_ASYNC_LISTEN_READ, sizeof(StateRead), NULL);
    state->is_chunk = is_chunked;
    state->buf = buf;
    state->bytes_left = nbytes;
    state->bytes_read = 0;
    state->mode = mode;
#ifdef JANET_WINDOWS
    ev_machine_read((JanetListenerState *) state, JANET_ASYNC_EVENT_USER);
    state->flags = (DWORD) flags;
#else
    state->flags = flags;
#endif
}

void janet_ev_read(JanetStream *stream, JanetBuffer *buf, int32_t nbytes) {
    janet_ev_read_generic(stream, buf, nbytes, 0, JANET_ASYNC_READMODE_READ, 0);
}
void janet_ev_readchunk(JanetStream *stream, JanetBuffer *buf, int32_t nbytes) {
    janet_ev_read_generic(stream, buf, nbytes, 1, JANET_ASYNC_READMODE_READ, 0);
}
#ifdef JANET_NET
void janet_ev_recv(JanetStream *stream, JanetBuffer *buf, int32_t nbytes, int flags) {
    janet_ev_read_generic(stream, buf, nbytes, 0, JANET_ASYNC_READMODE_RECV, flags);
}
void janet_ev_recvchunk(JanetStream *stream, JanetBuffer *buf, int32_t nbytes, int flags) {
    janet_ev_read_generic(stream, buf, nbytes, 1, JANET_ASYNC_READMODE_RECV, flags);
}
void janet_ev_recvfrom(JanetStream *stream, JanetBuffer *buf, int32_t nbytes, int flags) {
    janet_ev_read_generic(stream, buf, nbytes, 0, JANET_ASYNC_READMODE_RECVFROM, flags);
}
#endif

/*
 * State machine for write/send/send-to
 */

typedef enum {
    JANET_ASYNC_WRITEMODE_WRITE,
    JANET_ASYNC_WRITEMODE_SEND,
    JANET_ASYNC_WRITEMODE_SENDTO
} JanetWriteMode;

typedef struct {
    JanetListenerState head;
    union {
        JanetBuffer *buf;
        const uint8_t *str;
    } src;
    int is_buffer;
    JanetWriteMode mode;
    void *dest_abst;
#ifdef JANET_WINDOWS
    OVERLAPPED overlapped;
#ifdef JANET_NET
    WSABUF wbuf;
    DWORD flags;
#endif
#else
    int flags;
    int32_t start;
#endif
} StateWrite;

JanetAsyncStatus ev_machine_write(JanetListenerState *s, JanetAsyncEvent event) {
    StateWrite *state = (StateWrite *) s;
    switch (event) {
        default:
            break;
        case JANET_ASYNC_EVENT_MARK:
            janet_mark(state->is_buffer
                       ? janet_wrap_buffer(state->src.buf)
                       : janet_wrap_string(state->src.str));
            if (state->mode == JANET_ASYNC_WRITEMODE_SENDTO) {
                janet_mark(janet_wrap_abstract(state->dest_abst));
            }
            break;
        case JANET_ASYNC_EVENT_CLOSE:
            janet_cancel(s->fiber, janet_cstringv("stream closed"));
            return JANET_ASYNC_STATUS_DONE;
#ifdef JANET_WINDOWS
        case JANET_ASYNC_EVENT_COMPLETE: {
            /* Called when write finished */
            if (s->bytes == 0 && (state->mode != JANET_ASYNC_WRITEMODE_SENDTO)) {
                janet_cancel(s->fiber, janet_cstringv("disconnect"));
                return JANET_ASYNC_STATUS_DONE;
            }

            janet_schedule(s->fiber, janet_wrap_nil());
            return JANET_ASYNC_STATUS_DONE;
        }
        break;
        case JANET_ASYNC_EVENT_USER: {
            /* Begin write */
            int32_t len;
            const uint8_t *bytes;
            if (state->is_buffer) {
                /* If buffer, convert to string. */
                /* TODO - be more efficient about this */
                JanetBuffer *buffer = state->src.buf;
                JanetString str = janet_string(buffer->data, buffer->count);
                bytes = str;
                len = buffer->count;
                state->is_buffer = 0;
                state->src.str = str;
            } else {
                bytes = state->src.str;
                len = janet_string_length(bytes);
            }
            s->tag = &state->overlapped;
            memset(&(state->overlapped), 0, sizeof(WSAOVERLAPPED));

            int status;
#ifdef JANET_NET
            if (state->mode == JANET_ASYNC_WRITEMODE_SENDTO) {
                SOCKET sock = (SOCKET) s->stream->handle;
                state->wbuf.buf = (char *) bytes;
                state->wbuf.len = len;
                const struct sockaddr *to = state->dest_abst;
                int tolen = (int) janet_abstract_size((void *) to);
                status = WSASendTo(sock, &state->wbuf, 1, NULL, state->flags, to, tolen, &state->overlapped, NULL);
                if (status && (WSA_IO_PENDING != WSAGetLastError())) {
                    janet_cancel(s->fiber, janet_ev_lasterr());
                    return JANET_ASYNC_STATUS_DONE;
                }
            } else
#endif
            {
                /*
                 * File handles in IOCP need to specify this if they are writing to the
                 * ends of files, like how this is used here.
                 * If the underlying resource doesn't support seeking
                 * byte offsets, they will be ignored
                 * but this otherwise writes to the end of the file in question
                 * Right now, os/open streams aren't seekable, so this works.
                 * for more details see the lpOverlapped parameter in
                 * https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile
                 */
                state->overlapped.Offset = (DWORD) 0xFFFFFFFF;
                state->overlapped.OffsetHigh = (DWORD) 0xFFFFFFFF;
                status = WriteFile(s->stream->handle, bytes, len, NULL, &state->overlapped);
                if (!status && (ERROR_IO_PENDING != WSAGetLastError())) {
                    janet_cancel(s->fiber, janet_ev_lasterr());
                    return JANET_ASYNC_STATUS_DONE;
                }
            }
        }
        break;
#else
        case JANET_ASYNC_EVENT_ERR:
            janet_cancel(s->fiber, janet_cstringv("stream err"));
            return JANET_ASYNC_STATUS_DONE;
        case JANET_ASYNC_EVENT_HUP:
            janet_cancel(s->fiber, janet_cstringv("stream hup"));
            return JANET_ASYNC_STATUS_DONE;
        case JANET_ASYNC_EVENT_WRITE: {
            int32_t start, len;
            const uint8_t *bytes;
            start = state->start;
            if (state->is_buffer) {
                JanetBuffer *buffer = state->src.buf;
                bytes = buffer->data;
                len = buffer->count;
            } else {
                bytes = state->src.str;
                len = janet_string_length(bytes);
            }
            ssize_t nwrote = 0;
            if (start < len) {
                int32_t nbytes = len - start;
                void *dest_abst = state->dest_abst;
                do {
#ifdef JANET_NET
                    if (state->mode == JANET_ASYNC_WRITEMODE_SENDTO) {
                        nwrote = sendto(s->stream->handle, bytes + start, nbytes, state->flags,
                                        (struct sockaddr *) dest_abst, janet_abstract_size(dest_abst));
                    } else if (state->mode == JANET_ASYNC_WRITEMODE_SEND) {
                        nwrote = send(s->stream->handle, bytes + start, nbytes, state->flags);
                    } else
#endif
                    {
                        nwrote = write(s->stream->handle, bytes + start, nbytes);
                    }
                } while (nwrote == -1 && errno == EINTR);

                /* Handle write errors */
                if (nwrote == -1) {
                    if (errno == EAGAIN || errno  == EWOULDBLOCK) break;
                    janet_cancel(s->fiber, janet_ev_lasterr());
                    return JANET_ASYNC_STATUS_DONE;
                }

                /* Unless using datagrams, empty message is a disconnect */
                if (nwrote == 0 && !dest_abst) {
                    janet_cancel(s->fiber, janet_cstringv("disconnect"));
                    return JANET_ASYNC_STATUS_DONE;
                }

                if (nwrote > 0) {
                    start += nwrote;
                } else {
                    start = len;
                }
            }
            state->start = start;
            if (start >= len) {
                janet_schedule(s->fiber, janet_wrap_nil());
                return JANET_ASYNC_STATUS_DONE;
            }
            break;
        }
        break;
#endif
    }
    return JANET_ASYNC_STATUS_NOT_DONE;
}

static void janet_ev_write_generic(JanetStream *stream, void *buf, void *dest_abst, JanetWriteMode mode, int is_buffer, int flags) {
    StateWrite *state = (StateWrite *) janet_listen(stream, ev_machine_write,
                        JANET_ASYNC_LISTEN_WRITE, sizeof(StateWrite), NULL);
    state->is_buffer = is_buffer;
    state->src.buf = buf;
    state->dest_abst = dest_abst;
    state->mode = mode;
#ifdef JANET_WINDOWS
    state->flags = (DWORD) flags;
    ev_machine_write((JanetListenerState *) state, JANET_ASYNC_EVENT_USER);
#else
    state->start = 0;
    state->flags = flags;
#endif
}


void janet_ev_write_buffer(JanetStream *stream, JanetBuffer *buf) {
    janet_ev_write_generic(stream, buf, NULL, JANET_ASYNC_WRITEMODE_WRITE, 1, 0);
}

void janet_ev_write_string(JanetStream *stream, JanetString str) {
    janet_ev_write_generic(stream, (void *) str, NULL, JANET_ASYNC_WRITEMODE_WRITE, 0, 0);
}

#ifdef JANET_NET
void janet_ev_send_buffer(JanetStream *stream, JanetBuffer *buf, int flags) {
    janet_ev_write_generic(stream, buf, NULL, JANET_ASYNC_WRITEMODE_SEND, 1, flags);
}

void janet_ev_send_string(JanetStream *stream, JanetString str, int flags) {
    janet_ev_write_generic(stream, (void *) str, NULL, JANET_ASYNC_WRITEMODE_SEND, 0, flags);
}

void janet_ev_sendto_buffer(JanetStream *stream, JanetBuffer *buf, void *dest, int flags) {
    janet_ev_write_generic(stream, buf, dest, JANET_ASYNC_WRITEMODE_SENDTO, 1, flags);
}

void janet_ev_sendto_string(JanetStream *stream, JanetString str, void *dest, int flags) {
    janet_ev_write_generic(stream, (void *) str, dest, JANET_ASYNC_WRITEMODE_SENDTO, 0, flags);
}
#endif

/* For a pipe ID */
#ifdef JANET_WINDOWS
static volatile long PipeSerialNumber;
#endif

/*
 * mode = 0: both sides non-blocking.
 * mode = 1: only read side non-blocking: write side sent to subprocess
 * mode = 2: only write side non-blocking: read side sent to subprocess
 */
int janet_make_pipe(JanetHandle handles[2], int mode) {
#ifdef JANET_WINDOWS
    /*
     * On windows, the built in CreatePipe function doesn't support overlapped IO
     * so we lift from the windows source code and modify for our own version.
     */
    JanetHandle shandle, chandle;
    UCHAR PipeNameBuffer[MAX_PATH];
    SECURITY_ATTRIBUTES saAttr;
    memset(&saAttr, 0, sizeof(saAttr));
    saAttr.nLength = sizeof(saAttr);
    saAttr.bInheritHandle = TRUE;
    sprintf(PipeNameBuffer,
            "\\\\.\\Pipe\\JanetPipeFile.%08x.%08x",
            GetCurrentProcessId(),
            InterlockedIncrement(&PipeSerialNumber));

    /* server handle goes to subprocess */
    shandle = CreateNamedPipeA(
                  PipeNameBuffer,
                  (mode == 2 ? PIPE_ACCESS_INBOUND : PIPE_ACCESS_OUTBOUND) | FILE_FLAG_OVERLAPPED,
                  PIPE_TYPE_BYTE | PIPE_WAIT,
                  255,           /* Max number of pipes for duplication. */
                  4096,          /* Out buffer size */
                  4096,          /* In buffer size */
                  120 * 1000,    /* Timeout in ms */
                  &saAttr);
    if (shandle == INVALID_HANDLE_VALUE) {
        return -1;
    }

    /* we keep client handle */
    chandle = CreateFileA(
                  PipeNameBuffer,
                  (mode == 2 ? GENERIC_WRITE : GENERIC_READ),
                  0,
                  &saAttr,
                  OPEN_EXISTING,
                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                  NULL);

    if (chandle == INVALID_HANDLE_VALUE) {
        CloseHandle(shandle);
        return -1;
    }
    if (mode == 2) {
        handles[0] = shandle;
        handles[1] = chandle;
    } else {
        handles[0] = chandle;
        handles[1] = shandle;
    }
    return 0;
#else
    if (pipe(handles)) return -1;
    if (mode != 2 && fcntl(handles[0], F_SETFD, FD_CLOEXEC)) goto error;
    if (mode != 1 && fcntl(handles[1], F_SETFD, FD_CLOEXEC)) goto error;
    if (mode != 2 && fcntl(handles[0], F_SETFL, O_NONBLOCK)) goto error;
    if (mode != 1 && fcntl(handles[1], F_SETFL, O_NONBLOCK)) goto error;
    return 0;
error:
    close(handles[0]);
    close(handles[1]);
    return -1;
#endif
}

/* C functions */

JANET_CORE_FN(cfun_ev_go,
              "(ev/go fiber-or-fun &opt value supervisor)",
              "Put a fiber on the event loop to be resumed later. If a function is used, it is wrapped"
              "with `fiber/new` first. "
              "Optionally pass a value to resume with, otherwise resumes with nil. Returns the fiber. "
              "An optional `core/channel` can be provided as a supervisor. When various "
              "events occur in the newly scheduled fiber, an event will be pushed to the supervisor. "
              "If not provided, the new fiber will inherit the current supervisor.") {
    janet_arity(argc, 1, 3);
    Janet value = argc >= 2 ? argv[1] : janet_wrap_nil();
    void *supervisor = janet_optabstract(argv, argc, 2, &janet_channel_type, janet_vm.root_fiber->supervisor_channel);
    JanetFiber *fiber;
    if (janet_checktype(argv[0], JANET_FUNCTION)) {
        /* Create a fiber for the user */
        JanetFunction *func = janet_unwrap_function(argv[0]);
        if (func->def->min_arity > 1) {
            janet_panicf("task function must accept 0 or 1 arguments");
        }
        fiber = janet_fiber(func, 64, func->def->min_arity, &value);
        fiber->flags |=
            JANET_FIBER_MASK_ERROR |
            JANET_FIBER_MASK_USER0 |
            JANET_FIBER_MASK_USER1 |
            JANET_FIBER_MASK_USER2 |
            JANET_FIBER_MASK_USER3 |
            JANET_FIBER_MASK_USER4;
        if (!janet_vm.fiber->env) {
            janet_vm.fiber->env = janet_table(0);
        }
        fiber->env = janet_table(0);
        fiber->env->proto = janet_vm.fiber->env;
    } else {
        fiber = janet_getfiber(argv, 0);
    }
    fiber->supervisor_channel = supervisor;
    janet_schedule(fiber, value);
    return janet_wrap_fiber(fiber);
}

#define JANET_THREAD_SUPERVISOR_FLAG 0x100

/* For ev/thread - Run an interpreter in the new thread. */
static JanetEVGenericMessage janet_go_thread_subr(JanetEVGenericMessage args) {
    JanetBuffer *buffer = (JanetBuffer *) args.argp;
    const uint8_t *nextbytes = buffer->data;
    const uint8_t *endbytes = nextbytes + buffer->count;
    uint32_t flags = args.tag;
    args.tag = 0;
    janet_init();
    JanetTryState tstate;
    JanetSignal signal = janet_try(&tstate);
    if (!signal) {

        /* Set abstract registry */
        if (!(flags & 0x2)) {
            Janet aregv = janet_unmarshal(nextbytes, endbytes - nextbytes,
                                          JANET_MARSHAL_UNSAFE, NULL, &nextbytes);
            if (!janet_checktype(aregv, JANET_TABLE)) janet_panic("expected table for abstract registry");
            janet_vm.abstract_registry = janet_unwrap_table(aregv);
            janet_gcroot(janet_wrap_table(janet_vm.abstract_registry));
        }

        /* Get supervsior */
        if (flags & JANET_THREAD_SUPERVISOR_FLAG) {
            Janet sup =
                janet_unmarshal(nextbytes, endbytes - nextbytes,
                                JANET_MARSHAL_UNSAFE, NULL, &nextbytes);
            /* Hack - use a global variable to avoid longjmp clobber */
            janet_vm.user = janet_unwrap_pointer(sup);
        }

        /* Set cfunction registry */
        if (!(flags & 0x4)) {
            uint32_t count1;
            memcpy(&count1, nextbytes, sizeof(count1));
            size_t count = (size_t) count1;
            if (count > (endbytes - nextbytes) * sizeof(JanetCFunRegistry)) {
                janet_panic("thread message invalid");
            }
            janet_vm.registry_count = count;
            janet_vm.registry_cap = count;
            janet_vm.registry = janet_malloc(count * sizeof(JanetCFunRegistry));
            if (janet_vm.registry == NULL) {
                JANET_OUT_OF_MEMORY;
            }
            janet_vm.registry_dirty = 1;
            nextbytes += sizeof(uint32_t);
            memcpy(janet_vm.registry, nextbytes, count * sizeof(JanetCFunRegistry));
            nextbytes += count * sizeof(JanetCFunRegistry);
        }

        Janet fiberv = janet_unmarshal(nextbytes, endbytes - nextbytes,
                                       JANET_MARSHAL_UNSAFE, NULL, &nextbytes);
        Janet value = janet_unmarshal(nextbytes, endbytes - nextbytes,
                                      JANET_MARSHAL_UNSAFE, NULL, &nextbytes);
        JanetFiber *fiber;
        if (!janet_checktype(fiberv, JANET_FIBER)) {
            if (!janet_checktype(fiberv, JANET_FUNCTION)) {
                janet_panicf("expected function|fiber, got %v", fiberv);
            }
            JanetFunction *func = janet_unwrap_function(fiberv);
            if (func->def->min_arity > 1) {
                janet_panicf("thread function must accept 0 or 1 arguments");
            }
            fiber = janet_fiber(func, 64, func->def->min_arity, &value);
            fiber->flags |=
                JANET_FIBER_MASK_ERROR |
                JANET_FIBER_MASK_USER0 |
                JANET_FIBER_MASK_USER1 |
                JANET_FIBER_MASK_USER2 |
                JANET_FIBER_MASK_USER3 |
                JANET_FIBER_MASK_USER4;
        } else {
            fiber = janet_unwrap_fiber(fiberv);
        }
        if (flags & 0x8) {
            if (NULL == fiber->env) fiber->env = janet_table(0);
            janet_table_put(fiber->env, janet_ckeywordv("task-id"), value);
        }
        fiber->supervisor_channel = janet_vm.user;
        janet_schedule(fiber, value);
        janet_loop();
        args.tag = JANET_EV_TCTAG_NIL;
    } else {
        void *supervisor = janet_vm.user;
        if (NULL != supervisor) {
            /* Got a supervisor, write error there */
            Janet pair[] = {
                janet_ckeywordv("error"),
                tstate.payload
            };
            janet_channel_push((JanetChannel *)supervisor,
                               janet_wrap_tuple(janet_tuple_n(pair, 2)), 2);
        } else if (flags & 0x1) {
            /* No wait, just print to stderr */
            janet_eprintf("thread start failure: %v\n", tstate.payload);
        } else {
            /* Make ev/thread call from parent thread error */
            if (janet_checktype(tstate.payload, JANET_STRING)) {
                args.tag = JANET_EV_TCTAG_ERR_STRINGF;
                args.argp = strdup((const char *) janet_unwrap_string(tstate.payload));
            } else {
                args.tag = JANET_EV_TCTAG_ERR_STRING;
                args.argp = "failed to start thread";
            }
        }
    }
    janet_restore(&tstate);
    janet_buffer_deinit(buffer);
    janet_free(buffer);
    janet_deinit();
    return args;
}

JANET_CORE_FN(cfun_ev_thread,
              "(ev/thread main &opt value flags supervisor)",
              "Run `main` in a new operating system thread, optionally passing `value` "
              "to resume with. The parameter `main` can either be a fiber, or a function that accepts "
              "0 or 1 arguments. "
              "Unlike `ev/go`, this function will suspend the current fiber until the thread is complete. "
              "If you want to run the thread without waiting for a result, pass the `:n` flag to return nil immediately. "
              "Otherwise, returns nil. Available flags:\n\n"
              "* `:n` - return immediately\n"
              "* `:t` - set the task-id of the new thread to value. The task-id is passed in messages to the supervisor channel.\n"
              "* `:a` - don't copy abstract registry to new thread (performance optimization)\n"
              "* `:c` - don't copy cfunction registry to new thread (performance optimization)") {
    janet_arity(argc, 1, 4);
    Janet value = argc >= 2 ? argv[1] : janet_wrap_nil();
    if (!janet_checktype(argv[0], JANET_FUNCTION)) janet_getfiber(argv, 0);
    uint64_t flags = 0;
    if (argc >= 3) {
        flags = janet_getflags(argv, 2, "nact");
    }
    void *supervisor = janet_optabstract(argv, argc, 3, &janet_channel_type, janet_vm.root_fiber->supervisor_channel);
    if (NULL != supervisor) flags |= JANET_THREAD_SUPERVISOR_FLAG;

    /* Marshal arguments for the new thread. */
    JanetBuffer *buffer = janet_malloc(sizeof(JanetBuffer));
    if (NULL == buffer) {
        JANET_OUT_OF_MEMORY;
    }
    janet_buffer_init(buffer, 0);
    if (!(flags & 0x2)) {
        janet_marshal(buffer, janet_wrap_table(janet_vm.abstract_registry), NULL, JANET_MARSHAL_UNSAFE);
    }
    if (flags & JANET_THREAD_SUPERVISOR_FLAG) {
        janet_marshal(buffer, janet_wrap_abstract(supervisor), NULL, JANET_MARSHAL_UNSAFE);
    }
    if (!(flags & 0x4)) {
        janet_assert(janet_vm.registry_count <= INT32_MAX, "assert failed size check");
        uint32_t temp = (uint32_t) janet_vm.registry_count;
        janet_buffer_push_bytes(buffer, (uint8_t *) &temp, sizeof(temp));
        janet_buffer_push_bytes(buffer, (uint8_t *) janet_vm.registry, (int32_t) janet_vm.registry_count * sizeof(JanetCFunRegistry));
    }
    janet_marshal(buffer, argv[0], NULL, JANET_MARSHAL_UNSAFE);
    janet_marshal(buffer, value, NULL, JANET_MARSHAL_UNSAFE);
    if (flags & 0x1) {
        /* Return immediately */
        JanetEVGenericMessage arguments;
        memset(&arguments, 0, sizeof(arguments));
        arguments.tag = (uint32_t) flags;
        arguments.argi = argc;
        arguments.argp = buffer;
        arguments.fiber = NULL;
        janet_ev_threaded_call(janet_go_thread_subr, arguments, janet_ev_default_threaded_callback);
        return janet_wrap_nil();
    } else {
        janet_ev_threaded_await(janet_go_thread_subr, (uint32_t) flags, argc, buffer);
    }
}

JANET_CORE_FN(cfun_ev_give_supervisor,
              "(ev/give-supervisor tag & payload)",
              "Send a message to the current supervior channel if there is one. The message will be a "
              "tuple of all of the arguments combined into a single message, where the first element is tag. "
              "By convention, tag should be a keyword indicating the type of message. Returns nil.") {
    janet_arity(argc, 1, -1);
    void *chanv = janet_vm.root_fiber->supervisor_channel;
    if (NULL != chanv) {
        JanetChannel *chan = janet_channel_unwrap(chanv);
        if (janet_channel_push(chan, janet_wrap_tuple(janet_tuple_n(argv, argc)), 0)) {
            janet_await();
        }
    }
    return janet_wrap_nil();
}

JANET_NO_RETURN void janet_sleep_await(double sec) {
    JanetTimeout to;
    to.when = ts_delta(ts_now(), sec);
    to.fiber = janet_vm.root_fiber;
    to.is_error = 0;
    to.sched_id = to.fiber->sched_id;
    to.curr_fiber = NULL;
    add_timeout(to);
    janet_await();
}

JANET_CORE_FN(cfun_ev_sleep,
              "(ev/sleep sec)",
              "Suspend the current fiber for sec seconds without blocking the event loop.") {
    janet_fixarity(argc, 1);
    double sec = janet_getnumber(argv, 0);
    janet_sleep_await(sec);
}

JANET_CORE_FN(cfun_ev_deadline,
              "(ev/deadline sec &opt tocancel tocheck)",
              "Set a deadline for a fiber `tocheck`. If `tocheck` is not finished after `sec` seconds, "
              "`tocancel` will be canceled as with `ev/cancel`. "
              "If `tocancel` and `tocheck` are not given, they default to `(fiber/root)` and "
              "`(fiber/current)` respectively. Returns `tocancel`.") {
    janet_arity(argc, 1, 3);
    double sec = janet_getnumber(argv, 0);
    JanetFiber *tocancel = janet_optfiber(argv, argc, 1, janet_vm.root_fiber);
    JanetFiber *tocheck = janet_optfiber(argv, argc, 2, janet_vm.fiber);
    JanetTimeout to;
    to.when = ts_delta(ts_now(), sec);
    to.fiber = tocancel;
    to.curr_fiber = tocheck;
    to.is_error = 0;
    to.sched_id = to.fiber->sched_id;
    add_timeout(to);
    return janet_wrap_fiber(tocancel);
}

JANET_CORE_FN(cfun_ev_cancel,
              "(ev/cancel fiber err)",
              "Cancel a suspended fiber in the event loop. Differs from cancel in that it returns the canceled fiber immediately.") {
    janet_fixarity(argc, 2);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    Janet err = argv[1];
    janet_cancel(fiber, err);
    return argv[0];
}

JANET_CORE_FN(janet_cfun_stream_close,
              "(ev/close stream)",
              "Close a stream. This should be the same as calling (:close stream) for all streams.") {
    janet_fixarity(argc, 1);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_close(stream);
    return argv[0];
}

JANET_CORE_FN(janet_cfun_stream_read,
              "(ev/read stream n &opt buffer timeout)",
              "Read up to n bytes into a buffer asynchronously from a stream. `n` can also be the keyword "
              "`:all` to read into the buffer until end of stream. "
              "Optionally provide a buffer to write into "
              "as well as a timeout in seconds after which to cancel the operation and raise an error. "
              "Returns the buffer if the read was successful or nil if end-of-stream reached. Will raise an "
              "error if there are problems with the IO operation.") {
    janet_arity(argc, 2, 4);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_READABLE);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, 10);
    double to = janet_optnumber(argv, argc, 3, INFINITY);
    if (janet_keyeq(argv[1], "all")) {
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_readchunk(stream, buffer, INT32_MAX);
    } else {
        int32_t n = janet_getnat(argv, 1);
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_read(stream, buffer, n);
    }
    janet_await();
}

JANET_CORE_FN(janet_cfun_stream_chunk,
              "(ev/chunk stream n &opt buffer timeout)",
              "Same as ev/read, but will not return early if less than n bytes are available. If an end of "
              "stream is reached, will also return early with the collected bytes.") {
    janet_arity(argc, 2, 4);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_READABLE);
    int32_t n = janet_getnat(argv, 1);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, 10);
    double to = janet_optnumber(argv, argc, 3, INFINITY);
    if (to != INFINITY) janet_addtimeout(to);
    janet_ev_readchunk(stream, buffer, n);
    janet_await();
}

JANET_CORE_FN(janet_cfun_stream_write,
              "(ev/write stream data &opt timeout)",
              "Write data to a stream, suspending the current fiber until the write "
              "completes. Takes an optional timeout in seconds, after which will return nil. "
              "Returns nil, or raises an error if the write failed.") {
    janet_arity(argc, 2, 3);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_WRITABLE);
    double to = janet_optnumber(argv, argc, 2, INFINITY);
    if (janet_checktype(argv[1], JANET_BUFFER)) {
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_write_buffer(stream, janet_getbuffer(argv, 1));
    } else {
        JanetByteView bytes = janet_getbytes(argv, 1);
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_write_string(stream, bytes.bytes);
    }
    janet_await();
}

static int mutexgc(void *p, size_t size) {
    (void) size;
    janet_os_mutex_deinit(p);
    return 0;
}

const JanetAbstractType janet_mutex_type = {
    "core/lock",
    mutexgc,
    JANET_ATEND_GC
};

JANET_CORE_FN(janet_cfun_mutex,
              "(ev/lock)",
              "Create a new lock to coordinate threads.") {
    janet_fixarity(argc, 0);
    (void) argv;
    void *mutex = janet_abstract_threaded(&janet_mutex_type, janet_os_mutex_size());
    janet_os_mutex_init(mutex);
    return janet_wrap_abstract(mutex);
}

JANET_CORE_FN(janet_cfun_mutex_acquire,
              "(ev/acquire-lock lock)",
              "Acquire a lock such that this operating system thread is the only thread with access to this resource."
              " This will block this entire thread until the lock becomes available, and will not yield to other fibers "
              "on this system thread.") {
    janet_fixarity(argc, 1);
    void *mutex = janet_getabstract(argv, 0, &janet_mutex_type);
    janet_os_mutex_lock(mutex);
    return argv[0];
}

JANET_CORE_FN(janet_cfun_mutex_release,
              "(ev/release-lock lock)",
              "Release a lock such that other threads may acquire it.") {
    janet_fixarity(argc, 1);
    void *mutex = janet_getabstract(argv, 0, &janet_mutex_type);
    janet_os_mutex_unlock(mutex);
    return argv[0];
}

static int rwlockgc(void *p, size_t size) {
    (void) size;
    janet_os_rwlock_deinit(p);
    return 0;
}

const JanetAbstractType janet_rwlock_type = {
    "core/rwlock",
    rwlockgc,
    JANET_ATEND_GC
};

JANET_CORE_FN(janet_cfun_rwlock,
              "(ev/rwlock)",
              "Create a new read-write lock to coordinate threads.") {
    janet_fixarity(argc, 0);
    (void) argv;
    void *rwlock = janet_abstract_threaded(&janet_rwlock_type, janet_os_rwlock_size());
    janet_os_rwlock_init(rwlock);
    return janet_wrap_abstract(rwlock);
}

JANET_CORE_FN(janet_cfun_rwlock_read_lock,
              "(ev/acquire-rlock rwlock)",
              "Acquire a read lock an a read-write lock.") {
    janet_fixarity(argc, 1);
    void *rwlock = janet_getabstract(argv, 0, &janet_rwlock_type);
    janet_os_rwlock_rlock(rwlock);
    return argv[0];
}

JANET_CORE_FN(janet_cfun_rwlock_write_lock,
              "(ev/acquire-wlock rwlock)",
              "Acquire a write lock on a read-write lock.") {
    janet_fixarity(argc, 1);
    void *rwlock = janet_getabstract(argv, 0, &janet_rwlock_type);
    janet_os_rwlock_wlock(rwlock);
    return argv[0];
}

JANET_CORE_FN(janet_cfun_rwlock_read_release,
              "(ev/release-rlock rwlock)",
              "Release a read lock on a read-write lock") {
    janet_fixarity(argc, 1);
    void *rwlock = janet_getabstract(argv, 0, &janet_rwlock_type);
    janet_os_rwlock_runlock(rwlock);
    return argv[0];
}

JANET_CORE_FN(janet_cfun_rwlock_write_release,
              "(ev/release-wlock rwlock)",
              "Release a write lock on a read-write lock") {
    janet_fixarity(argc, 1);
    void *rwlock = janet_getabstract(argv, 0, &janet_rwlock_type);
    janet_os_rwlock_wunlock(rwlock);
    return argv[0];
}

void janet_lib_ev(JanetTable *env) {
    JanetRegExt ev_cfuns_ext[] = {
        JANET_CORE_REG("ev/give", cfun_channel_push),
        JANET_CORE_REG("ev/take", cfun_channel_pop),
        JANET_CORE_REG("ev/full", cfun_channel_full),
        JANET_CORE_REG("ev/capacity", cfun_channel_capacity),
        JANET_CORE_REG("ev/count", cfun_channel_count),
        JANET_CORE_REG("ev/select", cfun_channel_choice),
        JANET_CORE_REG("ev/rselect", cfun_channel_rchoice),
        JANET_CORE_REG("ev/chan", cfun_channel_new),
        JANET_CORE_REG("ev/thread-chan", cfun_channel_new_threaded),
        JANET_CORE_REG("ev/chan-close", cfun_channel_close),
        JANET_CORE_REG("ev/go", cfun_ev_go),
        JANET_CORE_REG("ev/thread", cfun_ev_thread),
        JANET_CORE_REG("ev/give-supervisor", cfun_ev_give_supervisor),
        JANET_CORE_REG("ev/sleep", cfun_ev_sleep),
        JANET_CORE_REG("ev/deadline", cfun_ev_deadline),
        JANET_CORE_REG("ev/cancel", cfun_ev_cancel),
        JANET_CORE_REG("ev/close", janet_cfun_stream_close),
        JANET_CORE_REG("ev/read", janet_cfun_stream_read),
        JANET_CORE_REG("ev/chunk", janet_cfun_stream_chunk),
        JANET_CORE_REG("ev/write", janet_cfun_stream_write),
        JANET_CORE_REG("ev/lock", janet_cfun_mutex),
        JANET_CORE_REG("ev/acquire-lock", janet_cfun_mutex_acquire),
        JANET_CORE_REG("ev/release-lock", janet_cfun_mutex_release),
        JANET_CORE_REG("ev/rwlock", janet_cfun_rwlock),
        JANET_CORE_REG("ev/acquire-rlock", janet_cfun_rwlock_read_lock),
        JANET_CORE_REG("ev/acquire-wlock", janet_cfun_rwlock_write_lock),
        JANET_CORE_REG("ev/release-rlock", janet_cfun_rwlock_read_release),
        JANET_CORE_REG("ev/release-wlock", janet_cfun_rwlock_write_release),
        JANET_REG_END
    };

    janet_core_cfuns_ext(env, NULL, ev_cfuns_ext);
    janet_register_abstract_type(&janet_stream_type);
    janet_register_abstract_type(&janet_channel_type);
    janet_register_abstract_type(&janet_mutex_type);
    janet_register_abstract_type(&janet_rwlock_type);
}

#endif


/* src/core/ffi.c */
#line 0 "src/core/ffi.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#ifdef JANET_FFI

#ifdef _MSC_VER
#define alloca _alloca
#elif defined(JANET_LINUX)
#include <alloca.h>
#elif !defined(alloca)
/* Last ditch effort to get alloca - works for gcc and clang */
#define alloca __builtin_alloca
#endif

/* FFI jit includes */
#ifdef JANET_FFI_JIT
#ifndef JANET_WINDOWS
#include <sys/mman.h>
#endif
#endif

#define JANET_FFI_MAX_RECUR 64

/* Compiler, OS, and arch detection. Used
 * to enable a set of calling conventions. The
 * :none calling convention is always enabled. */
#if defined(JANET_WINDOWS) && (defined(__x86_64__) || defined(_M_X64))
#define JANET_FFI_WIN64_ENABLED
#endif
#if (defined(__x86_64__) || defined(_M_X64)) && !defined(JANET_WINDOWS)
#define JANET_FFI_SYSV64_ENABLED
#endif

typedef struct JanetFFIType JanetFFIType;
typedef struct JanetFFIStruct JanetFFIStruct;

typedef enum {
    JANET_FFI_TYPE_VOID,
    JANET_FFI_TYPE_BOOL,
    JANET_FFI_TYPE_PTR,
    JANET_FFI_TYPE_STRING,
    JANET_FFI_TYPE_FLOAT,
    JANET_FFI_TYPE_DOUBLE,
    JANET_FFI_TYPE_INT8,
    JANET_FFI_TYPE_UINT8,
    JANET_FFI_TYPE_INT16,
    JANET_FFI_TYPE_UINT16,
    JANET_FFI_TYPE_INT32,
    JANET_FFI_TYPE_UINT32,
    JANET_FFI_TYPE_INT64,
    JANET_FFI_TYPE_UINT64,
    JANET_FFI_TYPE_STRUCT
} JanetFFIPrimType;

/* Custom alignof since alignof not in c99 standard */
#define ALIGNOF(type) offsetof(struct { char c; type member; }, member)

typedef struct {
    size_t size;
    size_t align;
} JanetFFIPrimInfo;

static const JanetFFIPrimInfo janet_ffi_type_info[] = {
    {0, 0}, /* JANET_FFI_TYPE_VOID */
    {sizeof(char), ALIGNOF(char)}, /* JANET_FFI_TYPE_BOOL */
    {sizeof(void *), ALIGNOF(void *)}, /* JANET_FFI_TYPE_PTR */
    {sizeof(char *), ALIGNOF(char *)}, /* JANET_FFI_TYPE_STRING */
    {sizeof(float), ALIGNOF(float)}, /* JANET_FFI_TYPE_FLOAT */
    {sizeof(double), ALIGNOF(double)}, /* JANET_FFI_TYPE_DOUBLE */
    {sizeof(int8_t), ALIGNOF(int8_t)}, /* JANET_FFI_TYPE_INT8 */
    {sizeof(uint8_t), ALIGNOF(uint8_t)}, /* JANET_FFI_TYPE_UINT8 */
    {sizeof(int16_t), ALIGNOF(int16_t)}, /* JANET_FFI_TYPE_INT16 */
    {sizeof(uint16_t), ALIGNOF(uint16_t)}, /* JANET_FFI_TYPE_UINT16 */
    {sizeof(int32_t), ALIGNOF(int32_t)}, /* JANET_FFI_TYPE_INT32 */
    {sizeof(uint32_t), ALIGNOF(uint32_t)}, /* JANET_FFI_TYPE_UINT32 */
    {sizeof(int64_t), ALIGNOF(int64_t)}, /* JANET_FFI_TYPE_INT64 */
    {sizeof(uint64_t), ALIGNOF(uint64_t)}, /* JANET_FFI_TYPE_UINT64 */
    {0, ALIGNOF(uint64_t)} /* JANET_FFI_TYPE_STRUCT */
};

struct JanetFFIType {
    JanetFFIStruct *st;
    JanetFFIPrimType prim;
    int32_t array_count;
};

typedef struct {
    JanetFFIType type;
    size_t offset;
} JanetFFIStructMember;

/* Also used to store array types */
struct JanetFFIStruct {
    uint32_t size;
    uint32_t align;
    uint32_t field_count;
    uint32_t is_aligned;
    JanetFFIStructMember fields[];
};

/* Specifies how the registers are classified. This is used
 * to determine if a certain argument should be passed in a register,
 * on the stack, special floating pointer register, etc. */
typedef enum {
    JANET_SYSV64_INTEGER,
    JANET_SYSV64_SSE,
    JANET_SYSV64_SSEUP,
    JANET_SYSV64_PAIR_INTINT,
    JANET_SYSV64_PAIR_INTSSE,
    JANET_SYSV64_PAIR_SSEINT,
    JANET_SYSV64_PAIR_SSESSE,
    JANET_SYSV64_NO_CLASS,
    JANET_SYSV64_MEMORY,
    JANET_WIN64_REGISTER,
    JANET_WIN64_STACK,
    JANET_WIN64_REGISTER_REF,
    JANET_WIN64_STACK_REF
} JanetFFIWordSpec;

/* Describe how each Janet argument is interpreted in terms of machine words
 * that will be mapped to registers/stack. */
typedef struct {
    JanetFFIType type;
    JanetFFIWordSpec spec;
    uint32_t offset; /* point to the exact register / stack offset depending on spec. */
    uint32_t offset2; /* for reference passing apis (windows), use to allocate reference */
} JanetFFIMapping;

typedef enum {
    JANET_FFI_CC_NONE,
    JANET_FFI_CC_SYSV_64,
    JANET_FFI_CC_WIN_64
} JanetFFICallingConvention;

#ifdef JANET_FFI_WIN64_ENABLED
#define JANET_FFI_CC_DEFAULT JANET_FFI_CC_WIN_64
#elif defined(JANET_FFI_SYSV64_ENABLED)
#define JANET_FFI_CC_DEFAULT JANET_FFI_CC_SYSV_64
#else
#define JANET_FFI_CC_DEFAULT JANET_FFI_CC_NONE
#endif

#define JANET_FFI_MAX_ARGS 32

typedef struct {
    uint32_t frame_size;
    uint32_t arg_count;
    uint32_t word_count;
    uint32_t variant;
    uint32_t stack_count;
    JanetFFICallingConvention cc;
    JanetFFIMapping ret;
    JanetFFIMapping args[JANET_FFI_MAX_ARGS];
} JanetFFISignature;

int signature_mark(void *p, size_t s) {
    (void) s;
    JanetFFISignature *sig = p;
    for (uint32_t i = 0; i < sig->arg_count; i++) {
        JanetFFIType t = sig->args[i].type;
        if (t.prim == JANET_FFI_TYPE_STRUCT) {
            janet_mark(janet_wrap_abstract(t.st));
        }
    }
    return 0;
}

static const JanetAbstractType janet_signature_type = {
    "core/ffi-signature",
    NULL,
    signature_mark,
    JANET_ATEND_GCMARK
};

int struct_mark(void *p, size_t s) {
    (void) s;
    JanetFFIStruct *st = p;
    for (uint32_t i = 0; i < st->field_count; i++) {
        JanetFFIType t = st->fields[i].type;
        if (t.prim == JANET_FFI_TYPE_STRUCT) {
            janet_mark(janet_wrap_abstract(t.st));
        }
    }
    return 0;
}

typedef struct {
    void *function_pointer;
    size_t size;
} JanetFFIJittedFn;

static const JanetAbstractType janet_struct_type = {
    "core/ffi-struct",
    NULL,
    struct_mark,
    JANET_ATEND_GCMARK
};

static int janet_ffijit_gc(void *p, size_t s) {
    (void) s;
    JanetFFIJittedFn *fn = p;
    if (fn->function_pointer == NULL) return 0;
#ifdef JANET_FFI_JIT
#ifdef JANET_WINDOWS
    VirtualFree(fn->function_pointer, fn->size, MEM_RELEASE);
#else
    munmap(fn->function_pointer, fn->size);
#endif
#endif
    return 0;
}

static JanetByteView janet_ffijit_getbytes(void *p, size_t s) {
    (void) s;
    JanetFFIJittedFn *fn = p;
    JanetByteView bytes;
    bytes.bytes = fn->function_pointer;
    bytes.len = (int32_t) fn->size;
    return bytes;
}

static size_t janet_ffijit_length(void *p, size_t s) {
    (void) s;
    JanetFFIJittedFn *fn = p;
    return fn->size;
}

const JanetAbstractType janet_type_ffijit = {
    .name = "ffi/jitfn",
    .gc = janet_ffijit_gc,
    .bytes = janet_ffijit_getbytes,
    .length = janet_ffijit_length
};

typedef struct {
    Clib clib;
    int closed;
    int is_self;
} JanetAbstractNative;

static const JanetAbstractType janet_native_type = {
    "core/ffi-native",
    JANET_ATEND_NAME
};

static JanetFFIType prim_type(JanetFFIPrimType pt) {
    JanetFFIType t;
    t.prim = pt;
    t.st = NULL;
    t.array_count = -1;
    return t;
}

static size_t type_size(JanetFFIType t) {
    size_t count = t.array_count < 0 ? 1 : (size_t) t.array_count;
    if (t.prim == JANET_FFI_TYPE_STRUCT) {
        return t.st->size * count;
    } else {
        return janet_ffi_type_info[t.prim].size * count;
    }
}

static size_t type_align(JanetFFIType t) {
    if (t.prim == JANET_FFI_TYPE_STRUCT) {
        return t.st->align;
    } else {
        return janet_ffi_type_info[t.prim].align;
    }
}

static JanetFFICallingConvention decode_ffi_cc(const uint8_t *name) {
    if (!janet_cstrcmp(name, "none")) return JANET_FFI_CC_NONE;
#ifdef JANET_FFI_WIN64_ENABLED
    if (!janet_cstrcmp(name, "win64")) return JANET_FFI_CC_WIN_64;
#endif
#ifdef JANET_FFI_SYSV64_ENABLED
    if (!janet_cstrcmp(name, "sysv64")) return JANET_FFI_CC_SYSV_64;
#endif
    if (!janet_cstrcmp(name, "default")) return JANET_FFI_CC_DEFAULT;
    janet_panicf("unknown calling convention %s", name);
}

static JanetFFIPrimType decode_ffi_prim(const uint8_t *name) {
    if (!janet_cstrcmp(name, "void")) return JANET_FFI_TYPE_VOID;
    if (!janet_cstrcmp(name, "bool")) return JANET_FFI_TYPE_BOOL;
    if (!janet_cstrcmp(name, "ptr")) return JANET_FFI_TYPE_PTR;
    if (!janet_cstrcmp(name, "string")) return JANET_FFI_TYPE_STRING;
    if (!janet_cstrcmp(name, "float")) return JANET_FFI_TYPE_FLOAT;
    if (!janet_cstrcmp(name, "double")) return JANET_FFI_TYPE_DOUBLE;
    if (!janet_cstrcmp(name, "int8")) return JANET_FFI_TYPE_INT8;
    if (!janet_cstrcmp(name, "uint8")) return JANET_FFI_TYPE_UINT8;
    if (!janet_cstrcmp(name, "int16")) return JANET_FFI_TYPE_INT16;
    if (!janet_cstrcmp(name, "uint16")) return JANET_FFI_TYPE_UINT16;
    if (!janet_cstrcmp(name, "int32")) return JANET_FFI_TYPE_INT32;
    if (!janet_cstrcmp(name, "uint32")) return JANET_FFI_TYPE_UINT32;
    if (!janet_cstrcmp(name, "int64")) return JANET_FFI_TYPE_INT64;
    if (!janet_cstrcmp(name, "uint64")) return JANET_FFI_TYPE_UINT64;
#ifdef JANET_64
    if (!janet_cstrcmp(name, "size")) return JANET_FFI_TYPE_UINT64;
    if (!janet_cstrcmp(name, "ssize")) return JANET_FFI_TYPE_INT64;
#else
    if (!janet_cstrcmp(name, "size")) return JANET_FFI_TYPE_UINT32;
    if (!janet_cstrcmp(name, "ssize")) return JANET_FFI_TYPE_INT32;
#endif
    /* aliases */
    if (!janet_cstrcmp(name, "r32")) return JANET_FFI_TYPE_FLOAT;
    if (!janet_cstrcmp(name, "r64")) return JANET_FFI_TYPE_DOUBLE;
    if (!janet_cstrcmp(name, "s8")) return JANET_FFI_TYPE_INT8;
    if (!janet_cstrcmp(name, "u8")) return JANET_FFI_TYPE_UINT8;
    if (!janet_cstrcmp(name, "s16")) return JANET_FFI_TYPE_INT16;
    if (!janet_cstrcmp(name, "u16")) return JANET_FFI_TYPE_UINT16;
    if (!janet_cstrcmp(name, "s32")) return JANET_FFI_TYPE_INT32;
    if (!janet_cstrcmp(name, "u32")) return JANET_FFI_TYPE_UINT32;
    if (!janet_cstrcmp(name, "s64")) return JANET_FFI_TYPE_INT64;
    if (!janet_cstrcmp(name, "u64")) return JANET_FFI_TYPE_UINT64;
    if (!janet_cstrcmp(name, "char")) return JANET_FFI_TYPE_INT8;
    if (!janet_cstrcmp(name, "short")) return JANET_FFI_TYPE_INT16;
    if (!janet_cstrcmp(name, "int")) return JANET_FFI_TYPE_INT32;
    if (!janet_cstrcmp(name, "long")) return JANET_FFI_TYPE_INT64;
    if (!janet_cstrcmp(name, "byte")) return JANET_FFI_TYPE_UINT8;
    if (!janet_cstrcmp(name, "uchar")) return JANET_FFI_TYPE_UINT8;
    if (!janet_cstrcmp(name, "ushort")) return JANET_FFI_TYPE_UINT16;
    if (!janet_cstrcmp(name, "uint")) return JANET_FFI_TYPE_UINT32;
    if (!janet_cstrcmp(name, "ulong")) return JANET_FFI_TYPE_UINT64;
    janet_panicf("unknown machine type %s", name);
}

/* A common callback function signature. To avoid runtime code generation, which is prohibited
 * on many platforms, often buggy (see libffi), and generally complicated, instead provide
 * a single (or small set of commonly used function signatures). All callbacks should
 * eventually call this. */
void janet_ffi_trampoline(void *ctx, void *userdata) {
    if (NULL == userdata) {
        /* Userdata not set. */
        janet_eprintf("no userdata found for janet callback");
        return;
    }
    Janet context = janet_wrap_pointer(ctx);
    JanetFunction *fun = userdata;
    janet_call(fun, 1, &context);
}

static JanetFFIType decode_ffi_type(Janet x);

static JanetFFIStruct *build_struct_type(int32_t argc, const Janet *argv) {
    /* Use :pack to indicate a single packed struct member and :pack-all
     * to pack the remaining members */
    int32_t member_count = argc;
    int all_packed = 0;
    for (int32_t i = 0; i < argc; i++) {
        if (janet_keyeq(argv[i], "pack")) {
            member_count--;
        } else if (janet_keyeq(argv[i], "pack-all")) {
            member_count--;
            all_packed = 1;
        }
    }

    JanetFFIStruct *st = janet_abstract(&janet_struct_type,
                                        sizeof(JanetFFIStruct) + argc * sizeof(JanetFFIStructMember));
    st->field_count = member_count;
    st->size = 0;
    st->align = 1;
    if (argc == 0) {
        janet_panic("invalid empty struct");
    }
    uint32_t is_aligned = 1;
    int32_t i = 0;
    for (int32_t j = 0; j < argc; j++) {
        int pack_one = 0;
        if (janet_keyeq(argv[j], "pack") || janet_keyeq(argv[j], "pack-all")) {
            pack_one = 1;
            j++;
            if (j == argc) break;
        }
        st->fields[i].type = decode_ffi_type(argv[j]);
        size_t el_size = type_size(st->fields[i].type);
        size_t el_align = type_align(st->fields[i].type);
        if (all_packed || pack_one) {
            if (st->size % el_align != 0) is_aligned = 0;
            st->fields[i].offset = st->size;
            st->size += (uint32_t) el_size;
        } else {
            if (el_align > st->align) st->align = (uint32_t) el_align;
            st->fields[i].offset = (uint32_t)(((st->size + el_align - 1) / el_align) * el_align);
            st->size = (uint32_t)(el_size + st->fields[i].offset);
        }
        i++;
    }
    st->is_aligned = is_aligned;
    st->size += (st->align - 1);
    st->size /= st->align;
    st->size *= st->align;
    return st;
}

static JanetFFIType decode_ffi_type(Janet x) {
    if (janet_checktype(x, JANET_KEYWORD)) {
        return prim_type(decode_ffi_prim(janet_unwrap_keyword(x)));
    }
    JanetFFIType ret;
    ret.array_count = -1;
    ret.prim = JANET_FFI_TYPE_STRUCT;
    if (janet_checkabstract(x, &janet_struct_type)) {
        ret.st = janet_unwrap_abstract(x);
        return ret;
    }
    int32_t len;
    const Janet *els;
    if (janet_indexed_view(x, &els, &len)) {
        if (janet_checktype(x, JANET_ARRAY)) {
            if (len != 2 && len != 1) janet_panicf("array type must be of form @[type count], got %v", x);
            ret = decode_ffi_type(els[0]);
            int32_t array_count = len == 1 ? 0 : janet_getnat(els, 1);
            ret.array_count = array_count;
        } else {
            ret.st = build_struct_type(len, els);
        }
        return ret;
    } else {
        janet_panicf("bad native type %v", x);
    }
}

JANET_CORE_FN(cfun_ffi_struct,
              "(ffi/struct & types)",
              "Create a struct type definition that can be used to pass structs into native functions. ") {
    janet_arity(argc, 1, -1);
    return janet_wrap_abstract(build_struct_type(argc, argv));
}

JANET_CORE_FN(cfun_ffi_size,
              "(ffi/size type)",
              "Get the size of an ffi type in bytes.") {
    janet_fixarity(argc, 1);
    size_t size = type_size(decode_ffi_type(argv[0]));
    return janet_wrap_number((double) size);
}

JANET_CORE_FN(cfun_ffi_align,
              "(ffi/align type)",
              "Get the align of an ffi type in bytes.") {
    janet_fixarity(argc, 1);
    size_t size = type_align(decode_ffi_type(argv[0]));
    return janet_wrap_number((double) size);
}

static void *janet_ffi_getpointer(const Janet *argv, int32_t n) {
    switch (janet_type(argv[n])) {
        default:
            janet_panicf("bad slot #%d, expected ffi pointer convertable type, got %v", n, argv[n]);
        case JANET_POINTER:
        case JANET_STRING:
        case JANET_KEYWORD:
        case JANET_SYMBOL:
        case JANET_CFUNCTION:
            return janet_unwrap_pointer(argv[n]);
        case JANET_ABSTRACT:
            return (void *) janet_getbytes(argv, n).bytes;
        case JANET_BUFFER:
            return janet_unwrap_buffer(argv[n])->data;
        case JANET_FUNCTION:
            /* Users may pass in a function. Any function passed is almost certainly
             * being used as a callback, so we add it to the root set. */
            janet_gcroot(argv[n]);
            return janet_unwrap_pointer(argv[n]);
        case JANET_NIL:
            return NULL;
    }
}

static void *janet_ffi_get_callable_pointer(const Janet *argv, int32_t n) {
    switch (janet_type(argv[n])) {
        default:
            break;
        case JANET_POINTER:
            return janet_unwrap_pointer(argv[n]);
        case JANET_ABSTRACT:
            if (!janet_checkabstract(argv[n], &janet_type_ffijit)) break;
            return ((JanetFFIJittedFn *)janet_unwrap_abstract(argv[n]))->function_pointer;
    }
    janet_panicf("bad slot #%d, expected ffi callable pointer type, got %v", n, argv[n]);
}

/* Write a value given by some Janet values and an FFI type as it would appear in memory.
 * The alignment and space available is assumed to already be sufficient */
static void janet_ffi_write_one(void *to, const Janet *argv, int32_t n, JanetFFIType type, int recur) {
    if (recur == 0) janet_panic("recursion too deep");
    if (type.array_count >= 0) {
        JanetFFIType el_type = type;
        el_type.array_count = -1;
        size_t el_size = type_size(el_type);
        JanetView els = janet_getindexed(argv, n);
        if (els.len != type.array_count) {
            janet_panicf("bad array length, expected %d, got %d", type.array_count, els.len);
        }
        char *cursor = to;
        for (int32_t i = 0; i < els.len; i++) {
            janet_ffi_write_one(cursor, els.items, i, el_type, recur - 1);
            cursor += el_size;
        }
        return;
    }
    switch (type.prim) {
        case JANET_FFI_TYPE_VOID:
            if (!janet_checktype(argv[n], JANET_NIL)) {
                janet_panicf("expected nil, got %v", argv[n]);
            }
            break;
        case JANET_FFI_TYPE_STRUCT: {
            JanetView els = janet_getindexed(argv, n);
            JanetFFIStruct *st = type.st;
            if ((uint32_t) els.len != st->field_count) {
                janet_panicf("wrong number of fields in struct, expected %d, got %d",
                             (int32_t) st->field_count, els.len);
            }
            for (int32_t i = 0; i < els.len; i++) {
                JanetFFIType tp = st->fields[i].type;
                janet_ffi_write_one((char *) to + st->fields[i].offset, els.items, i, tp, recur - 1);
            }
        }
        break;
        case JANET_FFI_TYPE_DOUBLE:
            ((double *)(to))[0] = janet_getnumber(argv, n);
            break;
        case JANET_FFI_TYPE_FLOAT:
            ((float *)(to))[0] = (float) janet_getnumber(argv, n);
            break;
        case JANET_FFI_TYPE_PTR:
            ((void **)(to))[0] = janet_ffi_getpointer(argv, n);
            break;
        case JANET_FFI_TYPE_STRING:
            ((const char **)(to))[0] = janet_getcstring(argv, n);
            break;
        case JANET_FFI_TYPE_BOOL:
            ((bool *)(to))[0] = janet_getboolean(argv, n);
            break;
        case JANET_FFI_TYPE_INT8:
            ((int8_t *)(to))[0] = janet_getinteger(argv, n);
            break;
        case JANET_FFI_TYPE_INT16:
            ((int16_t *)(to))[0] = janet_getinteger(argv, n);
            break;
        case JANET_FFI_TYPE_INT32:
            ((int32_t *)(to))[0] = janet_getinteger(argv, n);
            break;
        case JANET_FFI_TYPE_INT64:
            ((int64_t *)(to))[0] = janet_getinteger64(argv, n);
            break;
        case JANET_FFI_TYPE_UINT8:
            ((uint8_t *)(to))[0] = (uint8_t) janet_getuinteger64(argv, n);
            break;
        case JANET_FFI_TYPE_UINT16:
            ((uint16_t *)(to))[0] = (uint16_t) janet_getuinteger64(argv, n);
            break;
        case JANET_FFI_TYPE_UINT32:
            ((uint32_t *)(to))[0] = (uint32_t) janet_getuinteger64(argv, n);
            break;
        case JANET_FFI_TYPE_UINT64:
            ((uint64_t *)(to))[0] = janet_getuinteger64(argv, n);
            break;
    }
}

/* Read a value from memory and construct a Janet data structure that can be passed back into
 * the interpreter. This should be the inverse to janet_ffi_write_one. It is assumed that the
 * size of the data is correct. */
static Janet janet_ffi_read_one(const uint8_t *from, JanetFFIType type, int recur) {
    if (recur == 0) janet_panic("recursion too deep");
    if (type.array_count >= 0) {
        JanetFFIType el_type = type;
        el_type.array_count = -1;
        size_t el_size = type_size(el_type);
        JanetArray *array = janet_array(type.array_count);
        for (int32_t i = 0; i < type.array_count; i++) {
            janet_array_push(array, janet_ffi_read_one(from, el_type, recur - 1));
            from += el_size;
        }
        return janet_wrap_array(array);
    }
    switch (type.prim) {
        default:
        case JANET_FFI_TYPE_VOID:
            return janet_wrap_nil();
        case JANET_FFI_TYPE_STRUCT: {
            JanetFFIStruct *st = type.st;
            Janet *tup = janet_tuple_begin(st->field_count);
            for (uint32_t i = 0; i < st->field_count; i++) {
                JanetFFIType tp = st->fields[i].type;
                tup[i] = janet_ffi_read_one(from + st->fields[i].offset, tp, recur - 1);
            }
            return janet_wrap_tuple(janet_tuple_end(tup));
        }
        case JANET_FFI_TYPE_DOUBLE:
            return janet_wrap_number(((double *)(from))[0]);
        case JANET_FFI_TYPE_FLOAT:
            return janet_wrap_number(((float *)(from))[0]);
        case JANET_FFI_TYPE_PTR: {
            void *ptr = ((void **)(from))[0];
            return (NULL == ptr) ? janet_wrap_nil() : janet_wrap_pointer(ptr);
        }
        case JANET_FFI_TYPE_STRING:
            return janet_cstringv(((char **)(from))[0]);
        case JANET_FFI_TYPE_BOOL:
            return janet_wrap_boolean(((bool *)(from))[0]);
        case JANET_FFI_TYPE_INT8:
            return janet_wrap_number(((int8_t *)(from))[0]);
        case JANET_FFI_TYPE_INT16:
            return janet_wrap_number(((int16_t *)(from))[0]);
        case JANET_FFI_TYPE_INT32:
            return janet_wrap_number(((int32_t *)(from))[0]);
        case JANET_FFI_TYPE_UINT8:
            return janet_wrap_number(((uint8_t *)(from))[0]);
        case JANET_FFI_TYPE_UINT16:
            return janet_wrap_number(((uint16_t *)(from))[0]);
        case JANET_FFI_TYPE_UINT32:
            return janet_wrap_number(((uint32_t *)(from))[0]);
#ifdef JANET_INT_TYPES
        case JANET_FFI_TYPE_INT64:
            return janet_wrap_s64(((int64_t *)(from))[0]);
        case JANET_FFI_TYPE_UINT64:
            return janet_wrap_u64(((uint64_t *)(from))[0]);
#else
        case JANET_FFI_TYPE_INT64:
            return janet_wrap_number(((int64_t *)(from))[0]);
        case JANET_FFI_TYPE_UINT64:
            return janet_wrap_number(((uint64_t *)(from))[0]);
#endif
    }
}

static JanetFFIMapping void_mapping(void) {
    JanetFFIMapping m;
    m.type = prim_type(JANET_FFI_TYPE_VOID);
    m.spec = JANET_SYSV64_NO_CLASS;
    m.offset = 0;
    return m;
}

#ifdef JANET_FFI_SYSV64_ENABLED
/* AMD64 ABI Draft 0.99.7  November 17, 2014  15:08
 * See section 3.2.3 Parameter Passing */
static JanetFFIWordSpec sysv64_classify_ext(JanetFFIType type, size_t shift) {
    switch (type.prim) {
        case JANET_FFI_TYPE_PTR:
        case JANET_FFI_TYPE_STRING:
        case JANET_FFI_TYPE_BOOL:
        case JANET_FFI_TYPE_INT8:
        case JANET_FFI_TYPE_INT16:
        case JANET_FFI_TYPE_INT32:
        case JANET_FFI_TYPE_INT64:
        case JANET_FFI_TYPE_UINT8:
        case JANET_FFI_TYPE_UINT16:
        case JANET_FFI_TYPE_UINT32:
        case JANET_FFI_TYPE_UINT64:
            return JANET_SYSV64_INTEGER;
        case JANET_FFI_TYPE_DOUBLE:
        case JANET_FFI_TYPE_FLOAT:
            return JANET_SYSV64_SSE;
        case JANET_FFI_TYPE_STRUCT: {
            JanetFFIStruct *st = type.st;
            if (st->size > 16) return JANET_SYSV64_MEMORY;
            if (!st->is_aligned) return JANET_SYSV64_MEMORY;
            JanetFFIWordSpec clazz = JANET_SYSV64_NO_CLASS;
            if (st->size > 8 && st->size <= 16) {
                /* map to pair classification */
                int has_int_lo = 0;
                int has_int_hi = 0;
                for (uint32_t i = 0; i < st->field_count; i++) {
                    JanetFFIWordSpec next_class = sysv64_classify_ext(st->fields[i].type, shift + st->fields[i].offset);
                    switch (next_class) {
                        default:
                            break;
                        case JANET_SYSV64_INTEGER:
                            if (shift + st->fields[i].offset + type_size(st->fields[i].type) <= 8) {
                                has_int_lo = 1;
                            } else {
                                has_int_hi = 2;
                            }
                            break;
                        case JANET_SYSV64_PAIR_INTINT:
                            has_int_lo = 1;
                            has_int_hi = 2;
                            break;
                        case JANET_SYSV64_PAIR_INTSSE:
                            has_int_lo = 1;
                            break;
                        case JANET_SYSV64_PAIR_SSEINT:
                            has_int_hi = 2;
                            break;
                            break;
                    }
                }
                switch (has_int_hi + has_int_lo) {
                    case 0:
                        clazz = JANET_SYSV64_PAIR_SSESSE;
                        break;
                    case 1:
                        clazz = JANET_SYSV64_PAIR_INTSSE;
                        break;
                    case 2:
                        clazz = JANET_SYSV64_PAIR_SSEINT;
                        break;
                    case 3:
                        clazz = JANET_SYSV64_PAIR_INTINT;
                        break;
                }
            } else {
                /* Normal struct classification */
                for (uint32_t i = 0; i < st->field_count; i++) {
                    JanetFFIWordSpec next_class = sysv64_classify_ext(st->fields[i].type, shift + st->fields[i].offset);
                    if (next_class != clazz) {
                        if (clazz == JANET_SYSV64_NO_CLASS) {
                            clazz = next_class;
                        } else if (clazz == JANET_SYSV64_MEMORY || next_class == JANET_SYSV64_MEMORY) {
                            clazz = JANET_SYSV64_MEMORY;
                        } else if (clazz == JANET_SYSV64_INTEGER || next_class == JANET_SYSV64_INTEGER) {
                            clazz = JANET_SYSV64_INTEGER;
                        } else {
                            clazz = JANET_SYSV64_SSE;
                        }
                    }
                }
            }
            return clazz;
        }
        case JANET_FFI_TYPE_VOID:
            return JANET_SYSV64_NO_CLASS;
        default:
            janet_panic("nyi");
            return JANET_SYSV64_NO_CLASS;
    }
}
static JanetFFIWordSpec sysv64_classify(JanetFFIType type) {
    return sysv64_classify_ext(type, 0);
}
#endif

JANET_CORE_FN(cfun_ffi_signature,
              "(ffi/signature calling-convention ret-type & arg-types)",
              "Create a function signature object that can be used to make calls "
              "with raw function pointers.") {
    janet_arity(argc, 2, -1);
    uint32_t frame_size = 0;
    uint32_t variant = 0;
    uint32_t arg_count = argc - 2;
    uint32_t stack_count = 0;
    JanetFFICallingConvention cc = decode_ffi_cc(janet_getkeyword(argv, 0));
    JanetFFIType ret_type = decode_ffi_type(argv[1]);
    JanetFFIMapping ret = {
        ret_type,
        JANET_SYSV64_NO_CLASS,
        0,
        0
    };
    JanetFFIMapping mappings[JANET_FFI_MAX_ARGS];
    for (int i = 0; i < JANET_FFI_MAX_ARGS; i++) mappings[i] = void_mapping();
    switch (cc) {
        default:
        case JANET_FFI_CC_NONE: {
            /* Even if unsupported, we can check that the signature is valid
             * and error at runtime */
            for (uint32_t i = 0; i < arg_count; i++) {
                decode_ffi_type(argv[i + 2]);
            }
        }
        break;

#ifdef JANET_FFI_WIN64_ENABLED
        case JANET_FFI_CC_WIN_64: {
            size_t ret_size = type_size(ret.type);
            uint32_t ref_stack_count = 0;
            ret.spec = JANET_WIN64_REGISTER;
            uint32_t next_register = 0;
            if (ret_size != 0 && ret_size != 1 && ret_size != 2 && ret_size != 4 && ret_size != 8) {
                ret.spec = JANET_WIN64_REGISTER_REF;
                next_register++;
            } else if (ret.type.prim == JANET_FFI_TYPE_FLOAT ||
                       ret.type.prim == JANET_FFI_TYPE_DOUBLE) {
                variant += 16;
            }
            for (uint32_t i = 0; i < arg_count; i++) {
                mappings[i].type = decode_ffi_type(argv[i + 2]);
                size_t el_size = type_size(mappings[i].type);
                int is_register_sized = (el_size == 1 || el_size == 2 || el_size == 4 || el_size == 8);
                if (next_register < 4) {
                    mappings[i].offset = next_register;
                    if (is_register_sized) {
                        mappings[i].spec = JANET_WIN64_REGISTER;
                        if (mappings[i].type.prim == JANET_FFI_TYPE_FLOAT ||
                                mappings[i].type.prim == JANET_FFI_TYPE_DOUBLE) {
                            variant += 1 << (3 - next_register);
                        }
                    } else {
                        mappings[i].spec = JANET_WIN64_REGISTER_REF;
                        mappings[i].offset2 = ref_stack_count;
                        ref_stack_count += (uint32_t)((el_size + 15) / 16);
                    }
                    next_register++;
                } else {
                    if (is_register_sized) {
                        mappings[i].spec = JANET_WIN64_STACK;
                        mappings[i].offset = stack_count;
                        stack_count++;
                    } else {
                        mappings[i].spec = JANET_WIN64_STACK_REF;
                        mappings[i].offset = stack_count;
                        stack_count++;
                        mappings[i].offset2 = ref_stack_count;
                        ref_stack_count += (uint32_t)((el_size + 15) / 16);
                    }
                }
            }

            /* Add reference items */
            size_t old_stack_count = stack_count;
            stack_count += 2 * ref_stack_count;
            if (stack_count & 0x1) {
                stack_count++;
            }

            /* Invert stack
             * Offsets are in units of 8-bytes */
            for (uint32_t i = 0; i < arg_count; i++) {
                if (mappings[i].spec == JANET_WIN64_STACK_REF || mappings[i].spec == JANET_WIN64_REGISTER_REF) {
                    /* Align size to 16 bytes */
                    size_t size = (type_size(mappings[i].type) + 15) & ~0xFUL;
                    mappings[i].offset2 = (uint32_t)(stack_count - mappings[i].offset2 - (size / 8));
                }
            }

        }
        break;
#endif

#ifdef JANET_FFI_SYSV64_ENABLED
        case JANET_FFI_CC_SYSV_64: {
            JanetFFIWordSpec ret_spec = sysv64_classify(ret.type);
            ret.spec = ret_spec;
            if (ret_spec == JANET_SYSV64_SSE) variant = 1;
            if (ret_spec == JANET_SYSV64_PAIR_INTSSE) variant = 2;
            if (ret_spec == JANET_SYSV64_PAIR_SSEINT) variant = 3;
            /* Spill register overflow to memory */
            uint32_t next_register = 0;
            uint32_t next_fp_register = 0;
            const uint32_t max_regs = 6;
            const uint32_t max_fp_regs = 8;
            if (ret_spec == JANET_SYSV64_MEMORY) {
                /* First integer reg is pointer. */
                next_register = 1;
            }
            for (uint32_t i = 0; i < arg_count; i++) {
                mappings[i].type = decode_ffi_type(argv[i + 2]);
                mappings[i].offset = 0;
                mappings[i].spec = sysv64_classify(mappings[i].type);
                if (mappings[i].spec == JANET_SYSV64_NO_CLASS) {
                    janet_panic("unexpected void parameter");
                }
                size_t el_size = (type_size(mappings[i].type) + 7) / 8;
                switch (mappings[i].spec) {
                    default:
                        janet_panicf("nyi: %d", mappings[i].spec);
                    case JANET_SYSV64_INTEGER: {
                        if (next_register < max_regs) {
                            mappings[i].offset = next_register++;
                        } else {
                            mappings[i].spec = JANET_SYSV64_MEMORY;
                            mappings[i].offset = stack_count;
                            stack_count += el_size;
                        }
                    }
                    break;
                    case JANET_SYSV64_SSE: {
                        if (next_fp_register < max_fp_regs) {
                            mappings[i].offset = next_fp_register++;
                        } else {
                            mappings[i].spec = JANET_SYSV64_MEMORY;
                            mappings[i].offset = stack_count;
                            stack_count += el_size;
                        }
                    }
                    break;
                    case JANET_SYSV64_MEMORY: {
                        mappings[i].offset = stack_count;
                        stack_count += el_size;
                    }
                    break;
                    case JANET_SYSV64_PAIR_INTINT: {
                        if (next_register + 1 < max_regs) {
                            mappings[i].offset = next_register++;
                            mappings[i].offset2 = next_register++;
                        } else {
                            mappings[i].spec = JANET_SYSV64_MEMORY;
                            mappings[i].offset = stack_count;
                            stack_count += el_size;
                        }
                    }
                    break;
                    case JANET_SYSV64_PAIR_INTSSE: {
                        if (next_register < max_regs && next_fp_register < max_fp_regs) {
                            mappings[i].offset = next_register++;
                            mappings[i].offset2 = next_fp_register++;
                        } else {
                            mappings[i].spec = JANET_SYSV64_MEMORY;
                            mappings[i].offset = stack_count;
                            stack_count += el_size;
                        }
                    }
                    break;
                    case JANET_SYSV64_PAIR_SSEINT: {
                        if (next_register < max_regs && next_fp_register < max_fp_regs) {
                            mappings[i].offset = next_fp_register++;
                            mappings[i].offset2 = next_register++;
                        } else {
                            mappings[i].spec = JANET_SYSV64_MEMORY;
                            mappings[i].offset = stack_count;
                            stack_count += el_size;
                        }
                    }
                    break;
                    case JANET_SYSV64_PAIR_SSESSE: {
                        if (next_fp_register < max_fp_regs) {
                            mappings[i].offset = next_fp_register++;
                            mappings[i].offset2 = next_fp_register++;
                        } else {
                            mappings[i].spec = JANET_SYSV64_MEMORY;
                            mappings[i].offset = stack_count;
                            stack_count += el_size;
                        }
                    }
                    break;
                }
            }
        }
        break;
#endif
    }

    /* Create signature abstract value */
    JanetFFISignature *abst = janet_abstract(&janet_signature_type, sizeof(JanetFFISignature));
    abst->frame_size = frame_size;
    abst->cc = cc;
    abst->ret = ret;
    abst->arg_count = arg_count;
    abst->variant = variant;
    abst->stack_count = stack_count;
    memcpy(abst->args, mappings, sizeof(JanetFFIMapping) * JANET_FFI_MAX_ARGS);
    return janet_wrap_abstract(abst);
}

#ifdef JANET_FFI_SYSV64_ENABLED

static void janet_ffi_sysv64_standard_callback(void *ctx, void *userdata) {
    janet_ffi_trampoline(ctx, userdata);
}

/* Functions that set all argument registers. Two variants - one to read rax and rdx returns, another
 * to read xmm0 and xmm1 returns. */
typedef struct {
    uint64_t x;
    uint64_t y;
} sysv64_int_return;
typedef struct {
    double x;
    double y;
} sysv64_sse_return;
typedef struct {
    uint64_t x;
    double y;
} sysv64_intsse_return;
typedef struct {
    double y;
    uint64_t x;
} sysv64_sseint_return;
typedef sysv64_int_return janet_sysv64_variant_1(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f,
        double r1, double r2, double r3, double r4, double r5, double r6, double r7, double r8);
typedef sysv64_sse_return janet_sysv64_variant_2(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f,
        double r1, double r2, double r3, double r4, double r5, double r6, double r7, double r8);
typedef sysv64_intsse_return janet_sysv64_variant_3(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f,
        double r1, double r2, double r3, double r4, double r5, double r6, double r7, double r8);
typedef sysv64_sseint_return janet_sysv64_variant_4(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f,
        double r1, double r2, double r3, double r4, double r5, double r6, double r7, double r8);

static Janet janet_ffi_sysv64(JanetFFISignature *signature, void *function_pointer, const Janet *argv) {
    union {
        sysv64_int_return int_return;
        sysv64_sse_return sse_return;
        sysv64_sseint_return sseint_return;
        sysv64_intsse_return intsse_return;
    } retu;
    uint64_t pair[2];
    uint64_t regs[6];
    double fp_regs[8];
    JanetFFIWordSpec ret_spec = signature->ret.spec;
    void *ret_mem = &retu.int_return;
    if (ret_spec == JANET_SYSV64_MEMORY) {
        ret_mem = alloca(type_size(signature->ret.type));
        regs[0] = (uint64_t) ret_mem;
    }
    uint64_t *stack = alloca(sizeof(uint64_t) * signature->stack_count);
    for (uint32_t i = 0; i < signature->arg_count; i++) {
        uint64_t *to;
        int32_t n = i + 2;
        JanetFFIMapping arg = signature->args[i];
        switch (arg.spec) {
            default:
                janet_panic("nyi");
            case JANET_SYSV64_INTEGER:
                to = regs + arg.offset;
                break;
            case JANET_SYSV64_SSE:
                to = (uint64_t *)(fp_regs + arg.offset);
                break;
            case JANET_SYSV64_MEMORY:
                to = stack + arg.offset;
                break;
            case JANET_SYSV64_PAIR_INTINT:
                janet_ffi_write_one(pair, argv, n, arg.type, JANET_FFI_MAX_RECUR);
                regs[arg.offset] = pair[0];
                regs[arg.offset2] = pair[1];
                continue;
            case JANET_SYSV64_PAIR_INTSSE:
                janet_ffi_write_one(pair, argv, n, arg.type, JANET_FFI_MAX_RECUR);
                regs[arg.offset] = pair[0];
                ((uint64_t *) fp_regs)[arg.offset2] = pair[1];
                continue;
            case JANET_SYSV64_PAIR_SSEINT:
                janet_ffi_write_one(pair, argv, n, arg.type, JANET_FFI_MAX_RECUR);
                ((uint64_t *) fp_regs)[arg.offset] = pair[0];
                regs[arg.offset2] = pair[1];
                continue;
            case JANET_SYSV64_PAIR_SSESSE:
                janet_ffi_write_one(pair, argv, n, arg.type, JANET_FFI_MAX_RECUR);
                ((uint64_t *) fp_regs)[arg.offset] = pair[0];
                ((uint64_t *) fp_regs)[arg.offset2] = pair[1];
                continue;
        }
        janet_ffi_write_one(to, argv, n, arg.type, JANET_FFI_MAX_RECUR);
    }

    switch (signature->variant) {
        case 0:
            retu.int_return = ((janet_sysv64_variant_1 *)(function_pointer))(
                                  regs[0], regs[1], regs[2], regs[3], regs[4], regs[5],
                                  fp_regs[0], fp_regs[1], fp_regs[2], fp_regs[3],
                                  fp_regs[4], fp_regs[5], fp_regs[6], fp_regs[7]);
            break;
        case 1:
            retu.sse_return = ((janet_sysv64_variant_2 *)(function_pointer))(
                                  regs[0], regs[1], regs[2], regs[3], regs[4], regs[5],
                                  fp_regs[0], fp_regs[1], fp_regs[2], fp_regs[3],
                                  fp_regs[4], fp_regs[5], fp_regs[6], fp_regs[7]);
            break;
        case 2:
            retu.intsse_return = ((janet_sysv64_variant_3 *)(function_pointer))(
                                     regs[0], regs[1], regs[2], regs[3], regs[4], regs[5],
                                     fp_regs[0], fp_regs[1], fp_regs[2], fp_regs[3],
                                     fp_regs[4], fp_regs[5], fp_regs[6], fp_regs[7]);
            break;
        case 3:
            retu.sseint_return = ((janet_sysv64_variant_4 *)(function_pointer))(
                                     regs[0], regs[1], regs[2], regs[3], regs[4], regs[5],
                                     fp_regs[0], fp_regs[1], fp_regs[2], fp_regs[3],
                                     fp_regs[4], fp_regs[5], fp_regs[6], fp_regs[7]);
            break;
    }

    return janet_ffi_read_one(ret_mem, signature->ret.type, JANET_FFI_MAX_RECUR);
}

#endif

#ifdef JANET_FFI_WIN64_ENABLED

static void janet_ffi_win64_standard_callback(void *ctx, void *userdata) {
    janet_ffi_trampoline(ctx, userdata);
}

/* Variants that allow setting all required registers for 64 bit windows calling convention.
 * win64 calling convention has up to 4 arguments on registers, and one register for returns.
 * Each register can either be an integer or floating point register, resulting in
 * 2^5 = 32 variants. Unlike sysv, there are no function signatures that will fill
 * all of the possible registers which is why we have so many variants. If you were using
 * assembly, you could manually fill all of the registers and only have a single variant.
 * And msvc does not support inline assembly on 64 bit targets, so yeah, we have this hackery. */
typedef uint64_t (win64_variant_i_iiii)(uint64_t, uint64_t, uint64_t, uint64_t);
typedef uint64_t (win64_variant_i_iiif)(uint64_t, uint64_t, uint64_t, double);
typedef uint64_t (win64_variant_i_iifi)(uint64_t, uint64_t, double, uint64_t);
typedef uint64_t (win64_variant_i_iiff)(uint64_t, uint64_t, double, double);
typedef uint64_t (win64_variant_i_ifii)(uint64_t, double, uint64_t, uint64_t);
typedef uint64_t (win64_variant_i_ifif)(uint64_t, double, uint64_t, double);
typedef uint64_t (win64_variant_i_iffi)(uint64_t, double, double, uint64_t);
typedef uint64_t (win64_variant_i_ifff)(uint64_t, double, double, double);
typedef uint64_t (win64_variant_i_fiii)(double, uint64_t, uint64_t, uint64_t);
typedef uint64_t (win64_variant_i_fiif)(double, uint64_t, uint64_t, double);
typedef uint64_t (win64_variant_i_fifi)(double, uint64_t, double, uint64_t);
typedef uint64_t (win64_variant_i_fiff)(double, uint64_t, double, double);
typedef uint64_t (win64_variant_i_ffii)(double, double, uint64_t, uint64_t);
typedef uint64_t (win64_variant_i_ffif)(double, double, uint64_t, double);
typedef uint64_t (win64_variant_i_fffi)(double, double, double, uint64_t);
typedef uint64_t (win64_variant_i_ffff)(double, double, double, double);
typedef double (win64_variant_f_iiii)(uint64_t, uint64_t, uint64_t, uint64_t);
typedef double (win64_variant_f_iiif)(uint64_t, uint64_t, uint64_t, double);
typedef double (win64_variant_f_iifi)(uint64_t, uint64_t, double, uint64_t);
typedef double (win64_variant_f_iiff)(uint64_t, uint64_t, double, double);
typedef double (win64_variant_f_ifii)(uint64_t, double, uint64_t, uint64_t);
typedef double (win64_variant_f_ifif)(uint64_t, double, uint64_t, double);
typedef double (win64_variant_f_iffi)(uint64_t, double, double, uint64_t);
typedef double (win64_variant_f_ifff)(uint64_t, double, double, double);
typedef double (win64_variant_f_fiii)(double, uint64_t, uint64_t, uint64_t);
typedef double (win64_variant_f_fiif)(double, uint64_t, uint64_t, double);
typedef double (win64_variant_f_fifi)(double, uint64_t, double, uint64_t);
typedef double (win64_variant_f_fiff)(double, uint64_t, double, double);
typedef double (win64_variant_f_ffii)(double, double, uint64_t, uint64_t);
typedef double (win64_variant_f_ffif)(double, double, uint64_t, double);
typedef double (win64_variant_f_fffi)(double, double, double, uint64_t);
typedef double (win64_variant_f_ffff)(double, double, double, double);

static Janet janet_ffi_win64(JanetFFISignature *signature, void *function_pointer, const Janet *argv) {
    union {
        uint64_t integer;
        double real;
    } regs[4];
    union {
        uint64_t integer;
        double real;
    } ret_reg;
    JanetFFIWordSpec ret_spec = signature->ret.spec;
    void *ret_mem = &ret_reg.integer;
    if (ret_spec == JANET_WIN64_REGISTER_REF) {
        ret_mem = alloca(type_size(signature->ret.type));
        regs[0].integer = (uint64_t) ret_mem;
    }
    size_t stack_size = signature->stack_count * 8;
    size_t stack_shift = 2;
    uint64_t *stack = alloca(stack_size);
    for (uint32_t i = 0; i < signature->arg_count; i++) {
        int32_t n = i + 2;
        JanetFFIMapping arg = signature->args[i];
        if (arg.spec == JANET_WIN64_STACK) {
            janet_ffi_write_one(stack + arg.offset, argv, n, arg.type, JANET_FFI_MAX_RECUR);
        } else if (arg.spec == JANET_WIN64_STACK_REF) {
            uint8_t *ptr = (uint8_t *)(stack + arg.offset2);
            janet_ffi_write_one(ptr, argv, n, arg.type, JANET_FFI_MAX_RECUR);
            stack[arg.offset] = (uint64_t)(ptr - stack_shift * sizeof(uint64_t));
        } else if (arg.spec == JANET_WIN64_REGISTER_REF) {
            uint8_t *ptr = (uint8_t *)(stack + arg.offset2);
            janet_ffi_write_one(ptr, argv, n, arg.type, JANET_FFI_MAX_RECUR);
            regs[arg.offset].integer = (uint64_t)(ptr - stack_shift * sizeof(uint64_t));
        } else {
            janet_ffi_write_one((uint8_t *) &regs[arg.offset].integer, argv, n, arg.type, JANET_FFI_MAX_RECUR);
        }
    }

    /* hack to get proper stack placement and avoid clobbering from logic above - shift stack down, otherwise we have issues.
     * Technically, this writes into 16 bytes of unallocated stack memory */
    if (stack_size) memmove(stack - stack_shift, stack, stack_size);

    switch (signature->variant) {
        default:
            janet_panicf("unknown variant %d", signature->variant);
        case 0:
            ret_reg.integer = ((win64_variant_i_iiii *) function_pointer)(regs[0].integer, regs[1].integer, regs[2].integer, regs[3].integer);
            break;
        case 1:
            ret_reg.integer = ((win64_variant_i_iiif *) function_pointer)(regs[0].integer, regs[1].integer, regs[2].integer, regs[3].real);
            break;
        case 2:
            ret_reg.integer = ((win64_variant_i_iifi *) function_pointer)(regs[0].integer, regs[1].integer, regs[2].real, regs[3].integer);
            break;
        case 3:
            ret_reg.integer = ((win64_variant_i_iiff *) function_pointer)(regs[0].integer, regs[1].integer, regs[2].real, regs[3].real);
            break;
        case 4:
            ret_reg.integer = ((win64_variant_i_ifii *) function_pointer)(regs[0].integer, regs[1].real, regs[2].integer, regs[3].integer);
            break;
        case 5:
            ret_reg.integer = ((win64_variant_i_ifif *) function_pointer)(regs[0].integer, regs[1].real, regs[2].integer, regs[3].real);
            break;
        case 6:
            ret_reg.integer = ((win64_variant_i_iffi *) function_pointer)(regs[0].integer, regs[1].real, regs[2].real, regs[3].integer);
            break;
        case 7:
            ret_reg.integer = ((win64_variant_i_ifff *) function_pointer)(regs[0].integer, regs[1].real, regs[2].real, regs[3].real);
            break;
        case 8:
            ret_reg.integer = ((win64_variant_i_fiii *) function_pointer)(regs[0].real, regs[1].integer, regs[2].integer, regs[3].integer);
            break;
        case 9:
            ret_reg.integer = ((win64_variant_i_fiif *) function_pointer)(regs[0].real, regs[1].integer, regs[2].integer, regs[3].real);
            break;
        case 10:
            ret_reg.integer = ((win64_variant_i_fifi *) function_pointer)(regs[0].real, regs[1].integer, regs[2].real, regs[3].integer);
            break;
        case 11:
            ret_reg.integer = ((win64_variant_i_fiff *) function_pointer)(regs[0].real, regs[1].integer, regs[2].real, regs[3].real);
            break;
        case 12:
            ret_reg.integer = ((win64_variant_i_ffii *) function_pointer)(regs[0].real, regs[1].real, regs[2].integer, regs[3].integer);
            break;
        case 13:
            ret_reg.integer = ((win64_variant_i_ffif *) function_pointer)(regs[0].real, regs[1].real, regs[2].integer, regs[3].real);
            break;
        case 14:
            ret_reg.integer = ((win64_variant_i_fffi *) function_pointer)(regs[0].real, regs[1].real, regs[2].real, regs[3].integer);
            break;
        case 15:
            ret_reg.integer = ((win64_variant_i_ffff *) function_pointer)(regs[0].real, regs[1].real, regs[2].real, regs[3].real);
            break;
        case 16:
            ret_reg.real = ((win64_variant_f_iiii *) function_pointer)(regs[0].integer, regs[1].integer, regs[2].integer, regs[3].integer);
            break;
        case 17:
            ret_reg.real = ((win64_variant_f_iiif *) function_pointer)(regs[0].integer, regs[1].integer, regs[2].integer, regs[3].real);
            break;
        case 18:
            ret_reg.real = ((win64_variant_f_iifi *) function_pointer)(regs[0].integer, regs[1].integer, regs[2].real, regs[3].integer);
            break;
        case 19:
            ret_reg.real = ((win64_variant_f_iiff *) function_pointer)(regs[0].integer, regs[1].integer, regs[2].real, regs[3].real);
            break;
        case 20:
            ret_reg.real = ((win64_variant_f_ifii *) function_pointer)(regs[0].integer, regs[1].real, regs[2].integer, regs[3].integer);
            break;
        case 21:
            ret_reg.real = ((win64_variant_f_ifif *) function_pointer)(regs[0].integer, regs[1].real, regs[2].integer, regs[3].real);
            break;
        case 22:
            ret_reg.real = ((win64_variant_f_iffi *) function_pointer)(regs[0].integer, regs[1].real, regs[2].real, regs[3].integer);
            break;
        case 23:
            ret_reg.real = ((win64_variant_f_ifff *) function_pointer)(regs[0].integer, regs[1].real, regs[2].real, regs[3].real);
            break;
        case 24:
            ret_reg.real = ((win64_variant_f_fiii *) function_pointer)(regs[0].real, regs[1].integer, regs[2].integer, regs[3].integer);
            break;
        case 25:
            ret_reg.real = ((win64_variant_f_fiif *) function_pointer)(regs[0].real, regs[1].integer, regs[2].integer, regs[3].real);
            break;
        case 26:
            ret_reg.real = ((win64_variant_f_fifi *) function_pointer)(regs[0].real, regs[1].integer, regs[2].real, regs[3].integer);
            break;
        case 27:
            ret_reg.real = ((win64_variant_f_fiff *) function_pointer)(regs[0].real, regs[1].integer, regs[2].real, regs[3].real);
            break;
        case 28:
            ret_reg.real = ((win64_variant_f_ffii *) function_pointer)(regs[0].real, regs[1].real, regs[2].integer, regs[3].integer);
            break;
        case 29:
            ret_reg.real = ((win64_variant_f_ffif *) function_pointer)(regs[0].real, regs[1].real, regs[2].integer, regs[3].real);
            break;
        case 30:
            ret_reg.real = ((win64_variant_f_fffi *) function_pointer)(regs[0].real, regs[1].real, regs[2].real, regs[3].integer);
            break;
        case 31:
            ret_reg.real = ((win64_variant_f_ffff *) function_pointer)(regs[0].real, regs[1].real, regs[2].real, regs[3].real);
            break;
    }

    return janet_ffi_read_one(ret_mem, signature->ret.type, JANET_FFI_MAX_RECUR);
}

#endif

/* Allocate executable memory chunks in sizes of a page. Ideally we would keep
 * an allocator around so that multiple JIT allocations would point to the same
 * region but it isn't really worth it. */
#define FFI_PAGE_MASK 0xFFF

JANET_CORE_FN(cfun_ffi_jitfn,
              "(ffi/jitfn bytes)",
              "Create an abstract type that can be used as the pointer argument to `ffi/call`. The content "
              "of `bytes` is architecture specific machine code that will be copied into executable memory.") {
    janet_fixarity(argc, 1);
    JanetByteView bytes = janet_getbytes(argv, 0);

    /* Quick hack to align to page boundary, we should query OS. FIXME */
    size_t alloc_size = ((size_t) bytes.len + FFI_PAGE_MASK) & ~FFI_PAGE_MASK;

#ifdef JANET_FFI_JIT
    JanetFFIJittedFn *fn = janet_abstract_threaded(&janet_type_ffijit, sizeof(JanetFFIJittedFn));
    fn->function_pointer = NULL;
    fn->size = 0;
#ifdef JANET_WINDOWS
    void *ptr = VirtualAlloc(NULL, alloc_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
#elif defined(MAP_ANONYMOUS)
    void *ptr = mmap(0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
#elif defined(MAP_ANON)
    /* macos doesn't have MAP_ANONYMOUS */
    void *ptr = mmap(0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
#else
    /* -std=c99 gets in the way */
    /* #define MAP_ANONYMOUS 0x20 should work, though. */
    void *ptr = mmap(0, alloc_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, -1, 0);
#endif
    if (!ptr) {
        janet_panic("failed to memory map writable memory");
    }
    memcpy(ptr, bytes.bytes, bytes.len);
#ifdef JANET_WINDOWS
    DWORD old = 0;
    if (!VirtualProtect(ptr, alloc_size, PAGE_EXECUTE_READ, &old)) {
        janet_panic("failed to make mapped memory executable");
    }
#else
    if (mprotect(ptr, alloc_size, PROT_READ | PROT_EXEC) == -1) {
        janet_panic("failed to make mapped memory executable");
    }
#endif
    fn->size = alloc_size;
    fn->function_pointer = ptr;
    return janet_wrap_abstract(fn);
#else
    janet_panic("ffi/jitfn not available on this platform");
#endif
}

JANET_CORE_FN(cfun_ffi_call,
              "(ffi/call pointer signature & args)",
              "Call a raw pointer as a function pointer. The function signature specifies "
              "how Janet values in `args` are converted to native machine types.") {
    janet_arity(argc, 2, -1);
    void *function_pointer = janet_ffi_get_callable_pointer(argv, 0);
    JanetFFISignature *signature = janet_getabstract(argv, 1, &janet_signature_type);
    janet_fixarity(argc - 2, signature->arg_count);
    switch (signature->cc) {
        default:
        case JANET_FFI_CC_NONE:
            janet_panic("calling convention not supported");
#ifdef JANET_FFI_WIN64_ENABLED
        case JANET_FFI_CC_WIN_64:
            return janet_ffi_win64(signature, function_pointer, argv);
#endif
#ifdef JANET_FFI_SYSV64_ENABLED
        case JANET_FFI_CC_SYSV_64:
            return janet_ffi_sysv64(signature, function_pointer, argv);
#endif
    }
}

JANET_CORE_FN(cfun_ffi_buffer_write,
              "(ffi/write ffi-type data &opt buffer)",
              "Append a native tyep to a buffer such as it would appear in memory. This can be used "
              "to pass pointers to structs in the ffi, or send C/C++/native structs over the network "
              "or to files. Returns a modifed buffer or a new buffer if one is not supplied.") {
    janet_arity(argc, 2, 3);
    JanetFFIType type = decode_ffi_type(argv[0]);
    uint32_t el_size = (uint32_t) type_size(type);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, el_size);
    janet_buffer_extra(buffer, el_size);
    memset(buffer->data, 0, el_size);
    janet_ffi_write_one(buffer->data, argv, 1, type, JANET_FFI_MAX_RECUR);
    buffer->count += el_size;
    return janet_wrap_buffer(buffer);
}

JANET_CORE_FN(cfun_ffi_buffer_read,
              "(ffi/read ffi-type bytes &opt offset)",
              "Parse a native struct out of a buffer and convert it to normal Janet data structures. "
              "This function is the inverse of `ffi/write`. `bytes` can also be a raw pointer, although "
              "this is unsafe.") {
    janet_arity(argc, 2, 3);
    JanetFFIType type = decode_ffi_type(argv[0]);
    size_t offset = (size_t) janet_optnat(argv, argc, 2, 0);
    if (janet_checktype(argv[1], JANET_POINTER)) {
        uint8_t *ptr = janet_unwrap_pointer(argv[1]);
        return janet_ffi_read_one(ptr + offset, type, JANET_FFI_MAX_RECUR);
    } else {
        size_t el_size = type_size(type);
        JanetByteView bytes = janet_getbytes(argv, 1);
        if ((size_t) bytes.len < offset + el_size) janet_panic("read out of range");
        return janet_ffi_read_one(bytes.bytes + offset, type, JANET_FFI_MAX_RECUR);
    }
}

JANET_CORE_FN(cfun_ffi_get_callback_trampoline,
              "(ffi/trampoline cc)",
              "Get a native function pointer that can be used as a callback and passed to C libraries. "
              "This callback trampoline has the signature `void trampoline(void \\*ctx, void \\*userdata)` in "
              "the given calling convention. This is the only function signature supported. "
              "It is up to the programmer to ensure that the `userdata` argument contains a janet function "
              "the will be called with one argument, `ctx` which is an opaque pointer. This pointer can "
              "be further inspected with `ffi/read`.") {
    janet_arity(argc, 0, 1);
    JanetFFICallingConvention cc = JANET_FFI_CC_DEFAULT;
    if (argc >= 1) cc = decode_ffi_cc(janet_getkeyword(argv, 0));
    switch (cc) {
        default:
        case JANET_FFI_CC_NONE:
            janet_panic("calling convention not supported");
#ifdef JANET_FFI_WIN64_ENABLED
        case JANET_FFI_CC_WIN_64:
            return janet_wrap_pointer(janet_ffi_win64_standard_callback);
#endif
#ifdef JANET_FFI_SYSV64_ENABLED
        case JANET_FFI_CC_SYSV_64:
            return janet_wrap_pointer(janet_ffi_sysv64_standard_callback);
#endif
    }
}

JANET_CORE_FN(janet_core_raw_native,
              "(ffi/native &opt path)",
              "Load a shared object or dll from the given path, and do not extract"
              " or run any code from it. This is different than `native`, which will "
              "run initialization code to get a module table. If `path` is nil, opens the current running binary. "
              "Returns a `core/native`.") {
    janet_arity(argc, 0, 1);
    const char *path = janet_optcstring(argv, argc, 0, NULL);
    Clib lib = load_clib(path);
    if (!lib) janet_panic(error_clib());
    JanetAbstractNative *anative = janet_abstract(&janet_native_type, sizeof(JanetAbstractNative));
    anative->clib = lib;
    anative->closed = 0;
    anative->is_self = path == NULL;
    return janet_wrap_abstract(anative);
}

JANET_CORE_FN(janet_core_native_lookup,
              "(ffi/lookup native symbol-name)",
              "Lookup a symbol from a native object. All symbol lookups will return a raw pointer "
              "if the symbol is found, else nil.") {
    janet_fixarity(argc, 2);
    JanetAbstractNative *anative = janet_getabstract(argv, 0, &janet_native_type);
    const char *sym = janet_getcstring(argv, 1);
    if (anative->closed) janet_panic("native object already closed");
    void *value = symbol_clib(anative->clib, sym);
    if (NULL == value) return janet_wrap_nil();
    return janet_wrap_pointer(value);
}

JANET_CORE_FN(janet_core_native_close,
              "(ffi/close native)",
              "Free a native object. Dereferencing pointers to symbols in the object will have undefined "
              "behavior after freeing.") {
    janet_fixarity(argc, 1);
    JanetAbstractNative *anative = janet_getabstract(argv, 0, &janet_native_type);
    if (anative->closed) janet_panic("native object already closed");
    if (anative->is_self) janet_panic("cannot close self");
    anative->closed = 1;
    free_clib(anative->clib);
    return janet_wrap_nil();
}

JANET_CORE_FN(cfun_ffi_malloc,
              "(ffi/malloc size)",
              "Allocates memory directly using the system memory allocator. Memory allocated in this way must be freed manually! Returns a raw pointer, or nil if size = 0.") {
    janet_fixarity(argc, 1);
    size_t size = janet_getsize(argv, 0);
    if (size == 0) return janet_wrap_nil();
    return janet_wrap_pointer(malloc(size));
}

JANET_CORE_FN(cfun_ffi_free,
              "(ffi/free pointer)",
              "Free memory allocated with `ffi/malloc`.") {
    janet_fixarity(argc, 1);
    if (janet_checktype(argv[0], JANET_NIL)) return janet_wrap_nil();
    void *pointer = janet_getpointer(argv, 0);
    free(pointer);
    return janet_wrap_nil();
}

void janet_lib_ffi(JanetTable *env) {
    JanetRegExt ffi_cfuns[] = {
        JANET_CORE_REG("ffi/native", janet_core_raw_native),
        JANET_CORE_REG("ffi/lookup", janet_core_native_lookup),
        JANET_CORE_REG("ffi/close", janet_core_native_close),
        JANET_CORE_REG("ffi/signature", cfun_ffi_signature),
        JANET_CORE_REG("ffi/call", cfun_ffi_call),
        JANET_CORE_REG("ffi/struct", cfun_ffi_struct),
        JANET_CORE_REG("ffi/write", cfun_ffi_buffer_write),
        JANET_CORE_REG("ffi/read", cfun_ffi_buffer_read),
        JANET_CORE_REG("ffi/size", cfun_ffi_size),
        JANET_CORE_REG("ffi/align", cfun_ffi_align),
        JANET_CORE_REG("ffi/trampoline", cfun_ffi_get_callback_trampoline),
        JANET_CORE_REG("ffi/jitfn", cfun_ffi_jitfn),
        JANET_CORE_REG("ffi/malloc", cfun_ffi_malloc),
        JANET_CORE_REG("ffi/free", cfun_ffi_free),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, ffi_cfuns);
}

#endif


/* src/core/fiber.c */
#line 0 "src/core/fiber.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "fiber.h"
#include "state.h"
#include "gc.h"
#include "util.h"
#endif

static void fiber_reset(JanetFiber *fiber) {
    fiber->maxstack = JANET_STACK_MAX;
    fiber->frame = 0;
    fiber->stackstart = JANET_FRAME_SIZE;
    fiber->stacktop = JANET_FRAME_SIZE;
    fiber->child = NULL;
    fiber->flags = JANET_FIBER_MASK_YIELD | JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP;
    fiber->env = NULL;
    fiber->last_value = janet_wrap_nil();
#ifdef JANET_EV
    fiber->waiting = NULL;
    fiber->sched_id = 0;
    fiber->supervisor_channel = NULL;
#endif
    janet_fiber_set_status(fiber, JANET_STATUS_NEW);
}

static JanetFiber *fiber_alloc(int32_t capacity) {
    Janet *data;
    JanetFiber *fiber = janet_gcalloc(JANET_MEMORY_FIBER, sizeof(JanetFiber));
    if (capacity < 32) {
        capacity = 32;
    }
    fiber->capacity = capacity;
    data = janet_malloc(sizeof(Janet) * (size_t) capacity);
    if (NULL == data) {
        JANET_OUT_OF_MEMORY;
    }
    janet_vm.next_collection += sizeof(Janet) * capacity;
    fiber->data = data;
    return fiber;
}

/* Create a new fiber with argn values on the stack by reusing a fiber. */
JanetFiber *janet_fiber_reset(JanetFiber *fiber, JanetFunction *callee, int32_t argc, const Janet *argv) {
    int32_t newstacktop;
    fiber_reset(fiber);
    if (argc) {
        newstacktop = fiber->stacktop + argc;
        if (newstacktop >= fiber->capacity) {
            janet_fiber_setcapacity(fiber, 2 * newstacktop);
        }
        if (argv) {
            memcpy(fiber->data + fiber->stacktop, argv, argc * sizeof(Janet));
        } else {
            /* If argv not given, fill with nil */
            for (int32_t i = 0; i < argc; i++) {
                fiber->data[fiber->stacktop + i] = janet_wrap_nil();
            }
        }
        fiber->stacktop = newstacktop;
    }
    if (janet_fiber_funcframe(fiber, callee)) return NULL;
    janet_fiber_frame(fiber)->flags |= JANET_STACKFRAME_ENTRANCE;
#ifdef JANET_EV
    fiber->waiting = NULL;
    fiber->supervisor_channel = NULL;
#endif
    return fiber;
}

/* Create a new fiber with argn values on the stack. */
JanetFiber *janet_fiber(JanetFunction *callee, int32_t capacity, int32_t argc, const Janet *argv) {
    return janet_fiber_reset(fiber_alloc(capacity), callee, argc, argv);
}

#ifdef JANET_DEBUG
/* Test for memory issues by reallocating fiber every time we push a stack frame */
static void janet_fiber_refresh_memory(JanetFiber *fiber) {
    int32_t n = fiber->capacity;
    if (n) {
        Janet *newData = janet_malloc(sizeof(Janet) * n);
        if (NULL == newData) {
            JANET_OUT_OF_MEMORY;
        }
        memcpy(newData, fiber->data, fiber->capacity * sizeof(Janet));
        janet_free(fiber->data);
        fiber->data = newData;
    }
}
#endif

/* Ensure that the fiber has enough extra capacity */
void janet_fiber_setcapacity(JanetFiber *fiber, int32_t n) {
    int32_t old_size = fiber->capacity;
    int32_t diff = n - old_size;
    Janet *newData = janet_realloc(fiber->data, sizeof(Janet) * n);
    if (NULL == newData) {
        JANET_OUT_OF_MEMORY;
    }
    fiber->data = newData;
    fiber->capacity = n;
    janet_vm.next_collection += sizeof(Janet) * diff;
}

/* Grow fiber if needed */
static void janet_fiber_grow(JanetFiber *fiber, int32_t needed) {
    int32_t cap = needed > (INT32_MAX / 2) ? INT32_MAX : 2 * needed;
    janet_fiber_setcapacity(fiber, cap);
}

/* Push a value on the next stack frame */
void janet_fiber_push(JanetFiber *fiber, Janet x) {
    if (fiber->stacktop == INT32_MAX) janet_panic("stack overflow");
    if (fiber->stacktop >= fiber->capacity) {
        janet_fiber_grow(fiber, fiber->stacktop);
    }
    fiber->data[fiber->stacktop++] = x;
}

/* Push 2 values on the next stack frame */
void janet_fiber_push2(JanetFiber *fiber, Janet x, Janet y) {
    if (fiber->stacktop >= INT32_MAX - 1) janet_panic("stack overflow");
    int32_t newtop = fiber->stacktop + 2;
    if (newtop > fiber->capacity) {
        janet_fiber_grow(fiber, newtop);
    }
    fiber->data[fiber->stacktop] = x;
    fiber->data[fiber->stacktop + 1] = y;
    fiber->stacktop = newtop;
}

/* Push 3 values on the next stack frame */
void janet_fiber_push3(JanetFiber *fiber, Janet x, Janet y, Janet z) {
    if (fiber->stacktop >= INT32_MAX - 2) janet_panic("stack overflow");
    int32_t newtop = fiber->stacktop + 3;
    if (newtop > fiber->capacity) {
        janet_fiber_grow(fiber, newtop);
    }
    fiber->data[fiber->stacktop] = x;
    fiber->data[fiber->stacktop + 1] = y;
    fiber->data[fiber->stacktop + 2] = z;
    fiber->stacktop = newtop;
}

/* Push an array on the next stack frame */
void janet_fiber_pushn(JanetFiber *fiber, const Janet *arr, int32_t n) {
    if (fiber->stacktop > INT32_MAX - n) janet_panic("stack overflow");
    int32_t newtop = fiber->stacktop + n;
    if (newtop > fiber->capacity) {
        janet_fiber_grow(fiber, newtop);
    }
    safe_memcpy(fiber->data + fiber->stacktop, arr, n * sizeof(Janet));
    fiber->stacktop = newtop;
}

/* Create a struct with n values. If n is odd, the last value is ignored. */
static Janet make_struct_n(const Janet *args, int32_t n) {
    int32_t i = 0;
    JanetKV *st = janet_struct_begin(n & (~1));
    for (; i < n; i += 2) {
        janet_struct_put(st, args[i], args[i + 1]);
    }
    return janet_wrap_struct(janet_struct_end(st));
}

/* Push a stack frame to a fiber */
int janet_fiber_funcframe(JanetFiber *fiber, JanetFunction *func) {
    JanetStackFrame *newframe;

    int32_t i;
    int32_t oldtop = fiber->stacktop;
    int32_t oldframe = fiber->frame;
    int32_t nextframe = fiber->stackstart;
    int32_t nextstacktop = nextframe + func->def->slotcount + JANET_FRAME_SIZE;
    int32_t next_arity = fiber->stacktop - fiber->stackstart;

    /* Check strict arity before messing with state */
    if (next_arity < func->def->min_arity) return 1;
    if (next_arity > func->def->max_arity) return 1;

    if (fiber->capacity < nextstacktop) {
        janet_fiber_setcapacity(fiber, 2 * nextstacktop);
#ifdef JANET_DEBUG
    } else {
        janet_fiber_refresh_memory(fiber);
#endif
    }

    /* Nil unset stack arguments (Needed for gc correctness) */
    for (i = fiber->stacktop; i < nextstacktop; ++i) {
        fiber->data[i] = janet_wrap_nil();
    }

    /* Set up the next frame */
    fiber->frame = nextframe;
    fiber->stacktop = fiber->stackstart = nextstacktop;
    newframe = janet_fiber_frame(fiber);
    newframe->prevframe = oldframe;
    newframe->pc = func->def->bytecode;
    newframe->func = func;
    newframe->env = NULL;
    newframe->flags = 0;

    /* Check varargs */
    if (func->def->flags & JANET_FUNCDEF_FLAG_VARARG) {
        int32_t tuplehead = fiber->frame + func->def->arity;
        int st = func->def->flags & JANET_FUNCDEF_FLAG_STRUCTARG;
        if (tuplehead >= oldtop) {
            fiber->data[tuplehead] = st
                                     ? make_struct_n(NULL, 0)
                                     : janet_wrap_tuple(janet_tuple_n(NULL, 0));
        } else {
            fiber->data[tuplehead] = st
                                     ? make_struct_n(
                                         fiber->data + tuplehead,
                                         oldtop - tuplehead)
                                     : janet_wrap_tuple(janet_tuple_n(
                                                 fiber->data + tuplehead,
                                                 oldtop - tuplehead));
        }
    }

    /* Good return */
    return 0;
}

/* If a frame has a closure environment, detach it from
 * the stack and have it keep its own values */
static void janet_env_detach(JanetFuncEnv *env) {
    /* Check for closure environment */
    if (env) {
        janet_env_valid(env);
        int32_t len = env->length;
        size_t s = sizeof(Janet) * (size_t) len;
        Janet *vmem = janet_malloc(s);
        janet_vm.next_collection += (uint32_t) s;
        if (NULL == vmem) {
            JANET_OUT_OF_MEMORY;
        }
        Janet *values = env->as.fiber->data + env->offset;
        safe_memcpy(vmem, values, s);
        uint32_t *bitset = janet_stack_frame(values)->func->def->closure_bitset;
        if (bitset) {
            /* Clear unneeded references in closure environment */
            for (int32_t i = 0; i < len; i += 32) {
                uint32_t mask = ~(bitset[i >> 5]);
                int32_t maxj = i + 32 > len ? len : i + 32;
                for (int32_t j = i; j < maxj; j++) {
                    if (mask & 1) vmem[j] = janet_wrap_nil();
                    mask >>= 1;
                }
            }
        }
        env->offset = 0;
        env->as.values = vmem;
    }
}

/* Validate potentially untrusted func env (unmarshalled envs are difficult to verify) */
int janet_env_valid(JanetFuncEnv *env) {
    if (env->offset < 0) {
        int32_t real_offset = -(env->offset);
        JanetFiber *fiber = env->as.fiber;
        int32_t i = fiber->frame;
        while (i > 0) {
            JanetStackFrame *frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
            if (real_offset == i &&
                    frame->env == env &&
                    frame->func &&
                    frame->func->def->slotcount == env->length) {
                env->offset = real_offset;
                return 1;
            }
            i = frame->prevframe;
        }
        /* Invalid, set to empty off-stack variant. */
        env->offset = 0;
        env->length = 0;
        env->as.values = NULL;
        return 0;
    } else {
        return 1;
    }
}

/* Detach a fiber from the env if the target fiber has stopped mutating */
void janet_env_maybe_detach(JanetFuncEnv *env) {
    /* Check for detachable closure envs */
    janet_env_valid(env);
    if (env->offset > 0) {
        JanetFiberStatus s = janet_fiber_status(env->as.fiber);
        int isFinished = s == JANET_STATUS_DEAD ||
                         s == JANET_STATUS_ERROR ||
                         s == JANET_STATUS_USER0 ||
                         s == JANET_STATUS_USER1 ||
                         s == JANET_STATUS_USER2 ||
                         s == JANET_STATUS_USER3 ||
                         s == JANET_STATUS_USER4;
        if (isFinished) {
            janet_env_detach(env);
        }
    }
}

/* Create a tail frame for a function */
int janet_fiber_funcframe_tail(JanetFiber *fiber, JanetFunction *func) {
    int32_t i;
    int32_t nextframetop = fiber->frame + func->def->slotcount;
    int32_t nextstacktop = nextframetop + JANET_FRAME_SIZE;
    int32_t next_arity = fiber->stacktop - fiber->stackstart;
    int32_t stacksize;

    /* Check strict arity before messing with state */
    if (next_arity < func->def->min_arity) return 1;
    if (next_arity > func->def->max_arity) return 1;

    if (fiber->capacity < nextstacktop) {
        janet_fiber_setcapacity(fiber, 2 * nextstacktop);
#ifdef JANET_DEBUG
    } else {
        janet_fiber_refresh_memory(fiber);
#endif
    }

    Janet *stack = fiber->data + fiber->frame;
    Janet *args = fiber->data + fiber->stackstart;

    /* Detach old function */
    if (NULL != janet_fiber_frame(fiber)->func)
        janet_env_detach(janet_fiber_frame(fiber)->env);
    janet_fiber_frame(fiber)->env = NULL;

    /* Check varargs */
    if (func->def->flags & JANET_FUNCDEF_FLAG_VARARG) {
        int32_t tuplehead = fiber->stackstart + func->def->arity;
        int st = func->def->flags & JANET_FUNCDEF_FLAG_STRUCTARG;
        if (tuplehead >= fiber->stacktop) {
            if (tuplehead >= fiber->capacity) janet_fiber_setcapacity(fiber, 2 * (tuplehead + 1));
            for (i = fiber->stacktop; i < tuplehead; ++i) fiber->data[i] = janet_wrap_nil();
            fiber->data[tuplehead] = st
                                     ? make_struct_n(NULL, 0)
                                     : janet_wrap_tuple(janet_tuple_n(NULL, 0));
        } else {
            fiber->data[tuplehead] = st
                                     ? make_struct_n(
                                         fiber->data + tuplehead,
                                         fiber->stacktop - tuplehead)
                                     : janet_wrap_tuple(janet_tuple_n(
                                                 fiber->data + tuplehead,
                                                 fiber->stacktop - tuplehead));
        }
        stacksize = tuplehead - fiber->stackstart + 1;
    } else {
        stacksize = fiber->stacktop - fiber->stackstart;
    }

    if (stacksize) memmove(stack, args, stacksize * sizeof(Janet));

    /* Nil unset locals (Needed for functional correctness) */
    for (i = fiber->frame + stacksize; i < nextframetop; ++i)
        fiber->data[i] = janet_wrap_nil();

    /* Set stack stuff */
    fiber->stacktop = fiber->stackstart = nextstacktop;

    /* Set frame stuff */
    janet_fiber_frame(fiber)->func = func;
    janet_fiber_frame(fiber)->pc = func->def->bytecode;
    janet_fiber_frame(fiber)->flags |= JANET_STACKFRAME_TAILCALL;

    /* Good return */
    return 0;
}

/* Push a stack frame to a fiber for a c function */
void janet_fiber_cframe(JanetFiber *fiber, JanetCFunction cfun) {
    JanetStackFrame *newframe;

    int32_t oldframe = fiber->frame;
    int32_t nextframe = fiber->stackstart;
    int32_t nextstacktop = fiber->stacktop + JANET_FRAME_SIZE;

    if (fiber->capacity < nextstacktop) {
        janet_fiber_setcapacity(fiber, 2 * nextstacktop);
#ifdef JANET_DEBUG
    } else {
        janet_fiber_refresh_memory(fiber);
#endif
    }

    /* Set the next frame */
    fiber->frame = nextframe;
    fiber->stacktop = fiber->stackstart = nextstacktop;
    newframe = janet_fiber_frame(fiber);

    /* Set up the new frame */
    newframe->prevframe = oldframe;
    newframe->pc = (uint32_t *) cfun;
    newframe->func = NULL;
    newframe->env = NULL;
    newframe->flags = 0;
}

/* Pop a stack frame from the fiber. */
void janet_fiber_popframe(JanetFiber *fiber) {
    JanetStackFrame *frame = janet_fiber_frame(fiber);
    if (fiber->frame == 0) return;

    /* Clean up the frame (detach environments) */
    if (NULL != frame->func)
        janet_env_detach(frame->env);

    /* Shrink stack */
    fiber->stacktop = fiber->stackstart = fiber->frame;
    fiber->frame = frame->prevframe;
}

JanetFiberStatus janet_fiber_status(JanetFiber *f) {
    return ((f)->flags & JANET_FIBER_STATUS_MASK) >> JANET_FIBER_STATUS_OFFSET;
}

JanetFiber *janet_current_fiber(void) {
    return janet_vm.fiber;
}

JanetFiber *janet_root_fiber(void) {
    return janet_vm.root_fiber;
}

/* CFuns */

JANET_CORE_FN(cfun_fiber_getenv,
              "(fiber/getenv fiber)",
              "Gets the environment for a fiber. Returns nil if no such table is "
              "set yet.") {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    return fiber->env ?
           janet_wrap_table(fiber->env) :
           janet_wrap_nil();
}

JANET_CORE_FN(cfun_fiber_setenv,
              "(fiber/setenv fiber table)",
              "Sets the environment table for a fiber. Set to nil to remove the current "
              "environment.") {
    janet_fixarity(argc, 2);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    if (janet_checktype(argv[1], JANET_NIL)) {
        fiber->env = NULL;
    } else {
        fiber->env = janet_gettable(argv, 1);
    }
    return argv[0];
}

JANET_CORE_FN(cfun_fiber_new,
              "(fiber/new func &opt sigmask)",
              "Create a new fiber with function body func. Can optionally "
              "take a set of signals to block from the current parent fiber "
              "when called. The mask is specified as a keyword where each character "
              "is used to indicate a signal to block. If the ev module is enabled, and "
              "this fiber is used as an argument to `ev/go`, these \"blocked\" signals "
              "will result in messages being sent to the supervisor channel. "
              "The default sigmask is :y. "
              "For example,\n\n"
              "    (fiber/new myfun :e123)\n\n"
              "blocks error signals and user signals 1, 2 and 3. The signals are "
              "as follows:\n\n"
              "* :a - block all signals\n"
              "* :d - block debug signals\n"
              "* :e - block error signals\n"
              "* :t - block termination signals: error + user[0-4]\n"
              "* :u - block user signals\n"
              "* :y - block yield signals\n"
              "* :0-9 - block a specific user signal\n\n"
              "The sigmask argument also can take environment flags. If any mutually "
              "exclusive flags are present, the last flag takes precedence.\n\n"
              "* :i - inherit the environment from the current fiber\n"
              "* :p - the environment table's prototype is the current environment table") {
    janet_arity(argc, 1, 2);
    JanetFunction *func = janet_getfunction(argv, 0);
    JanetFiber *fiber;
    if (func->def->min_arity > 1) {
        janet_panicf("fiber function must accept 0 or 1 arguments");
    }
    fiber = janet_fiber(func, 64, func->def->min_arity, NULL);
    if (argc == 2) {
        int32_t i;
        JanetByteView view = janet_getbytes(argv, 1);
        fiber->flags = JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP;
        janet_fiber_set_status(fiber, JANET_STATUS_NEW);
        for (i = 0; i < view.len; i++) {
            if (view.bytes[i] >= '0' && view.bytes[i] <= '9') {
                fiber->flags |= JANET_FIBER_MASK_USERN(view.bytes[i] - '0');
            } else {
                switch (view.bytes[i]) {
                    default:
                        janet_panicf("invalid flag %c, expected a, t, d, e, u, y, i, or p", view.bytes[i]);
                        break;
                    case 'a':
                        fiber->flags |=
                            JANET_FIBER_MASK_DEBUG |
                            JANET_FIBER_MASK_ERROR |
                            JANET_FIBER_MASK_USER |
                            JANET_FIBER_MASK_YIELD;
                        break;
                    case 't':
                        fiber->flags |=
                            JANET_FIBER_MASK_ERROR |
                            JANET_FIBER_MASK_USER0 |
                            JANET_FIBER_MASK_USER1 |
                            JANET_FIBER_MASK_USER2 |
                            JANET_FIBER_MASK_USER3 |
                            JANET_FIBER_MASK_USER4;
                        break;
                    case 'd':
                        fiber->flags |= JANET_FIBER_MASK_DEBUG;
                        break;
                    case 'e':
                        fiber->flags |= JANET_FIBER_MASK_ERROR;
                        break;
                    case 'u':
                        fiber->flags |= JANET_FIBER_MASK_USER;
                        break;
                    case 'y':
                        fiber->flags |= JANET_FIBER_MASK_YIELD;
                        break;
                    case 'i':
                        if (!janet_vm.fiber->env) {
                            janet_vm.fiber->env = janet_table(0);
                        }
                        fiber->env = janet_vm.fiber->env;
                        break;
                    case 'p':
                        if (!janet_vm.fiber->env) {
                            janet_vm.fiber->env = janet_table(0);
                        }
                        fiber->env = janet_table(0);
                        fiber->env->proto = janet_vm.fiber->env;
                        break;
                }
            }
        }
    }
    return janet_wrap_fiber(fiber);
}

JANET_CORE_FN(cfun_fiber_status,
              "(fiber/status fib)",
              "Get the status of a fiber. The status will be one of:\n\n"
              "* :dead - the fiber has finished\n"
              "* :error - the fiber has errored out\n"
              "* :debug - the fiber is suspended in debug mode\n"
              "* :pending - the fiber has been yielded\n"
              "* :user(0-9) - the fiber is suspended by a user signal\n"
              "* :alive - the fiber is currently running and cannot be resumed\n"
              "* :new - the fiber has just been created and not yet run") {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    uint32_t s = janet_fiber_status(fiber);
    return janet_ckeywordv(janet_status_names[s]);
}

JANET_CORE_FN(cfun_fiber_current,
              "(fiber/current)",
              "Returns the currently running fiber.") {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_fiber(janet_vm.fiber);
}

JANET_CORE_FN(cfun_fiber_root,
              "(fiber/root)",
              "Returns the current root fiber. The root fiber is the oldest ancestor "
              "that does not have a parent.") {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_fiber(janet_vm.root_fiber);
}

JANET_CORE_FN(cfun_fiber_maxstack,
              "(fiber/maxstack fib)",
              "Gets the maximum stack size in janet values allowed for a fiber. While memory for "
              "the fiber's stack is not allocated up front, the fiber will not allocated more "
              "than this amount and will throw a stack-overflow error if more memory is needed. ") {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    return janet_wrap_integer(fiber->maxstack);
}

JANET_CORE_FN(cfun_fiber_setmaxstack,
              "(fiber/setmaxstack fib maxstack)",
              "Sets the maximum stack size in janet values for a fiber. By default, the "
              "maximum stack size is usually 8192.") {
    janet_fixarity(argc, 2);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    int32_t maxs = janet_getinteger(argv, 1);
    if (maxs < 0) {
        janet_panic("expected positive integer");
    }
    fiber->maxstack = maxs;
    return argv[0];
}

JANET_CORE_FN(cfun_fiber_can_resume,
              "(fiber/can-resume? fiber)",
              "Check if a fiber is finished and cannot be resumed.") {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    JanetFiberStatus s = janet_fiber_status(fiber);
    int isFinished = s == JANET_STATUS_DEAD ||
                     s == JANET_STATUS_ERROR ||
                     s == JANET_STATUS_USER0 ||
                     s == JANET_STATUS_USER1 ||
                     s == JANET_STATUS_USER2 ||
                     s == JANET_STATUS_USER3 ||
                     s == JANET_STATUS_USER4;
    return janet_wrap_boolean(!isFinished);
}

JANET_CORE_FN(cfun_fiber_last_value,
              "(fiber/last-value)",
              "Get the last value returned or signaled from the fiber.") {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    return fiber->last_value;
}

/* Module entry point */
void janet_lib_fiber(JanetTable *env) {
    JanetRegExt fiber_cfuns[] = {
        JANET_CORE_REG("fiber/new", cfun_fiber_new),
        JANET_CORE_REG("fiber/status", cfun_fiber_status),
        JANET_CORE_REG("fiber/root", cfun_fiber_root),
        JANET_CORE_REG("fiber/current", cfun_fiber_current),
        JANET_CORE_REG("fiber/maxstack", cfun_fiber_maxstack),
        JANET_CORE_REG("fiber/setmaxstack", cfun_fiber_setmaxstack),
        JANET_CORE_REG("fiber/getenv", cfun_fiber_getenv),
        JANET_CORE_REG("fiber/setenv", cfun_fiber_setenv),
        JANET_CORE_REG("fiber/can-resume?", cfun_fiber_can_resume),
        JANET_CORE_REG("fiber/last-value", cfun_fiber_last_value),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, fiber_cfuns);
}


/* src/core/gc.c */
#line 0 "src/core/gc.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "symcache.h"
#include "gc.h"
#include "util.h"
#include "fiber.h"
#include "vector.h"
#endif

/* Helpers for marking the various gc types */
static void janet_mark_funcenv(JanetFuncEnv *env);
static void janet_mark_funcdef(JanetFuncDef *def);
static void janet_mark_function(JanetFunction *func);
static void janet_mark_array(JanetArray *array);
static void janet_mark_table(JanetTable *table);
static void janet_mark_struct(const JanetKV *st);
static void janet_mark_tuple(const Janet *tuple);
static void janet_mark_buffer(JanetBuffer *buffer);
static void janet_mark_string(const uint8_t *str);
static void janet_mark_fiber(JanetFiber *fiber);
static void janet_mark_abstract(void *adata);

/* Local state that is only temporary for gc */
static JANET_THREAD_LOCAL uint32_t depth = JANET_RECURSION_GUARD;
static JANET_THREAD_LOCAL size_t orig_rootcount;

/* Hint to the GC that we may need to collect */
void janet_gcpressure(size_t s) {
    janet_vm.next_collection += s;
}

/* Mark a value */
void janet_mark(Janet x) {
    if (depth) {
        depth--;
        switch (janet_type(x)) {
            default:
                break;
            case JANET_STRING:
            case JANET_KEYWORD:
            case JANET_SYMBOL:
                janet_mark_string(janet_unwrap_string(x));
                break;
            case JANET_FUNCTION:
                janet_mark_function(janet_unwrap_function(x));
                break;
            case JANET_ARRAY:
                janet_mark_array(janet_unwrap_array(x));
                break;
            case JANET_TABLE:
                janet_mark_table(janet_unwrap_table(x));
                break;
            case JANET_STRUCT:
                janet_mark_struct(janet_unwrap_struct(x));
                break;
            case JANET_TUPLE:
                janet_mark_tuple(janet_unwrap_tuple(x));
                break;
            case JANET_BUFFER:
                janet_mark_buffer(janet_unwrap_buffer(x));
                break;
            case JANET_FIBER:
                janet_mark_fiber(janet_unwrap_fiber(x));
                break;
            case JANET_ABSTRACT:
                janet_mark_abstract(janet_unwrap_abstract(x));
                break;
        }
        depth++;
    } else {
        janet_gcroot(x);
    }
}

static void janet_mark_string(const uint8_t *str) {
    janet_gc_mark(janet_string_head(str));
}

static void janet_mark_buffer(JanetBuffer *buffer) {
    janet_gc_mark(buffer);
}

static void janet_mark_abstract(void *adata) {
#ifdef JANET_EV
    /* Check if abstract type is a threaded abstract type. If it is, marking means
     * updating the threaded_abstract table. */
    if ((janet_abstract_head(adata)->gc.flags & JANET_MEM_TYPEBITS) == JANET_MEMORY_THREADED_ABSTRACT) {
        janet_table_put(&janet_vm.threaded_abstracts, janet_wrap_abstract(adata), janet_wrap_true());
        return;
    }
#endif
    if (janet_gc_reachable(janet_abstract_head(adata)))
        return;
    janet_gc_mark(janet_abstract_head(adata));
    if (janet_abstract_head(adata)->type->gcmark) {
        janet_abstract_head(adata)->type->gcmark(adata, janet_abstract_size(adata));
    }
}

/* Mark a bunch of items in memory */
static void janet_mark_many(const Janet *values, int32_t n) {
    if (values == NULL)
        return;
    const Janet *end = values + n;
    while (values < end) {
        janet_mark(*values);
        values += 1;
    }
}

/* Mark a bunch of key values items in memory */
static void janet_mark_kvs(const JanetKV *kvs, int32_t n) {
    const JanetKV *end = kvs + n;
    while (kvs < end) {
        janet_mark(kvs->key);
        janet_mark(kvs->value);
        kvs++;
    }
}

static void janet_mark_array(JanetArray *array) {
    if (janet_gc_reachable(array))
        return;
    janet_gc_mark(array);
    janet_mark_many(array->data, array->count);
}

static void janet_mark_table(JanetTable *table) {
recur: /* Manual tail recursion */
    if (janet_gc_reachable(table))
        return;
    janet_gc_mark(table);
    janet_mark_kvs(table->data, table->capacity);
    if (table->proto) {
        table = table->proto;
        goto recur;
    }
}

static void janet_mark_struct(const JanetKV *st) {
recur:
    if (janet_gc_reachable(janet_struct_head(st)))
        return;
    janet_gc_mark(janet_struct_head(st));
    janet_mark_kvs(st, janet_struct_capacity(st));
    st = janet_struct_proto(st);
    if (st) goto recur;
}

static void janet_mark_tuple(const Janet *tuple) {
    if (janet_gc_reachable(janet_tuple_head(tuple)))
        return;
    janet_gc_mark(janet_tuple_head(tuple));
    janet_mark_many(tuple, janet_tuple_length(tuple));
}

/* Helper to mark function environments */
static void janet_mark_funcenv(JanetFuncEnv *env) {
    if (janet_gc_reachable(env))
        return;
    janet_gc_mark(env);
    /* If closure env references a dead fiber, we can just copy out the stack frame we need so
     * we don't need to keep around the whole dead fiber. */
    janet_env_maybe_detach(env);
    if (env->offset > 0) {
        /* On stack */
        janet_mark_fiber(env->as.fiber);
    } else {
        /* Not on stack */
        janet_mark_many(env->as.values, env->length);
    }
}

/* GC helper to mark a FuncDef */
static void janet_mark_funcdef(JanetFuncDef *def) {
    int32_t i;
    if (janet_gc_reachable(def))
        return;
    janet_gc_mark(def);
    janet_mark_many(def->constants, def->constants_length);
    for (i = 0; i < def->defs_length; ++i) {
        janet_mark_funcdef(def->defs[i]);
    }
    if (def->source)
        janet_mark_string(def->source);
    if (def->name)
        janet_mark_string(def->name);
}

static void janet_mark_function(JanetFunction *func) {
    int32_t i;
    int32_t numenvs;
    if (janet_gc_reachable(func))
        return;
    janet_gc_mark(func);
    if (NULL != func->def) {
        /* this should always be true, except if function is only partially constructed */
        numenvs = func->def->environments_length;
        for (i = 0; i < numenvs; ++i) {
            janet_mark_funcenv(func->envs[i]);
        }
        janet_mark_funcdef(func->def);
    }
}

static void janet_mark_fiber(JanetFiber *fiber) {
    int32_t i, j;
    JanetStackFrame *frame;
recur:
    if (janet_gc_reachable(fiber))
        return;
    janet_gc_mark(fiber);

    janet_mark(fiber->last_value);

    /* Mark values on the argument stack */
    janet_mark_many(fiber->data + fiber->stackstart,
                    fiber->stacktop - fiber->stackstart);

    i = fiber->frame;
    j = fiber->stackstart - JANET_FRAME_SIZE;
    while (i > 0) {
        frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
        if (NULL != frame->func)
            janet_mark_function(frame->func);
        if (NULL != frame->env)
            janet_mark_funcenv(frame->env);
        /* Mark all values in the stack frame */
        janet_mark_many(fiber->data + i, j - i);
        j = i - JANET_FRAME_SIZE;
        i = frame->prevframe;
    }

    if (fiber->env)
        janet_mark_table(fiber->env);

#ifdef JANET_EV
    if (fiber->supervisor_channel) {
        janet_mark_abstract(fiber->supervisor_channel);
    }
#endif

    /* Explicit tail recursion */
    if (fiber->child) {
        fiber = fiber->child;
        goto recur;
    }
}

/* Deinitialize a block of memory */
static void janet_deinit_block(JanetGCObject *mem) {
    switch (mem->flags & JANET_MEM_TYPEBITS) {
        default:
        case JANET_MEMORY_FUNCTION:
            break; /* Do nothing for non gc types */
        case JANET_MEMORY_SYMBOL:
            janet_symbol_deinit(((JanetStringHead *) mem)->data);
            break;
        case JANET_MEMORY_ARRAY:
            janet_free(((JanetArray *) mem)->data);
            break;
        case JANET_MEMORY_TABLE:
            janet_free(((JanetTable *) mem)->data);
            break;
        case JANET_MEMORY_FIBER:
            janet_free(((JanetFiber *)mem)->data);
            break;
        case JANET_MEMORY_BUFFER:
            janet_buffer_deinit((JanetBuffer *) mem);
            break;
        case JANET_MEMORY_ABSTRACT: {
            JanetAbstractHead *head = (JanetAbstractHead *)mem;
            if (head->type->gc) {
                janet_assert(!head->type->gc(head->data, head->size), "finalizer failed");
            }
        }
        break;
        case JANET_MEMORY_FUNCENV: {
            JanetFuncEnv *env = (JanetFuncEnv *)mem;
            if (0 == env->offset)
                janet_free(env->as.values);
        }
        break;
        case JANET_MEMORY_FUNCDEF: {
            JanetFuncDef *def = (JanetFuncDef *)mem;
            /* TODO - get this all with one alloc and one free */
            janet_free(def->defs);
            janet_free(def->environments);
            janet_free(def->constants);
            janet_free(def->bytecode);
            janet_free(def->sourcemap);
            janet_free(def->closure_bitset);
        }
        break;
    }
}

/* Iterate over all allocated memory, and free memory that is not
 * marked as reachable. Flip the gc color flag for next sweep. */
void janet_sweep() {
    JanetGCObject *previous = NULL;
    JanetGCObject *current = janet_vm.blocks;
    JanetGCObject *next;
    while (NULL != current) {
        next = current->data.next;
        if (current->flags & (JANET_MEM_REACHABLE | JANET_MEM_DISABLED)) {
            previous = current;
            current->flags &= ~JANET_MEM_REACHABLE;
        } else {
            janet_vm.block_count--;
            janet_deinit_block(current);
            if (NULL != previous) {
                previous->data.next = next;
            } else {
                janet_vm.blocks = next;
            }
            janet_free(current);
        }
        current = next;
    }
#ifdef JANET_EV
    /* Sweep threaded abstract types for references to decrement */
    JanetKV *items = janet_vm.threaded_abstracts.data;
    for (int32_t i = 0; i < janet_vm.threaded_abstracts.capacity; i++) {
        if (janet_checktype(items[i].key, JANET_ABSTRACT)) {

            /* If item was not visited during the mark phase, then this
             * abstract type isn't present in the heap and needs its refcount
             * decremented, and shouuld be removed from table. If the refcount is
             * then 0, the item will be collected. This ensures that only one interpreter
             * will clean up the threaded abstract. */

            /* If not visited... */
            if (!janet_truthy(items[i].value)) {
                void *abst = janet_unwrap_abstract(items[i].key);
                if (0 == janet_abstract_decref(abst)) {
                    /* Run finalizer */
                    JanetAbstractHead *head = janet_abstract_head(abst);
                    if (head->type->gc) {
                        janet_assert(!head->type->gc(head->data, head->size), "finalizer failed");
                    }
                    /* Mark as tombstone in place */
                    items[i].key = janet_wrap_nil();
                    items[i].value = janet_wrap_false();
                    janet_vm.threaded_abstracts.deleted++;
                    janet_vm.threaded_abstracts.count--;
                    /* Free memory */
                    janet_free(janet_abstract_head(abst));
                }
            }

            /* Reset for next sweep */
            items[i].value = janet_wrap_false();
        }
    }
#endif
}

/* Allocate some memory that is tracked for garbage collection */
void *janet_gcalloc(enum JanetMemoryType type, size_t size) {
    JanetGCObject *mem;

    /* Make sure everything is inited */
    janet_assert(NULL != janet_vm.cache, "please initialize janet before use");
    mem = janet_malloc(size);

    /* Check for bad malloc */
    if (NULL == mem) {
        JANET_OUT_OF_MEMORY;
    }

    /* Configure block */
    mem->flags = type;

    /* Prepend block to heap list */
    janet_vm.next_collection += size;
    mem->data.next = janet_vm.blocks;
    janet_vm.blocks = mem;
    janet_vm.block_count++;

    return (void *)mem;
}

static void free_one_scratch(JanetScratch *s) {
    if (NULL != s->finalize) {
        s->finalize((char *) s->mem);
    }
    janet_free(s);
}

/* Free all allocated scratch memory */
static void janet_free_all_scratch(void) {
    for (size_t i = 0; i < janet_vm.scratch_len; i++) {
        free_one_scratch(janet_vm.scratch_mem[i]);
    }
    janet_vm.scratch_len = 0;
}

static JanetScratch *janet_mem2scratch(void *mem) {
    JanetScratch *s = (JanetScratch *)mem;
    return s - 1;
}

/* Run garbage collection */
void janet_collect(void) {
    uint32_t i;
    if (janet_vm.gc_suspend) return;
    depth = JANET_RECURSION_GUARD;
    /* Try and prevent many major collections back to back.
     * A full collection will take O(janet_vm.block_count) time.
     * If we have a large heap, make sure our interval is not too
     * small so we won't make many collections over it. This is just a
     * heuristic for automatically changing the gc interval */
    if (janet_vm.block_count * 8 > janet_vm.gc_interval) {
        janet_vm.gc_interval = janet_vm.block_count * sizeof(JanetGCObject);
    }
    orig_rootcount = janet_vm.root_count;
#ifdef JANET_EV
    janet_ev_mark();
#endif
    janet_mark_fiber(janet_vm.root_fiber);
    for (i = 0; i < orig_rootcount; i++)
        janet_mark(janet_vm.roots[i]);
    while (orig_rootcount < janet_vm.root_count) {
        Janet x = janet_vm.roots[--janet_vm.root_count];
        janet_mark(x);
    }
    janet_sweep();
    janet_vm.next_collection = 0;
    janet_free_all_scratch();
}

/* Add a root value to the GC. This prevents the GC from removing a value
 * and all of its children. If gcroot is called on a value n times, unroot
 * must also be called n times to remove it as a gc root. */
void janet_gcroot(Janet root) {
    size_t newcount = janet_vm.root_count + 1;
    if (newcount > janet_vm.root_capacity) {
        size_t newcap = 2 * newcount;
        janet_vm.roots = janet_realloc(janet_vm.roots, sizeof(Janet) * newcap);
        if (NULL == janet_vm.roots) {
            JANET_OUT_OF_MEMORY;
        }
        janet_vm.root_capacity = newcap;
    }
    janet_vm.roots[janet_vm.root_count] = root;
    janet_vm.root_count = newcount;
}

/* Identity equality for GC purposes */
static int janet_gc_idequals(Janet lhs, Janet rhs) {
    if (janet_type(lhs) != janet_type(rhs))
        return 0;
    switch (janet_type(lhs)) {
        case JANET_BOOLEAN:
        case JANET_NIL:
        case JANET_NUMBER:
            /* These values don't really matter to the gc so returning 1 all the time is fine. */
            return 1;
        default:
            return janet_unwrap_pointer(lhs) == janet_unwrap_pointer(rhs);
    }
}

/* Remove a root value from the GC. This allows the gc to potentially reclaim
 * a value and all its children. */
int janet_gcunroot(Janet root) {
    Janet *vtop = janet_vm.roots + janet_vm.root_count;
    /* Search from top to bottom as access is most likely LIFO */
    for (Janet *v = janet_vm.roots; v < vtop; v++) {
        if (janet_gc_idequals(root, *v)) {
            *v = janet_vm.roots[--janet_vm.root_count];
            return 1;
        }
    }
    return 0;
}

/* Remove a root value from the GC. This sets the effective reference count to 0. */
int janet_gcunrootall(Janet root) {
    Janet *vtop = janet_vm.roots + janet_vm.root_count;
    int ret = 0;
    /* Search from top to bottom as access is most likely LIFO */
    for (Janet *v = janet_vm.roots; v < vtop; v++) {
        if (janet_gc_idequals(root, *v)) {
            *v = janet_vm.roots[--janet_vm.root_count];
            vtop--;
            ret = 1;
        }
    }
    return ret;
}

/* Free all allocated memory */
void janet_clear_memory(void) {
#ifdef JANET_EV
    JanetKV *items = janet_vm.threaded_abstracts.data;
    for (int32_t i = 0; i < janet_vm.threaded_abstracts.capacity; i++) {
        if (janet_checktype(items[i].key, JANET_ABSTRACT)) {
            void *abst = janet_unwrap_abstract(items[i].key);
            if (0 == janet_abstract_decref(abst)) {
                JanetAbstractHead *head = janet_abstract_head(abst);
                if (head->type->gc) {
                    janet_assert(!head->type->gc(head->data, head->size), "finalizer failed");
                }
                janet_free(janet_abstract_head(abst));
            }
        }
    }
#endif
    JanetGCObject *current = janet_vm.blocks;
    while (NULL != current) {
        janet_deinit_block(current);
        JanetGCObject *next = current->data.next;
        janet_free(current);
        current = next;
    }
    janet_vm.blocks = NULL;
    janet_free_all_scratch();
    janet_free(janet_vm.scratch_mem);
}

/* Primitives for suspending GC. */
int janet_gclock(void) {
    return janet_vm.gc_suspend++;
}
void janet_gcunlock(int handle) {
    janet_vm.gc_suspend = handle;
}

/* Scratch memory API */

void *janet_smalloc(size_t size) {
    JanetScratch *s = janet_malloc(sizeof(JanetScratch) + size);
    if (NULL == s) {
        JANET_OUT_OF_MEMORY;
    }
    s->finalize = NULL;
    if (janet_vm.scratch_len == janet_vm.scratch_cap) {
        size_t newcap = 2 * janet_vm.scratch_cap + 2;
        JanetScratch **newmem = (JanetScratch **) janet_realloc(janet_vm.scratch_mem, newcap * sizeof(JanetScratch));
        if (NULL == newmem) {
            JANET_OUT_OF_MEMORY;
        }
        janet_vm.scratch_cap = newcap;
        janet_vm.scratch_mem = newmem;
    }
    janet_vm.scratch_mem[janet_vm.scratch_len++] = s;
    return (char *)(s->mem);
}

void *janet_scalloc(size_t nmemb, size_t size) {
    if (nmemb && size > SIZE_MAX / nmemb) {
        JANET_OUT_OF_MEMORY;
    }
    size_t n = nmemb * size;
    void *p = janet_smalloc(n);
    memset(p, 0, n);
    return p;
}

void *janet_srealloc(void *mem, size_t size) {
    if (NULL == mem) return janet_smalloc(size);
    JanetScratch *s = janet_mem2scratch(mem);
    if (janet_vm.scratch_len) {
        for (size_t i = janet_vm.scratch_len - 1; ; i--) {
            if (janet_vm.scratch_mem[i] == s) {
                JanetScratch *news = janet_realloc(s, size + sizeof(JanetScratch));
                if (NULL == news) {
                    JANET_OUT_OF_MEMORY;
                }
                janet_vm.scratch_mem[i] = news;
                return (char *)(news->mem);
            }
            if (i == 0) break;
        }
    }
    JANET_EXIT("invalid janet_srealloc");
}

void janet_sfinalizer(void *mem, JanetScratchFinalizer finalizer) {
    JanetScratch *s = janet_mem2scratch(mem);
    s->finalize = finalizer;
}

void janet_sfree(void *mem) {
    if (NULL == mem) return;
    JanetScratch *s = janet_mem2scratch(mem);
    if (janet_vm.scratch_len) {
        for (size_t i = janet_vm.scratch_len - 1; ; i--) {
            if (janet_vm.scratch_mem[i] == s) {
                janet_vm.scratch_mem[i] = janet_vm.scratch_mem[--janet_vm.scratch_len];
                free_one_scratch(s);
                return;
            }
            if (i == 0) break;
        }
    }
    JANET_EXIT("invalid janet_sfree");
}


/* src/core/inttypes.c */
#line 0 "src/core/inttypes.c"

/*
* Copyright (c) 2023 Calvin Rose & contributors
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#include <errno.h>
#include <stdlib.h>
#include <limits.h>
#include <inttypes.h>
#include <math.h>

/* Conditional compilation */
#ifdef JANET_INT_TYPES

#define MAX_INT_IN_DBL 9007199254740992ULL /* 2^53 */

static int it_s64_get(void *p, Janet key, Janet *out);
static int it_u64_get(void *p, Janet key, Janet *out);
static Janet janet_int64_next(void *p, Janet key);
static Janet janet_uint64_next(void *p, Janet key);

static int32_t janet_int64_hash(void *p1, size_t size) {
    (void) size;
    int32_t *words = p1;
    return words[0] ^ words[1];
}

static int janet_int64_compare(void *p1, void *p2) {
    int64_t x = *((int64_t *)p1);
    int64_t y = *((int64_t *)p2);
    return x == y ? 0 : x < y ? -1 : 1;
}

static int janet_uint64_compare(void *p1, void *p2) {
    uint64_t x = *((uint64_t *)p1);
    uint64_t y = *((uint64_t *)p2);
    return x == y ? 0 : x < y ? -1 : 1;
}

static void int64_marshal(void *p, JanetMarshalContext *ctx) {
    janet_marshal_abstract(ctx, p);
    janet_marshal_int64(ctx, *((int64_t *)p));
}

static void *int64_unmarshal(JanetMarshalContext *ctx) {
    int64_t *p = janet_unmarshal_abstract(ctx, sizeof(int64_t));
    p[0] = janet_unmarshal_int64(ctx);
    return p;
}

static void it_s64_tostring(void *p, JanetBuffer *buffer) {
    char str[32];
    sprintf(str, "%" PRId64, *((int64_t *)p));
    janet_buffer_push_cstring(buffer, str);
}

static void it_u64_tostring(void *p, JanetBuffer *buffer) {
    char str[32];
    sprintf(str, "%" PRIu64, *((uint64_t *)p));
    janet_buffer_push_cstring(buffer, str);
}

const JanetAbstractType janet_s64_type = {
    "core/s64",
    NULL,
    NULL,
    it_s64_get,
    NULL,
    int64_marshal,
    int64_unmarshal,
    it_s64_tostring,
    janet_int64_compare,
    janet_int64_hash,
    janet_int64_next,
    JANET_ATEND_NEXT
};

const JanetAbstractType janet_u64_type = {
    "core/u64",
    NULL,
    NULL,
    it_u64_get,
    NULL,
    int64_marshal,
    int64_unmarshal,
    it_u64_tostring,
    janet_uint64_compare,
    janet_int64_hash,
    janet_uint64_next,
    JANET_ATEND_NEXT
};

int64_t janet_unwrap_s64(Janet x) {
    switch (janet_type(x)) {
        default:
            break;
        case JANET_NUMBER : {
            double dbl = janet_unwrap_number(x);
            if (fabs(dbl) <=  MAX_INT_IN_DBL)
                return (int64_t)dbl;
            break;
        }
        case JANET_STRING: {
            int64_t value;
            const uint8_t *str = janet_unwrap_string(x);
            if (janet_scan_int64(str, janet_string_length(str), &value))
                return value;
            break;
        }
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(x);
            if (janet_abstract_type(abst) == &janet_s64_type ||
                    (janet_abstract_type(abst) == &janet_u64_type))
                return *(int64_t *)abst;
            break;
        }
    }
    janet_panicf("bad s64 initializer: %t", x);
    return 0;
}

uint64_t janet_unwrap_u64(Janet x) {
    switch (janet_type(x)) {
        default:
            break;
        case JANET_NUMBER : {
            double dbl = janet_unwrap_number(x);
            /* Allow negative values to be cast to "wrap around".
             * This let's addition and subtraction work as expected. */
            if (fabs(dbl) <=  MAX_INT_IN_DBL)
                return (uint64_t)dbl;
            break;
        }
        case JANET_STRING: {
            uint64_t value;
            const uint8_t *str = janet_unwrap_string(x);
            if (janet_scan_uint64(str, janet_string_length(str), &value))
                return value;
            break;
        }
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(x);
            if (janet_abstract_type(abst) == &janet_s64_type ||
                    (janet_abstract_type(abst) == &janet_u64_type))
                return *(uint64_t *)abst;
            break;
        }
    }
    janet_panicf("bad u64 initializer: %t", x);
    return 0;
}

JanetIntType janet_is_int(Janet x) {
    if (!janet_checktype(x, JANET_ABSTRACT)) return JANET_INT_NONE;
    const JanetAbstractType *at = janet_abstract_type(janet_unwrap_abstract(x));
    return (at == &janet_s64_type) ? JANET_INT_S64 :
           ((at == &janet_u64_type) ? JANET_INT_U64 :
            JANET_INT_NONE);
}

Janet janet_wrap_s64(int64_t x) {
    int64_t *box = janet_abstract(&janet_s64_type, sizeof(int64_t));
    *box = (int64_t)x;
    return janet_wrap_abstract(box);
}

Janet janet_wrap_u64(uint64_t x) {
    uint64_t *box = janet_abstract(&janet_u64_type, sizeof(uint64_t));
    *box = (uint64_t)x;
    return janet_wrap_abstract(box);
}

JANET_CORE_FN(cfun_it_s64_new,
              "(int/s64 value)",
              "Create a boxed signed 64 bit integer from a string value.") {
    janet_fixarity(argc, 1);
    return janet_wrap_s64(janet_unwrap_s64(argv[0]));
}

JANET_CORE_FN(cfun_it_u64_new,
              "(int/u64 value)",
              "Create a boxed unsigned 64 bit integer from a string value.") {
    janet_fixarity(argc, 1);
    return janet_wrap_u64(janet_unwrap_u64(argv[0]));
}

JANET_CORE_FN(cfun_to_number,
              "(int/to-number value)",
              "Convert an int/u64 or int/s64 to a number. Fails if the number is out of range for an int32.") {
    janet_fixarity(argc, 1);
    if (janet_type(argv[0]) == JANET_ABSTRACT) {
        void *abst = janet_unwrap_abstract(argv[0]);

        if (janet_abstract_type(abst) == &janet_s64_type) {
            int64_t value = *((int64_t *)abst);
            if (value > JANET_INTMAX_INT64) {
                janet_panicf("cannot convert %q to a number, must be in the range [%q, %q]", argv[0], janet_wrap_number(JANET_INTMIN_DOUBLE), janet_wrap_number(JANET_INTMAX_DOUBLE));
            }
            if (value < -JANET_INTMAX_INT64) {
                janet_panicf("cannot convert %q to a number, must be in the range [%q, %q]", argv[0], janet_wrap_number(JANET_INTMIN_DOUBLE), janet_wrap_number(JANET_INTMAX_DOUBLE));
            }
            return janet_wrap_number((double)value);
        }

        if (janet_abstract_type(abst) == &janet_u64_type) {
            uint64_t value = *((uint64_t *)abst);
            if (value > JANET_INTMAX_INT64) {
                janet_panicf("cannot convert %q to a number, must be in the range [%q, %q]", argv[0], janet_wrap_number(JANET_INTMIN_DOUBLE), janet_wrap_number(JANET_INTMAX_DOUBLE));
            }

            return janet_wrap_number((double)value);
        }
    }

    janet_panicf("expected int/u64 or int/s64, got %q", argv[0]);
}

JANET_CORE_FN(cfun_to_bytes,
              "(int/to-bytes value &opt endianness buffer)",
              "Write the bytes of an `int/s64` or `int/u64` into a buffer.\n"
              "The `buffer` parameter specifies an existing buffer to write to, if unset a new buffer will be created.\n"
              "Returns the modified buffer.\n"
              "The `endianness` paramater indicates the byte order:\n"
              "- `nil` (unset): system byte order\n"
              "- `:le`: little-endian, least significant byte first\n"
              "- `:be`: big-endian, most significant byte first\n") {
    janet_arity(argc, 1, 3);
    if (janet_is_int(argv[0]) == JANET_INT_NONE) {
        janet_panicf("int/to-bytes: expected an int/s64 or int/u64, got %q", argv[0]);
    }

    int reverse = 0;
    if (argc > 1 && !janet_checktype(argv[1], JANET_NIL)) {
        JanetKeyword endianness_kw = janet_getkeyword(argv, 1);
        if (!janet_cstrcmp(endianness_kw, "le")) {
#if JANET_BIG_ENDIAN
            reverse = 1;
#endif
        } else if (!janet_cstrcmp(endianness_kw, "be")) {
#if JANET_LITTLE_ENDIAN
            reverse = 1;
#endif
        } else {
            janet_panicf("int/to-bytes: expected endianness :le, :be or nil, got %v", argv[1]);
        }
    }

    JanetBuffer *buffer = NULL;
    if (argc > 2 && !janet_checktype(argv[2], JANET_NIL)) {
        if (!janet_checktype(argv[2], JANET_BUFFER)) {
            janet_panicf("int/to-bytes: expected buffer or nil, got %q", argv[2]);
        }

        buffer = janet_unwrap_buffer(argv[2]);
        janet_buffer_extra(buffer, 8);
    } else {
        buffer = janet_buffer(8);
    }

    uint8_t *bytes = janet_unwrap_abstract(argv[0]);
    if (reverse) {
        for (int i = 0; i < 8; ++i) {
            buffer->data[buffer->count + 7 - i] = bytes[i];
        }
    } else {
        memcpy(buffer->data + buffer->count, bytes, 8);
    }
    buffer->count += 8;

    return janet_wrap_buffer(buffer);
}

/*
 * Code to support polymorphic comparison.
 * int/u64 and int/s64 support a "compare" method that allows
 * comparison to each other, and to Janet numbers, using the
 * "compare" "compare<" ... functions.
 * In the following code explicit casts are sometimes used to help
 * make it clear when int/float conversions are happening.
 */
static int compare_double_double(double x, double y) {
    return (x < y) ? -1 : ((x > y) ? 1 : 0);
}

static int compare_int64_double(int64_t x, double y) {
    if (isnan(y)) {
        return 0; // clojure and python do this
    } else if ((y > (- ((double) MAX_INT_IN_DBL))) && (y < ((double) MAX_INT_IN_DBL))) {
        double dx = (double) x;
        return compare_double_double(dx, y);
    } else if (y > ((double) INT64_MAX)) {
        return -1;
    } else if (y < ((double) INT64_MIN)) {
        return 1;
    } else {
        int64_t yi = (int64_t) y;
        return (x < yi) ? -1 : ((x > yi) ? 1 : 0);
    }
}

static int compare_uint64_double(uint64_t x, double y) {
    if (isnan(y)) {
        return 0; // clojure and python do this
    } else if (y < 0) {
        return 1;
    } else if ((y >= 0) && (y < ((double) MAX_INT_IN_DBL))) {
        double dx = (double) x;
        return compare_double_double(dx, y);
    } else if (y > ((double) UINT64_MAX)) {
        return -1;
    } else {
        uint64_t yi = (uint64_t) y;
        return (x < yi) ? -1 : ((x > yi) ? 1 : 0);
    }
}

static Janet cfun_it_s64_compare(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    if (janet_is_int(argv[0]) != JANET_INT_S64)
        janet_panic("compare method requires int/s64 as first argument");
    int64_t x = janet_unwrap_s64(argv[0]);
    switch (janet_type(argv[1])) {
        default:
            break;
        case JANET_NUMBER : {
            double y = janet_unwrap_number(argv[1]);
            return janet_wrap_number(compare_int64_double(x, y));
        }
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(argv[1]);
            if (janet_abstract_type(abst) == &janet_s64_type) {
                int64_t y = *(int64_t *)abst;
                return janet_wrap_number((x < y) ? -1 : (x > y ? 1 : 0));
            } else if (janet_abstract_type(abst) == &janet_u64_type) {
                // comparing signed to unsigned -- be careful!
                uint64_t y = *(uint64_t *)abst;
                if (x < 0) {
                    return janet_wrap_number(-1);
                } else if (y > INT64_MAX) {
                    return janet_wrap_number(-1);
                } else {
                    int64_t y2 = (int64_t) y;
                    return janet_wrap_number((x < y2) ? -1 : (x > y2 ? 1 : 0));
                }
            }
            break;
        }
    }
    return janet_wrap_nil();
}

static Janet cfun_it_u64_compare(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    if (janet_is_int(argv[0]) != JANET_INT_U64)  // is this needed?
        janet_panic("compare method requires int/u64 as first argument");
    uint64_t x = janet_unwrap_u64(argv[0]);
    switch (janet_type(argv[1])) {
        default:
            break;
        case JANET_NUMBER : {
            double y = janet_unwrap_number(argv[1]);
            return janet_wrap_number(compare_uint64_double(x, y));
        }
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(argv[1]);
            if (janet_abstract_type(abst) == &janet_u64_type) {
                uint64_t y = *(uint64_t *)abst;
                return janet_wrap_number((x < y) ? -1 : (x > y ? 1 : 0));
            } else if (janet_abstract_type(abst) == &janet_s64_type) {
                // comparing unsigned to signed -- be careful!
                int64_t y = *(int64_t *)abst;
                if (y < 0) {
                    return janet_wrap_number(1);
                } else if (x > INT64_MAX) {
                    return janet_wrap_number(1);
                } else {
                    int64_t x2 = (int64_t) x;
                    return janet_wrap_number((x2 < y) ? -1 : (x2 > y ? 1 : 0));
                }
            }
            break;
        }
    }
    return janet_wrap_nil();
}

/*
 * In C, signed arithmetic overflow is undefined behvior
 * but unsigned arithmetic overflow is twos complement
 *
 * Reference:
 * https://en.cppreference.com/w/cpp/language/ub
 * http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html
 *
 * This means OPMETHOD & OPMETHODINVERT must always use
 * unsigned arithmetic internally, regardless of the true type.
 * This will not affect the end result (property of twos complement).
 */
#define OPMETHOD(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_arity(argc, 2, -1); \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[0]); \
    for (int32_t i = 1; i < argc; i++) \
        /* This avoids undefined behavior. See above for why. */ \
        *box = (T) ((uint64_t) (*box)) oper ((uint64_t) janet_unwrap_##type(argv[i])); \
    return janet_wrap_abstract(box); \
} \

#define OPMETHODINVERT(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_fixarity(argc, 2); \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[1]); \
    /* This avoids undefined behavior. See above for why. */ \
    *box = (T) ((uint64_t) *box) oper ((uint64_t) janet_unwrap_##type(argv[0])); \
    return janet_wrap_abstract(box); \
} \

#define DIVMETHOD(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_arity(argc, 2, -1);                       \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[0]); \
    for (int32_t i = 1; i < argc; i++) { \
      T value = janet_unwrap_##type(argv[i]); \
      if (value == 0) janet_panic("division by zero"); \
      *box oper##= value; \
    } \
    return janet_wrap_abstract(box); \
} \

#define DIVMETHODINVERT(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_fixarity(argc, 2);                       \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[1]); \
    T value = janet_unwrap_##type(argv[0]); \
    if (value == 0) janet_panic("division by zero"); \
    *box oper##= value; \
    return janet_wrap_abstract(box); \
} \

#define DIVMETHOD_SIGNED(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_arity(argc, 2, -1);                       \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[0]); \
    for (int32_t i = 1; i < argc; i++) { \
      T value = janet_unwrap_##type(argv[i]); \
      if (value == 0) janet_panic("division by zero"); \
      if ((value == -1) && (*box == INT64_MIN)) janet_panic("INT64_MIN divided by -1"); \
      *box oper##= value; \
    } \
    return janet_wrap_abstract(box); \
} \

#define DIVMETHODINVERT_SIGNED(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_fixarity(argc, 2);                       \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[1]); \
    T value = janet_unwrap_##type(argv[0]); \
    if (value == 0) janet_panic("division by zero"); \
    if ((value == -1) && (*box == INT64_MIN)) janet_panic("INT64_MIN divided by -1"); \
    *box oper##= value; \
    return janet_wrap_abstract(box); \
} \

static Janet cfun_it_s64_mod(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    int64_t *box = janet_abstract(&janet_s64_type, sizeof(int64_t));
    int64_t op1 = janet_unwrap_s64(argv[0]);
    int64_t op2 = janet_unwrap_s64(argv[1]);
    int64_t x = op1 % op2;
    *box = (op1 > 0)
           ? ((op2 > 0) ? x : (0 == x ? x : x + op2))
           : ((op2 > 0) ? (0 == x ? x : x + op2) : x);
    return janet_wrap_abstract(box);
}

OPMETHOD(int64_t, s64, add, +)
OPMETHOD(int64_t, s64, sub, -)
OPMETHODINVERT(int64_t, s64, subi, -)
OPMETHOD(int64_t, s64, mul, *)
DIVMETHOD_SIGNED(int64_t, s64, div, /)
DIVMETHOD_SIGNED(int64_t, s64, rem, %)
DIVMETHODINVERT_SIGNED(int64_t, s64, divi, /)
OPMETHOD(int64_t, s64, and, &)
OPMETHOD(int64_t, s64, or, |)
OPMETHOD(int64_t, s64, xor, ^)
OPMETHOD(int64_t, s64, lshift, <<)
OPMETHOD(int64_t, s64, rshift, >>)
OPMETHOD(uint64_t, u64, add, +)
OPMETHOD(uint64_t, u64, sub, -)
OPMETHODINVERT(uint64_t, u64, subi, -)
OPMETHOD(uint64_t, u64, mul, *)
DIVMETHOD(uint64_t, u64, div, /)
DIVMETHOD(uint64_t, u64, mod, %)
DIVMETHODINVERT(uint64_t, u64, divi, /)
OPMETHOD(uint64_t, u64, and, &)
OPMETHOD(uint64_t, u64, or, |)
OPMETHOD(uint64_t, u64, xor, ^)
OPMETHOD(uint64_t, u64, lshift, <<)
OPMETHOD(uint64_t, u64, rshift, >>)

#undef OPMETHOD
#undef DIVMETHOD
#undef DIVMETHOD_SIGNED
#undef COMPMETHOD

static JanetMethod it_s64_methods[] = {
    {"+", cfun_it_s64_add},
    {"r+", cfun_it_s64_add},
    {"-", cfun_it_s64_sub},
    {"r-", cfun_it_s64_subi},
    {"*", cfun_it_s64_mul},
    {"r*", cfun_it_s64_mul},
    {"/", cfun_it_s64_div},
    {"r/", cfun_it_s64_divi},
    {"mod", cfun_it_s64_mod},
    {"rmod", cfun_it_s64_mod},
    {"%", cfun_it_s64_rem},
    {"r%", cfun_it_s64_rem},
    {"&", cfun_it_s64_and},
    {"r&", cfun_it_s64_and},
    {"|", cfun_it_s64_or},
    {"r|", cfun_it_s64_or},
    {"^", cfun_it_s64_xor},
    {"r^", cfun_it_s64_xor},
    {"<<", cfun_it_s64_lshift},
    {">>", cfun_it_s64_rshift},
    {"compare", cfun_it_s64_compare},
    {NULL, NULL}
};

static JanetMethod it_u64_methods[] = {
    {"+", cfun_it_u64_add},
    {"r+", cfun_it_u64_add},
    {"-", cfun_it_u64_sub},
    {"r-", cfun_it_u64_subi},
    {"*", cfun_it_u64_mul},
    {"r*", cfun_it_u64_mul},
    {"/", cfun_it_u64_div},
    {"r/", cfun_it_u64_divi},
    {"mod", cfun_it_u64_mod},
    {"rmod", cfun_it_u64_mod},
    {"%", cfun_it_u64_mod},
    {"r%", cfun_it_u64_mod},
    {"&", cfun_it_u64_and},
    {"r&", cfun_it_u64_and},
    {"|", cfun_it_u64_or},
    {"r|", cfun_it_u64_or},
    {"^", cfun_it_u64_xor},
    {"r^", cfun_it_u64_xor},
    {"<<", cfun_it_u64_lshift},
    {">>", cfun_it_u64_rshift},
    {"compare", cfun_it_u64_compare},
    {NULL, NULL}
};

static Janet janet_int64_next(void *p, Janet key) {
    (void) p;
    return janet_nextmethod(it_s64_methods, key);
}

static Janet janet_uint64_next(void *p, Janet key) {
    (void) p;
    return janet_nextmethod(it_u64_methods, key);
}

static int it_s64_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD))
        return 0;
    return janet_getmethod(janet_unwrap_keyword(key), it_s64_methods, out);
}

static int it_u64_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD))
        return 0;
    return janet_getmethod(janet_unwrap_keyword(key), it_u64_methods, out);
}

/* Module entry point */
void janet_lib_inttypes(JanetTable *env) {
    JanetRegExt it_cfuns[] = {
        JANET_CORE_REG("int/s64", cfun_it_s64_new),
        JANET_CORE_REG("int/u64", cfun_it_u64_new),
        JANET_CORE_REG("int/to-number", cfun_to_number),
        JANET_CORE_REG("int/to-bytes", cfun_to_bytes),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, it_cfuns);
    janet_register_abstract_type(&janet_s64_type);
    janet_register_abstract_type(&janet_u64_type);
}

#endif


/* src/core/io.c */
#line 0 "src/core/io.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#include <stdio.h>
#include <errno.h>

#ifndef JANET_WINDOWS
#include <fcntl.h>
#include <sys/wait.h>
#include <unistd.h>
#endif

static int cfun_io_gc(void *p, size_t len);
static int io_file_get(void *p, Janet key, Janet *out);
static void io_file_marshal(void *p, JanetMarshalContext *ctx);
static void *io_file_unmarshal(JanetMarshalContext *ctx);
static Janet io_file_next(void *p, Janet key);

const JanetAbstractType janet_file_type = {
    "core/file",
    cfun_io_gc,
    NULL,
    io_file_get,
    NULL,
    io_file_marshal,
    io_file_unmarshal,
    NULL, /* tostring */
    NULL, /* compare */
    NULL, /* hash */
    io_file_next,
    JANET_ATEND_NEXT
};

/* Check arguments to fopen */
static int32_t checkflags(const uint8_t *str) {
    int32_t flags = 0;
    int32_t i;
    int32_t len = janet_string_length(str);
    if (!len || len > 10)
        janet_panic("file mode must have a length between 1 and 10");
    switch (*str) {
        default:
            janet_panicf("invalid flag %c, expected w, a, or r", *str);
            break;
        case 'w':
            flags |= JANET_FILE_WRITE;
            break;
        case 'a':
            flags |= JANET_FILE_APPEND;
            break;
        case 'r':
            flags |= JANET_FILE_READ;
            break;
    }
    for (i = 1; i < len; i++) {
        switch (str[i]) {
            default:
                janet_panicf("invalid flag %c, expected +, b, or n", str[i]);
                break;
            case '+':
                if (flags & JANET_FILE_UPDATE) return -1;
                flags |= JANET_FILE_UPDATE;
                break;
            case 'b':
                if (flags & JANET_FILE_BINARY) return -1;
                flags |= JANET_FILE_BINARY;
                break;
            case 'n':
                if (flags & JANET_FILE_NONIL) return -1;
                flags |= JANET_FILE_NONIL;
                break;
        }
    }
    return flags;
}

static void *makef(FILE *f, int32_t flags) {
    JanetFile *iof = (JanetFile *) janet_abstract(&janet_file_type, sizeof(JanetFile));
    iof->file = f;
    iof->flags = flags;
#ifndef JANET_WINDOWS
    /* While we would like fopen to set cloexec by default (like O_CLOEXEC) with the e flag, that is
     * not standard. */
    if (!(flags & JANET_FILE_NOT_CLOSEABLE))
        fcntl(fileno(f), F_SETFD, FD_CLOEXEC);
#endif
    return iof;
}

JANET_CORE_FN(cfun_io_temp,
              "(file/temp)",
              "Open an anonymous temporary file that is removed on close. "
              "Raises an error on failure.") {
    (void)argv;
    janet_fixarity(argc, 0);
    // XXX use mkostemp when we can to avoid CLOEXEC race.
    FILE *tmp = tmpfile();
    if (!tmp)
        janet_panicf("unable to create temporary file - %s", strerror(errno));
    return janet_makefile(tmp, JANET_FILE_WRITE | JANET_FILE_READ | JANET_FILE_BINARY);
}

JANET_CORE_FN(cfun_io_fopen,
              "(file/open path &opt mode)",
              "Open a file. `path` is an absolute or relative path, and "
              "`mode` is a set of flags indicating the mode to open the file in. "
              "`mode` is a keyword where each character represents a flag. If the file "
              "cannot be opened, returns nil, otherwise returns the new file handle. "
              "Mode flags:\n\n"
              "* r - allow reading from the file\n\n"
              "* w - allow writing to the file\n\n"
              "* a - append to the file\n\n"
              "Following one of the initial flags, 0 or more of the following flags can be appended:\n\n"
              "* b - open the file in binary mode (rather than text mode)\n\n"
              "* + - append to the file instead of overwriting it\n\n"
              "* n - error if the file cannot be opened instead of returning nil") {
    janet_arity(argc, 1, 2);
    const uint8_t *fname = janet_getstring(argv, 0);
    const uint8_t *fmode;
    int32_t flags;
    if (argc == 2) {
        fmode = janet_getkeyword(argv, 1);
        flags = checkflags(fmode);
    } else {
        fmode = (const uint8_t *)"r";
        flags = JANET_FILE_READ;
    }
    FILE *f = fopen((const char *)fname, (const char *)fmode);
    return f ? janet_makefile(f, flags)
           : (flags & JANET_FILE_NONIL) ? (janet_panicf("failed to open file %s: %s", fname, strerror(errno)), janet_wrap_nil())
           : janet_wrap_nil();
}

/* Read up to n bytes into buffer. */
static void read_chunk(JanetFile *iof, JanetBuffer *buffer, int32_t nBytesMax) {
    if (!(iof->flags & (JANET_FILE_READ | JANET_FILE_UPDATE)))
        janet_panic("file is not readable");
    janet_buffer_extra(buffer, nBytesMax);
    size_t ntoread = nBytesMax;
    size_t nread = fread((char *)(buffer->data + buffer->count), 1, ntoread, iof->file);
    if (nread != ntoread && ferror(iof->file))
        janet_panic("could not read file");
    buffer->count += (int32_t) nread;
}

/* Read a certain number of bytes into memory */
JANET_CORE_FN(cfun_io_fread,
              "(file/read f what &opt buf)",
              "Read a number of bytes from a file `f` into a buffer. A buffer `buf` can "
              "be provided as an optional third argument, otherwise a new buffer "
              "is created. `what` can either be an integer or a keyword. Returns the "
              "buffer with file contents. "
              "Values for `what`:\n\n"
              "* :all - read the whole file\n\n"
              "* :line - read up to and including the next newline character\n\n"
              "* n (integer) - read up to n bytes from the file") {
    janet_arity(argc, 2, 3);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED) janet_panic("file is closed");
    JanetBuffer *buffer;
    if (argc == 2) {
        buffer = janet_buffer(0);
    } else {
        buffer = janet_getbuffer(argv, 2);
    }
    int32_t bufstart = buffer->count;
    if (janet_checktype(argv[1], JANET_KEYWORD)) {
        const uint8_t *sym = janet_unwrap_keyword(argv[1]);
        if (!janet_cstrcmp(sym, "all")) {
            int32_t sizeBefore;
            do {
                sizeBefore = buffer->count;
                read_chunk(iof, buffer, 4096);
            } while (sizeBefore < buffer->count);
            /* Never return nil for :all */
            return janet_wrap_buffer(buffer);
        } else if (!janet_cstrcmp(sym, "line")) {
            for (;;) {
                int x = fgetc(iof->file);
                if (x != EOF) janet_buffer_push_u8(buffer, (uint8_t)x);
                if (x == EOF || x == '\n') break;
            }
        } else {
            janet_panicf("expected one of :all, :line, got %v", argv[1]);
        }
    } else {
        int32_t len = janet_getinteger(argv, 1);
        if (len < 0) janet_panic("expected positive integer");
        read_chunk(iof, buffer, len);
    }
    if (bufstart == buffer->count) return janet_wrap_nil();
    return janet_wrap_buffer(buffer);
}

/* Write bytes to a file */
JANET_CORE_FN(cfun_io_fwrite,
              "(file/write f bytes)",
              "Writes to a file. 'bytes' must be string, buffer, or symbol. Returns the "
              "file.") {
    janet_arity(argc, 1, -1);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED)
        janet_panic("file is closed");
    if (!(iof->flags & (JANET_FILE_WRITE | JANET_FILE_APPEND | JANET_FILE_UPDATE)))
        janet_panic("file is not writeable");
    int32_t i;
    /* Verify all arguments before writing to file */
    for (i = 1; i < argc; i++)
        janet_getbytes(argv, i);
    for (i = 1; i < argc; i++) {
        JanetByteView view = janet_getbytes(argv, i);
        if (view.len) {
            if (!fwrite(view.bytes, view.len, 1, iof->file)) {
                janet_panic("error writing to file");
            }
        }
    }
    return argv[0];
}

/* Flush the bytes in the file */
JANET_CORE_FN(cfun_io_fflush,
              "(file/flush f)",
              "Flush any buffered bytes to the file system. In most files, writes are "
              "buffered for efficiency reasons. Returns the file handle.") {
    janet_fixarity(argc, 1);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED)
        janet_panic("file is closed");
    if (!(iof->flags & (JANET_FILE_WRITE | JANET_FILE_APPEND | JANET_FILE_UPDATE)))
        janet_panic("file is not writeable");
    if (fflush(iof->file))
        janet_panic("could not flush file");
    return argv[0];
}

#ifdef JANET_WINDOWS
#define WEXITSTATUS(x) x
#endif

/* For closing files from C API */
int janet_file_close(JanetFile *file) {
    int ret = 0;
    if (!(file->flags & (JANET_FILE_NOT_CLOSEABLE | JANET_FILE_CLOSED))) {
        ret = fclose(file->file);
        file->flags |= JANET_FILE_CLOSED;
        return ret;
    }
    return 0;
}

/* Cleanup a file */
static int cfun_io_gc(void *p, size_t len) {
    (void) len;
    JanetFile *iof = (JanetFile *)p;
    janet_file_close(iof);
    return 0;
}

/* Close a file */
JANET_CORE_FN(cfun_io_fclose,
              "(file/close f)",
              "Close a file and release all related resources. When you are "
              "done reading a file, close it to prevent a resource leak and let "
              "other processes read the file.") {
    janet_fixarity(argc, 1);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED)
        return janet_wrap_nil();
    if (iof->flags & (JANET_FILE_NOT_CLOSEABLE))
        janet_panic("file not closable");
    if (fclose(iof->file)) {
        iof->flags |= JANET_FILE_NOT_CLOSEABLE;
        janet_panic("could not close file");
    }
    iof->flags |= JANET_FILE_CLOSED;
    return janet_wrap_nil();
}

/* Seek a file */
JANET_CORE_FN(cfun_io_fseek,
              "(file/seek f &opt whence n)",
              "Jump to a relative location in the file `f`. `whence` must be one of:\n\n"
              "* :cur - jump relative to the current file location\n\n"
              "* :set - jump relative to the beginning of the file\n\n"
              "* :end - jump relative to the end of the file\n\n"
              "By default, `whence` is :cur. Optionally a value `n` may be passed "
              "for the relative number of bytes to seek in the file. `n` may be a real "
              "number to handle large files of more than 4GB. Returns the file handle.") {
    janet_arity(argc, 2, 3);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED)
        janet_panic("file is closed");
    long int offset = 0;
    int whence = SEEK_CUR;
    if (argc >= 2) {
        const uint8_t *whence_sym = janet_getkeyword(argv, 1);
        if (!janet_cstrcmp(whence_sym, "cur")) {
            whence = SEEK_CUR;
        } else if (!janet_cstrcmp(whence_sym, "set")) {
            whence = SEEK_SET;
        } else if (!janet_cstrcmp(whence_sym, "end")) {
            whence = SEEK_END;
        } else {
            janet_panicf("expected one of :cur, :set, :end, got %v", argv[1]);
        }
        if (argc == 3) {
            offset = (long) janet_getinteger64(argv, 2);
        }
    }
    if (fseek(iof->file, offset, whence)) janet_panic("error seeking file");
    return argv[0];
}

static JanetMethod io_file_methods[] = {
    {"close", cfun_io_fclose},
    {"flush", cfun_io_fflush},
    {"read", cfun_io_fread},
    {"seek", cfun_io_fseek},
    {"write", cfun_io_fwrite},
    {NULL, NULL}
};

static int io_file_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD))
        return 0;
    return janet_getmethod(janet_unwrap_keyword(key), io_file_methods, out);
}

static Janet io_file_next(void *p, Janet key) {
    (void) p;
    return janet_nextmethod(io_file_methods, key);
}

static void io_file_marshal(void *p, JanetMarshalContext *ctx) {
    JanetFile *iof = (JanetFile *)p;
    if (ctx->flags & JANET_MARSHAL_UNSAFE) {
        janet_marshal_abstract(ctx, p);
#ifdef JANET_WINDOWS
        janet_marshal_int(ctx, _fileno(iof->file));
#else
        janet_marshal_int(ctx, fileno(iof->file));
#endif
        janet_marshal_int(ctx, iof->flags);
    } else {
        janet_panic("cannot marshal file in safe mode");
    }
}

static void *io_file_unmarshal(JanetMarshalContext *ctx) {
    if (ctx->flags & JANET_MARSHAL_UNSAFE) {
        JanetFile *iof = janet_unmarshal_abstract(ctx, sizeof(JanetFile));
        int32_t fd = janet_unmarshal_int(ctx);
        int32_t flags = janet_unmarshal_int(ctx);
        char fmt[4] = {0};
        int index = 0;
        if (flags & JANET_FILE_READ) fmt[index++] = 'r';
        if (flags & JANET_FILE_APPEND) {
            fmt[index++] = 'a';
        } else if (flags & JANET_FILE_WRITE) {
            fmt[index++] = 'w';
        }
#ifdef JANET_WINDOWS
        iof->file = _fdopen(fd, fmt);
#else
        iof->file = fdopen(fd, fmt);
#endif
        if (iof->file == NULL) {
            iof->flags = JANET_FILE_CLOSED;
        } else {
            iof->flags = flags;
        }
        return iof;
    } else {
        janet_panic("cannot unmarshal file in safe mode");
    }
}

FILE *janet_dynfile(const char *name, FILE *def) {
    Janet x = janet_dyn(name);
    if (!janet_checktype(x, JANET_ABSTRACT)) return def;
    void *abstract = janet_unwrap_abstract(x);
    if (janet_abstract_type(abstract) != &janet_file_type) return def;
    JanetFile *iofile = abstract;
    return iofile->file;
}

static Janet cfun_io_print_impl_x(int32_t argc, Janet *argv, int newline,
                                  FILE *dflt_file, int32_t offset, Janet x) {
    FILE *f;
    switch (janet_type(x)) {
        default:
            janet_panicf("cannot print to %v", x);
        case JANET_BUFFER: {
            /* Special case buffer */
            JanetBuffer *buf = janet_unwrap_buffer(x);
            for (int32_t i = offset; i < argc; ++i) {
                janet_to_string_b(buf, argv[i]);
            }
            if (newline)
                janet_buffer_push_u8(buf, '\n');
            return janet_wrap_nil();
        }
        case JANET_FUNCTION: {
            /* Special case function */
            JanetFunction *fun = janet_unwrap_function(x);
            JanetBuffer *buf = janet_buffer(0);
            for (int32_t i = offset; i < argc; ++i) {
                janet_to_string_b(buf, argv[i]);
            }
            if (newline)
                janet_buffer_push_u8(buf, '\n');
            Janet args[1] = { janet_wrap_buffer(buf) };
            janet_call(fun, 1, args);
            return janet_wrap_nil();
        }
        case JANET_NIL:
            f = dflt_file;
            if (f == NULL) janet_panic("cannot print to nil");
            break;
        case JANET_ABSTRACT: {
            void *abstract = janet_unwrap_abstract(x);
            if (janet_abstract_type(abstract) != &janet_file_type)
                return janet_wrap_nil();
            JanetFile *iofile = abstract;
            f = iofile->file;
            break;
        }
    }
    for (int32_t i = offset; i < argc; ++i) {
        int32_t len;
        const uint8_t *vstr;
        if (janet_checktype(argv[i], JANET_BUFFER)) {
            JanetBuffer *b = janet_unwrap_buffer(argv[i]);
            vstr = b->data;
            len = b->count;
        } else {
            vstr = janet_to_string(argv[i]);
            len = janet_string_length(vstr);
        }
        if (len) {
            if (1 != fwrite(vstr, len, 1, f)) {
                if (f == dflt_file) {
                    janet_panicf("cannot print %d bytes", len);
                } else {
                    janet_panicf("cannot print %d bytes to %v", len, x);
                }
            }
        }
    }
    if (newline)
        putc('\n', f);
    return janet_wrap_nil();
}


static Janet cfun_io_print_impl(int32_t argc, Janet *argv,
                                int newline, const char *name, FILE *dflt_file) {
    Janet x = janet_dyn(name);
    return cfun_io_print_impl_x(argc, argv, newline, dflt_file, 0, x);
}

JANET_CORE_FN(cfun_io_print,
              "(print & xs)",
              "Print values to the console (standard out). Value are converted "
              "to strings if they are not already. After printing all values, a "
              "newline character is printed. Use the value of `(dyn :out stdout)` to determine "
              "what to push characters to. Expects `(dyn :out stdout)` to be either a core/file or "
              "a buffer. Returns nil.") {
    return cfun_io_print_impl(argc, argv, 1, "out", stdout);
}

JANET_CORE_FN(cfun_io_prin,
              "(prin & xs)",
              "Same as `print`, but does not add trailing newline.") {
    return cfun_io_print_impl(argc, argv, 0, "out", stdout);
}

JANET_CORE_FN(cfun_io_eprint,
              "(eprint & xs)",
              "Same as `print`, but uses `(dyn :err stderr)` instead of `(dyn :out stdout)`.") {
    return cfun_io_print_impl(argc, argv, 1, "err", stderr);
}

JANET_CORE_FN(cfun_io_eprin,
              "(eprin & xs)",
              "Same as `prin`, but uses `(dyn :err stderr)` instead of `(dyn :out stdout)`.") {
    return cfun_io_print_impl(argc, argv, 0, "err", stderr);
}

JANET_CORE_FN(cfun_io_xprint,
              "(xprint to & xs)",
              "Print to a file or other value explicitly (no dynamic bindings) with a trailing "
              "newline character. The value to print "
              "to is the first argument, and is otherwise the same as `print`. Returns nil.") {
    janet_arity(argc, 1, -1);
    return cfun_io_print_impl_x(argc, argv, 1, NULL, 1, argv[0]);
}

JANET_CORE_FN(cfun_io_xprin,
              "(xprin to & xs)",
              "Print to a file or other value explicitly (no dynamic bindings). The value to print "
              "to is the first argument, and is otherwise the same as `prin`. Returns nil.") {
    janet_arity(argc, 1, -1);
    return cfun_io_print_impl_x(argc, argv, 0, NULL, 1, argv[0]);
}

static Janet cfun_io_printf_impl_x(int32_t argc, Janet *argv, int newline,
                                   FILE *dflt_file, int32_t offset, Janet x) {
    FILE *f;
    const char *fmt = janet_getcstring(argv, offset);
    switch (janet_type(x)) {
        default:
            janet_panicf("cannot print to %v", x);
        case JANET_BUFFER: {
            /* Special case buffer */
            JanetBuffer *buf = janet_unwrap_buffer(x);
            janet_buffer_format(buf, fmt, offset, argc, argv);
            if (newline) janet_buffer_push_u8(buf, '\n');
            return janet_wrap_nil();
        }
        case JANET_FUNCTION: {
            /* Special case function */
            JanetFunction *fun = janet_unwrap_function(x);
            JanetBuffer *buf = janet_buffer(0);
            janet_buffer_format(buf, fmt, offset, argc, argv);
            if (newline) janet_buffer_push_u8(buf, '\n');
            Janet args[1] = { janet_wrap_buffer(buf) };
            janet_call(fun, 1, args);
            return janet_wrap_nil();
        }
        case JANET_NIL:
            f = dflt_file;
            if (f == NULL) janet_panic("cannot print to nil");
            break;
        case JANET_ABSTRACT: {
            void *abstract = janet_unwrap_abstract(x);
            if (janet_abstract_type(abstract) != &janet_file_type)
                return janet_wrap_nil();
            JanetFile *iofile = abstract;
            f = iofile->file;
            break;
        }
    }
    JanetBuffer *buf = janet_buffer(10);
    janet_buffer_format(buf, fmt, offset, argc, argv);
    if (newline) janet_buffer_push_u8(buf, '\n');
    if (buf->count) {
        if (1 != fwrite(buf->data, buf->count, 1, f)) {
            janet_panicf("could not print %d bytes to file", buf->count);
        }
    }
    /* Clear buffer to make things easier for GC */
    buf->count = 0;
    buf->capacity = 0;
    janet_free(buf->data);
    buf->data = NULL;
    return janet_wrap_nil();
}

static Janet cfun_io_printf_impl(int32_t argc, Janet *argv, int newline,
                                 const char *name, FILE *dflt_file) {
    janet_arity(argc, 1, -1);
    Janet x = janet_dyn(name);
    return cfun_io_printf_impl_x(argc, argv, newline, dflt_file, 0, x);

}

JANET_CORE_FN(cfun_io_printf,
              "(printf fmt & xs)",
              "Prints output formatted as if with `(string/format fmt ;xs)` to `(dyn :out stdout)` with a trailing newline.") {
    return cfun_io_printf_impl(argc, argv, 1, "out", stdout);
}

JANET_CORE_FN(cfun_io_prinf,
              "(prinf fmt & xs)",
              "Like `printf` but with no trailing newline.") {
    return cfun_io_printf_impl(argc, argv, 0, "out", stdout);
}

JANET_CORE_FN(cfun_io_eprintf,
              "(eprintf fmt & xs)",
              "Prints output formatted as if with `(string/format fmt ;xs)` to `(dyn :err stderr)` with a trailing newline.") {
    return cfun_io_printf_impl(argc, argv, 1, "err", stderr);
}

JANET_CORE_FN(cfun_io_eprinf,
              "(eprinf fmt & xs)",
              "Like `eprintf` but with no trailing newline.") {
    return cfun_io_printf_impl(argc, argv, 0, "err", stderr);
}

JANET_CORE_FN(cfun_io_xprintf,
              "(xprintf to fmt & xs)",
              "Like `printf` but prints to an explicit file or value `to`. Returns nil.") {
    janet_arity(argc, 2, -1);
    return cfun_io_printf_impl_x(argc, argv, 1, NULL, 1, argv[0]);
}

JANET_CORE_FN(cfun_io_xprinf,
              "(xprinf to fmt & xs)",
              "Like `prinf` but prints to an explicit file or value `to`. Returns nil.") {
    janet_arity(argc, 2, -1);
    return cfun_io_printf_impl_x(argc, argv, 0, NULL, 1, argv[0]);
}

static void janet_flusher(const char *name, FILE *dflt_file) {
    Janet x = janet_dyn(name);
    switch (janet_type(x)) {
        default:
            break;
        case JANET_NIL:
            fflush(dflt_file);
            break;
        case JANET_ABSTRACT: {
            void *abstract = janet_unwrap_abstract(x);
            if (janet_abstract_type(abstract) != &janet_file_type) break;
            JanetFile *iofile = abstract;
            fflush(iofile->file);
            break;
        }
    }
}

JANET_CORE_FN(cfun_io_flush,
              "(flush)",
              "Flush `(dyn :out stdout)` if it is a file, otherwise do nothing.") {
    janet_fixarity(argc, 0);
    (void) argv;
    janet_flusher("out", stdout);
    return janet_wrap_nil();
}

JANET_CORE_FN(cfun_io_eflush,
              "(eflush)",
              "Flush `(dyn :err stderr)` if it is a file, otherwise do nothing.") {
    janet_fixarity(argc, 0);
    (void) argv;
    janet_flusher("err", stderr);
    return janet_wrap_nil();
}

void janet_dynprintf(const char *name, FILE *dflt_file, const char *format, ...) {
    va_list args;
    va_start(args, format);
    Janet x = janet_dyn(name);
    JanetType xtype = janet_type(x);
    switch (xtype) {
        default:
            /* Other values simply do nothing */
            break;
        case JANET_NIL:
        case JANET_ABSTRACT: {
            FILE *f = dflt_file;
            JanetBuffer buffer;
            int32_t len = 0;
            while (format[len]) len++;
            janet_buffer_init(&buffer, len);
            janet_formatbv(&buffer, format, args);
            if (xtype == JANET_ABSTRACT) {
                void *abstract = janet_unwrap_abstract(x);
                if (janet_abstract_type(abstract) != &janet_file_type)
                    break;
                JanetFile *iofile = abstract;
                f = iofile->file;
            }
            fwrite(buffer.data, buffer.count, 1, f);
            janet_buffer_deinit(&buffer);
            break;
        }
        case JANET_FUNCTION: {
            JanetFunction *fun = janet_unwrap_function(x);
            int32_t len = 0;
            while (format[len]) len++;
            JanetBuffer *buf = janet_buffer(len);
            janet_formatbv(buf, format, args);
            Janet args[1] = { janet_wrap_buffer(buf) };
            janet_call(fun, 1, args);
            break;
        }
        case JANET_BUFFER:
            janet_formatbv(janet_unwrap_buffer(x), format, args);
            break;
    }
    va_end(args);
    return;
}

/* C API */

JanetFile *janet_getjfile(const Janet *argv, int32_t n) {
    return janet_getabstract(argv, n, &janet_file_type);
}

FILE *janet_getfile(const Janet *argv, int32_t n, int *flags) {
    JanetFile *iof = janet_getabstract(argv, n, &janet_file_type);
    if (NULL != flags) *flags = iof->flags;
    return iof->file;
}

JanetFile *janet_makejfile(FILE *f, int flags) {
    return makef(f, flags);
}

Janet janet_makefile(FILE *f, int flags) {
    return janet_wrap_abstract(makef(f, flags));
}

JanetAbstract janet_checkfile(Janet j) {
    return janet_checkabstract(j, &janet_file_type);
}

FILE *janet_unwrapfile(Janet j, int *flags) {
    JanetFile *iof = janet_unwrap_abstract(j);
    if (NULL != flags) *flags = iof->flags;
    return iof->file;
}

/* Module entry point */
void janet_lib_io(JanetTable *env) {
    JanetRegExt io_cfuns[] = {
        JANET_CORE_REG("print", cfun_io_print),
        JANET_CORE_REG("prin", cfun_io_prin),
        JANET_CORE_REG("printf", cfun_io_printf),
        JANET_CORE_REG("prinf", cfun_io_prinf),
        JANET_CORE_REG("eprin", cfun_io_eprin),
        JANET_CORE_REG("eprint", cfun_io_eprint),
        JANET_CORE_REG("eprintf", cfun_io_eprintf),
        JANET_CORE_REG("eprinf", cfun_io_eprinf),
        JANET_CORE_REG("xprint", cfun_io_xprint),
        JANET_CORE_REG("xprin", cfun_io_xprin),
        JANET_CORE_REG("xprintf", cfun_io_xprintf),
        JANET_CORE_REG("xprinf", cfun_io_xprinf),
        JANET_CORE_REG("flush", cfun_io_flush),
        JANET_CORE_REG("eflush", cfun_io_eflush),
        JANET_CORE_REG("file/temp", cfun_io_temp),
        JANET_CORE_REG("file/open", cfun_io_fopen),
        JANET_CORE_REG("file/close", cfun_io_fclose),
        JANET_CORE_REG("file/read", cfun_io_fread),
        JANET_CORE_REG("file/write", cfun_io_fwrite),
        JANET_CORE_REG("file/flush", cfun_io_fflush),
        JANET_CORE_REG("file/seek", cfun_io_fseek),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, io_cfuns);
    janet_register_abstract_type(&janet_file_type);
    int default_flags = JANET_FILE_NOT_CLOSEABLE | JANET_FILE_SERIALIZABLE;
    /* stdout */
    JANET_CORE_DEF(env, "stdout",
                   janet_makefile(stdout, JANET_FILE_APPEND | default_flags),
                   "The standard output file.");
    /* stderr */
    JANET_CORE_DEF(env, "stderr",
                   janet_makefile(stderr, JANET_FILE_APPEND | default_flags),
                   "The standard error file.");
    /* stdin */
    JANET_CORE_DEF(env, "stdin",
                   janet_makefile(stdin, JANET_FILE_READ | default_flags),
                   "The standard input file.");

}


/* src/core/marsh.c */
#line 0 "src/core/marsh.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "vector.h"
#include "gc.h"
#include "fiber.h"
#include "util.h"
#endif

typedef struct {
    JanetBuffer *buf;
    JanetTable seen;
    JanetTable *rreg;
    JanetFuncEnv **seen_envs;
    JanetFuncDef **seen_defs;
    int32_t nextid;
    int maybe_cycles;
} MarshalState;

/* Lead bytes in marshaling protocol */
enum {
    LB_REAL = 200,
    LB_NIL, /* 201 */
    LB_FALSE, /* 202 */
    LB_TRUE,  /* 203 */
    LB_FIBER, /* 204 */
    LB_INTEGER, /* 205 */
    LB_STRING, /* 206 */
    LB_SYMBOL, /* 207 */
    LB_KEYWORD, /* 208 */
    LB_ARRAY, /* 209 */
    LB_TUPLE, /* 210 */
    LB_TABLE, /* 211 */
    LB_TABLE_PROTO, /* 212 */
    LB_STRUCT, /* 213 */
    LB_BUFFER, /* 214 */
    LB_FUNCTION, /* 215 */
    LB_REGISTRY, /* 216 */
    LB_ABSTRACT, /* 217 */
    LB_REFERENCE, /* 218 */
    LB_FUNCENV_REF, /* 219 */
    LB_FUNCDEF_REF, /* 220 */
    LB_UNSAFE_CFUNCTION, /* 221 */
    LB_UNSAFE_POINTER, /* 222 */
    LB_STRUCT_PROTO, /* 223 */
#ifdef JANET_EV
    LB_THREADED_ABSTRACT/* 224 */
#endif
} LeadBytes;

/* Helper to look inside an entry in an environment */
static Janet entry_getval(Janet env_entry) {
    if (janet_checktype(env_entry, JANET_TABLE)) {
        JanetTable *entry = janet_unwrap_table(env_entry);
        Janet checkval = janet_table_get(entry, janet_ckeywordv("value"));
        if (janet_checktype(checkval, JANET_NIL)) {
            checkval = janet_table_get(entry, janet_ckeywordv("ref"));
        }
        return checkval;
    } else if (janet_checktype(env_entry, JANET_STRUCT)) {
        const JanetKV *entry = janet_unwrap_struct(env_entry);
        Janet checkval = janet_struct_get(entry, janet_ckeywordv("value"));
        if (janet_checktype(checkval, JANET_NIL)) {
            checkval = janet_struct_get(entry, janet_ckeywordv("ref"));
        }
        return checkval;
    } else {
        return janet_wrap_nil();
    }
}

/* Merge values from an environment into an existing lookup table. */
void janet_env_lookup_into(JanetTable *renv, JanetTable *env, const char *prefix, int recurse) {
    while (env) {
        for (int32_t i = 0; i < env->capacity; i++) {
            if (janet_checktype(env->data[i].key, JANET_SYMBOL)) {
                if (prefix) {
                    int32_t prelen = (int32_t) strlen(prefix);
                    const uint8_t *oldsym = janet_unwrap_symbol(env->data[i].key);
                    int32_t oldlen = janet_string_length(oldsym);
                    uint8_t *symbuf = janet_smalloc(prelen + oldlen);
                    safe_memcpy(symbuf, prefix, prelen);
                    safe_memcpy(symbuf + prelen, oldsym, oldlen);
                    Janet s = janet_symbolv(symbuf, prelen + oldlen);
                    janet_sfree(symbuf);
                    janet_table_put(renv, s, entry_getval(env->data[i].value));
                } else {
                    janet_table_put(renv,
                                    env->data[i].key,
                                    entry_getval(env->data[i].value));
                }
            }
        }
        env = recurse ? env->proto : NULL;
    }
}

/* Make a forward lookup table from an environment (for unmarshaling) */
JanetTable *janet_env_lookup(JanetTable *env) {
    JanetTable *renv = janet_table(env->count);
    janet_env_lookup_into(renv, env, NULL, 1);
    return renv;
}

/* Marshal an integer onto the buffer */
static void pushint(MarshalState *st, int32_t x) {
    if (x >= 0 && x < 128) {
        janet_buffer_push_u8(st->buf, x);
    } else if (x <= 8191 && x >= -8192) {
        uint8_t intbuf[2];
        intbuf[0] = ((x >> 8) & 0x3F) | 0x80;
        intbuf[1] = x & 0xFF;
        janet_buffer_push_bytes(st->buf, intbuf, 2);
    } else {
        uint8_t intbuf[5];
        intbuf[0] = LB_INTEGER;
        intbuf[1] = (x >> 24) & 0xFF;
        intbuf[2] = (x >> 16) & 0xFF;
        intbuf[3] = (x >> 8) & 0xFF;
        intbuf[4] = x & 0xFF;
        janet_buffer_push_bytes(st->buf, intbuf, 5);
    }
}

static void pushbyte(MarshalState *st, uint8_t b) {
    janet_buffer_push_u8(st->buf, b);
}

static void pushbytes(MarshalState *st, const uint8_t *bytes, int32_t len) {
    janet_buffer_push_bytes(st->buf, bytes, len);
}

/* Marshal a size_t onto the buffer */
static void push64(MarshalState *st, uint64_t x) {
    if (x <= 0xF0) {
        /* Single byte */
        pushbyte(st, (uint8_t) x);
    } else {
        /* Multibyte, little endian */
        uint8_t bytes[9];
        int nbytes = 0;
        while (x) {
            bytes[++nbytes] = x & 0xFF;
            x >>= 8;
        }
        bytes[0] = 0xF0 + nbytes;
        pushbytes(st, bytes, nbytes + 1);
    }
}

/* Forward declaration to enable mutual recursion. */
static void marshal_one(MarshalState *st, Janet x, int flags);
static void marshal_one_fiber(MarshalState *st, JanetFiber *fiber, int flags);
static void marshal_one_def(MarshalState *st, JanetFuncDef *def, int flags);
static void marshal_one_env(MarshalState *st, JanetFuncEnv *env, int flags);

/* Prevent stack overflows */
#define MARSH_STACKCHECK if ((flags & 0xFFFF) > JANET_RECURSION_GUARD) janet_panic("stack overflow")

/* Marshal a function env */
static void marshal_one_env(MarshalState *st, JanetFuncEnv *env, int flags) {
    MARSH_STACKCHECK;
    for (int32_t i = 0; i < janet_v_count(st->seen_envs); i++) {
        if (st->seen_envs[i] == env) {
            pushbyte(st, LB_FUNCENV_REF);
            pushint(st, i);
            return;
        }
    }
    janet_env_valid(env);
    janet_v_push(st->seen_envs, env);
    if (env->offset > 0 && (JANET_STATUS_ALIVE == janet_fiber_status(env->as.fiber))) {
        pushint(st, 0);
        pushint(st, env->length);
        Janet *values = env->as.fiber->data + env->offset;
        uint32_t *bitset = janet_stack_frame(values)->func->def->closure_bitset;
        for (int32_t i = 0; i < env->length; i++) {
            if (1 & (bitset[i >> 5] >> (i & 0x1F))) {
                marshal_one(st, values[i], flags + 1);
            } else {
                pushbyte(st, LB_NIL);
            }
        }
    } else {
        janet_env_maybe_detach(env);
        pushint(st, env->offset);
        pushint(st, env->length);
        if (env->offset > 0) {
            /* On stack variant */
            marshal_one(st, janet_wrap_fiber(env->as.fiber), flags + 1);
        } else {
            /* Off stack variant */
            for (int32_t i = 0; i < env->length; i++)
                marshal_one(st, env->as.values[i], flags + 1);
        }
    }
}

/* Marshal a sequence of u32s */
static void janet_marshal_u32s(MarshalState *st, const uint32_t *u32s, int32_t n) {
    for (int32_t i = 0; i < n; i++) {
        pushbyte(st, u32s[i] & 0xFF);
        pushbyte(st, (u32s[i] >> 8) & 0xFF);
        pushbyte(st, (u32s[i] >> 16) & 0xFF);
        pushbyte(st, (u32s[i] >> 24) & 0xFF);
    }
}

/* Marshal a function def */
static void marshal_one_def(MarshalState *st, JanetFuncDef *def, int flags) {
    MARSH_STACKCHECK;
    for (int32_t i = 0; i < janet_v_count(st->seen_defs); i++) {
        if (st->seen_defs[i] == def) {
            pushbyte(st, LB_FUNCDEF_REF);
            pushint(st, i);
            return;
        }
    }
    /* Add to lookup */
    janet_v_push(st->seen_defs, def);
    pushint(st, def->flags);
    pushint(st, def->slotcount);
    pushint(st, def->arity);
    pushint(st, def->min_arity);
    pushint(st, def->max_arity);
    pushint(st, def->constants_length);
    pushint(st, def->bytecode_length);
    if (def->flags & JANET_FUNCDEF_FLAG_HASENVS)
        pushint(st, def->environments_length);
    if (def->flags & JANET_FUNCDEF_FLAG_HASDEFS)
        pushint(st, def->defs_length);
    if (def->flags & JANET_FUNCDEF_FLAG_HASNAME)
        marshal_one(st, janet_wrap_string(def->name), flags);
    if (def->flags & JANET_FUNCDEF_FLAG_HASSOURCE)
        marshal_one(st, janet_wrap_string(def->source), flags);

    /* marshal constants */
    for (int32_t i = 0; i < def->constants_length; i++)
        marshal_one(st, def->constants[i], flags);

    /* marshal the bytecode */
    janet_marshal_u32s(st, def->bytecode, def->bytecode_length);

    /* marshal the environments if needed */
    for (int32_t i = 0; i < def->environments_length; i++)
        pushint(st, def->environments[i]);

    /* marshal the sub funcdefs if needed */
    for (int32_t i = 0; i < def->defs_length; i++)
        marshal_one_def(st, def->defs[i], flags);

    /* marshal source maps if needed */
    if (def->flags & JANET_FUNCDEF_FLAG_HASSOURCEMAP) {
        int32_t current = 0;
        for (int32_t i = 0; i < def->bytecode_length; i++) {
            JanetSourceMapping map = def->sourcemap[i];
            pushint(st, map.line - current);
            pushint(st, map.column);
            current = map.line;
        }
    }

    /* Marshal closure bitset, if needed */
    if (def->flags & JANET_FUNCDEF_FLAG_HASCLOBITSET) {
        janet_marshal_u32s(st, def->closure_bitset, ((def->slotcount + 31) >> 5));
    }
}

#define JANET_FIBER_FLAG_HASCHILD (1 << 29)
#define JANET_FIBER_FLAG_HASENV   (1 << 30)
#define JANET_STACKFRAME_HASENV   (INT32_MIN)

/* Marshal a fiber */
static void marshal_one_fiber(MarshalState *st, JanetFiber *fiber, int flags) {
    MARSH_STACKCHECK;
    int32_t fflags = fiber->flags;
    if (fiber->child) fflags |= JANET_FIBER_FLAG_HASCHILD;
    if (fiber->env) fflags |= JANET_FIBER_FLAG_HASENV;
    if (janet_fiber_status(fiber) == JANET_STATUS_ALIVE)
        janet_panic("cannot marshal alive fiber");
    pushint(st, fflags);
    pushint(st, fiber->frame);
    pushint(st, fiber->stackstart);
    pushint(st, fiber->stacktop);
    pushint(st, fiber->maxstack);
    /* Do frames */
    int32_t i = fiber->frame;
    int32_t j = fiber->stackstart - JANET_FRAME_SIZE;
    while (i > 0) {
        JanetStackFrame *frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
        if (frame->env) frame->flags |= JANET_STACKFRAME_HASENV;
        if (!frame->func) janet_panic("cannot marshal fiber with c stackframe");
        pushint(st, frame->flags);
        pushint(st, frame->prevframe);
        int32_t pcdiff = (int32_t)(frame->pc - frame->func->def->bytecode);
        pushint(st, pcdiff);
        marshal_one(st, janet_wrap_function(frame->func), flags + 1);
        if (frame->env) marshal_one_env(st, frame->env, flags + 1);
        /* Marshal all values in the stack frame */
        for (int32_t k = i; k < j; k++)
            marshal_one(st, fiber->data[k], flags + 1);
        j = i - JANET_FRAME_SIZE;
        i = frame->prevframe;
    }
    if (fiber->env) {
        marshal_one(st, janet_wrap_table(fiber->env), flags + 1);
    }
    if (fiber->child)
        marshal_one(st, janet_wrap_fiber(fiber->child), flags + 1);
    marshal_one(st, fiber->last_value, flags + 1);
}

void janet_marshal_size(JanetMarshalContext *ctx, size_t value) {
    janet_marshal_int64(ctx, (int64_t) value);
}

void janet_marshal_int64(JanetMarshalContext *ctx, int64_t value) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    push64(st, (uint64_t) value);
}

void janet_marshal_int(JanetMarshalContext *ctx, int32_t value) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    pushint(st, value);
}

void janet_marshal_byte(JanetMarshalContext *ctx, uint8_t value) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    pushbyte(st, value);
}

void janet_marshal_bytes(JanetMarshalContext *ctx, const uint8_t *bytes, size_t len) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    if (len > INT32_MAX) janet_panic("size_t too large to fit in buffer");
    pushbytes(st, bytes, (int32_t) len);
}

void janet_marshal_janet(JanetMarshalContext *ctx, Janet x) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    marshal_one(st, x, ctx->flags + 1);
}

void janet_marshal_abstract(JanetMarshalContext *ctx, void *abstract) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    if (st->maybe_cycles) {
        janet_table_put(&st->seen,
                        janet_wrap_abstract(abstract),
                        janet_wrap_integer(st->nextid++));
    }
}

#define MARK_SEEN() \
    do { if (st->maybe_cycles) janet_table_put(&st->seen, x, janet_wrap_integer(st->nextid++)); } while (0)

static void marshal_one_abstract(MarshalState *st, Janet x, int flags) {
    void *abstract = janet_unwrap_abstract(x);
#ifdef JANET_EV
    /* Threaded abstract types get passed through as pointers in the unsafe mode */
    if ((flags & JANET_MARSHAL_UNSAFE) &&
            (JANET_MEMORY_THREADED_ABSTRACT == (janet_abstract_head(abstract)->gc.flags & JANET_MEM_TYPEBITS))) {

        /* Increment refcount before sending message. This prevents a "death in transit" problem
         * where a message is garbage collected while in transit between two threads - i.e., the sending threads
         * loses the reference and runs a garbage collection before the receiving thread gets the message. */
        janet_abstract_incref(abstract);
        pushbyte(st, LB_THREADED_ABSTRACT);
        pushbytes(st, (uint8_t *) &abstract, sizeof(abstract));
        MARK_SEEN();
        return;
    }
#endif
    const JanetAbstractType *at = janet_abstract_type(abstract);
    if (at->marshal) {
        pushbyte(st, LB_ABSTRACT);
        marshal_one(st, janet_csymbolv(at->name), flags + 1);
        JanetMarshalContext context = {st, NULL, flags, NULL, at};
        at->marshal(abstract, &context);
    } else {
        janet_panicf("cannot marshal %p", x);
    }
}

/* The main body of the marshaling function. Is the main
 * entry point for the mutually recursive functions. */
static void marshal_one(MarshalState *st, Janet x, int flags) {
    MARSH_STACKCHECK;
    JanetType type = janet_type(x);

    /* Check simple primitives (non reference types, no benefit from memoization) */
    switch (type) {
        default:
            break;
        case JANET_NIL:
            pushbyte(st, LB_NIL);
            return;
        case JANET_BOOLEAN:
            pushbyte(st, janet_unwrap_boolean(x) ? LB_TRUE : LB_FALSE);
            return;
        case JANET_NUMBER: {
            double xval = janet_unwrap_number(x);
            if (janet_checkintrange(xval)) {
                pushint(st, (int32_t) xval);
                return;
            }
            break;
        }
    }

    /* Check reference and registry value */
    {
        Janet check;
        if (st->maybe_cycles) {
            check = janet_table_get(&st->seen, x);
            if (janet_checkint(check)) {
                pushbyte(st, LB_REFERENCE);
                pushint(st, janet_unwrap_integer(check));
                return;
            }
        }
        if (st->rreg) {
            check = janet_table_get(st->rreg, x);
            if (janet_checktype(check, JANET_SYMBOL)) {
                MARK_SEEN();
                const uint8_t *regname = janet_unwrap_symbol(check);
                pushbyte(st, LB_REGISTRY);
                pushint(st, janet_string_length(regname));
                pushbytes(st, regname, janet_string_length(regname));
                return;
            }
        }
    }

    /* Reference types */
    switch (type) {
        case JANET_NUMBER: {
            union {
                double d;
                uint8_t bytes[8];
            } u;
            u.d = janet_unwrap_number(x);
#ifdef JANET_BIG_ENDIAN
            /* Swap byte order */
            uint8_t temp;
            temp = u.bytes[7];
            u.bytes[7] = u.bytes[0];
            u.bytes[0] = temp;
            temp = u.bytes[6];
            u.bytes[6] = u.bytes[1];
            u.bytes[1] = temp;
            temp = u.bytes[5];
            u.bytes[5] = u.bytes[2];
            u.bytes[2] = temp;
            temp = u.bytes[4];
            u.bytes[4] = u.bytes[3];
            u.bytes[3] = temp;
#endif
            pushbyte(st, LB_REAL);
            pushbytes(st, u.bytes, 8);
            MARK_SEEN();
            return;
        }
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD: {
            const uint8_t *str = janet_unwrap_string(x);
            int32_t length = janet_string_length(str);
            /* Record reference */
            MARK_SEEN();
            uint8_t lb = (type == JANET_STRING) ? LB_STRING :
                         (type == JANET_SYMBOL) ? LB_SYMBOL :
                         LB_KEYWORD;
            pushbyte(st, lb);
            pushint(st, length);
            pushbytes(st, str, length);
            return;
        }
        case JANET_BUFFER: {
            JanetBuffer *buffer = janet_unwrap_buffer(x);
            /* Record reference */
            MARK_SEEN();
            pushbyte(st, LB_BUFFER);
            pushint(st, buffer->count);
            pushbytes(st, buffer->data, buffer->count);
            return;
        }
        case JANET_ARRAY: {
            int32_t i;
            JanetArray *a = janet_unwrap_array(x);
            MARK_SEEN();
            pushbyte(st, LB_ARRAY);
            pushint(st, a->count);
            for (i = 0; i < a->count; i++)
                marshal_one(st, a->data[i], flags + 1);
            return;
        }
        case JANET_TUPLE: {
            int32_t i, count, flag;
            const Janet *tup = janet_unwrap_tuple(x);
            count = janet_tuple_length(tup);
            flag = janet_tuple_flag(tup) >> 16;
            pushbyte(st, LB_TUPLE);
            pushint(st, count);
            pushint(st, flag);
            for (i = 0; i < count; i++)
                marshal_one(st, tup[i], flags + 1);
            /* Mark as seen AFTER marshaling */
            MARK_SEEN();
            return;
        }
        case JANET_TABLE: {
            JanetTable *t = janet_unwrap_table(x);
            MARK_SEEN();
            pushbyte(st, t->proto ? LB_TABLE_PROTO : LB_TABLE);
            pushint(st, t->count);
            if (t->proto)
                marshal_one(st, janet_wrap_table(t->proto), flags + 1);
            for (int32_t i = 0; i < t->capacity; i++) {
                if (janet_checktype(t->data[i].key, JANET_NIL))
                    continue;
                marshal_one(st, t->data[i].key, flags + 1);
                marshal_one(st, t->data[i].value, flags + 1);
            }
            return;
        }
        case JANET_STRUCT: {
            int32_t count;
            const JanetKV *struct_ = janet_unwrap_struct(x);
            count = janet_struct_length(struct_);
            pushbyte(st, janet_struct_proto(struct_) ? LB_STRUCT_PROTO : LB_STRUCT);
            pushint(st, count);
            if (janet_struct_proto(struct_))
                marshal_one(st, janet_wrap_struct(janet_struct_proto(struct_)), flags + 1);
            for (int32_t i = 0; i < janet_struct_capacity(struct_); i++) {
                if (janet_checktype(struct_[i].key, JANET_NIL))
                    continue;
                marshal_one(st, struct_[i].key, flags + 1);
                marshal_one(st, struct_[i].value, flags + 1);
            }
            /* Mark as seen AFTER marshaling */
            MARK_SEEN();
            return;
        }
        case JANET_ABSTRACT: {
            marshal_one_abstract(st, x, flags);
            return;
        }
        case JANET_FUNCTION: {
            pushbyte(st, LB_FUNCTION);
            JanetFunction *func = janet_unwrap_function(x);
            pushint(st, func->def->environments_length);
            /* Mark seen before reading def */
            MARK_SEEN();
            marshal_one_def(st, func->def, flags);
            for (int32_t i = 0; i < func->def->environments_length; i++)
                marshal_one_env(st, func->envs[i], flags + 1);
            return;
        }
        case JANET_FIBER: {
            MARK_SEEN();
            pushbyte(st, LB_FIBER);
            marshal_one_fiber(st, janet_unwrap_fiber(x), flags + 1);
            return;
        }
        case JANET_CFUNCTION: {
            if (!(flags & JANET_MARSHAL_UNSAFE)) goto no_registry;
            MARK_SEEN();
            pushbyte(st, LB_UNSAFE_CFUNCTION);
            JanetCFunction cfn = janet_unwrap_cfunction(x);
            pushbytes(st, (uint8_t *) &cfn, sizeof(JanetCFunction));
            return;
        }
        case JANET_POINTER: {
            if (!(flags & JANET_MARSHAL_UNSAFE)) goto no_registry;
            MARK_SEEN();
            pushbyte(st, LB_UNSAFE_POINTER);
            void *ptr = janet_unwrap_pointer(x);
            pushbytes(st, (uint8_t *) &ptr, sizeof(void *));
            return;
        }
    no_registry:
        default: {
            janet_panicf("no registry value and cannot marshal %p", x);
        }
    }
#undef MARK_SEEN
}

void janet_marshal(
    JanetBuffer *buf,
    Janet x,
    JanetTable *rreg,
    int flags) {
    MarshalState st;
    st.buf = buf;
    st.nextid = 0;
    st.seen_defs = NULL;
    st.seen_envs = NULL;
    st.rreg = rreg;
    st.maybe_cycles = !(flags & JANET_MARSHAL_NO_CYCLES);
    janet_table_init(&st.seen, 0);
    marshal_one(&st, x, flags);
    janet_table_deinit(&st.seen);
    janet_v_free(st.seen_envs);
    janet_v_free(st.seen_defs);
}

typedef struct {
    jmp_buf err;
    Janet *lookup;
    JanetTable *reg;
    JanetFuncEnv **lookup_envs;
    JanetFuncDef **lookup_defs;
    const uint8_t *start;
    const uint8_t *end;
} UnmarshalState;

#define MARSH_EOS(st, data) do { \
    if ((data) >= (st)->end) janet_panic("unexpected end of source");\
} while (0)

/* Helper to read a 32 bit integer from an unmarshal state */
static int32_t readint(UnmarshalState *st, const uint8_t **atdata) {
    const uint8_t *data = *atdata;
    int32_t ret;
    MARSH_EOS(st, data);
    if (*data < 128) {
        ret = *data++;
    } else if (*data < 192) {
        MARSH_EOS(st, data + 1);
        uint32_t uret = ((data[0] & 0x3F) << 8) + data[1];
        /* Sign extend 18 MSBs */
        uret |= (uret >> 13) ? 0xFFFFC000 : 0;
        ret = (int32_t)uret;
        data += 2;
    } else if (*data == LB_INTEGER) {
        MARSH_EOS(st, data + 4);
        uint32_t ui = ((uint32_t)(data[1]) << 24) |
                      ((uint32_t)(data[2]) << 16) |
                      ((uint32_t)(data[3]) << 8) |
                      (uint32_t)(data[4]);
        ret = (int32_t)ui;
        data += 5;
    } else {
        janet_panicf("expected integer, got byte %x at index %d",
                     *data,
                     data - st->start);
        ret = 0;
    }
    *atdata = data;
    return ret;
}

/* Helper to read a natural number (int >= 0). */
static int32_t readnat(UnmarshalState *st, const uint8_t **atdata) {
    int32_t ret = readint(st, atdata);
    if (ret < 0) {
        janet_panicf("expected integer >= 0, got %d", ret);
    }
    return ret;
}

/* Helper to read a size_t (up to 8 bytes unsigned). */
static uint64_t read64(UnmarshalState *st, const uint8_t **atdata) {
    uint64_t ret;
    const uint8_t *data = *atdata;
    MARSH_EOS(st, data);
    if (*data <= 0xF0) {
        /* Single byte */
        ret = *data;
        *atdata = data + 1;
    } else {
        /* Multibyte, little endian */
        int nbytes = *data - 0xF0;
        ret = 0;
        if (nbytes > 8) janet_panic("invalid 64 bit integer");
        MARSH_EOS(st, data + nbytes);
        for (int i = nbytes; i > 0; i--)
            ret = (ret << 8) + data[i];
        *atdata = data + nbytes + 1;
    }
    return ret;
}

/* Assert a janet type */
static void janet_asserttype(Janet x, JanetType t) {
    if (!janet_checktype(x, t)) {
        janet_panicf("expected type %T, got %v", 1 << t, x);
    }
}

/* Forward declarations for mutual recursion */
static const uint8_t *unmarshal_one(
    UnmarshalState *st,
    const uint8_t *data,
    Janet *out,
    int flags);
static const uint8_t *unmarshal_one_env(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFuncEnv **out,
    int flags);
static const uint8_t *unmarshal_one_def(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFuncDef **out,
    int flags);
static const uint8_t *unmarshal_one_fiber(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFiber **out,
    int flags);

/* Unmarshal a funcenv */
static const uint8_t *unmarshal_one_env(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFuncEnv **out,
    int flags) {
    MARSH_EOS(st, data);
    if (*data == LB_FUNCENV_REF) {
        data++;
        int32_t index = readint(st, &data);
        if (index < 0 || index >= janet_v_count(st->lookup_envs))
            janet_panicf("invalid funcenv reference %d", index);
        *out = st->lookup_envs[index];
    } else {
        JanetFuncEnv *env = janet_gcalloc(JANET_MEMORY_FUNCENV, sizeof(JanetFuncEnv));
        env->length = 0;
        env->offset = 0;
        env->as.values = NULL;
        janet_v_push(st->lookup_envs, env);
        int32_t offset = readnat(st, &data);
        int32_t length = readnat(st, &data);
        if (offset > 0) {
            Janet fiberv;
            /* On stack variant */
            data = unmarshal_one(st, data, &fiberv, flags);
            janet_asserttype(fiberv, JANET_FIBER);
            env->as.fiber = janet_unwrap_fiber(fiberv);
            /* Negative offset indicates untrusted input */
            env->offset = -offset;
        } else {
            /* Off stack variant */
            if (length == 0) {
                janet_panic("invalid funcenv length");
            }
            env->as.values = janet_malloc(sizeof(Janet) * (size_t) length);
            if (!env->as.values) {
                JANET_OUT_OF_MEMORY;
            }
            env->offset = 0;
            for (int32_t i = 0; i < length; i++)
                data = unmarshal_one(st, data, env->as.values + i, flags);
        }
        env->length = length;
        *out = env;
    }
    return data;
}

/* Unmarshal a series of u32s */
static const uint8_t *janet_unmarshal_u32s(UnmarshalState *st, const uint8_t *data, uint32_t *into, int32_t n) {
    for (int32_t i = 0; i < n; i++) {
        MARSH_EOS(st, data + 3);
        into[i] =
            (uint32_t)(data[0]) |
            ((uint32_t)(data[1]) << 8) |
            ((uint32_t)(data[2]) << 16) |
            ((uint32_t)(data[3]) << 24);
        data += 4;
    }
    return data;
}

/* Unmarshal a funcdef */
static const uint8_t *unmarshal_one_def(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFuncDef **out,
    int flags) {
    MARSH_EOS(st, data);
    if (*data == LB_FUNCDEF_REF) {
        data++;
        int32_t index = readint(st, &data);
        if (index < 0 || index >= janet_v_count(st->lookup_defs))
            janet_panicf("invalid funcdef reference %d", index);
        *out = st->lookup_defs[index];
    } else {
        /* Initialize with values that will not break garbage collection
         * if unmarshalling fails. */
        JanetFuncDef *def = janet_gcalloc(JANET_MEMORY_FUNCDEF, sizeof(JanetFuncDef));
        def->environments_length = 0;
        def->defs_length = 0;
        def->constants_length = 0;
        def->bytecode_length = 0;
        def->name = NULL;
        def->source = NULL;
        def->closure_bitset = NULL;
        def->defs = NULL;
        def->environments = NULL;
        def->constants = NULL;
        def->bytecode = NULL;
        def->sourcemap = NULL;
        janet_v_push(st->lookup_defs, def);

        /* Set default lengths to zero */
        int32_t bytecode_length = 0;
        int32_t constants_length = 0;
        int32_t environments_length = 0;
        int32_t defs_length = 0;

        /* Read flags and other fixed values */
        def->flags = readint(st, &data);
        def->slotcount = readnat(st, &data);
        def->arity = readnat(st, &data);
        def->min_arity = readnat(st, &data);
        def->max_arity = readnat(st, &data);

        /* Read some lengths */
        constants_length = readnat(st, &data);
        bytecode_length = readnat(st, &data);
        if (def->flags & JANET_FUNCDEF_FLAG_HASENVS)
            environments_length = readnat(st, &data);
        if (def->flags & JANET_FUNCDEF_FLAG_HASDEFS)
            defs_length = readnat(st, &data);

        /* Check name and source (optional) */
        if (def->flags & JANET_FUNCDEF_FLAG_HASNAME) {
            Janet x;
            data = unmarshal_one(st, data, &x, flags + 1);
            janet_asserttype(x, JANET_STRING);
            def->name = janet_unwrap_string(x);
        }
        if (def->flags & JANET_FUNCDEF_FLAG_HASSOURCE) {
            Janet x;
            data = unmarshal_one(st, data, &x, flags + 1);
            janet_asserttype(x, JANET_STRING);
            def->source = janet_unwrap_string(x);
        }

        /* Unmarshal constants */
        if (constants_length) {
            def->constants = janet_malloc(sizeof(Janet) * constants_length);
            if (!def->constants) {
                JANET_OUT_OF_MEMORY;
            }
            for (int32_t i = 0; i < constants_length; i++)
                data = unmarshal_one(st, data, def->constants + i, flags + 1);
        } else {
            def->constants = NULL;
        }
        def->constants_length = constants_length;

        /* Unmarshal bytecode */
        def->bytecode = janet_malloc(sizeof(uint32_t) * bytecode_length);
        if (!def->bytecode) {
            JANET_OUT_OF_MEMORY;
        }
        data = janet_unmarshal_u32s(st, data, def->bytecode, bytecode_length);
        def->bytecode_length = bytecode_length;

        /* Unmarshal environments */
        if (def->flags & JANET_FUNCDEF_FLAG_HASENVS) {
            def->environments = janet_calloc(1, sizeof(int32_t) * (size_t) environments_length);
            if (!def->environments) {
                JANET_OUT_OF_MEMORY;
            }
            for (int32_t i = 0; i < environments_length; i++) {
                def->environments[i] = readint(st, &data);
            }
        } else {
            def->environments = NULL;
        }
        def->environments_length = environments_length;

        /* Unmarshal sub funcdefs */
        if (def->flags & JANET_FUNCDEF_FLAG_HASDEFS) {
            def->defs = janet_calloc(1, sizeof(JanetFuncDef *) * (size_t) defs_length);
            if (!def->defs) {
                JANET_OUT_OF_MEMORY;
            }
            for (int32_t i = 0; i < defs_length; i++) {
                data = unmarshal_one_def(st, data, def->defs + i, flags + 1);
            }
        } else {
            def->defs = NULL;
        }
        def->defs_length = defs_length;

        /* Unmarshal source maps if needed */
        if (def->flags & JANET_FUNCDEF_FLAG_HASSOURCEMAP) {
            int32_t current = 0;
            def->sourcemap = janet_malloc(sizeof(JanetSourceMapping) * (size_t) bytecode_length);
            if (!def->sourcemap) {
                JANET_OUT_OF_MEMORY;
            }
            for (int32_t i = 0; i < bytecode_length; i++) {
                current += readint(st, &data);
                def->sourcemap[i].line = current;
                def->sourcemap[i].column = readint(st, &data);
            }
        } else {
            def->sourcemap = NULL;
        }

        /* Unmarshal closure bitset if needed */
        if (def->flags & JANET_FUNCDEF_FLAG_HASCLOBITSET) {
            int32_t n = (def->slotcount + 31) >> 5;
            def->closure_bitset = janet_malloc(sizeof(uint32_t) * (size_t) n);
            if (NULL == def->closure_bitset) {
                JANET_OUT_OF_MEMORY;
            }
            data = janet_unmarshal_u32s(st, data, def->closure_bitset, n);
        }

        /* Validate */
        if (janet_verify(def))
            janet_panic("funcdef has invalid bytecode");

        /* Set def */
        *out = def;
    }
    return data;
}

/* Unmarshal a fiber */
static const uint8_t *unmarshal_one_fiber(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFiber **out,
    int flags) {

    /* Initialize a new fiber with gc friendly defaults */
    JanetFiber *fiber = janet_gcalloc(JANET_MEMORY_FIBER, sizeof(JanetFiber));
    fiber->flags = 0;
    fiber->frame = 0;
    fiber->stackstart = 0;
    fiber->stacktop = 0;
    fiber->capacity = 0;
    fiber->maxstack = 0;
    fiber->data = NULL;
    fiber->child = NULL;
    fiber->env = NULL;
    fiber->last_value = janet_wrap_nil();
#ifdef JANET_EV
    fiber->waiting = NULL;
    fiber->sched_id = 0;
    fiber->supervisor_channel = NULL;
#endif

    /* Push fiber to seen stack */
    janet_v_push(st->lookup, janet_wrap_fiber(fiber));

    /* Read ints */
    int32_t fiber_flags = readint(st, &data);
    int32_t frame = readnat(st, &data);
    int32_t fiber_stackstart = readnat(st, &data);
    int32_t fiber_stacktop = readnat(st, &data);
    int32_t fiber_maxstack = readnat(st, &data);
    JanetTable *fiber_env = NULL;

    /* Check for bad flags and ints */
    if ((int32_t)(frame + JANET_FRAME_SIZE) > fiber_stackstart ||
            fiber_stackstart > fiber_stacktop ||
            fiber_stacktop > fiber_maxstack) {
        janet_panic("fiber has incorrect stack setup");
    }

    /* Allocate stack memory */
    fiber->capacity = fiber_stacktop + 10;
    fiber->data = janet_malloc(sizeof(Janet) * fiber->capacity);
    if (!fiber->data) {
        JANET_OUT_OF_MEMORY;
    }
    for (int32_t i = 0; i < fiber->capacity; i++) {
        fiber->data[i] = janet_wrap_nil();
    }

    /* get frames */
    int32_t stack = frame;
    int32_t stacktop = fiber_stackstart - JANET_FRAME_SIZE;
    while (stack > 0) {
        JanetFunction *func = NULL;
        JanetFuncDef *def = NULL;
        JanetFuncEnv *env = NULL;
        int32_t frameflags = readint(st, &data);
        int32_t prevframe = readnat(st, &data);
        int32_t pcdiff = readnat(st, &data);

        /* Get frame items */
        Janet *framestack = fiber->data + stack;
        JanetStackFrame *framep = janet_stack_frame(framestack);

        /* Get function */
        Janet funcv;
        data = unmarshal_one(st, data, &funcv, flags + 1);
        janet_asserttype(funcv, JANET_FUNCTION);
        func = janet_unwrap_function(funcv);
        def = func->def;

        /* Check env */
        if (frameflags & JANET_STACKFRAME_HASENV) {
            frameflags &= ~JANET_STACKFRAME_HASENV;
            data = unmarshal_one_env(st, data, &env, flags + 1);
        }

        /* Error checking */
        int32_t expected_framesize = def->slotcount;
        if (expected_framesize != stacktop - stack) {
            janet_panic("fiber stackframe size mismatch");
        }
        if (pcdiff >= def->bytecode_length) {
            janet_panic("fiber stackframe has invalid pc");
        }
        if ((int32_t)(prevframe + JANET_FRAME_SIZE) > stack) {
            janet_panic("fiber stackframe does not align with previous frame");
        }

        /* Get stack items */
        for (int32_t i = stack; i < stacktop; i++)
            data = unmarshal_one(st, data, fiber->data + i, flags + 1);

        /* Set frame */
        framep->env = env;
        framep->pc = def->bytecode + pcdiff;
        framep->prevframe = prevframe;
        framep->flags = frameflags;
        framep->func = func;

        /* Goto previous frame */
        stacktop = stack - JANET_FRAME_SIZE;
        stack = prevframe;
    }
    if (stack < 0) {
        janet_panic("fiber has too many stackframes");
    }

    /* Check for fiber env */
    if (fiber_flags & JANET_FIBER_FLAG_HASENV) {
        Janet envv;
        fiber_flags &= ~JANET_FIBER_FLAG_HASENV;
        data = unmarshal_one(st, data, &envv, flags + 1);
        janet_asserttype(envv, JANET_TABLE);
        fiber_env = janet_unwrap_table(envv);
    }

    /* Check for child fiber */
    if (fiber_flags & JANET_FIBER_FLAG_HASCHILD) {
        Janet fiberv;
        fiber_flags &= ~JANET_FIBER_FLAG_HASCHILD;
        data = unmarshal_one(st, data, &fiberv, flags + 1);
        janet_asserttype(fiberv, JANET_FIBER);
        fiber->child = janet_unwrap_fiber(fiberv);
    }

    /* Get the fiber last value */
    data = unmarshal_one(st, data, &fiber->last_value, flags + 1);

    /* We have valid fiber, finally construct remaining fields. */
    fiber->frame = frame;
    fiber->flags = fiber_flags;
    fiber->stackstart = fiber_stackstart;
    fiber->stacktop = fiber_stacktop;
    fiber->maxstack = fiber_maxstack;
    fiber->env = fiber_env;

    int status = janet_fiber_status(fiber);
    if (status < 0 || status > JANET_STATUS_ALIVE) {
        janet_panic("invalid fiber status");
    }

    /* Return data */
    *out = fiber;
    return data;
}

void janet_unmarshal_ensure(JanetMarshalContext *ctx, size_t size) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    MARSH_EOS(st, ctx->data + size);
}

int32_t janet_unmarshal_int(JanetMarshalContext *ctx) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    return readint(st, &(ctx->data));
}

size_t janet_unmarshal_size(JanetMarshalContext *ctx) {
    return (size_t) janet_unmarshal_int64(ctx);
}

int64_t janet_unmarshal_int64(JanetMarshalContext *ctx) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    return read64(st, &(ctx->data));
}

uint8_t janet_unmarshal_byte(JanetMarshalContext *ctx) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    MARSH_EOS(st, ctx->data);
    return *(ctx->data++);
}

void janet_unmarshal_bytes(JanetMarshalContext *ctx, uint8_t *dest, size_t len) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    MARSH_EOS(st, ctx->data + len - 1);
    safe_memcpy(dest, ctx->data, len);
    ctx->data += len;
}

Janet janet_unmarshal_janet(JanetMarshalContext *ctx) {
    Janet ret;
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    ctx->data = unmarshal_one(st, ctx->data, &ret, ctx->flags);
    return ret;
}

void janet_unmarshal_abstract_reuse(JanetMarshalContext *ctx, void *p) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    if (ctx->at == NULL) {
        janet_panicf("janet_unmarshal_abstract called more than once");
    }
    janet_v_push(st->lookup, janet_wrap_abstract(p));
    ctx->at = NULL;
}

void *janet_unmarshal_abstract(JanetMarshalContext *ctx, size_t size) {
    void *p = janet_abstract(ctx->at, size);
    janet_unmarshal_abstract_reuse(ctx, p);
    return p;
}

static const uint8_t *unmarshal_one_abstract(UnmarshalState *st, const uint8_t *data, Janet *out, int flags) {
    Janet key;
    data = unmarshal_one(st, data, &key, flags + 1);
    const JanetAbstractType *at = janet_get_abstract_type(key);
    if (at == NULL) janet_panic("unknown abstract type");
    if (at->unmarshal) {
        JanetMarshalContext context = {NULL, st, flags, data, at};
        *out = janet_wrap_abstract(at->unmarshal(&context));
        if (context.at != NULL) {
            janet_panic("janet_unmarshal_abstract not called");
        }
        return context.data;
    }
    janet_panic("invalid abstract type - no unmarshal function pointer");
}

static const uint8_t *unmarshal_one(
    UnmarshalState *st,
    const uint8_t *data,
    Janet *out,
    int flags) {
    uint8_t lead;
    MARSH_STACKCHECK;
    MARSH_EOS(st, data);
    lead = data[0];
    if (lead < LB_REAL) {
        *out = janet_wrap_integer(readint(st, &data));
        return data;
    }
    switch (lead) {
        case LB_NIL:
            *out = janet_wrap_nil();
            return data + 1;
        case LB_FALSE:
            *out = janet_wrap_false();
            return data + 1;
        case LB_TRUE:
            *out = janet_wrap_true();
            return data + 1;
        case LB_INTEGER:
            /* Long integer */
            MARSH_EOS(st, data + 4);
            uint32_t ui = ((uint32_t)(data[4])) |
                          ((uint32_t)(data[3]) << 8) |
                          ((uint32_t)(data[2]) << 16) |
                          ((uint32_t)(data[1]) << 24);
            int32_t si = (int32_t)ui;
            *out = janet_wrap_integer(si);
            return data + 5;
        case LB_REAL:
            /* Real */
        {
            union {
                double d;
                uint8_t bytes[8];
            } u;
            MARSH_EOS(st, data + 8);
#ifdef JANET_BIG_ENDIAN
            u.bytes[0] = data[8];
            u.bytes[1] = data[7];
            u.bytes[2] = data[6];
            u.bytes[3] = data[5];
            u.bytes[4] = data[4];
            u.bytes[5] = data[3];
            u.bytes[6] = data[2];
            u.bytes[7] = data[1];
#else
            memcpy(&u.bytes, data + 1, sizeof(double));
#endif
            *out = janet_wrap_number_safe(u.d);
            janet_v_push(st->lookup, *out);
            return data + 9;
        }
        case LB_STRING:
        case LB_SYMBOL:
        case LB_BUFFER:
        case LB_KEYWORD:
        case LB_REGISTRY: {
            data++;
            int32_t len = readnat(st, &data);
            MARSH_EOS(st, data - 1 + len);
            if (lead == LB_STRING) {
                const uint8_t *str = janet_string(data, len);
                *out = janet_wrap_string(str);
            } else if (lead == LB_SYMBOL) {
                const uint8_t *str = janet_symbol(data, len);
                *out = janet_wrap_symbol(str);
            } else if (lead == LB_KEYWORD) {
                const uint8_t *str = janet_keyword(data, len);
                *out = janet_wrap_keyword(str);
            } else if (lead == LB_REGISTRY) {
                if (st->reg) {
                    Janet regkey = janet_symbolv(data, len);
                    *out = janet_table_get(st->reg, regkey);
                } else {
                    *out = janet_wrap_nil();
                }
            } else { /* (lead == LB_BUFFER) */
                JanetBuffer *buffer = janet_buffer(len);
                buffer->count = len;
                safe_memcpy(buffer->data, data, len);
                *out = janet_wrap_buffer(buffer);
            }
            janet_v_push(st->lookup, *out);
            return data + len;
        }
        case LB_FIBER: {
            JanetFiber *fiber;
            data = unmarshal_one_fiber(st, data + 1, &fiber, flags);
            *out = janet_wrap_fiber(fiber);
            return data;
        }
        case LB_FUNCTION: {
            JanetFunction *func;
            JanetFuncDef *def;
            data++;
            int32_t len = readnat(st, &data);
            if (len > 255) {
                janet_panicf("invalid function - too many environments (%d)", len);
            }
            func = janet_gcalloc(JANET_MEMORY_FUNCTION, sizeof(JanetFunction) +
                                 len * sizeof(JanetFuncEnv));
            func->def = NULL;
            *out = janet_wrap_function(func);
            janet_v_push(st->lookup, *out);
            data = unmarshal_one_def(st, data, &def, flags + 1);
            func->def = def;
            for (int32_t i = 0; i < len; i++) {
                data = unmarshal_one_env(st, data, &(func->envs[i]), flags + 1);
            }
            return data;
        }
        case LB_ABSTRACT: {
            data++;
            return unmarshal_one_abstract(st, data, out, flags);
        }
        case LB_REFERENCE:
        case LB_ARRAY:
        case LB_TUPLE:
        case LB_STRUCT:
        case LB_STRUCT_PROTO:
        case LB_TABLE:
        case LB_TABLE_PROTO:
            /* Things that open with integers */
        {
            data++;
            int32_t len = readnat(st, &data);
            /* DOS check */
            if (lead != LB_REFERENCE) {
                MARSH_EOS(st, data - 1 + len);
            }
            if (lead == LB_ARRAY) {
                /* Array */
                JanetArray *array = janet_array(len);
                array->count = len;
                *out = janet_wrap_array(array);
                janet_v_push(st->lookup, *out);
                for (int32_t i = 0; i < len; i++) {
                    data = unmarshal_one(st, data, array->data + i, flags + 1);
                }
            } else if (lead == LB_TUPLE) {
                /* Tuple */
                Janet *tup = janet_tuple_begin(len);
                int32_t flag = readint(st, &data);
                janet_tuple_flag(tup) |= flag << 16;
                for (int32_t i = 0; i < len; i++) {
                    data = unmarshal_one(st, data, tup + i, flags + 1);
                }
                *out = janet_wrap_tuple(janet_tuple_end(tup));
                janet_v_push(st->lookup, *out);
            } else if (lead == LB_STRUCT || lead == LB_STRUCT_PROTO) {
                /* Struct */
                JanetKV *struct_ = janet_struct_begin(len);
                if (lead == LB_STRUCT_PROTO) {
                    Janet proto;
                    data = unmarshal_one(st, data, &proto, flags + 1);
                    janet_asserttype(proto, JANET_STRUCT);
                    janet_struct_proto(struct_) = janet_unwrap_struct(proto);
                }
                for (int32_t i = 0; i < len; i++) {
                    Janet key, value;
                    data = unmarshal_one(st, data, &key, flags + 1);
                    data = unmarshal_one(st, data, &value, flags + 1);
                    janet_struct_put(struct_, key, value);
                }
                *out = janet_wrap_struct(janet_struct_end(struct_));
                janet_v_push(st->lookup, *out);
            } else if (lead == LB_REFERENCE) {
                if (len >= janet_v_count(st->lookup))
                    janet_panicf("invalid reference %d", len);
                *out = st->lookup[len];
            } else {
                /* Table */
                JanetTable *t = janet_table(len);
                *out = janet_wrap_table(t);
                janet_v_push(st->lookup, *out);
                if (lead == LB_TABLE_PROTO) {
                    Janet proto;
                    data = unmarshal_one(st, data, &proto, flags + 1);
                    janet_asserttype(proto, JANET_TABLE);
                    t->proto = janet_unwrap_table(proto);
                }
                for (int32_t i = 0; i < len; i++) {
                    Janet key, value;
                    data = unmarshal_one(st, data, &key, flags + 1);
                    data = unmarshal_one(st, data, &value, flags + 1);
                    janet_table_put(t, key, value);
                }
            }
            return data;
        }
        case LB_UNSAFE_POINTER: {
            MARSH_EOS(st, data + sizeof(void *));
            data++;
            if (!(flags & JANET_MARSHAL_UNSAFE)) {
                janet_panicf("unsafe flag not given, "
                             "will not unmarshal raw pointer at index %d",
                             (int)(data - st->start));
            }
            union {
                void *ptr;
                uint8_t bytes[sizeof(void *)];
            } u;
            memcpy(u.bytes, data, sizeof(void *));
            data += sizeof(void *);
            *out = janet_wrap_pointer(u.ptr);
            janet_v_push(st->lookup, *out);
            return data;
        }
        case LB_UNSAFE_CFUNCTION: {
            MARSH_EOS(st, data + sizeof(JanetCFunction));
            data++;
            if (!(flags & JANET_MARSHAL_UNSAFE)) {
                janet_panicf("unsafe flag not given, "
                             "will not unmarshal function pointer at index %d",
                             (int)(data - st->start));
            }
            union {
                JanetCFunction ptr;
                uint8_t bytes[sizeof(JanetCFunction)];
            } u;
            memcpy(u.bytes, data, sizeof(JanetCFunction));
            data += sizeof(JanetCFunction);
            *out = janet_wrap_cfunction(u.ptr);
            janet_v_push(st->lookup, *out);
            return data;
        }
#ifdef JANET_EV
        case LB_THREADED_ABSTRACT: {
            MARSH_EOS(st, data + sizeof(void *));
            data++;
            if (!(flags & JANET_MARSHAL_UNSAFE)) {
                janet_panicf("unsafe flag not given, "
                             "will not unmarshal threaded abstract pointer at index %d",
                             (int)(data - st->start));
            }
            union {
                void *ptr;
                uint8_t bytes[sizeof(void *)];
            } u;
            memcpy(u.bytes, data, sizeof(void *));
            data += sizeof(void *);

            if (flags & JANET_MARSHAL_DECREF) {
                /* Decrement immediately and don't bother putting into heap */
                janet_abstract_decref(u.ptr);
                *out = janet_wrap_nil();
            } else {
                *out = janet_wrap_abstract(u.ptr);
                Janet check = janet_table_get(&janet_vm.threaded_abstracts, *out);
                if (janet_checktype(check, JANET_NIL)) {
                    /* Transfers reference from threaded channel buffer to current heap */
                    janet_table_put(&janet_vm.threaded_abstracts, *out, janet_wrap_false());
                } else {
                    /* Heap reference already accounted for, remove threaded channel reference. */
                    janet_abstract_decref(u.ptr);
                }
            }

            janet_v_push(st->lookup, *out);
            return data;
        }
#endif
        default: {
            janet_panicf("unknown byte %x at index %d",
                         *data,
                         (int)(data - st->start));
            return NULL;
        }
    }
}

Janet janet_unmarshal(
    const uint8_t *bytes,
    size_t len,
    int flags,
    JanetTable *reg,
    const uint8_t **next) {
    UnmarshalState st;
    st.start = bytes;
    st.end = bytes + len;
    st.lookup_defs = NULL;
    st.lookup_envs = NULL;
    st.lookup = NULL;
    st.reg = reg;
    Janet out;
    const uint8_t *nextbytes = unmarshal_one(&st, bytes, &out, flags);
    if (next) *next = nextbytes;
    janet_v_free(st.lookup_defs);
    janet_v_free(st.lookup_envs);
    janet_v_free(st.lookup);
    return out;
}

/* C functions */

JANET_CORE_FN(cfun_env_lookup,
              "(env-lookup env)",
              "Creates a forward lookup table for unmarshalling from an environment. "
              "To create a reverse lookup table, use the invert function to swap keys "
              "and values in the returned table.") {
    janet_fixarity(argc, 1);
    JanetTable *env = janet_gettable(argv, 0);
    return janet_wrap_table(janet_env_lookup(env));
}

JANET_CORE_FN(cfun_marshal,
              "(marshal x &opt reverse-lookup buffer no-cycles)",
              "Marshal a value into a buffer and return the buffer. The buffer "
              "can then later be unmarshalled to reconstruct the initial value. "
              "Optionally, one can pass in a reverse lookup table to not marshal "
              "aliased values that are found in the table. Then a forward "
              "lookup table can be used to recover the original value when "
              "unmarshalling.") {
    janet_arity(argc, 1, 4);
    JanetBuffer *buffer;
    JanetTable *rreg = NULL;
    uint32_t flags = 0;
    if (argc > 1) {
        rreg = janet_gettable(argv, 1);
    }
    if (argc > 2) {
        buffer = janet_getbuffer(argv, 2);
    } else {
        buffer = janet_buffer(10);
    }
    if (argc > 3 && janet_truthy(argv[3])) {
        flags |= JANET_MARSHAL_NO_CYCLES;
    }
    janet_marshal(buffer, argv[0], rreg, flags);
    return janet_wrap_buffer(buffer);
}

JANET_CORE_FN(cfun_unmarshal,
              "(unmarshal buffer &opt lookup)",
              "Unmarshal a value from a buffer. An optional lookup table "
              "can be provided to allow for aliases to be resolved. Returns the value "
              "unmarshalled from the buffer.") {
    janet_arity(argc, 1, 2);
    JanetByteView view = janet_getbytes(argv, 0);
    JanetTable *reg = NULL;
    if (argc > 1) {
        reg = janet_gettable(argv, 1);
    }
    return janet_unmarshal(view.bytes, (size_t) view.len, 0, reg, NULL);
}

/* Module entry point */
void janet_lib_marsh(JanetTable *env) {
    JanetRegExt marsh_cfuns[] = {
        JANET_CORE_REG("marshal", cfun_marshal),
        JANET_CORE_REG("unmarshal", cfun_unmarshal),
        JANET_CORE_REG("env-lookup", cfun_env_lookup),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, marsh_cfuns);
}


/* src/core/math.c */
#line 0 "src/core/math.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "util.h"
#endif

#include <math.h>

static int janet_rng_get(void *p, Janet key, Janet *out);
static Janet janet_rng_next(void *p, Janet key);

static void janet_rng_marshal(void *p, JanetMarshalContext *ctx) {
    JanetRNG *rng = (JanetRNG *)p;
    janet_marshal_abstract(ctx, p);
    janet_marshal_int(ctx, (int32_t) rng->a);
    janet_marshal_int(ctx, (int32_t) rng->b);
    janet_marshal_int(ctx, (int32_t) rng->c);
    janet_marshal_int(ctx, (int32_t) rng->d);
    janet_marshal_int(ctx, (int32_t) rng->counter);
}

static void *janet_rng_unmarshal(JanetMarshalContext *ctx) {
    JanetRNG *rng = janet_unmarshal_abstract(ctx, sizeof(JanetRNG));
    rng->a = (uint32_t) janet_unmarshal_int(ctx);
    rng->b = (uint32_t) janet_unmarshal_int(ctx);
    rng->c = (uint32_t) janet_unmarshal_int(ctx);
    rng->d = (uint32_t) janet_unmarshal_int(ctx);
    rng->counter = (uint32_t) janet_unmarshal_int(ctx);
    return rng;
}

const JanetAbstractType janet_rng_type = {
    "core/rng",
    NULL,
    NULL,
    janet_rng_get,
    NULL,
    janet_rng_marshal,
    janet_rng_unmarshal,
    NULL, /* tostring */
    NULL, /* compare */
    NULL, /* hash */
    janet_rng_next,
    JANET_ATEND_NEXT
};

JanetRNG *janet_default_rng(void) {
    return &janet_vm.rng;
}

void janet_rng_seed(JanetRNG *rng, uint32_t seed) {
    rng->a = seed;
    rng->b = 0x97654321u;
    rng->c = 123871873u;
    rng->d = 0xf23f56c8u;
    rng->counter = 0u;
    /* First several numbers aren't that random. */
    for (int i = 0; i < 16; i++) janet_rng_u32(rng);
}

void janet_rng_longseed(JanetRNG *rng, const uint8_t *bytes, int32_t len) {
    uint8_t state[16] = {0};
    for (int32_t i = 0; i < len; i++)
        state[i & 0xF] ^= bytes[i];
    rng->a = state[0] + (state[1] << 8) + (state[2] << 16) + (state[3] << 24);
    rng->b = state[4] + (state[5] << 8) + (state[6] << 16) + (state[7] << 24);
    rng->c = state[8] + (state[9] << 8) + (state[10] << 16) + (state[11] << 24);
    rng->d = state[12] + (state[13] << 8) + (state[14] << 16) + (state[15] << 24);
    rng->counter = 0u;
    /* a, b, c, d can't all be 0 */
    if (rng->a == 0) rng->a = 1u;
    for (int i = 0; i < 16; i++) janet_rng_u32(rng);
}

uint32_t janet_rng_u32(JanetRNG *rng) {
    /* Algorithm "xorwow" from p. 5 of Marsaglia, "Xorshift RNGs" */
    uint32_t t = rng->d;
    uint32_t const s = rng->a;
    rng->d = rng->c;
    rng->c = rng->b;
    rng->b = s;
    t ^= t >> 2;
    t ^= t << 1;
    t ^= s ^ (s << 4);
    rng->a = t;
    rng->counter += 362437;
    return t + rng->counter;
}

double janet_rng_double(JanetRNG *rng) {
    uint32_t hi = janet_rng_u32(rng);
    uint32_t lo = janet_rng_u32(rng);
    uint64_t big = (uint64_t)(lo) | (((uint64_t) hi) << 32);
    return ldexp((double)(big >> (64 - 52)), -52);
}

JANET_CORE_FN(cfun_rng_make,
              "(math/rng &opt seed)",
              "Creates a Psuedo-Random number generator, with an optional seed. "
              "The seed should be an unsigned 32 bit integer or a buffer. "
              "Do not use this for cryptography. Returns a core/rng abstract type."
             ) {
    janet_arity(argc, 0, 1);
    JanetRNG *rng = janet_abstract(&janet_rng_type, sizeof(JanetRNG));
    if (argc == 1) {
        if (janet_checkint(argv[0])) {
            uint32_t seed = (uint32_t)(janet_getinteger(argv, 0));
            janet_rng_seed(rng, seed);
        } else {
            JanetByteView bytes = janet_getbytes(argv, 0);
            janet_rng_longseed(rng, bytes.bytes, bytes.len);
        }
    } else {
        janet_rng_seed(rng, 0);
    }
    return janet_wrap_abstract(rng);
}

JANET_CORE_FN(cfun_rng_uniform,
              "(math/rng-uniform rng)",
              "Extract a random number in the range [0, 1) from the RNG."
             ) {
    janet_fixarity(argc, 1);
    JanetRNG *rng = janet_getabstract(argv, 0, &janet_rng_type);
    return janet_wrap_number(janet_rng_double(rng));
}

JANET_CORE_FN(cfun_rng_int,
              "(math/rng-int rng &opt max)",
              "Extract a random random integer in the range [0, max] from the RNG. If "
              "no max is given, the default is 2^31 - 1."
             ) {
    janet_arity(argc, 1, 2);
    JanetRNG *rng = janet_getabstract(argv, 0, &janet_rng_type);
    if (argc == 1) {
        uint32_t word = janet_rng_u32(rng) >> 1;
        return janet_wrap_integer(word);
    } else {
        int32_t max = janet_optnat(argv, argc, 1, INT32_MAX);
        if (max == 0) return janet_wrap_number(0.0);
        uint32_t modulo = (uint32_t) max;
        uint32_t maxgen = INT32_MAX;
        uint32_t maxword = maxgen - (maxgen % modulo);
        uint32_t word;
        do {
            word = janet_rng_u32(rng) >> 1;
        } while (word > maxword);
        return janet_wrap_integer(word % modulo);
    }
}

static void rng_get_4bytes(JanetRNG *rng, uint8_t *buf) {
    uint32_t word = janet_rng_u32(rng);
    buf[0] = word & 0xFF;
    buf[1] = (word >> 8) & 0xFF;
    buf[2] = (word >> 16) & 0xFF;
    buf[3] = (word >> 24) & 0xFF;
}

JANET_CORE_FN(cfun_rng_buffer,
              "(math/rng-buffer rng n &opt buf)",
              "Get n random bytes and put them in a buffer. Creates a new buffer if no buffer is "
              "provided, otherwise appends to the given buffer. Returns the buffer."
             ) {
    janet_arity(argc, 2, 3);
    JanetRNG *rng = janet_getabstract(argv, 0, &janet_rng_type);
    int32_t n = janet_getnat(argv, 1);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, n);

    /* Split into first part (that is divisible by 4), and rest */
    int32_t first_part = n & ~3;
    int32_t second_part = n - first_part;

    /* Get first part in chunks of 4 bytes */
    janet_buffer_extra(buffer, n);
    uint8_t *buf = buffer->data + buffer->count;
    for (int32_t i = 0; i < first_part; i += 4) rng_get_4bytes(rng, buf + i);
    buffer->count += first_part;

    /* Get remaining 0 - 3 bytes */
    if (second_part) {
        uint8_t wordbuf[4] = {0};
        rng_get_4bytes(rng, wordbuf);
        janet_buffer_push_bytes(buffer, wordbuf, second_part);
    }

    return janet_wrap_buffer(buffer);
}

static const JanetMethod rng_methods[] = {
    {"uniform", cfun_rng_uniform},
    {"int", cfun_rng_int},
    {"buffer", cfun_rng_buffer},
    {NULL, NULL}
};

static int janet_rng_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    return janet_getmethod(janet_unwrap_keyword(key), rng_methods, out);
}

static Janet janet_rng_next(void *p, Janet key) {
    (void) p;
    return janet_nextmethod(rng_methods, key);
}

/* Get a random number */
JANET_CORE_FN(janet_rand,
              "(math/random)",
              "Returns a uniformly distributed random number between 0 and 1.") {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_number(janet_rng_double(&janet_vm.rng));
}

/* Seed the random number generator */
JANET_CORE_FN(janet_srand,
              "(math/seedrandom seed)",
              "Set the seed for the random number generator. `seed` should be "
              "an integer or a buffer."
             ) {
    janet_fixarity(argc, 1);
    if (janet_checkint(argv[0])) {
        uint32_t seed = (uint32_t)(janet_getinteger(argv, 0));
        janet_rng_seed(&janet_vm.rng, seed);
    } else {
        JanetByteView bytes = janet_getbytes(argv, 0);
        janet_rng_longseed(&janet_vm.rng, bytes.bytes, bytes.len);
    }
    return janet_wrap_nil();
}

#define JANET_DEFINE_MATHOP(name, fop, doc)\
JANET_CORE_FN(janet_##name, "(math/" #name " x)", doc) {\
    janet_fixarity(argc, 1); \
    double x = janet_getnumber(argv, 0); \
    return janet_wrap_number(fop(x)); \
}

JANET_DEFINE_MATHOP(acos, acos, "Returns the arccosine of x.")
JANET_DEFINE_MATHOP(asin, asin, "Returns the arcsin of x.")
JANET_DEFINE_MATHOP(atan, atan, "Returns the arctangent of x.")
JANET_DEFINE_MATHOP(cos, cos, "Returns the cosine of x.")
JANET_DEFINE_MATHOP(cosh, cosh, "Returns the hyperbolic cosine of x.")
JANET_DEFINE_MATHOP(acosh, acosh, "Returns the hyperbolic arccosine of x.")
JANET_DEFINE_MATHOP(sin, sin, "Returns the sine of x.")
JANET_DEFINE_MATHOP(sinh, sinh, "Returns the hyperbolic sine of x.")
JANET_DEFINE_MATHOP(asinh, asinh, "Returns the hypberbolic arcsine of x.")
JANET_DEFINE_MATHOP(tan, tan, "Returns the tangent of x.")
JANET_DEFINE_MATHOP(tanh, tanh, "Returns the hyperbolic tangent of x.")
JANET_DEFINE_MATHOP(atanh, atanh, "Returns the hyperbolic arctangent of x.")
JANET_DEFINE_MATHOP(exp, exp, "Returns e to the power of x.")
JANET_DEFINE_MATHOP(exp2, exp2, "Returns 2 to the power of x.")
JANET_DEFINE_MATHOP(expm1, expm1, "Returns e to the power of x minus 1.")
JANET_DEFINE_MATHOP(log, log, "Returns the natural logarithm of x.")
JANET_DEFINE_MATHOP(log10, log10, "Returns the log base 10 of x.")
JANET_DEFINE_MATHOP(log2, log2, "Returns the log base 2 of x.")
JANET_DEFINE_MATHOP(sqrt, sqrt, "Returns the square root of x.")
JANET_DEFINE_MATHOP(cbrt, cbrt, "Returns the cube root of x.")
JANET_DEFINE_MATHOP(ceil, ceil, "Returns the smallest integer value number that is not less than x.")
JANET_DEFINE_MATHOP(abs, fabs, "Return the absolute value of x.")
JANET_DEFINE_MATHOP(floor, floor, "Returns the largest integer value number that is not greater than x.")
JANET_DEFINE_MATHOP(trunc, trunc, "Returns the integer between x and 0 nearest to x.")
JANET_DEFINE_MATHOP(round, round, "Returns the integer nearest to x.")
JANET_DEFINE_MATHOP(gamma, tgamma, "Returns gamma(x).")
JANET_DEFINE_MATHOP(lgamma, lgamma, "Returns log-gamma(x).")
JANET_DEFINE_MATHOP(log1p, log1p, "Returns (log base e of x) + 1 more accurately than (+ (math/log x) 1)")
JANET_DEFINE_MATHOP(erf, erf, "Returns the error function of x.")
JANET_DEFINE_MATHOP(erfc, erfc, "Returns the complementary error function of x.")

#define JANET_DEFINE_MATH2OP(name, fop, signature, doc)\
JANET_CORE_FN(janet_##name, signature, doc) {\
    janet_fixarity(argc, 2); \
    double lhs = janet_getnumber(argv, 0); \
    double rhs = janet_getnumber(argv, 1); \
    return janet_wrap_number(fop(lhs, rhs)); \
}

JANET_DEFINE_MATH2OP(atan2, atan2, "(math/atan2 y x)", "Returns the arctangent of y/x. Works even when x is 0.")
JANET_DEFINE_MATH2OP(pow, pow, "(math/pow a x)", "Returns a to the power of x.")
JANET_DEFINE_MATH2OP(hypot, hypot, "(math/hypot a b)", "Returns c from the equation c^2 = a^2 + b^2.")
JANET_DEFINE_MATH2OP(nextafter, nextafter,  "(math/next x y)", "Returns the next representable floating point vaue after x in the direction of y.")

JANET_CORE_FN(janet_not, "(not x)", "Returns the boolean inverse of x.") {
    janet_fixarity(argc, 1);
    return janet_wrap_boolean(!janet_truthy(argv[0]));
}

static double janet_gcd(double x, double y) {
    if (isnan(x) || isnan(y)) {
#ifdef NAN
        return NAN;
#else
        return 0.0 \ 0.0;
#endif
    }
    if (isinf(x) || isinf(y)) return INFINITY;
    while (y != 0) {
        double temp = y;
        y = fmod(x, y);
        x = temp;
    }
    return x;
}

static double janet_lcm(double x, double y) {
    return (x / janet_gcd(x, y)) * y;
}

JANET_CORE_FN(janet_cfun_gcd, "(math/gcd x y)",
              "Returns the greatest common divisor between x and y.") {
    janet_fixarity(argc, 2);
    double x = janet_getnumber(argv, 0);
    double y = janet_getnumber(argv, 1);
    return janet_wrap_number(janet_gcd(x, y));
}

JANET_CORE_FN(janet_cfun_lcm, "(math/lcm x y)",
              "Returns the least common multiple of x and y.") {
    janet_fixarity(argc, 2);
    double x = janet_getnumber(argv, 0);
    double y = janet_getnumber(argv, 1);
    return janet_wrap_number(janet_lcm(x, y));
}

/* Module entry point */
void janet_lib_math(JanetTable *env) {
    JanetRegExt math_cfuns[] = {
        JANET_CORE_REG("not", janet_not),
        JANET_CORE_REG("math/random", janet_rand),
        JANET_CORE_REG("math/seedrandom", janet_srand),
        JANET_CORE_REG("math/cos", janet_cos),
        JANET_CORE_REG("math/sin", janet_sin),
        JANET_CORE_REG("math/tan", janet_tan),
        JANET_CORE_REG("math/acos", janet_acos),
        JANET_CORE_REG("math/asin", janet_asin),
        JANET_CORE_REG("math/atan", janet_atan),
        JANET_CORE_REG("math/exp", janet_exp),
        JANET_CORE_REG("math/log", janet_log),
        JANET_CORE_REG("math/log10", janet_log10),
        JANET_CORE_REG("math/log2", janet_log2),
        JANET_CORE_REG("math/sqrt", janet_sqrt),
        JANET_CORE_REG("math/cbrt", janet_cbrt),
        JANET_CORE_REG("math/floor", janet_floor),
        JANET_CORE_REG("math/ceil", janet_ceil),
        JANET_CORE_REG("math/pow", janet_pow),
        JANET_CORE_REG("math/abs", janet_abs),
        JANET_CORE_REG("math/sinh", janet_sinh),
        JANET_CORE_REG("math/cosh", janet_cosh),
        JANET_CORE_REG("math/tanh", janet_tanh),
        JANET_CORE_REG("math/atanh", janet_atanh),
        JANET_CORE_REG("math/asinh", janet_asinh),
        JANET_CORE_REG("math/acosh", janet_acosh),
        JANET_CORE_REG("math/atan2", janet_atan2),
        JANET_CORE_REG("math/rng", cfun_rng_make),
        JANET_CORE_REG("math/rng-uniform", cfun_rng_uniform),
        JANET_CORE_REG("math/rng-int", cfun_rng_int),
        JANET_CORE_REG("math/rng-buffer", cfun_rng_buffer),
        JANET_CORE_REG("math/hypot", janet_hypot),
        JANET_CORE_REG("math/exp2", janet_exp2),
        JANET_CORE_REG("math/log1p", janet_log1p),
        JANET_CORE_REG("math/gamma", janet_gamma),
        JANET_CORE_REG("math/log-gamma", janet_lgamma),
        JANET_CORE_REG("math/erfc", janet_erfc),
        JANET_CORE_REG("math/erf", janet_erf),
        JANET_CORE_REG("math/expm1", janet_expm1),
        JANET_CORE_REG("math/trunc", janet_trunc),
        JANET_CORE_REG("math/round", janet_round),
        JANET_CORE_REG("math/next", janet_nextafter),
        JANET_CORE_REG("math/gcd", janet_cfun_gcd),
        JANET_CORE_REG("math/lcm", janet_cfun_lcm),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, math_cfuns);
    janet_register_abstract_type(&janet_rng_type);
#ifdef JANET_BOOTSTRAP
    JANET_CORE_DEF(env, "math/pi", janet_wrap_number(3.1415926535897931),
                   "The value pi.");
    JANET_CORE_DEF(env, "math/e", janet_wrap_number(2.7182818284590451),
                   "The base of the natural log.");
    JANET_CORE_DEF(env, "math/inf", janet_wrap_number(INFINITY),
                   "The number representing positive infinity");
    JANET_CORE_DEF(env, "math/-inf", janet_wrap_number(-INFINITY),
                   "The number representing negative infinity");
    JANET_CORE_DEF(env, "math/int32-min", janet_wrap_number(INT32_MIN),
                   "The minimum contiguous integer representable by a 32 bit signed integer");
    JANET_CORE_DEF(env, "math/int32-max", janet_wrap_number(INT32_MAX),
                   "The maximum contiguous integer represtenable by a 32 bit signed integer");
    JANET_CORE_DEF(env, "math/int-min", janet_wrap_number(JANET_INTMIN_DOUBLE),
                   "The minimum contiguous integer representable by a double (2^53)");
    JANET_CORE_DEF(env, "math/int-max", janet_wrap_number(JANET_INTMAX_DOUBLE),
                   "The maximum contiguous integer represtenable by a double (-(2^53))");
#ifdef NAN
    JANET_CORE_DEF(env, "math/nan", janet_wrap_number(NAN), "Not a number (IEEE-754 NaN)");
#else
    JANET_CORE_DEF(env, "math/nan", janet_wrap_number(0.0 / 0.0), "Not a number (IEEE-754 NaN)");
#endif
#endif
}


/* src/core/net.c */
#line 0 "src/core/net.c"

/*
* Copyright (c) 2023 Calvin Rose and contributors.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#ifdef JANET_NET

#include <math.h>
#ifdef JANET_WINDOWS
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include <mswsock.h>
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "Advapi32.lib")
#else
#include <arpa/inet.h>
#include <unistd.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netdb.h>
#include <fcntl.h>
#endif

const JanetAbstractType janet_address_type = {
    "core/socket-address",
    JANET_ATEND_NAME
};

#ifdef JANET_WINDOWS
#define JSOCKCLOSE(x) closesocket((SOCKET) x)
#define JSOCKDEFAULT INVALID_SOCKET
#define JSOCKVALID(x) ((x) != INVALID_SOCKET)
#define JSock SOCKET
#define JSOCKFLAGS 0
#else
#define JSOCKCLOSE(x) close(x)
#define JSOCKDEFAULT 0
#define JSOCKVALID(x) ((x) >= 0)
#define JSock int
#ifdef SOCK_CLOEXEC
#define JSOCKFLAGS SOCK_CLOEXEC
#else
#define JSOCKFLAGS 0
#endif
#endif

/* maximum number of bytes in a socket address host (post name resolution) */
#ifdef JANET_WINDOWS
#define SA_ADDRSTRLEN (INET6_ADDRSTRLEN + 1)
typedef unsigned short in_port_t;
#else
#define JANET_SA_MAX(a, b) (((a) > (b))? (a) : (b))
#define SA_ADDRSTRLEN JANET_SA_MAX(INET6_ADDRSTRLEN + 1, (sizeof ((struct sockaddr_un *)0)->sun_path) + 1)
#endif

static JanetStream *make_stream(JSock handle, uint32_t flags);

/* We pass this flag to all send calls to prevent sigpipe */
#ifndef MSG_NOSIGNAL
#define MSG_NOSIGNAL 0
#endif

/* Make sure a socket doesn't block */
static void janet_net_socknoblock(JSock s) {
#ifdef JANET_WINDOWS
    unsigned long arg = 1;
    ioctlsocket(s, FIONBIO, &arg);
#else
#if !defined(SOCK_CLOEXEC) && defined(O_CLOEXEC)
    int extra = O_CLOEXEC;
#else
    int extra = 0;
#endif
    fcntl(s, F_SETFL, fcntl(s, F_GETFL, 0) | O_NONBLOCK | extra);
#ifdef SO_NOSIGPIPE
    int enable = 1;
    setsockopt(s, SOL_SOCKET, SO_NOSIGPIPE, &enable, sizeof(int));
#endif
#endif
}

/* State machine for accepting connections. */

#ifdef JANET_WINDOWS

typedef struct {
    JanetListenerState head;
    WSAOVERLAPPED overlapped;
    JanetFunction *function;
    JanetStream *lstream;
    JanetStream *astream;
    char buf[1024];
} NetStateAccept;

static int net_sched_accept_impl(NetStateAccept *state, Janet *err);

JanetAsyncStatus net_machine_accept(JanetListenerState *s, JanetAsyncEvent event) {
    NetStateAccept *state = (NetStateAccept *)s;
    switch (event) {
        default:
            break;
        case JANET_ASYNC_EVENT_MARK: {
            if (state->lstream) janet_mark(janet_wrap_abstract(state->lstream));
            if (state->astream) janet_mark(janet_wrap_abstract(state->astream));
            if (state->function) janet_mark(janet_wrap_function(state->function));
            break;
        }
        case JANET_ASYNC_EVENT_CLOSE:
            janet_schedule(s->fiber, janet_wrap_nil());
            return JANET_ASYNC_STATUS_DONE;
        case JANET_ASYNC_EVENT_COMPLETE: {
            if (state->astream->flags & JANET_STREAM_CLOSED) {
                janet_cancel(s->fiber, janet_cstringv("failed to accept connection"));
                return JANET_ASYNC_STATUS_DONE;
            }
            SOCKET lsock = (SOCKET) state->lstream->handle;
            if (NO_ERROR != setsockopt((SOCKET) state->astream->handle, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
                                       (char *) &lsock, sizeof(lsock))) {
                janet_cancel(s->fiber, janet_cstringv("failed to accept connection"));
                return JANET_ASYNC_STATUS_DONE;
            }

            Janet streamv = janet_wrap_abstract(state->astream);
            if (state->function) {
                /* Schedule worker */
                JanetFiber *fiber = janet_fiber(state->function, 64, 1, &streamv);
                fiber->supervisor_channel = s->fiber->supervisor_channel;
                janet_schedule(fiber, janet_wrap_nil());
                /* Now listen again for next connection */
                Janet err;
                if (net_sched_accept_impl(state, &err)) {
                    janet_cancel(s->fiber, err);
                    return JANET_ASYNC_STATUS_DONE;
                }
            } else {
                janet_schedule(s->fiber, streamv);
                return JANET_ASYNC_STATUS_DONE;
            }
        }
    }
    return JANET_ASYNC_STATUS_NOT_DONE;
}

JANET_NO_RETURN static void janet_sched_accept(JanetStream *stream, JanetFunction *fun) {
    Janet err;
    SOCKET lsock = (SOCKET) stream->handle;
    JanetListenerState *s = janet_listen(stream, net_machine_accept, JANET_ASYNC_LISTEN_READ, sizeof(NetStateAccept), NULL);
    NetStateAccept *state = (NetStateAccept *)s;
    memset(&state->overlapped, 0, sizeof(WSAOVERLAPPED));
    memset(&state->buf, 0, 1024);
    state->function = fun;
    state->lstream = stream;
    s->tag = &state->overlapped;
    if (net_sched_accept_impl(state, &err)) janet_panicv(err);
    janet_await();
}

static int net_sched_accept_impl(NetStateAccept *state, Janet *err) {
    SOCKET lsock = (SOCKET) state->lstream->handle;
    SOCKET asock = WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
    if (asock == INVALID_SOCKET) {
        *err = janet_ev_lasterr();
        return 1;
    }
    JanetStream *astream = make_stream(asock, JANET_STREAM_READABLE | JANET_STREAM_WRITABLE);
    state->astream = astream;
    int socksize = sizeof(SOCKADDR_STORAGE) + 16;
    if (FALSE == AcceptEx(lsock, asock, state->buf, 0, socksize, socksize, NULL, &state->overlapped)) {
        int code = WSAGetLastError();
        if (code == WSA_IO_PENDING) return 0; /* indicates io is happening async */
        *err = janet_ev_lasterr();
        return 1;
    }
    return 0;
}

#else

typedef struct {
    JanetListenerState head;
    JanetFunction *function;
} NetStateAccept;

JanetAsyncStatus net_machine_accept(JanetListenerState *s, JanetAsyncEvent event) {
    NetStateAccept *state = (NetStateAccept *)s;
    switch (event) {
        default:
            break;
        case JANET_ASYNC_EVENT_MARK: {
            if (state->function) janet_mark(janet_wrap_function(state->function));
            break;
        }
        case JANET_ASYNC_EVENT_CLOSE:
            janet_schedule(s->fiber, janet_wrap_nil());
            return JANET_ASYNC_STATUS_DONE;
        case JANET_ASYNC_EVENT_READ: {
#if defined(JANET_LINUX)
            JSock connfd = accept4(s->stream->handle, NULL, NULL, SOCK_CLOEXEC);
#else
            /* On BSDs, CLOEXEC should be inherited from server socket */
            JSock connfd = accept(s->stream->handle, NULL, NULL);
#endif
            if (JSOCKVALID(connfd)) {
                janet_net_socknoblock(connfd);
                JanetStream *stream = make_stream(connfd, JANET_STREAM_READABLE | JANET_STREAM_WRITABLE);
                Janet streamv = janet_wrap_abstract(stream);
                if (state->function) {
                    JanetFiber *fiber = janet_fiber(state->function, 64, 1, &streamv);
                    fiber->supervisor_channel = s->fiber->supervisor_channel;
                    janet_schedule(fiber, janet_wrap_nil());
                } else {
                    janet_schedule(s->fiber, streamv);
                    return JANET_ASYNC_STATUS_DONE;
                }
            }
            break;
        }
    }
    return JANET_ASYNC_STATUS_NOT_DONE;
}

JANET_NO_RETURN static void janet_sched_accept(JanetStream *stream, JanetFunction *fun) {
    NetStateAccept *state = (NetStateAccept *) janet_listen(stream, net_machine_accept, JANET_ASYNC_LISTEN_READ, sizeof(NetStateAccept), NULL);
    state->function = fun;
    janet_await();
}


#endif

/* Adress info */

static int janet_get_sockettype(Janet *argv, int32_t argc, int32_t n) {
    JanetKeyword stype = janet_optkeyword(argv, argc, n, NULL);
    int socktype = SOCK_DGRAM;
    if ((NULL == stype) || !janet_cstrcmp(stype, "stream")) {
        socktype = SOCK_STREAM;
    } else if (janet_cstrcmp(stype, "datagram")) {
        janet_panicf("expected socket type as :stream or :datagram, got %v", argv[n]);
    }
    return socktype;
}

/* Needs argc >= offset + 2 */
/* For unix paths, just rertuns a single sockaddr and sets *is_unix to 1,
 * otherwise 0. Also, ignores is_bind when is a unix socket. */
static struct addrinfo *janet_get_addrinfo(Janet *argv, int32_t offset, int socktype, int passive, int *is_unix) {
    /* Unix socket support - not yet supported on windows. */
#ifndef JANET_WINDOWS
    if (janet_keyeq(argv[offset], "unix")) {
        const char *path = janet_getcstring(argv, offset + 1);
        struct sockaddr_un *saddr = janet_calloc(1, sizeof(struct sockaddr_un));
        if (saddr == NULL) {
            JANET_OUT_OF_MEMORY;
        }
        saddr->sun_family = AF_UNIX;
        size_t path_size = sizeof(saddr->sun_path);
#ifdef JANET_LINUX
        if (path[0] == '@') {
            saddr->sun_path[0] = '\0';
            snprintf(saddr->sun_path + 1, path_size - 1, "%s", path + 1);
        } else
#endif
        {
            snprintf(saddr->sun_path, path_size, "%s", path);
        }
        *is_unix = 1;
        return (struct addrinfo *) saddr;
    }
#endif
    /* Get host and port */
    char *host = (char *)janet_getcstring(argv, offset);
    char *port = NULL;
    if (janet_checkint(argv[offset + 1])) {
        port = (char *)janet_to_string(argv[offset + 1]);
    } else {
        port = (char *)janet_optcstring(argv, offset + 2, offset + 1, NULL);
    }
    /* getaddrinfo */
    struct addrinfo *ai = NULL;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = socktype;
    hints.ai_flags = passive ? AI_PASSIVE : 0;
    int status = getaddrinfo(host, port, &hints, &ai);
    if (status) {
        janet_panicf("could not get address info: %s", gai_strerror(status));
    }
    *is_unix = 0;
    return ai;
}

/*
 * C Funs
 */

JANET_CORE_FN(cfun_net_sockaddr,
              "(net/address host port &opt type multi)",
              "Look up the connection information for a given hostname, port, and connection type. Returns "
              "a handle that can be used to send datagrams over network without establishing a connection. "
              "On Posix platforms, you can use :unix for host to connect to a unix domain socket, where the name is "
              "given in the port argument. On Linux, abstract "
              "unix domain sockets are specified with a leading '@' character in port. If `multi` is truthy, will "
              "return all address that match in an array instead of just the first.") {
    janet_arity(argc, 2, 4);
    int socktype = janet_get_sockettype(argv, argc, 2);
    int is_unix = 0;
    int make_arr = (argc >= 3 && janet_truthy(argv[3]));
    struct addrinfo *ai = janet_get_addrinfo(argv, 0, socktype, 0, &is_unix);
#ifndef JANET_WINDOWS
    /* no unix domain socket support on windows yet */
    if (is_unix) {
        void *abst = janet_abstract(&janet_address_type, sizeof(struct sockaddr_un));
        memcpy(abst, ai, sizeof(struct sockaddr_un));
        Janet ret = janet_wrap_abstract(abst);
        return make_arr ? janet_wrap_array(janet_array_n(&ret, 1)) : ret;
    }
#endif
    if (make_arr) {
        /* Select all */
        JanetArray *arr = janet_array(10);
        struct addrinfo *iter = ai;
        while (NULL != iter) {
            void *abst = janet_abstract(&janet_address_type, iter->ai_addrlen);
            memcpy(abst, iter->ai_addr, iter->ai_addrlen);
            janet_array_push(arr, janet_wrap_abstract(abst));
            iter = iter->ai_next;
        }
        freeaddrinfo(ai);
        return janet_wrap_array(arr);
    } else {
        /* Select first */
        if (NULL == ai) {
            janet_panic("no data for given address");
        }
        void *abst = janet_abstract(&janet_address_type, ai->ai_addrlen);
        memcpy(abst, ai->ai_addr, ai->ai_addrlen);
        freeaddrinfo(ai);
        return janet_wrap_abstract(abst);
    }
}

JANET_CORE_FN(cfun_net_connect,
              "(net/connect host port &opt type bindhost bindport)",
              "Open a connection to communicate with a server. Returns a duplex stream "
              "that can be used to communicate with the server. Type is an optional keyword "
              "to specify a connection type, either :stream or :datagram. The default is :stream. "
              "Bindhost is an optional string to select from what address to make the outgoing "
              "connection, with the default being the same as using the OS's preferred address. ") {
    janet_arity(argc, 2, 5);

    /* Check arguments */
    int socktype = janet_get_sockettype(argv, argc, 2);
    int is_unix = 0;
    char *bindhost = (char *) janet_optcstring(argv, argc, 3, NULL);
    char *bindport = NULL;
    if (argc >= 5 && janet_checkint(argv[4])) {
        bindport = (char *)janet_to_string(argv[4]);
    } else {
        bindport = (char *)janet_optcstring(argv, argc, 4, NULL);
    }

    /* Where we're connecting to */
    struct addrinfo *ai = janet_get_addrinfo(argv, 0, socktype, 0, &is_unix);

    /* Check if we're binding address */
    struct addrinfo *binding = NULL;
    if (bindhost != NULL) {
        if (is_unix) {
            freeaddrinfo(ai);
            janet_panic("bindhost not supported for unix domain sockets");
        }
        /* getaddrinfo */
        struct addrinfo hints;
        memset(&hints, 0, sizeof(hints));
        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = socktype;
        hints.ai_flags = 0;
        int status = getaddrinfo(bindhost, bindport, &hints, &binding);
        if (status) {
            freeaddrinfo(ai);
            janet_panicf("could not get address info for bindhost: %s", gai_strerror(status));
        }
    }


    /* Create socket */
    JSock sock = JSOCKDEFAULT;
    void *addr = NULL;
    socklen_t addrlen = 0;
#ifndef JANET_WINDOWS
    if (is_unix) {
        sock = socket(AF_UNIX, socktype | JSOCKFLAGS, 0);
        if (!JSOCKVALID(sock)) {
            Janet v = janet_ev_lasterr();
            janet_free(ai);
            janet_panicf("could not create socket: %V", v);
        }
        addr = (void *) ai;
        addrlen = sizeof(struct sockaddr_un);
    } else
#endif
    {
        struct addrinfo *rp = NULL;
        for (rp = ai; rp != NULL; rp = rp->ai_next) {
#ifdef JANET_WINDOWS
            sock = WSASocketW(rp->ai_family, rp->ai_socktype, rp->ai_protocol, NULL, 0, WSA_FLAG_OVERLAPPED);
#else
            sock = socket(rp->ai_family, rp->ai_socktype | JSOCKFLAGS, rp->ai_protocol);
#endif
            if (JSOCKVALID(sock)) {
                addr = rp->ai_addr;
                addrlen = (socklen_t) rp->ai_addrlen;
                break;
            }
        }
        if (NULL == addr) {
            Janet v = janet_ev_lasterr();
            if (binding) freeaddrinfo(binding);
            freeaddrinfo(ai);
            janet_panicf("could not create socket: %V", v);
        }
    }

    /* Bind to bindhost and bindport if given */
    if (binding) {
        struct addrinfo *rp = NULL;
        int did_bind = 0;
        for (rp = ai; rp != NULL; rp = rp->ai_next) {
            if (bind(sock, rp->ai_addr, (int) rp->ai_addrlen) == 0) {
                did_bind = 1;
                break;
            }
        }
        if (!did_bind) {
            Janet v = janet_ev_lasterr();
            freeaddrinfo(binding);
            freeaddrinfo(ai);
            JSOCKCLOSE(sock);
            janet_panicf("could not bind outgoing address: %V", v);
        } else {
            freeaddrinfo(binding);
        }
    }

    /* Connect to socket */
#ifdef JANET_WINDOWS
    int status = WSAConnect(sock, addr, addrlen, NULL, NULL, NULL, NULL);
    Janet lasterr = janet_ev_lasterr();
    freeaddrinfo(ai);
#else
    int status = connect(sock, addr, addrlen);
    Janet lasterr = janet_ev_lasterr();
    if (is_unix) {
        janet_free(ai);
    } else {
        freeaddrinfo(ai);
    }
#endif

    if (status == -1) {
        JSOCKCLOSE(sock);
        janet_panicf("could not connect socket: %V", lasterr);
    }

    /* Set up the socket for non-blocking IO after connect - TODO - non-blocking connect? */
    janet_net_socknoblock(sock);

    /* Wrap socket in abstract type JanetStream */
    JanetStream *stream = make_stream(sock, JANET_STREAM_READABLE | JANET_STREAM_WRITABLE);
    return janet_wrap_abstract(stream);
}

static const char *serverify_socket(JSock sfd) {
    /* Set various socket options */
    int enable = 1;
    if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (char *) &enable, sizeof(int)) < 0) {
        return "setsockopt(SO_REUSEADDR) failed";
    }
#ifdef SO_REUSEPORT
    if (setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(int)) < 0) {
        return "setsockopt(SO_REUSEPORT) failed";
    }
#endif
    janet_net_socknoblock(sfd);
    return NULL;
}

#ifdef JANET_WINDOWS
#define JANET_SHUTDOWN_RW SD_BOTH
#define JANET_SHUTDOWN_R SD_RECEIVE
#define JANET_SHUTDOWN_W SD_SEND
#else
#define JANET_SHUTDOWN_RW SHUT_RDWR
#define JANET_SHUTDOWN_R SHUT_RD
#define JANET_SHUTDOWN_W SHUT_WR
#endif

JANET_CORE_FN(cfun_net_shutdown,
              "(net/shutdown stream &opt mode)",
              "Stop communication on this socket in a graceful manner, either in both directions or just "
              "reading/writing from the stream. The `mode` parameter controls which communication to stop on the socket. "
              "\n\n* `:wr` is the default and prevents both reading new data from the socket and writing new data to the socket.\n"
              "* `:r` disables reading new data from the socket.\n"
              "* `:w` disable writing data to the socket.\n\n"
              "Returns the original socket.") {
    janet_arity(argc, 1, 2);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_SOCKET);
    int shutdown_type = JANET_SHUTDOWN_RW;
    if (argc == 2) {
        const uint8_t *kw = janet_getkeyword(argv, 1);
        if (0 == janet_cstrcmp(kw, "rw")) {
            shutdown_type = JANET_SHUTDOWN_RW;
        } else if (0 == janet_cstrcmp(kw, "r")) {
            shutdown_type = JANET_SHUTDOWN_R;
        } else if (0 == janet_cstrcmp(kw, "w")) {
            shutdown_type = JANET_SHUTDOWN_W;
        } else {
            janet_panicf("unexpected keyword %v", argv[1]);
        }
    }
    int status;
#ifdef JANET_WINDOWS
    status = shutdown((SOCKET) stream->handle, shutdown_type);
#else
    do {
        status = shutdown(stream->handle, shutdown_type);
    } while (status == -1 && errno == EINTR);
#endif
    if (status) {
        janet_panicf("could not shutdown socket: %V", janet_ev_lasterr());
    }
    return argv[0];
}

JANET_CORE_FN(cfun_net_listen,
              "(net/listen host port &opt type)",
              "Creates a server. Returns a new stream that is neither readable nor "
              "writeable. Use net/accept or net/accept-loop be to handle connections and start the server. "
              "The type parameter specifies the type of network connection, either "
              "a :stream (usually tcp), or :datagram (usually udp). If not specified, the default is "
              ":stream. The host and port arguments are the same as in net/address.") {
    janet_arity(argc, 2, 3);

    /* Get host, port, and handler*/
    int socktype = janet_get_sockettype(argv, argc, 2);
    int is_unix = 0;
    struct addrinfo *ai = janet_get_addrinfo(argv, 0, socktype, 1, &is_unix);

    JSock sfd = JSOCKDEFAULT;
#ifndef JANET_WINDOWS
    if (is_unix) {
        sfd = socket(AF_UNIX, socktype | JSOCKFLAGS, 0);
        if (!JSOCKVALID(sfd)) {
            janet_free(ai);
            janet_panicf("could not create socket: %V", janet_ev_lasterr());
        }
        const char *err = serverify_socket(sfd);
        if (NULL != err || bind(sfd, (struct sockaddr *)ai, sizeof(struct sockaddr_un))) {
            JSOCKCLOSE(sfd);
            janet_free(ai);
            if (err) {
                janet_panic(err);
            } else {
                janet_panicf("could not bind socket: %V", janet_ev_lasterr());
            }
        }
        janet_free(ai);
    } else
#endif
    {
        /* Check all addrinfos in a loop for the first that we can bind to. */
        struct addrinfo *rp = NULL;
        for (rp = ai; rp != NULL; rp = rp->ai_next) {
#ifdef JANET_WINDOWS
            sfd = WSASocketW(rp->ai_family, rp->ai_socktype | JSOCKFLAGS, rp->ai_protocol, NULL, 0, WSA_FLAG_OVERLAPPED);
#else
            sfd = socket(rp->ai_family, rp->ai_socktype | JSOCKFLAGS, rp->ai_protocol);
#endif
            if (!JSOCKVALID(sfd)) continue;
            const char *err = serverify_socket(sfd);
            if (NULL != err) {
                JSOCKCLOSE(sfd);
                continue;
            }
            /* Bind */
            if (bind(sfd, rp->ai_addr, (int) rp->ai_addrlen) == 0) break;
            JSOCKCLOSE(sfd);
        }
        freeaddrinfo(ai);
        if (NULL == rp) {
            janet_panic("could not bind to any sockets");
        }
    }

    if (socktype == SOCK_DGRAM) {
        /* Datagram server (UDP) */
        JanetStream *stream = make_stream(sfd, JANET_STREAM_UDPSERVER | JANET_STREAM_READABLE);
        return janet_wrap_abstract(stream);
    } else {
        /* Stream server (TCP) */

        /* listen */
        int status = listen(sfd, 1024);
        if (status) {
            JSOCKCLOSE(sfd);
            janet_panicf("could not listen on file descriptor: %V", janet_ev_lasterr());
        }

        /* Put sfd on our loop */
        JanetStream *stream = make_stream(sfd, JANET_STREAM_ACCEPTABLE);
        return janet_wrap_abstract(stream);
    }
}

/* Types of socket's we need to deal with - relevant type puns below.
struct sockaddr *sa;           // Common base structure
struct sockaddr_storage *ss;   // Size of largest socket address type
struct sockaddr_in *sin;       // IPv4 address + port
struct sockaddr_in6 *sin6;     // IPv6 address + port
struct sockaddr_un *sun;       // Unix Domain Socket Address
*/

/* Turn a socket address into a host, port pair.
 * For unix domain sockets, returned tuple will have only a single element, the path string. */
static Janet janet_so_getname(const void *sa_any) {
    const struct sockaddr *sa = sa_any;
    char buffer[SA_ADDRSTRLEN];
    switch (sa->sa_family) {
        default:
            janet_panic("unknown address family");
        case AF_INET: {
            const struct sockaddr_in *sai = sa_any;
            if (!inet_ntop(AF_INET, &(sai->sin_addr), buffer, sizeof(buffer))) {
                janet_panic("unable to decode ipv4 host address");
            }
            Janet pair[2] = {janet_cstringv(buffer), janet_wrap_integer(ntohs(sai->sin_port))};
            return janet_wrap_tuple(janet_tuple_n(pair, 2));
        }
        case AF_INET6: {
            const struct sockaddr_in6 *sai6 = sa_any;
            if (!inet_ntop(AF_INET6, &(sai6->sin6_addr), buffer, sizeof(buffer))) {
                janet_panic("unable to decode ipv4 host address");
            }
            Janet pair[2] = {janet_cstringv(buffer), janet_wrap_integer(ntohs(sai6->sin6_port))};
            return janet_wrap_tuple(janet_tuple_n(pair, 2));
        }
#ifndef JANET_WINDOWS
        case AF_UNIX: {
            const struct sockaddr_un *sun = sa_any;
            Janet pathname;
            if (sun->sun_path[0] == '\0') {
                memcpy(buffer, sun->sun_path, sizeof(sun->sun_path));
                buffer[0] = '@';
                pathname = janet_cstringv(buffer);
            } else {
                pathname = janet_cstringv(sun->sun_path);
            }
            return janet_wrap_tuple(janet_tuple_n(&pathname, 1));
        }
#endif
    }
}

JANET_CORE_FN(cfun_net_getsockname,
              "(net/localname stream)",
              "Gets the local address and port in a tuple in that order.") {
    janet_fixarity(argc, 1);
    JanetStream *js = janet_getabstract(argv, 0, &janet_stream_type);
    if (js->flags & JANET_STREAM_CLOSED) janet_panic("stream closed");
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);
    memset(&ss, 0, slen);
    if (getsockname((JSock)js->handle, (struct sockaddr *) &ss, &slen)) {
        janet_panicf("Failed to get localname on %v: %V", argv[0], janet_ev_lasterr());
    }
    janet_assert(slen <= sizeof(ss), "socket address truncated");
    return janet_so_getname(&ss);
}

JANET_CORE_FN(cfun_net_getpeername,
              "(net/peername stream)",
              "Gets the remote peer's address and port in a tuple in that order.") {
    janet_fixarity(argc, 1);
    JanetStream *js = janet_getabstract(argv, 0, &janet_stream_type);
    if (js->flags & JANET_STREAM_CLOSED) janet_panic("stream closed");
    struct sockaddr_storage ss;
    socklen_t slen = sizeof(ss);
    memset(&ss, 0, slen);
    if (getpeername((JSock)js->handle, (struct sockaddr *)&ss, &slen)) {
        janet_panicf("Failed to get peername on %v: %V", argv[0], janet_ev_lasterr());
    }
    janet_assert(slen <= sizeof(ss), "socket address truncated");
    return janet_so_getname(&ss);
}

JANET_CORE_FN(cfun_net_address_unpack,
              "(net/address-unpack address)",
              "Given an address returned by net/adress, return a host, port pair. Unix domain sockets "
              "will have only the path in the returned tuple.") {
    janet_fixarity(argc, 1);
    struct sockaddr *sa = janet_getabstract(argv, 0, &janet_address_type);
    return janet_so_getname(sa);
}

JANET_CORE_FN(cfun_stream_accept_loop,
              "(net/accept-loop stream handler)",
              "Shorthand for running a server stream that will continuously accept new connections. "
              "Blocks the current fiber until the stream is closed, and will return the stream.") {
    janet_fixarity(argc, 2);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_ACCEPTABLE | JANET_STREAM_SOCKET);
    JanetFunction *fun = janet_getfunction(argv, 1);
    janet_sched_accept(stream, fun);
}

JANET_CORE_FN(cfun_stream_accept,
              "(net/accept stream &opt timeout)",
              "Get the next connection on a server stream. This would usually be called in a loop in a dedicated fiber. "
              "Takes an optional timeout in seconds, after which will return nil. "
              "Returns a new duplex stream which represents a connection to the client.") {
    janet_arity(argc, 1, 2);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_ACCEPTABLE | JANET_STREAM_SOCKET);
    double to = janet_optnumber(argv, argc, 1, INFINITY);
    if (to != INFINITY) janet_addtimeout(to);
    janet_sched_accept(stream, NULL);
}

JANET_CORE_FN(cfun_stream_read,
              "(net/read stream nbytes &opt buf timeout)",
              "Read up to n bytes from a stream, suspending the current fiber until the bytes are available. "
              "`n` can also be the keyword `:all` to read into the buffer until end of stream. "
              "If less than n bytes are available (and more than 0), will push those bytes and return early. "
              "Takes an optional timeout in seconds, after which will return nil. "
              "Returns a buffer with up to n more bytes in it, or raises an error if the read failed.") {
    janet_arity(argc, 2, 4);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_READABLE | JANET_STREAM_SOCKET);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, 10);
    double to = janet_optnumber(argv, argc, 3, INFINITY);
    if (janet_keyeq(argv[1], "all")) {
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_recvchunk(stream, buffer, INT32_MAX, MSG_NOSIGNAL);
    } else {
        int32_t n = janet_getnat(argv, 1);
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_recv(stream, buffer, n, MSG_NOSIGNAL);
    }
    janet_await();
}

JANET_CORE_FN(cfun_stream_chunk,
              "(net/chunk stream nbytes &opt buf timeout)",
              "Same a net/read, but will wait for all n bytes to arrive rather than return early. "
              "Takes an optional timeout in seconds, after which will return nil.") {
    janet_arity(argc, 2, 4);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_READABLE | JANET_STREAM_SOCKET);
    int32_t n = janet_getnat(argv, 1);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, 10);
    double to = janet_optnumber(argv, argc, 3, INFINITY);
    if (to != INFINITY) janet_addtimeout(to);
    janet_ev_recvchunk(stream, buffer, n, MSG_NOSIGNAL);
    janet_await();
}

JANET_CORE_FN(cfun_stream_recv_from,
              "(net/recv-from stream nbytes buf &opt timoeut)",
              "Receives data from a server stream and puts it into a buffer. Returns the socket-address the "
              "packet came from. Takes an optional timeout in seconds, after which will return nil.") {
    janet_arity(argc, 3, 4);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_UDPSERVER | JANET_STREAM_SOCKET);
    int32_t n = janet_getnat(argv, 1);
    JanetBuffer *buffer = janet_getbuffer(argv, 2);
    double to = janet_optnumber(argv, argc, 3, INFINITY);
    if (to != INFINITY) janet_addtimeout(to);
    janet_ev_recvfrom(stream, buffer, n, MSG_NOSIGNAL);
    janet_await();
}

JANET_CORE_FN(cfun_stream_write,
              "(net/write stream data &opt timeout)",
              "Write data to a stream, suspending the current fiber until the write "
              "completes. Takes an optional timeout in seconds, after which will return nil. "
              "Returns nil, or raises an error if the write failed.") {
    janet_arity(argc, 2, 3);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_WRITABLE | JANET_STREAM_SOCKET);
    double to = janet_optnumber(argv, argc, 2, INFINITY);
    if (janet_checktype(argv[1], JANET_BUFFER)) {
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_send_buffer(stream, janet_getbuffer(argv, 1), MSG_NOSIGNAL);
    } else {
        JanetByteView bytes = janet_getbytes(argv, 1);
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_send_string(stream, bytes.bytes, MSG_NOSIGNAL);
    }
    janet_await();
}

JANET_CORE_FN(cfun_stream_send_to,
              "(net/send-to stream dest data &opt timeout)",
              "Writes a datagram to a server stream. dest is a the destination address of the packet. "
              "Takes an optional timeout in seconds, after which will return nil. "
              "Returns stream.") {
    janet_arity(argc, 3, 4);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_UDPSERVER | JANET_STREAM_SOCKET);
    void *dest = janet_getabstract(argv, 1, &janet_address_type);
    double to = janet_optnumber(argv, argc, 3, INFINITY);
    if (janet_checktype(argv[2], JANET_BUFFER)) {
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_sendto_buffer(stream, janet_getbuffer(argv, 2), dest, MSG_NOSIGNAL);
    } else {
        JanetByteView bytes = janet_getbytes(argv, 2);
        if (to != INFINITY) janet_addtimeout(to);
        janet_ev_sendto_string(stream, bytes.bytes, dest, MSG_NOSIGNAL);
    }
    janet_await();
}

JANET_CORE_FN(cfun_stream_flush,
              "(net/flush stream)",
              "Make sure that a stream is not buffering any data. This temporarily disables Nagle's algorithm. "
              "Use this to make sure data is sent without delay. Returns stream.") {
    janet_fixarity(argc, 1);
    JanetStream *stream = janet_getabstract(argv, 0, &janet_stream_type);
    janet_stream_flags(stream, JANET_STREAM_WRITABLE | JANET_STREAM_SOCKET);
    /* Toggle no delay flag */
    int flag = 1;
    setsockopt((JSock) stream->handle, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, sizeof(int));
    flag = 0;
    setsockopt((JSock) stream->handle, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, sizeof(int));
    return argv[0];
}

static const JanetMethod net_stream_methods[] = {
    {"chunk", cfun_stream_chunk},
    {"close", janet_cfun_stream_close},
    {"read", cfun_stream_read},
    {"write", cfun_stream_write},
    {"flush", cfun_stream_flush},
    {"accept", cfun_stream_accept},
    {"accept-loop", cfun_stream_accept_loop},
    {"send-to", cfun_stream_send_to},
    {"recv-from", cfun_stream_recv_from},
    {"evread", janet_cfun_stream_read},
    {"evchunk", janet_cfun_stream_chunk},
    {"evwrite", janet_cfun_stream_write},
    {"shutdown", cfun_net_shutdown},
    {NULL, NULL}
};

static JanetStream *make_stream(JSock handle, uint32_t flags) {
    return janet_stream((JanetHandle) handle, flags | JANET_STREAM_SOCKET, net_stream_methods);
}

void janet_lib_net(JanetTable *env) {
    JanetRegExt net_cfuns[] = {
        JANET_CORE_REG("net/address", cfun_net_sockaddr),
        JANET_CORE_REG("net/listen", cfun_net_listen),
        JANET_CORE_REG("net/accept", cfun_stream_accept),
        JANET_CORE_REG("net/accept-loop", cfun_stream_accept_loop),
        JANET_CORE_REG("net/read", cfun_stream_read),
        JANET_CORE_REG("net/chunk", cfun_stream_chunk),
        JANET_CORE_REG("net/write", cfun_stream_write),
        JANET_CORE_REG("net/send-to", cfun_stream_send_to),
        JANET_CORE_REG("net/recv-from", cfun_stream_recv_from),
        JANET_CORE_REG("net/flush", cfun_stream_flush),
        JANET_CORE_REG("net/connect", cfun_net_connect),
        JANET_CORE_REG("net/shutdown", cfun_net_shutdown),
        JANET_CORE_REG("net/peername", cfun_net_getpeername),
        JANET_CORE_REG("net/localname", cfun_net_getsockname),
        JANET_CORE_REG("net/address-unpack", cfun_net_address_unpack),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, net_cfuns);
}

void janet_net_init(void) {
#ifdef JANET_WINDOWS
    WSADATA wsaData;
    janet_assert(!WSAStartup(MAKEWORD(2, 2), &wsaData), "could not start winsock");
#endif
}

void janet_net_deinit(void) {
#ifdef JANET_WINDOWS
    WSACleanup();
#endif
}

#endif


/* src/core/os.c */
#line 0 "src/core/os.c"

/*
* Copyright (c) 2023 Calvin Rose and contributors.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#include "gc.h"
#endif

#ifndef JANET_REDUCED_OS

#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <signal.h>

#ifdef JANET_BSD
#include <sys/sysctl.h>
#endif

#ifdef JANET_LINUX
#include <sched.h>
#endif

#ifdef JANET_WINDOWS
#include <windows.h>
#include <direct.h>
#include <sys/utime.h>
#include <io.h>
#include <process.h>
#else
#include <spawn.h>
#include <utime.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/wait.h>
#ifdef JANET_APPLE
#include <crt_externs.h>
#define environ (*_NSGetEnviron())
#else
extern char **environ;
#endif
#ifdef JANET_THREADS
#include <pthread.h>
#endif
#endif

/* Not POSIX, but all Unixes but Solaris have this function. */
#if defined(JANET_POSIX) && !defined(__sun)
time_t timegm(struct tm *tm);
#elif defined(JANET_WINDOWS)
#define timegm _mkgmtime
#endif

/* Access to some global variables should be synchronized if not in single threaded mode, as
 * setenv/getenv are not thread safe. */
#ifdef JANET_THREADS
# ifdef JANET_WINDOWS
static CRITICAL_SECTION env_lock;
static void janet_lock_environ(void) {
    EnterCriticalSection(&env_lock);
}
static void janet_unlock_environ(void) {
    LeaveCriticalSection(&env_lock);
}
# else
static pthread_mutex_t env_lock = PTHREAD_MUTEX_INITIALIZER;
static void janet_lock_environ(void) {
    pthread_mutex_lock(&env_lock);
}
static void janet_unlock_environ(void) {
    pthread_mutex_unlock(&env_lock);
}
# endif
#else
static void janet_lock_environ(void) {
}
static void janet_unlock_environ(void) {
}
#endif

#endif /* JANET_REDCUED_OS */

/* Core OS functions */

/* Full OS functions */

#define janet_stringify1(x) #x
#define janet_stringify(x) janet_stringify1(x)

JANET_CORE_FN(os_which,
              "(os/which)",
              "Check the current operating system. Returns one of:\n\n"
              "* :windows\n\n"
              "* :macos\n\n"
              "* :web - Web assembly (emscripten)\n\n"
              "* :linux\n\n"
              "* :freebsd\n\n"
              "* :openbsd\n\n"
              "* :netbsd\n\n"
              "* :posix - A POSIX compatible system (default)\n\n"
              "May also return a custom keyword specified at build time.") {
    janet_fixarity(argc, 0);
    (void) argv;
#if defined(JANET_OS_NAME)
    return janet_ckeywordv(janet_stringify(JANET_OS_NAME));
#elif defined(JANET_WINDOWS)
    return janet_ckeywordv("windows");
#elif defined(JANET_APPLE)
    return janet_ckeywordv("macos");
#elif defined(__EMSCRIPTEN__)
    return janet_ckeywordv("web");
#elif defined(JANET_LINUX)
    return janet_ckeywordv("linux");
#elif defined(__FreeBSD__)
    return janet_ckeywordv("freebsd");
#elif defined(__NetBSD__)
    return janet_ckeywordv("netbsd");
#elif defined(__OpenBSD__)
    return janet_ckeywordv("openbsd");
#elif defined(JANET_BSD)
    return janet_ckeywordv("bsd");
#else
    return janet_ckeywordv("posix");
#endif
}

/* Detect the ISA we are compiled for */
JANET_CORE_FN(os_arch,
              "(os/arch)",
              "Check the ISA that janet was compiled for. Returns one of:\n\n"
              "* :x86\n\n"
              "* :x64\n\n"
              "* :arm\n\n"
              "* :aarch64\n\n"
              "* :sparc\n\n"
              "* :wasm\n\n"
              "* :unknown\n") {
    janet_fixarity(argc, 0);
    (void) argv;
    /* Check 64-bit vs 32-bit */
#if defined(JANET_ARCH_NAME)
    return janet_ckeywordv(janet_stringify(JANET_ARCH_NAME));
#elif defined(__EMSCRIPTEN__)
    return janet_ckeywordv("wasm");
#elif (defined(__x86_64__) || defined(_M_X64))
    return janet_ckeywordv("x64");
#elif defined(__i386) || defined(_M_IX86)
    return janet_ckeywordv("x86");
#elif defined(_M_ARM64) || defined(__aarch64__)
    return janet_ckeywordv("aarch64");
#elif defined(_M_ARM) || defined(__arm__)
    return janet_ckeywordv("arm");
#elif (defined(__sparc__))
    return janet_ckeywordv("sparc");
#elif (defined(__ppc__))
    return janet_ckeywordv("ppc");
#elif (defined(__ppc64__) || defined(_ARCH_PPC64) || defined(_M_PPC))
    return janet_ckeywordv("ppc64");
#else
    return janet_ckeywordv("unknown");
#endif
}

#undef janet_stringify1
#undef janet_stringify

JANET_CORE_FN(os_exit,
              "(os/exit &opt x)",
              "Exit from janet with an exit code equal to x. If x is not an integer, "
              "the exit with status equal the hash of x.") {
    janet_arity(argc, 0, 1);
    int status;
    if (argc == 0) {
        status = EXIT_SUCCESS;
    } else if (janet_checkint(argv[0])) {
        status = janet_unwrap_integer(argv[0]);
    } else {
        status = EXIT_FAILURE;
    }
    janet_deinit();
    exit(status);
    return janet_wrap_nil();
}

#ifndef JANET_REDUCED_OS

JANET_CORE_FN(os_cpu_count,
              "(os/cpu-count &opt dflt)",
              "Get an approximate number of CPUs available on for this process to use. If "
              "unable to get an approximation, will return a default value dflt.") {
    janet_arity(argc, 0, 1);
    Janet dflt = argc > 0 ? argv[0] : janet_wrap_nil();
#ifdef JANET_WINDOWS
    (void) dflt;
    SYSTEM_INFO info;
    GetSystemInfo(&info);
    return janet_wrap_integer(info.dwNumberOfProcessors);
#elif defined(JANET_LINUX)
    (void) dflt;
    cpu_set_t cs;
    CPU_ZERO(&cs);
    sched_getaffinity(0, sizeof(cs), &cs);
    int count = CPU_COUNT(&cs);
    return janet_wrap_integer(count);
#elif defined(JANET_BSD) && defined(HW_NCPUONLINE)
    (void) dflt;
    const int name[2] = {CTL_HW, HW_NCPUONLINE};
    int result = 0;
    size_t len = sizeof(int);
    if (-1 == sysctl(name, 2, &result, &len, NULL, 0)) {
        return dflt;
    }
    return janet_wrap_integer(result);
#elif defined(JANET_BSD) && defined(HW_NCPU)
    (void) dflt;
    const int name[2] = {CTL_HW, HW_NCPU};
    int result = 0;
    size_t len = sizeof(int);
    if (-1 == sysctl(name, 2, &result, &len, NULL, 0)) {
        return dflt;
    }
    return janet_wrap_integer(result);
#else
    return dflt;
#endif
}


#ifndef JANET_NO_PROCESSES

/* Get env for os_execute */
#ifdef JANET_WINDOWS
typedef char *EnvBlock;
#else
typedef char **EnvBlock;
#endif

/* Get env for os_execute */
static EnvBlock os_execute_env(int32_t argc, const Janet *argv) {
    if (argc <= 2) return NULL;
    JanetDictView dict = janet_getdictionary(argv, 2);
#ifdef JANET_WINDOWS
    JanetBuffer *temp = janet_buffer(10);
    for (int32_t i = 0; i < dict.cap; i++) {
        const JanetKV *kv = dict.kvs + i;
        if (!janet_checktype(kv->key, JANET_STRING)) continue;
        if (!janet_checktype(kv->value, JANET_STRING)) continue;
        const uint8_t *keys = janet_unwrap_string(kv->key);
        const uint8_t *vals = janet_unwrap_string(kv->value);
        janet_buffer_push_bytes(temp, keys, janet_string_length(keys));
        janet_buffer_push_u8(temp, '=');
        janet_buffer_push_bytes(temp, vals, janet_string_length(vals));
        janet_buffer_push_u8(temp, '\0');
    }
    janet_buffer_push_u8(temp, '\0');
    char *ret = janet_smalloc(temp->count);
    memcpy(ret, temp->data, temp->count);
    return ret;
#else
    char **envp = janet_smalloc(sizeof(char *) * ((size_t)dict.len + 1));
    int32_t j = 0;
    for (int32_t i = 0; i < dict.cap; i++) {
        const JanetKV *kv = dict.kvs + i;
        if (!janet_checktype(kv->key, JANET_STRING)) continue;
        if (!janet_checktype(kv->value, JANET_STRING)) continue;
        const uint8_t *keys = janet_unwrap_string(kv->key);
        const uint8_t *vals = janet_unwrap_string(kv->value);
        int32_t klen = janet_string_length(keys);
        int32_t vlen = janet_string_length(vals);
        /* Check keys has no embedded 0s or =s. */
        int skip = 0;
        for (int32_t k = 0; k < klen; k++) {
            if (keys[k] == '\0' || keys[k] == '=') {
                skip = 1;
                break;
            }
        }
        if (skip) continue;
        char *envitem = janet_smalloc((size_t) klen + (size_t) vlen + 2);
        memcpy(envitem, keys, klen);
        envitem[klen] = '=';
        memcpy(envitem + klen + 1, vals, vlen);
        envitem[klen + vlen + 1] = 0;
        envp[j++] = envitem;
    }
    envp[j] = NULL;
    return envp;
#endif
}

static void os_execute_cleanup(EnvBlock envp, const char **child_argv) {
#ifdef JANET_WINDOWS
    (void) child_argv;
    if (NULL != envp) janet_sfree(envp);
#else
    janet_sfree((void *)child_argv);
    if (NULL != envp) {
        char **envitem = envp;
        while (*envitem != NULL) {
            janet_sfree(*envitem);
            envitem++;
        }
    }
    janet_sfree(envp);
#endif
}

#ifdef JANET_WINDOWS
/* Windows processes created via CreateProcess get only one command line argument string, and
 * must parse this themselves. Each processes is free to do this however they like, but the
 * standard parsing method is CommandLineToArgvW. We need to properly escape arguments into
 * a single string of this format. Returns a buffer that can be cast into a c string. */
static JanetBuffer *os_exec_escape(JanetView args) {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < args.len; i++) {
        const char *arg = janet_getcstring(args.items, i);

        /* Push leading space if not first */
        if (i) janet_buffer_push_u8(b, ' ');

        /* Find first special character */
        const char *first_spec = arg;
        while (*first_spec) {
            switch (*first_spec) {
                case ' ':
                case '\t':
                case '\v':
                case '\n':
                case '"':
                    goto found;
                case '\0':
                    janet_panic("embedded 0 not allowed in command line string");
                default:
                    first_spec++;
                    break;
            }
        }
    found:

        /* Check if needs escape */
        if (*first_spec == '\0') {
            /* No escape needed */
            janet_buffer_push_cstring(b, arg);
        } else {
            /* Escape */
            janet_buffer_push_u8(b, '"');
            for (const char *c = arg; ; c++) {
                unsigned numBackSlashes = 0;
                while (*c == '\\') {
                    c++;
                    numBackSlashes++;
                }
                if (*c == '"') {
                    /* Escape all backslashes and double quote mark */
                    int32_t n = 2 * numBackSlashes + 1;
                    janet_buffer_extra(b, n + 1);
                    memset(b->data + b->count, '\\', n);
                    b->count += n;
                    janet_buffer_push_u8(b, '"');
                } else if (*c) {
                    /* Don't escape backslashes. */
                    int32_t n = numBackSlashes;
                    janet_buffer_extra(b, n + 1);
                    memset(b->data + b->count, '\\', n);
                    b->count += n;
                    janet_buffer_push_u8(b, *c);
                } else {
                    /* we finished Escape all backslashes */
                    int32_t n = 2 * numBackSlashes;
                    janet_buffer_extra(b, n + 1);
                    memset(b->data + b->count, '\\', n);
                    b->count += n;
                    break;
                }
            }
            janet_buffer_push_u8(b, '"');
        }
    }
    janet_buffer_push_u8(b, 0);
    return b;
}
#endif

/* Process type for when running a subprocess and not immediately waiting */
static const JanetAbstractType ProcAT;
#define JANET_PROC_CLOSED 1
#define JANET_PROC_WAITED 2
#define JANET_PROC_WAITING 4
#define JANET_PROC_ERROR_NONZERO 8
#define JANET_PROC_OWNS_STDIN 16
#define JANET_PROC_OWNS_STDOUT 32
#define JANET_PROC_OWNS_STDERR 64
#define JANET_PROC_ALLOW_ZOMBIE 128
typedef struct {
    int flags;
#ifdef JANET_WINDOWS
    HANDLE pHandle;
    HANDLE tHandle;
#else
    pid_t pid;
#endif
    int return_code;
#ifdef JANET_EV
    JanetStream *in;
    JanetStream *out;
    JanetStream *err;
#else
    JanetFile *in;
    JanetFile *out;
    JanetFile *err;
#endif
} JanetProc;

#ifdef JANET_EV

#ifdef JANET_WINDOWS

static JanetEVGenericMessage janet_proc_wait_subr(JanetEVGenericMessage args) {
    JanetProc *proc = (JanetProc *) args.argp;
    WaitForSingleObject(proc->pHandle, INFINITE);
    GetExitCodeProcess(proc->pHandle, &args.tag);
    return args;
}

#else /* windows check */

static int proc_get_status(JanetProc *proc) {
    /* Use POSIX shell semantics for interpreting signals */
    int status = 0;
    pid_t result;
    do {
        result = waitpid(proc->pid, &status, 0);
    } while (result == -1 && errno == EINTR);
    if (WIFEXITED(status)) {
        status = WEXITSTATUS(status);
    } else if (WIFSTOPPED(status)) {
        status = WSTOPSIG(status) + 128;
    } else {
        status = WTERMSIG(status) + 128;
    }
    return status;
}

/* Function that is called in separate thread to wait on a pid */
static JanetEVGenericMessage janet_proc_wait_subr(JanetEVGenericMessage args) {
    JanetProc *proc = (JanetProc *) args.argp;
    args.tag = proc_get_status(proc);
    return args;
}

#endif /* End windows check */

/* Callback that is called in main thread when subroutine completes. */
static void janet_proc_wait_cb(JanetEVGenericMessage args) {
    janet_ev_dec_refcount();
    JanetProc *proc = (JanetProc *) args.argp;
    if (NULL != proc) {
        int status = args.tag;
        proc->return_code = (int32_t) status;
        proc->flags |= JANET_PROC_WAITED;
        proc->flags &= ~JANET_PROC_WAITING;
        janet_gcunroot(janet_wrap_abstract(proc));
        janet_gcunroot(janet_wrap_fiber(args.fiber));
        if ((status != 0) && (proc->flags & JANET_PROC_ERROR_NONZERO)) {
            JanetString s = janet_formatc("command failed with non-zero exit code %d", status);
            janet_cancel(args.fiber, janet_wrap_string(s));
        } else {
            janet_schedule(args.fiber, janet_wrap_integer(status));
        }
    }
}

#endif /* End ev check */

static int janet_proc_gc(void *p, size_t s) {
    (void) s;
    JanetProc *proc = (JanetProc *) p;
#ifdef JANET_WINDOWS
    if (!(proc->flags & JANET_PROC_CLOSED)) {
        if (!(proc->flags & JANET_PROC_ALLOW_ZOMBIE)) {
            TerminateProcess(proc->pHandle, 1);
        }
        CloseHandle(proc->pHandle);
        CloseHandle(proc->tHandle);
    }
#else
    if (!(proc->flags & (JANET_PROC_WAITED | JANET_PROC_ALLOW_ZOMBIE))) {
        /* Kill and wait to prevent zombies */
        kill(proc->pid, SIGKILL);
        int status;
        if (!(proc->flags & JANET_PROC_WAITING)) {
            waitpid(proc->pid, &status, 0);
        }
    }
#endif
    return 0;
}

static int janet_proc_mark(void *p, size_t s) {
    (void) s;
    JanetProc *proc = (JanetProc *)p;
    if (NULL != proc->in) janet_mark(janet_wrap_abstract(proc->in));
    if (NULL != proc->out) janet_mark(janet_wrap_abstract(proc->out));
    if (NULL != proc->err) janet_mark(janet_wrap_abstract(proc->err));
    return 0;
}

#ifdef JANET_EV
static JANET_NO_RETURN void
#else
static Janet
#endif
os_proc_wait_impl(JanetProc *proc) {
    if (proc->flags & (JANET_PROC_WAITED | JANET_PROC_WAITING)) {
        janet_panicf("cannot wait twice on a process");
    }
#ifdef JANET_EV
    /* Event loop implementation - threaded call */
    proc->flags |= JANET_PROC_WAITING;
    JanetEVGenericMessage targs;
    memset(&targs, 0, sizeof(targs));
    targs.argp = proc;
    targs.fiber = janet_root_fiber();
    janet_gcroot(janet_wrap_abstract(proc));
    janet_gcroot(janet_wrap_fiber(targs.fiber));
    janet_ev_threaded_call(janet_proc_wait_subr, targs, janet_proc_wait_cb);
    janet_await();
#else
    /* Non evented implementation */
    proc->flags |= JANET_PROC_WAITED;
    int status = 0;
#ifdef JANET_WINDOWS
    WaitForSingleObject(proc->pHandle, INFINITE);
    GetExitCodeProcess(proc->pHandle, &status);
    if (!(proc->flags & JANET_PROC_CLOSED)) {
        proc->flags |= JANET_PROC_CLOSED;
        CloseHandle(proc->pHandle);
        CloseHandle(proc->tHandle);
    }
#else
    waitpid(proc->pid, &status, 0);
#endif
    proc->return_code = (int32_t) status;
    return janet_wrap_integer(proc->return_code);
#endif
}

JANET_CORE_FN(os_proc_wait,
              "(os/proc-wait proc)",
              "Block until the subprocess completes. Returns the subprocess return code.") {
    janet_fixarity(argc, 1);
    JanetProc *proc = janet_getabstract(argv, 0, &ProcAT);
#ifdef JANET_EV
    os_proc_wait_impl(proc);
    return janet_wrap_nil();
#else
    return os_proc_wait_impl(proc);
#endif
}

JANET_CORE_FN(os_proc_kill,
              "(os/proc-kill proc &opt wait)",
              "Kill a subprocess by sending SIGKILL to it on posix systems, or by closing the process "
              "handle on windows. If `wait` is truthy, will wait for the process to finish and "
              "returns the exit code. Otherwise, returns `proc`.") {
    janet_arity(argc, 1, 2);
    JanetProc *proc = janet_getabstract(argv, 0, &ProcAT);
    if (proc->flags & JANET_PROC_WAITED) {
        janet_panicf("cannot kill process that has already finished");
    }
#ifdef JANET_WINDOWS
    if (proc->flags & JANET_PROC_CLOSED) {
        janet_panicf("cannot close process handle that is already closed");
    }
    proc->flags |= JANET_PROC_CLOSED;
    TerminateProcess(proc->pHandle, 1);
    CloseHandle(proc->pHandle);
    CloseHandle(proc->tHandle);
#else
    int status = kill(proc->pid, SIGKILL);
    if (status) {
        janet_panic(strerror(errno));
    }
#endif
    /* After killing process we wait on it. */
    if (argc > 1 && janet_truthy(argv[1])) {
#ifdef JANET_EV
        os_proc_wait_impl(proc);
        return janet_wrap_nil();
#else
        return os_proc_wait_impl(proc);
#endif
    } else {
        return argv[0];
    }
}

JANET_CORE_FN(os_proc_close,
              "(os/proc-close proc)",
              "Wait on a process if it has not been waited on, and close pipes created by `os/spawn` "
              "if they have not been closed. Returns nil.") {
    janet_fixarity(argc, 1);
    JanetProc *proc = janet_getabstract(argv, 0, &ProcAT);
#ifdef JANET_EV
    if (proc->flags & JANET_PROC_OWNS_STDIN) janet_stream_close(proc->in);
    if (proc->flags & JANET_PROC_OWNS_STDOUT) janet_stream_close(proc->out);
    if (proc->flags & JANET_PROC_OWNS_STDERR) janet_stream_close(proc->err);
#else
    if (proc->flags & JANET_PROC_OWNS_STDIN) janet_file_close(proc->in);
    if (proc->flags & JANET_PROC_OWNS_STDOUT) janet_file_close(proc->out);
    if (proc->flags & JANET_PROC_OWNS_STDERR) janet_file_close(proc->err);
#endif
    proc->flags &= ~(JANET_PROC_OWNS_STDIN | JANET_PROC_OWNS_STDOUT | JANET_PROC_OWNS_STDERR);
    if (proc->flags & (JANET_PROC_WAITED | JANET_PROC_WAITING)) {
        return janet_wrap_nil();
    }
#ifdef JANET_EV
    os_proc_wait_impl(proc);
    return janet_wrap_nil();
#else
    return os_proc_wait_impl(proc);
#endif
}

static void swap_handles(JanetHandle *handles) {
    JanetHandle temp = handles[0];
    handles[0] = handles[1];
    handles[1] = temp;
}

static void close_handle(JanetHandle handle) {
#ifdef JANET_WINDOWS
    CloseHandle(handle);
#else
    close(handle);
#endif
}

/* Create piped file for os/execute and os/spawn. Need to be careful that we mark
   the error flag if we can't create pipe and don't leak handles. *handle will be cleaned
   up by the calling function. If everything goes well, *handle is owned by the calling function,
   (if it is set) and the returned handle owns the other end of the pipe, which will be closed
   on GC or fclose. */
static JanetHandle make_pipes(JanetHandle *handle, int reverse, int *errflag) {
    JanetHandle handles[2];
#ifdef JANET_EV

    /* non-blocking pipes */
    if (janet_make_pipe(handles, reverse ? 2 : 1)) goto error;
    if (reverse) swap_handles(handles);
#ifdef JANET_WINDOWS
    if (!SetHandleInformation(handles[0], HANDLE_FLAG_INHERIT, 0)) goto error;
#endif
    *handle = handles[1];
    return handles[0];

#else

    /* Normal blocking pipes */
#ifdef JANET_WINDOWS
    SECURITY_ATTRIBUTES saAttr;
    memset(&saAttr, 0, sizeof(saAttr));
    saAttr.nLength = sizeof(saAttr);
    saAttr.bInheritHandle = TRUE;
    if (!CreatePipe(handles, handles + 1, &saAttr, 0)) goto error;
    if (reverse) swap_handles(handles);
    /* Don't inherit the side of the pipe owned by this process */
    if (!SetHandleInformation(handles[0], HANDLE_FLAG_INHERIT, 0)) goto error;
    *handle = handles[1];
    return handles[0];
#else
    if (pipe(handles)) goto error;
    if (reverse) swap_handles(handles);
    *handle = handles[1];
    return handles[0];
#endif

#endif
error:
    *errflag = 1;
    return JANET_HANDLE_NONE;
}

static const JanetMethod proc_methods[] = {
    {"wait", os_proc_wait},
    {"kill", os_proc_kill},
    {"close", os_proc_close},
    /* dud methods for janet_proc_next */
    {"in", NULL},
    {"out", NULL},
    {"err", NULL},
    {NULL, NULL}
};

static int janet_proc_get(void *p, Janet key, Janet *out) {
    JanetProc *proc = (JanetProc *)p;
    if (janet_keyeq(key, "in")) {
        *out = (NULL == proc->in) ? janet_wrap_nil() : janet_wrap_abstract(proc->in);
        return 1;
    }
    if (janet_keyeq(key, "out")) {
        *out = (NULL == proc->out) ? janet_wrap_nil() : janet_wrap_abstract(proc->out);
        return 1;
    }
    if (janet_keyeq(key, "err")) {
        *out = (NULL == proc->err) ? janet_wrap_nil() : janet_wrap_abstract(proc->err);
        return 1;
    }
#ifndef JANET_WINDOWS
    if (janet_keyeq(key, "pid")) {
        *out = janet_wrap_number(proc->pid);
        return 1;
    }
#endif
    if ((-1 != proc->return_code) && janet_keyeq(key, "return-code")) {
        *out = janet_wrap_integer(proc->return_code);
        return 1;
    }
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    return janet_getmethod(janet_unwrap_keyword(key), proc_methods, out);
}

static Janet janet_proc_next(void *p, Janet key) {
    (void) p;
    return janet_nextmethod(proc_methods, key);
}

static const JanetAbstractType ProcAT = {
    "core/process",
    janet_proc_gc,
    janet_proc_mark,
    janet_proc_get,
    NULL, /* put */
    NULL, /* marshal */
    NULL, /* unmarshal */
    NULL, /* tostring */
    NULL, /* compare */
    NULL, /* hash */
    janet_proc_next,
    JANET_ATEND_NEXT
};

static JanetHandle janet_getjstream(Janet *argv, int32_t n, void **orig) {
#ifdef JANET_EV
    JanetStream *stream = janet_checkabstract(argv[n], &janet_stream_type);
    if (stream != NULL) {
        if (stream->flags & JANET_STREAM_CLOSED)
            janet_panic("stream is closed");
        *orig = stream;
        return stream->handle;
    }
#endif
    JanetFile *f = janet_checkabstract(argv[n], &janet_file_type);
    if (f != NULL) {
        if (f->flags & JANET_FILE_CLOSED) {
            janet_panic("file is closed");
        }
        *orig = f;
#ifdef JANET_WINDOWS
        return (HANDLE) _get_osfhandle(_fileno(f->file));
#else
        return fileno(f->file);
#endif
    }
    janet_panicf("expected file|stream, got %v", argv[n]);
}

#ifdef JANET_EV
static JanetStream *get_stdio_for_handle(JanetHandle handle, void *orig, int iswrite) {
    if (orig == NULL) {
        return janet_stream(handle, iswrite ? JANET_STREAM_WRITABLE : JANET_STREAM_READABLE, NULL);
    } else if (janet_abstract_type(orig) == &janet_file_type) {
        JanetFile *jf = (JanetFile *)orig;
        uint32_t flags = 0;
        if (jf->flags & JANET_FILE_WRITE) {
            flags |= JANET_STREAM_WRITABLE;
        }
        if (jf->flags & JANET_FILE_READ) {
            flags |= JANET_STREAM_READABLE;
        }
        /* duplicate handle when converting file to stream */
#ifdef JANET_WINDOWS
        HANDLE prochandle = GetCurrentProcess();
        HANDLE newHandle = INVALID_HANDLE_VALUE;
        if (!DuplicateHandle(prochandle, handle, prochandle, &newHandle, 0, FALSE, DUPLICATE_SAME_ACCESS)) {
            return NULL;
        }
#else
        int newHandle = dup(handle);
        if (newHandle < 0) {
            return NULL;
        }
#endif
        return janet_stream(newHandle, flags, NULL);
    } else {
        return orig;
    }
}
#else
static JanetFile *get_stdio_for_handle(JanetHandle handle, void *orig, int iswrite) {
    if (NULL != orig) return (JanetFile *) orig;
#ifdef JANET_WINDOWS
    int fd = _open_osfhandle((intptr_t) handle, iswrite ? _O_WRONLY : _O_RDONLY);
    if (-1 == fd) return NULL;
    FILE *f = _fdopen(fd, iswrite ? "w" : "r");
    if (NULL == f) {
        _close(fd);
        return NULL;
    }
#else
    FILE *f = fdopen(handle, iswrite ? "w" : "r");
    if (NULL == f) return NULL;
#endif
    return janet_makejfile(f, iswrite ? JANET_FILE_WRITE : JANET_FILE_READ);
}
#endif

static Janet os_execute_impl(int32_t argc, Janet *argv, int is_spawn) {
    janet_arity(argc, 1, 3);

    /* Get flags */
    uint64_t flags = 0;
    if (argc > 1) {
        flags = janet_getflags(argv, 1, "epxd");
    }

    /* Get environment */
    int use_environ = !janet_flag_at(flags, 0);
    EnvBlock envp = os_execute_env(argc, argv);

    /* Get arguments */
    JanetView exargs = janet_getindexed(argv, 0);
    if (exargs.len < 1) {
        janet_panic("expected at least 1 command line argument");
    }

    /* Optional stdio redirections */
    JanetAbstract orig_in = NULL, orig_out = NULL, orig_err = NULL;
    JanetHandle new_in = JANET_HANDLE_NONE, new_out = JANET_HANDLE_NONE, new_err = JANET_HANDLE_NONE;
    JanetHandle pipe_in = JANET_HANDLE_NONE, pipe_out = JANET_HANDLE_NONE, pipe_err = JANET_HANDLE_NONE;
    int pipe_errflag = 0; /* Track errors setting up pipes */
    int pipe_owner_flags = (is_spawn && (flags & 0x8)) ? JANET_PROC_ALLOW_ZOMBIE : 0;

    /* Get optional redirections */
    if (argc > 2) {
        JanetDictView tab = janet_getdictionary(argv, 2);
        Janet maybe_stdin = janet_dictionary_get(tab.kvs, tab.cap, janet_ckeywordv("in"));
        Janet maybe_stdout = janet_dictionary_get(tab.kvs, tab.cap, janet_ckeywordv("out"));
        Janet maybe_stderr = janet_dictionary_get(tab.kvs, tab.cap, janet_ckeywordv("err"));
        if (is_spawn && janet_keyeq(maybe_stdin, "pipe")) {
            new_in = make_pipes(&pipe_in, 1, &pipe_errflag);
            pipe_owner_flags |= JANET_PROC_OWNS_STDIN;
        } else if (!janet_checktype(maybe_stdin, JANET_NIL)) {
            new_in = janet_getjstream(&maybe_stdin, 0, &orig_in);
        }
        if (is_spawn && janet_keyeq(maybe_stdout, "pipe")) {
            new_out = make_pipes(&pipe_out, 0, &pipe_errflag);
            pipe_owner_flags |= JANET_PROC_OWNS_STDOUT;
        } else if (!janet_checktype(maybe_stdout, JANET_NIL)) {
            new_out = janet_getjstream(&maybe_stdout, 0, &orig_out);
        }
        if (is_spawn && janet_keyeq(maybe_stderr, "pipe")) {
            new_err = make_pipes(&pipe_err, 0, &pipe_errflag);
            pipe_owner_flags |= JANET_PROC_OWNS_STDERR;
        } else if (!janet_checktype(maybe_stderr, JANET_NIL)) {
            new_err = janet_getjstream(&maybe_stderr, 0, &orig_err);
        }
    }

    /* Clean up if any of the pipes have any issues */
    if (pipe_errflag) {
        if (pipe_in != JANET_HANDLE_NONE) close_handle(pipe_in);
        if (pipe_out != JANET_HANDLE_NONE) close_handle(pipe_out);
        if (pipe_err != JANET_HANDLE_NONE) close_handle(pipe_err);
        janet_panic("failed to create pipes");
    }

    /* Result */
    int status = 0;

#ifdef JANET_WINDOWS

    HANDLE pHandle, tHandle;
    SECURITY_ATTRIBUTES saAttr;
    PROCESS_INFORMATION processInfo;
    STARTUPINFO startupInfo;
    memset(&saAttr, 0, sizeof(saAttr));
    memset(&processInfo, 0, sizeof(processInfo));
    memset(&startupInfo, 0, sizeof(startupInfo));
    startupInfo.cb = sizeof(startupInfo);
    startupInfo.dwFlags |= STARTF_USESTDHANDLES;
    saAttr.nLength = sizeof(saAttr);

    JanetBuffer *buf = os_exec_escape(exargs);
    if (buf->count > 8191) {
        if (pipe_in != JANET_HANDLE_NONE) CloseHandle(pipe_in);
        if (pipe_out != JANET_HANDLE_NONE) CloseHandle(pipe_out);
        if (pipe_err != JANET_HANDLE_NONE) CloseHandle(pipe_err);
        janet_panic("command line string too long (max 8191 characters)");
    }
    const char *path = (const char *) janet_unwrap_string(exargs.items[0]);

    /* Do IO redirection */

    if (pipe_in != JANET_HANDLE_NONE) {
        startupInfo.hStdInput = pipe_in;
    } else if (new_in != JANET_HANDLE_NONE) {
        startupInfo.hStdInput = new_in;
    } else {
        startupInfo.hStdInput = (HANDLE) _get_osfhandle(0);
    }


    if (pipe_out != JANET_HANDLE_NONE) {
        startupInfo.hStdOutput = pipe_out;
    } else if (new_out != JANET_HANDLE_NONE) {
        startupInfo.hStdOutput = new_out;
    } else {
        startupInfo.hStdOutput = (HANDLE) _get_osfhandle(1);
    }

    if (pipe_err != JANET_HANDLE_NONE) {
        startupInfo.hStdError = pipe_err;
    } else if (new_err != NULL) {
        startupInfo.hStdError = new_err;
    } else {
        startupInfo.hStdError = (HANDLE) _get_osfhandle(2);
    }

    int cp_failed = 0;
    if (!CreateProcess(janet_flag_at(flags, 1) ? NULL : path,
                       (char *) buf->data, /* Single CLI argument */
                       &saAttr, /* no proc inheritance */
                       &saAttr, /* no thread inheritance */
                       TRUE, /* handle inheritance */
                       0, /* flags */
                       use_environ ? NULL : envp, /* pass in environment */
                       NULL, /* use parents starting directory */
                       &startupInfo,
                       &processInfo)) {
        cp_failed = 1;
    }

    if (pipe_in != JANET_HANDLE_NONE) CloseHandle(pipe_in);
    if (pipe_out != JANET_HANDLE_NONE) CloseHandle(pipe_out);
    if (pipe_err != JANET_HANDLE_NONE) CloseHandle(pipe_err);

    os_execute_cleanup(envp, NULL);

    if (cp_failed)  {
        janet_panic("failed to create process");
    }

    pHandle = processInfo.hProcess;
    tHandle = processInfo.hThread;

#else

    const char **child_argv = janet_smalloc(sizeof(char *) * ((size_t) exargs.len + 1));
    for (int32_t i = 0; i < exargs.len; i++)
        child_argv[i] = janet_getcstring(exargs.items, i);
    child_argv[exargs.len] = NULL;
    /* Coerce to form that works for spawn. I'm fairly confident no implementation
     * of posix_spawn would modify the argv array passed in. */
    char *const *cargv = (char *const *)child_argv;

    /* Use posix_spawn to spawn new process */

    if (use_environ) {
        janet_lock_environ();
    }

    /* Posix spawn setup */
    posix_spawn_file_actions_t actions;
    posix_spawn_file_actions_init(&actions);
    if (pipe_in != JANET_HANDLE_NONE) {
        posix_spawn_file_actions_adddup2(&actions, pipe_in, 0);
        posix_spawn_file_actions_addclose(&actions, pipe_in);
    } else if (new_in != JANET_HANDLE_NONE) {
        posix_spawn_file_actions_adddup2(&actions, new_in, 0);
        posix_spawn_file_actions_addclose(&actions, new_in);
    }
    if (pipe_out != JANET_HANDLE_NONE) {
        posix_spawn_file_actions_adddup2(&actions, pipe_out, 1);
        posix_spawn_file_actions_addclose(&actions, pipe_out);
    } else if (new_out != JANET_HANDLE_NONE) {
        posix_spawn_file_actions_adddup2(&actions, new_out, 1);
        posix_spawn_file_actions_addclose(&actions, new_out);
    }
    if (pipe_err != JANET_HANDLE_NONE) {
        posix_spawn_file_actions_adddup2(&actions, pipe_err, 2);
        posix_spawn_file_actions_addclose(&actions, pipe_err);
    } else if (new_err != JANET_HANDLE_NONE) {
        posix_spawn_file_actions_adddup2(&actions, new_err, 2);
        posix_spawn_file_actions_addclose(&actions, new_err);
    }

    pid_t pid;
    if (janet_flag_at(flags, 1)) {
        status = posix_spawnp(&pid,
                              child_argv[0], &actions, NULL, cargv,
                              use_environ ? environ : envp);
    } else {
        status = posix_spawn(&pid,
                             child_argv[0], &actions, NULL, cargv,
                             use_environ ? environ : envp);
    }

    posix_spawn_file_actions_destroy(&actions);

    if (pipe_in != JANET_HANDLE_NONE) close(pipe_in);
    if (pipe_out != JANET_HANDLE_NONE) close(pipe_out);
    if (pipe_err != JANET_HANDLE_NONE) close(pipe_err);

    if (use_environ) {
        janet_unlock_environ();
    }

    os_execute_cleanup(envp, child_argv);
    if (status) {
        janet_panicf("%p: %s", argv[0], strerror(errno));
    }

#endif
    JanetProc *proc = janet_abstract(&ProcAT, sizeof(JanetProc));
    proc->return_code = -1;
#ifdef JANET_WINDOWS
    proc->pHandle = pHandle;
    proc->tHandle = tHandle;
#else
    proc->pid = pid;
#endif
    proc->in = NULL;
    proc->out = NULL;
    proc->err = NULL;
    proc->flags = pipe_owner_flags;
    if (janet_flag_at(flags, 2)) {
        proc->flags |= JANET_PROC_ERROR_NONZERO;
    }
    if (is_spawn) {
        /* Only set up pointers to stdin, stdout, and stderr if os/spawn. */
        if (new_in != JANET_HANDLE_NONE) {
            proc->in = get_stdio_for_handle(new_in, orig_in, 1);
            if (NULL == proc->in) janet_panic("failed to construct proc");
        }
        if (new_out != JANET_HANDLE_NONE) {
            proc->out = get_stdio_for_handle(new_out, orig_out, 0);
            if (NULL == proc->out) janet_panic("failed to construct proc");
        }
        if (new_err != JANET_HANDLE_NONE) {
            proc->err = get_stdio_for_handle(new_err, orig_err, 0);
            if (NULL == proc->err) janet_panic("failed to construct proc");
        }
        return janet_wrap_abstract(proc);
    } else {
#ifdef JANET_EV
        os_proc_wait_impl(proc);
#else
        return os_proc_wait_impl(proc);
#endif
    }
}

JANET_CORE_FN(os_execute,
              "(os/execute args &opt flags env)",
              "Execute a program on the system and pass it string arguments. `flags` "
              "is a keyword that modifies how the program will execute.\n"
              "* :e - enables passing an environment to the program. Without :e, the "
              "current environment is inherited.\n"
              "* :p - allows searching the current PATH for the binary to execute. "
              "Without this flag, binaries must use absolute paths.\n"
              "* :x - raise error if exit code is non-zero.\n"
              "* :d - Don't try and terminate the process on garbage collection (allow spawning zombies).\n"
              "`env` is a table or struct mapping environment variables to values. It can also "
              "contain the keys :in, :out, and :err, which allow redirecting stdio in the subprocess. "
              "These arguments should be core/file values. "
              "Returns the exit status of the program.") {
    return os_execute_impl(argc, argv, 0);
}

JANET_CORE_FN(os_spawn,
              "(os/spawn args &opt flags env)",
              "Execute a program on the system and return a handle to the process. Otherwise, takes the "
              "same arguments as `os/execute`. Does not wait for the process. "
              "For each of the :in, :out, and :err keys to the `env` argument, one "
              "can also pass in the keyword `:pipe` "
              "to get streams for standard IO of the subprocess that can be read from and written to. "
              "The returned value `proc` has the fields :in, :out, :err, :return-code, and "
              "the additional field :pid on unix-like platforms. Use `(os/proc-wait proc)` to rejoin the "
              "subprocess or `(os/proc-kill proc)`.") {
    return os_execute_impl(argc, argv, 1);
}

#ifdef JANET_EV
/* Runs in a separate thread */
static JanetEVGenericMessage os_shell_subr(JanetEVGenericMessage args) {
    int stat = system((const char *) args.argp);
    janet_free(args.argp);
    if (args.argi) {
        args.tag = JANET_EV_TCTAG_INTEGER;
    } else {
        args.tag = JANET_EV_TCTAG_BOOLEAN;
    }
    args.argi = stat;
    return args;
}
#endif

JANET_CORE_FN(os_shell,
              "(os/shell str)",
              "Pass a command string str directly to the system shell.") {
    janet_arity(argc, 0, 1);
    const char *cmd = argc
                      ? janet_getcstring(argv, 0)
                      : NULL;
#ifdef JANET_EV
    janet_ev_threaded_await(os_shell_subr, 0, argc, cmd ? strdup(cmd) : NULL);
#else
    int stat = system(cmd);
    return argc
           ? janet_wrap_integer(stat)
           : janet_wrap_boolean(stat);
#endif
}

#endif /* JANET_NO_PROCESSES */

JANET_CORE_FN(os_environ,
              "(os/environ)",
              "Get a copy of the OS environment table.") {
    (void) argv;
    janet_fixarity(argc, 0);
    int32_t nenv = 0;
    janet_lock_environ();
    char **env = environ;
    while (*env++)
        nenv += 1;
    JanetTable *t = janet_table(nenv);
    for (int32_t i = 0; i < nenv; i++) {
        char *e = environ[i];
        char *eq = strchr(e, '=');
        if (!eq) {
            janet_unlock_environ();
            janet_panic("no '=' in environ");
        }
        char *v = eq + 1;
        int32_t full_len = (int32_t) strlen(e);
        int32_t val_len = (int32_t) strlen(v);
        janet_table_put(
            t,
            janet_stringv((const uint8_t *)e, full_len - val_len - 1),
            janet_stringv((const uint8_t *)v, val_len)
        );
    }
    janet_unlock_environ();
    return janet_wrap_table(t);
}

JANET_CORE_FN(os_getenv,
              "(os/getenv variable &opt dflt)",
              "Get the string value of an environment variable.") {
    janet_arity(argc, 1, 2);
    const char *cstr = janet_getcstring(argv, 0);
    const char *res = getenv(cstr);
    janet_lock_environ();
    Janet ret = res
                ? janet_cstringv(res)
                : argc == 2
                ? argv[1]
                : janet_wrap_nil();
    janet_unlock_environ();
    return ret;
}

JANET_CORE_FN(os_setenv,
              "(os/setenv variable value)",
              "Set an environment variable.") {
#ifdef JANET_WINDOWS
#define SETENV(K,V) _putenv_s(K, V)
#define UNSETENV(K) _putenv_s(K, "")
#else
#define SETENV(K,V) setenv(K, V, 1)
#define UNSETENV(K) unsetenv(K)
#endif
    janet_arity(argc, 1, 2);
    const char *ks = janet_getcstring(argv, 0);
    const char *vs = janet_optcstring(argv, argc, 1, NULL);
    janet_lock_environ();
    if (NULL == vs) {
        UNSETENV(ks);
    } else {
        SETENV(ks, vs);
    }
    janet_unlock_environ();
    return janet_wrap_nil();
}

JANET_CORE_FN(os_time,
              "(os/time)",
              "Get the current time expressed as the number of whole seconds since "
              "January 1, 1970, the Unix epoch. Returns a real number.") {
    janet_fixarity(argc, 0);
    (void) argv;
    double dtime = (double)(time(NULL));
    return janet_wrap_number(dtime);
}

JANET_CORE_FN(os_clock,
              "(os/clock)",
              "Return the number of whole + fractional seconds since some fixed point in time. The clock "
              "is guaranteed to be non-decreasing in real time.") {
    janet_fixarity(argc, 0);
    (void) argv;
    struct timespec tv;
    if (janet_gettime(&tv)) janet_panic("could not get time");
    double dtime = tv.tv_sec + (tv.tv_nsec / 1E9);
    return janet_wrap_number(dtime);
}

JANET_CORE_FN(os_sleep,
              "(os/sleep n)",
              "Suspend the program for `n` seconds. `n` can be a real number. Returns "
              "nil.") {
    janet_fixarity(argc, 1);
    double delay = janet_getnumber(argv, 0);
    if (delay < 0) janet_panic("invalid argument to sleep");
#ifdef JANET_WINDOWS
    Sleep((DWORD)(delay * 1000));
#else
    int rc;
    struct timespec ts;
    ts.tv_sec = (time_t) delay;
    ts.tv_nsec = (delay <= UINT32_MAX)
                 ? (long)((delay - ((uint32_t)delay)) * 1000000000)
                 : 0;
    RETRY_EINTR(rc, nanosleep(&ts, &ts));
#endif
    return janet_wrap_nil();
}

JANET_CORE_FN(os_cwd,
              "(os/cwd)",
              "Returns the current working directory.") {
    janet_fixarity(argc, 0);
    (void) argv;
    char buf[FILENAME_MAX];
    char *ptr;
#ifdef JANET_WINDOWS
    ptr = _getcwd(buf, FILENAME_MAX);
#else
    ptr = getcwd(buf, FILENAME_MAX);
#endif
    if (NULL == ptr) janet_panic("could not get current directory");
    return janet_cstringv(ptr);
}

JANET_CORE_FN(os_cryptorand,
              "(os/cryptorand n &opt buf)",
              "Get or append `n` bytes of good quality random data provided by the OS. Returns a new buffer or `buf`.") {
    JanetBuffer *buffer;
    janet_arity(argc, 1, 2);
    int32_t offset;
    int32_t n = janet_getinteger(argv, 0);
    if (n < 0) janet_panic("expected positive integer");
    if (argc == 2) {
        buffer = janet_getbuffer(argv, 1);
        offset = buffer->count;
    } else {
        offset = 0;
        buffer = janet_buffer(n);
    }
    /* We could optimize here by adding setcount_uninit */
    janet_buffer_setcount(buffer, offset + n);

    if (janet_cryptorand(buffer->data + offset, n) != 0)
        janet_panic("unable to get sufficient random data");

    return janet_wrap_buffer(buffer);
}

JANET_CORE_FN(os_date,
              "(os/date &opt time local)",
              "Returns the given time as a date struct, or the current time if `time` is not given. "
              "Returns a struct with following key values. Note that all numbers are 0-indexed. "
              "Date is given in UTC unless `local` is truthy, in which case the date is formatted for "
              "the local timezone.\n\n"
              "* :seconds - number of seconds [0-61]\n\n"
              "* :minutes - number of minutes [0-59]\n\n"
              "* :hours - number of hours [0-23]\n\n"
              "* :month-day - day of month [0-30]\n\n"
              "* :month - month of year [0, 11]\n\n"
              "* :year - years since year 0 (e.g. 2019)\n\n"
              "* :week-day - day of the week [0-6]\n\n"
              "* :year-day - day of the year [0-365]\n\n"
              "* :dst - if Day Light Savings is in effect") {
    janet_arity(argc, 0, 2);
    (void) argv;
    time_t t;
    struct tm t_infos;
    struct tm *t_info = NULL;
    if (argc && !janet_checktype(argv[0], JANET_NIL)) {
        int64_t integer = janet_getinteger64(argv, 0);
        t = (time_t) integer;
    } else {
        time(&t);
    }
    if (argc >= 2 && janet_truthy(argv[1])) {
        /* local time */
#ifdef JANET_WINDOWS
        _tzset();
        localtime_s(&t_infos, &t);
        t_info = &t_infos;
#else
        tzset();
        t_info = localtime_r(&t, &t_infos);
#endif
    } else {
        /* utc time */
#ifdef JANET_WINDOWS
        gmtime_s(&t_infos, &t);
        t_info = &t_infos;
#else
        t_info = gmtime_r(&t, &t_infos);
#endif
    }
    JanetKV *st = janet_struct_begin(9);
    janet_struct_put(st, janet_ckeywordv("seconds"), janet_wrap_number(t_info->tm_sec));
    janet_struct_put(st, janet_ckeywordv("minutes"), janet_wrap_number(t_info->tm_min));
    janet_struct_put(st, janet_ckeywordv("hours"), janet_wrap_number(t_info->tm_hour));
    janet_struct_put(st, janet_ckeywordv("month-day"), janet_wrap_number(t_info->tm_mday - 1));
    janet_struct_put(st, janet_ckeywordv("month"), janet_wrap_number(t_info->tm_mon));
    janet_struct_put(st, janet_ckeywordv("year"), janet_wrap_number(t_info->tm_year + 1900));
    janet_struct_put(st, janet_ckeywordv("week-day"), janet_wrap_number(t_info->tm_wday));
    janet_struct_put(st, janet_ckeywordv("year-day"), janet_wrap_number(t_info->tm_yday));
    janet_struct_put(st, janet_ckeywordv("dst"), janet_wrap_boolean(t_info->tm_isdst));
    return janet_wrap_struct(janet_struct_end(st));
}

static int entry_getdst(Janet env_entry) {
    Janet v;
    if (janet_checktype(env_entry, JANET_TABLE)) {
        JanetTable *entry = janet_unwrap_table(env_entry);
        v = janet_table_get(entry, janet_ckeywordv("dst"));
    } else if (janet_checktype(env_entry, JANET_STRUCT)) {
        const JanetKV *entry = janet_unwrap_struct(env_entry);
        v = janet_struct_get(entry, janet_ckeywordv("dst"));
    } else {
        v = janet_wrap_nil();
    }
    if (janet_checktype(v, JANET_NIL)) {
        return -1;
    } else {
        return janet_truthy(v);
    }
}

#ifdef JANET_WINDOWS
typedef int32_t timeint_t;
#else
typedef int64_t timeint_t;
#endif

static timeint_t entry_getint(Janet env_entry, char *field) {
    Janet i;
    if (janet_checktype(env_entry, JANET_TABLE)) {
        JanetTable *entry = janet_unwrap_table(env_entry);
        i = janet_table_get(entry, janet_ckeywordv(field));
    } else if (janet_checktype(env_entry, JANET_STRUCT)) {
        const JanetKV *entry = janet_unwrap_struct(env_entry);
        i = janet_struct_get(entry, janet_ckeywordv(field));
    } else {
        return 0;
    }

    if (janet_checktype(i, JANET_NIL)) {
        return 0;
    }

#ifdef JANET_WINDOWS
    if (!janet_checkint(i)) {
        janet_panicf("bad slot #%s, expected 32 bit signed integer, got %v",
                     field, i);
    }
#else
    if (!janet_checkint64(i)) {
        janet_panicf("bad slot #%s, expected 64 bit signed integer, got %v",
                     field, i);
    }
#endif

    return (timeint_t)janet_unwrap_number(i);
}

JANET_CORE_FN(os_mktime,
              "(os/mktime date-struct &opt local)",
              "Get the broken down date-struct time expressed as the number "
              "of seconds since January 1, 1970, the Unix epoch. "
              "Returns a real number. "
              "Date is given in UTC unless `local` is truthy, in which case the "
              "date is computed for the local timezone.\n\n"
              "Inverse function to os/date.") {
    janet_arity(argc, 1, 2);
    time_t t;
    struct tm t_info;

    /* Use memset instead of = {0} to silence paranoid warning in macos */
    memset(&t_info, 0, sizeof(t_info));

    if (!janet_checktype(argv[0], JANET_TABLE) &&
            !janet_checktype(argv[0], JANET_STRUCT))
        janet_panic_type(argv[0], 0, JANET_TFLAG_DICTIONARY);

    t_info.tm_sec = entry_getint(argv[0], "seconds");
    t_info.tm_min = entry_getint(argv[0], "minutes");
    t_info.tm_hour = entry_getint(argv[0], "hours");
    t_info.tm_mday = entry_getint(argv[0], "month-day") + 1;
    t_info.tm_mon = entry_getint(argv[0], "month");
    t_info.tm_year = entry_getint(argv[0], "year") - 1900;
    t_info.tm_isdst = entry_getdst(argv[0]);

    if (argc >= 2 && janet_truthy(argv[1])) {
        /* local time */
        t = mktime(&t_info);
    } else {
        /* utc time */
#ifdef JANET_NO_UTC_MKTIME
        janet_panic("os/mktime UTC not supported on this platform");
        return janet_wrap_nil();
#else
        t = timegm(&t_info);
#endif
    }

    if (t == (time_t) -1) {
        janet_panicf("%s", strerror(errno));
    }

    return janet_wrap_number((double)t);
}

#ifdef JANET_NO_SYMLINKS
#define j_symlink link
#else
#define j_symlink symlink
#endif

JANET_CORE_FN(os_link,
              "(os/link oldpath newpath &opt symlink)",
              "Create a link at newpath that points to oldpath and returns nil. "
              "Iff symlink is truthy, creates a symlink. "
              "Iff symlink is falsey or not provided, "
              "creates a hard link. Does not work on Windows.") {
    janet_arity(argc, 2, 3);
#ifdef JANET_WINDOWS
    (void) argc;
    (void) argv;
    janet_panic("os/link not supported on Windows");
    return janet_wrap_nil();
#else
    const char *oldpath = janet_getcstring(argv, 0);
    const char *newpath = janet_getcstring(argv, 1);
    int res = ((argc == 3 && janet_truthy(argv[2])) ? j_symlink : link)(oldpath, newpath);
    if (-1 == res) janet_panicf("%s: %s -> %s", strerror(errno), oldpath, newpath);
    return janet_wrap_nil();
#endif
}

JANET_CORE_FN(os_symlink,
              "(os/symlink oldpath newpath)",
              "Create a symlink from oldpath to newpath, returning nil. Same as `(os/link oldpath newpath true)`.") {
    janet_fixarity(argc, 2);
#ifdef JANET_WINDOWS
    (void) argc;
    (void) argv;
    janet_panic("os/symlink not supported on Windows");
    return janet_wrap_nil();
#else
    const char *oldpath = janet_getcstring(argv, 0);
    const char *newpath = janet_getcstring(argv, 1);
    int res = j_symlink(oldpath, newpath);
    if (-1 == res) janet_panicf("%s: %s -> %s", strerror(errno), oldpath, newpath);
    return janet_wrap_nil();
#endif
}

#undef j_symlink

JANET_CORE_FN(os_mkdir,
              "(os/mkdir path)",
              "Create a new directory. The path will be relative to the current directory if relative, otherwise "
              "it will be an absolute path. Returns true if the directory was created, false if the directory already exists, and "
              "errors otherwise.") {
    janet_fixarity(argc, 1);
    const char *path = janet_getcstring(argv, 0);
#ifdef JANET_WINDOWS
    int res = _mkdir(path);
#else
    int res = mkdir(path, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IXOTH);
#endif
    if (res == 0) return janet_wrap_true();
    if (errno == EEXIST) return janet_wrap_false();
    janet_panicf("%s: %s", strerror(errno), path);
}

JANET_CORE_FN(os_rmdir,
              "(os/rmdir path)",
              "Delete a directory. The directory must be empty to succeed.") {
    janet_fixarity(argc, 1);
    const char *path = janet_getcstring(argv, 0);
#ifdef JANET_WINDOWS
    int res = _rmdir(path);
#else
    int res = rmdir(path);
#endif
    if (-1 == res) janet_panicf("%s: %s", strerror(errno), path);
    return janet_wrap_nil();
}

JANET_CORE_FN(os_cd,
              "(os/cd path)",
              "Change current directory to path. Returns nil on success, errors on failure.") {
    janet_fixarity(argc, 1);
    const char *path = janet_getcstring(argv, 0);
#ifdef JANET_WINDOWS
    int res = _chdir(path);
#else
    int res = chdir(path);
#endif
    if (-1 == res) janet_panicf("%s: %s", strerror(errno), path);
    return janet_wrap_nil();
}

JANET_CORE_FN(os_touch,
              "(os/touch path &opt actime modtime)",
              "Update the access time and modification times for a file. By default, sets "
              "times to the current time.") {
    janet_arity(argc, 1, 3);
    const char *path = janet_getcstring(argv, 0);
    struct utimbuf timebuf, *bufp;
    if (argc >= 2) {
        bufp = &timebuf;
        timebuf.actime = (time_t) janet_getnumber(argv, 1);
        if (argc >= 3) {
            timebuf.modtime = (time_t) janet_getnumber(argv, 2);
        } else {
            timebuf.modtime = timebuf.actime;
        }
    } else {
        bufp = NULL;
    }
    int res = utime(path, bufp);
    if (-1 == res) janet_panic(strerror(errno));
    return janet_wrap_nil();
}

JANET_CORE_FN(os_remove,
              "(os/rm path)",
              "Delete a file. Returns nil.") {
    janet_fixarity(argc, 1);
    const char *path = janet_getcstring(argv, 0);
    int status = remove(path);
    if (-1 == status) janet_panicf("%s: %s", strerror(errno), path);
    return janet_wrap_nil();
}

#ifndef JANET_NO_SYMLINKS
JANET_CORE_FN(os_readlink,
              "(os/readlink path)",
              "Read the contents of a symbolic link. Does not work on Windows.\n") {
    janet_fixarity(argc, 1);
#ifdef JANET_WINDOWS
    (void) argc;
    (void) argv;
    janet_panic("os/readlink not supported on Windows");
    return janet_wrap_nil();
#else
    static char buffer[PATH_MAX];
    const char *path = janet_getcstring(argv, 0);
    ssize_t len = readlink(path, buffer, sizeof buffer);
    if (len < 0 || (size_t)len >= sizeof buffer)
        janet_panicf("%s: %s", strerror(errno), path);
    return janet_stringv((const uint8_t *)buffer, len);
#endif
}
#endif

#ifdef JANET_WINDOWS

typedef struct _stat jstat_t;
typedef unsigned short jmode_t;

static int32_t janet_perm_to_unix(unsigned short m) {
    int32_t ret = 0;
    if (m & S_IEXEC) ret |= 0111;
    if (m & S_IWRITE) ret |= 0222;
    if (m & S_IREAD) ret |= 0444;
    return ret;
}

static unsigned short janet_perm_from_unix(int32_t x) {
    unsigned short m = 0;
    if (x & 111) m |= S_IEXEC;
    if (x & 222) m |= S_IWRITE;
    if (x & 444) m |= S_IREAD;
    return m;
}

static const uint8_t *janet_decode_mode(unsigned short m) {
    const char *str = "other";
    if (m & _S_IFREG) str = "file";
    else if (m & _S_IFDIR) str = "directory";
    else if (m & _S_IFCHR) str = "character";
    return janet_ckeyword(str);
}

static int32_t janet_decode_permissions(jmode_t mode) {
    return (int32_t)(mode & (S_IEXEC | S_IWRITE | S_IREAD));
}

#else

typedef struct stat jstat_t;
typedef mode_t jmode_t;

static int32_t janet_perm_to_unix(mode_t m) {
    return (int32_t) m;
}

static mode_t janet_perm_from_unix(int32_t x) {
    return (mode_t) x;
}

static const uint8_t *janet_decode_mode(mode_t m) {
    const char *str = "other";
    if (S_ISREG(m)) str = "file";
    else if (S_ISDIR(m)) str = "directory";
    else if (S_ISFIFO(m)) str = "fifo";
    else if (S_ISBLK(m)) str = "block";
    else if (S_ISSOCK(m)) str = "socket";
    else if (S_ISLNK(m)) str = "link";
    else if (S_ISCHR(m)) str = "character";
    return janet_ckeyword(str);
}

static int32_t janet_decode_permissions(jmode_t mode) {
    return (int32_t)(mode & 0777);
}

#endif

static int32_t os_parse_permstring(const uint8_t *perm) {
    int32_t m = 0;
    if (perm[0] == 'r') m |= 0400;
    if (perm[1] == 'w') m |= 0200;
    if (perm[2] == 'x') m |= 0100;
    if (perm[3] == 'r') m |= 0040;
    if (perm[4] == 'w') m |= 0020;
    if (perm[5] == 'x') m |= 0010;
    if (perm[6] == 'r') m |= 0004;
    if (perm[7] == 'w') m |= 0002;
    if (perm[8] == 'x') m |= 0001;
    return m;
}

static Janet os_make_permstring(int32_t permissions) {
    uint8_t bytes[9] = {0};
    bytes[0] = (permissions & 0400) ? 'r' : '-';
    bytes[1] = (permissions & 0200) ? 'w' : '-';
    bytes[2] = (permissions & 0100) ? 'x' : '-';
    bytes[3] = (permissions & 0040) ? 'r' : '-';
    bytes[4] = (permissions & 0020) ? 'w' : '-';
    bytes[5] = (permissions & 0010) ? 'x' : '-';
    bytes[6] = (permissions & 0004) ? 'r' : '-';
    bytes[7] = (permissions & 0002) ? 'w' : '-';
    bytes[8] = (permissions & 0001) ? 'x' : '-';
    return janet_stringv(bytes, sizeof(bytes));
}

static int32_t os_get_unix_mode(const Janet *argv, int32_t n) {
    int32_t unix_mode;
    if (janet_checkint(argv[n])) {
        /* Integer mode */
        int32_t x = janet_unwrap_integer(argv[n]);
        if (x < 0 || x > 0777) {
            janet_panicf("bad slot #%d, expected integer in range [0, 8r777], got %v", n, argv[n]);
        }
        unix_mode = x;
    } else {
        /* Bytes mode */
        JanetByteView bytes = janet_getbytes(argv, n);
        if (bytes.len != 9) {
            janet_panicf("bad slot #%d: expected byte sequence of length 9, got %v", n, argv[n]);
        }
        unix_mode = os_parse_permstring(bytes.bytes);
    }
    return unix_mode;
}

static jmode_t os_getmode(const Janet *argv, int32_t n) {
    return janet_perm_from_unix(os_get_unix_mode(argv, n));
}

/* Getters */
static Janet os_stat_dev(jstat_t *st) {
    return janet_wrap_number(st->st_dev);
}
static Janet os_stat_inode(jstat_t *st) {
    return janet_wrap_number(st->st_ino);
}
static Janet os_stat_mode(jstat_t *st) {
    return janet_wrap_keyword(janet_decode_mode(st->st_mode));
}
static Janet os_stat_int_permissions(jstat_t *st) {
    return janet_wrap_integer(janet_perm_to_unix(janet_decode_permissions(st->st_mode)));
}
static Janet os_stat_permissions(jstat_t *st) {
    return os_make_permstring(janet_perm_to_unix(janet_decode_permissions(st->st_mode)));
}
static Janet os_stat_uid(jstat_t *st) {
    return janet_wrap_number(st->st_uid);
}
static Janet os_stat_gid(jstat_t *st) {
    return janet_wrap_number(st->st_gid);
}
static Janet os_stat_nlink(jstat_t *st) {
    return janet_wrap_number(st->st_nlink);
}
static Janet os_stat_rdev(jstat_t *st) {
    return janet_wrap_number(st->st_rdev);
}
static Janet os_stat_size(jstat_t *st) {
    return janet_wrap_number(st->st_size);
}
static Janet os_stat_accessed(jstat_t *st) {
    return janet_wrap_number((double) st->st_atime);
}
static Janet os_stat_modified(jstat_t *st) {
    return janet_wrap_number((double) st->st_mtime);
}
static Janet os_stat_changed(jstat_t *st) {
    return janet_wrap_number((double) st->st_ctime);
}
#ifdef JANET_WINDOWS
static Janet os_stat_blocks(jstat_t *st) {
    return janet_wrap_number(0);
}
static Janet os_stat_blocksize(jstat_t *st) {
    return janet_wrap_number(0);
}
#else
static Janet os_stat_blocks(jstat_t *st) {
    return janet_wrap_number(st->st_blocks);
}
static Janet os_stat_blocksize(jstat_t *st) {
    return janet_wrap_number(st->st_blksize);
}
#endif

struct OsStatGetter {
    const char *name;
    Janet(*fn)(jstat_t *st);
};

static const struct OsStatGetter os_stat_getters[] = {
    {"dev", os_stat_dev},
    {"inode", os_stat_inode},
    {"mode", os_stat_mode},
    {"int-permissions", os_stat_int_permissions},
    {"permissions", os_stat_permissions},
    {"uid", os_stat_uid},
    {"gid", os_stat_gid},
    {"nlink", os_stat_nlink},
    {"rdev", os_stat_rdev},
    {"size", os_stat_size},
    {"blocks", os_stat_blocks},
    {"blocksize", os_stat_blocksize},
    {"accessed", os_stat_accessed},
    {"modified", os_stat_modified},
    {"changed", os_stat_changed},
    {NULL, NULL}
};

static Janet os_stat_or_lstat(int do_lstat, int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    const char *path = janet_getcstring(argv, 0);
    JanetTable *tab = NULL;
    const uint8_t *key = NULL;
    if (argc == 2) {
        if (janet_checktype(argv[1], JANET_KEYWORD)) {
            key = janet_getkeyword(argv, 1);
        } else {
            tab = janet_gettable(argv, 1);
        }
    } else {
        tab = janet_table(0);
    }

    /* Build result */
    jstat_t st;
#ifdef JANET_WINDOWS
    (void) do_lstat;
    int res = _stat(path, &st);
#else
    int res;
    if (do_lstat) {
        res = lstat(path, &st);
    } else {
        res = stat(path, &st);
    }
#endif
    if (-1 == res) {
        return janet_wrap_nil();
    }

    if (NULL == key) {
        /* Put results in table */
        for (const struct OsStatGetter *sg = os_stat_getters; sg->name != NULL; sg++) {
            janet_table_put(tab, janet_ckeywordv(sg->name), sg->fn(&st));
        }
        return janet_wrap_table(tab);
    } else {
        /* Get one result */
        for (const struct OsStatGetter *sg = os_stat_getters; sg->name != NULL; sg++) {
            if (janet_cstrcmp(key, sg->name)) continue;
            return sg->fn(&st);
        }
        janet_panicf("unexpected keyword %v", janet_wrap_keyword(key));
        return janet_wrap_nil();
    }
}

JANET_CORE_FN(os_stat,
              "(os/stat path &opt tab|key)",
              "Gets information about a file or directory. Returns a table if the second argument is a keyword, returns "
              " only that information from stat. If the file or directory does not exist, returns nil. The keys are:\n\n"
              "* :dev - the device that the file is on\n\n"
              "* :mode - the type of file, one of :file, :directory, :block, :character, :fifo, :socket, :link, or :other\n\n"
              "* :int-permissions - A Unix permission integer like 8r744\n\n"
              "* :permissions - A Unix permission string like \"rwxr--r--\"\n\n"
              "* :uid - File uid\n\n"
              "* :gid - File gid\n\n"
              "* :nlink - number of links to file\n\n"
              "* :rdev - Real device of file. 0 on Windows\n\n"
              "* :size - size of file in bytes\n\n"
              "* :blocks - number of blocks in file. 0 on Windows\n\n"
              "* :blocksize - size of blocks in file. 0 on Windows\n\n"
              "* :accessed - timestamp when file last accessed\n\n"
              "* :changed - timestamp when file last changed (permissions changed)\n\n"
              "* :modified - timestamp when file last modified (content changed)\n") {
    return os_stat_or_lstat(0, argc, argv);
}

JANET_CORE_FN(os_lstat,
              "(os/lstat path &opt tab|key)",
              "Like os/stat, but don't follow symlinks.\n") {
    return os_stat_or_lstat(1, argc, argv);
}

JANET_CORE_FN(os_chmod,
              "(os/chmod path mode)",
              "Change file permissions, where `mode` is a permission string as returned by "
              "`os/perm-string`, or an integer as returned by `os/perm-int`. "
              "When `mode` is an integer, it is interpreted as a Unix permission value, best specified in octal, like "
              "8r666 or 8r400. Windows will not differentiate between user, group, and other permissions, and thus will combine all of these permissions. Returns nil.") {
    janet_fixarity(argc, 2);
    const char *path = janet_getcstring(argv, 0);
#ifdef JANET_WINDOWS
    int res = _chmod(path, os_getmode(argv, 1));
#else
    int res = chmod(path, os_getmode(argv, 1));
#endif
    if (-1 == res) janet_panicf("%s: %s", strerror(errno), path);
    return janet_wrap_nil();
}

#ifndef JANET_NO_UMASK
JANET_CORE_FN(os_umask,
              "(os/umask mask)",
              "Set a new umask, returns the old umask.") {
    janet_fixarity(argc, 1);
    int mask = (int) os_getmode(argv, 0);
#ifdef JANET_WINDOWS
    int res = _umask(mask);
#else
    int res = umask(mask);
#endif
    return janet_wrap_integer(janet_perm_to_unix(res));
}
#endif

JANET_CORE_FN(os_dir,
              "(os/dir dir &opt array)",
              "Iterate over files and subdirectories in a directory. Returns an array of paths parts, "
              "with only the file name or directory name and no prefix.") {
    janet_arity(argc, 1, 2);
    const char *dir = janet_getcstring(argv, 0);
    JanetArray *paths = (argc == 2) ? janet_getarray(argv, 1) : janet_array(0);
#ifdef JANET_WINDOWS
    /* Read directory items with FindFirstFile / FindNextFile / FindClose */
    struct _finddata_t afile;
    char pattern[MAX_PATH + 1];
    if (strlen(dir) > (sizeof(pattern) - 3))
        janet_panicf("path too long: %s", dir);
    sprintf(pattern, "%s/*", dir);
    intptr_t res = _findfirst(pattern, &afile);
    if (-1 == res) janet_panicv(janet_cstringv(strerror(errno)));
    do {
        if (strcmp(".", afile.name) && strcmp("..", afile.name)) {
            janet_array_push(paths, janet_cstringv(afile.name));
        }
    } while (_findnext(res, &afile) != -1);
    _findclose(res);
#else
    /* Read directory items with opendir / readdir / closedir */
    struct dirent *dp;
    DIR *dfd = opendir(dir);
    if (dfd == NULL) janet_panicf("cannot open directory %s", dir);
    while ((dp = readdir(dfd)) != NULL) {
        if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, "..")) {
            continue;
        }
        janet_array_push(paths, janet_cstringv(dp->d_name));
    }
    closedir(dfd);
#endif
    return janet_wrap_array(paths);
}

JANET_CORE_FN(os_rename,
              "(os/rename oldname newname)",
              "Rename a file on disk to a new path. Returns nil.") {
    janet_fixarity(argc, 2);
    const char *src = janet_getcstring(argv, 0);
    const char *dest = janet_getcstring(argv, 1);
    int status = rename(src, dest);
    if (status) {
        janet_panic(strerror(errno));
    }
    return janet_wrap_nil();
}

JANET_CORE_FN(os_realpath,
              "(os/realpath path)",
              "Get the absolute path for a given path, following ../, ./, and symlinks. "
              "Returns an absolute path as a string. Will raise an error on Windows.") {
    janet_fixarity(argc, 1);
    const char *src = janet_getcstring(argv, 0);
#ifdef JANET_NO_REALPATH
    janet_panic("os/realpath not enabled for this platform");
#else
#ifdef JANET_WINDOWS
    char *dest = _fullpath(NULL, src, _MAX_PATH);
#else
    char *dest = realpath(src, NULL);
#endif
    if (NULL == dest) janet_panicf("%s: %s", strerror(errno), src);
    Janet ret = janet_cstringv(dest);
    janet_free(dest);
    return ret;
#endif
}

JANET_CORE_FN(os_permission_string,
              "(os/perm-string int)",
              "Convert a Unix octal permission value from a permission integer as returned by `os/stat` "
              "to a human readable string, that follows the formatting "
              "of Unix tools like `ls`. Returns the string as a 9-character string of r, w, x and - characters. Does not "
              "include the file/directory/symlink character as rendered by `ls`.") {
    janet_fixarity(argc, 1);
    return os_make_permstring(os_get_unix_mode(argv, 0));
}

JANET_CORE_FN(os_permission_int,
              "(os/perm-int bytes)",
              "Parse a 9-character permission string and return an integer that can be used by chmod.") {
    janet_fixarity(argc, 1);
    return janet_wrap_integer(os_get_unix_mode(argv, 0));
}

#ifdef JANET_EV

/*
 * Define a few functions on streams the require JANET_EV to be defined.
 */

static jmode_t os_optmode(int32_t argc, const Janet *argv, int32_t n, int32_t dflt) {
    if (argc > n) return os_getmode(argv, n);
    return janet_perm_from_unix(dflt);
}

JANET_CORE_FN(os_open,
              "(os/open path &opt flags mode)",
              "Create a stream from a file, like the POSIX open system call. Returns a new stream. "
              "`mode` should be a file mode as passed to `os/chmod`, but only if the create flag is given. "
              "The default mode is 8r666. "
              "Allowed flags are as follows:\n\n"
              "  * :r - open this file for reading\n"
              "  * :w - open this file for writing\n"
              "  * :c - create a new file (O\\_CREATE)\n"
              "  * :e - fail if the file exists (O\\_EXCL)\n"
              "  * :t - shorten an existing file to length 0 (O\\_TRUNC)\n\n"
              "Posix-only flags:\n\n"
              "  * :a - append to a file (O\\_APPEND)\n"
              "  * :x - O\\_SYNC\n"
              "  * :C - O\\_NOCTTY\n\n"
              "Windows-only flags:\n\n"
              "  * :R - share reads (FILE\\_SHARE\\_READ)\n"
              "  * :W - share writes (FILE\\_SHARE\\_WRITE)\n"
              "  * :D - share deletes (FILE\\_SHARE\\_DELETE)\n"
              "  * :H - FILE\\_ATTRIBUTE\\_HIDDEN\n"
              "  * :O - FILE\\_ATTRIBUTE\\_READONLY\n"
              "  * :F - FILE\\_ATTRIBUTE\\_OFFLINE\n"
              "  * :T - FILE\\_ATTRIBUTE\\_TEMPORARY\n"
              "  * :d - FILE\\_FLAG\\_DELETE\\_ON\\_CLOSE\n"
              "  * :b - FILE\\_FLAG\\_NO\\_BUFFERING\n") {
    janet_arity(argc, 1, 3);
    const char *path = janet_getcstring(argv, 0);
    const uint8_t *opt_flags = janet_optkeyword(argv, argc, 1, (const uint8_t *) "r");
    jmode_t mode = os_optmode(argc, argv, 2, 0666);
    uint32_t stream_flags = 0;
    JanetHandle fd;
#ifdef JANET_WINDOWS
    DWORD desiredAccess = 0;
    DWORD shareMode = 0;
    DWORD creationDisp = 0;
    DWORD flagsAndAttributes = FILE_FLAG_OVERLAPPED;
    /* We map unix-like open flags to the creationDisp parameter */
    int creatUnix = 0;
#define OCREAT 1
#define OEXCL 2
#define OTRUNC 4
    for (const uint8_t *c = opt_flags; *c; c++) {
        switch (*c) {
            default:
                break;
            case 'r':
                desiredAccess |= GENERIC_READ;
                stream_flags |= JANET_STREAM_READABLE;
                break;
            case 'w':
                desiredAccess |= GENERIC_WRITE;
                stream_flags |= JANET_STREAM_WRITABLE;
                break;
            case 'c':
                creatUnix |= OCREAT;
                break;
            case 'e':
                creatUnix |= OEXCL;
                break;
            case 't':
                creatUnix |= OTRUNC;
                break;
            /* Windows only flags */
            case 'D':
                shareMode |= FILE_SHARE_DELETE;
                break;
            case 'R':
                shareMode |= FILE_SHARE_READ;
                break;
            case 'W':
                shareMode |= FILE_SHARE_WRITE;
                break;
            case 'H':
                flagsAndAttributes |= FILE_ATTRIBUTE_HIDDEN;
                break;
            case 'O':
                flagsAndAttributes |= FILE_ATTRIBUTE_READONLY;
                break;
            case 'F':
                flagsAndAttributes |= FILE_ATTRIBUTE_OFFLINE;
                break;
            case 'T':
                flagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY;
                break;
            case 'd':
                flagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;
                break;
            case 'b':
                flagsAndAttributes |= FILE_FLAG_NO_BUFFERING;
                break;
                /* we could potentially add more here -
                 * https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
                 */
        }
    }
    switch (creatUnix) {
        default:
            janet_panic("invalid creation flags");
        case 0:
            creationDisp = OPEN_EXISTING;
            break;
        case OCREAT:
            creationDisp = OPEN_ALWAYS;
            break;
        case OCREAT + OEXCL:
            creationDisp = CREATE_NEW;
            break;
        case OCREAT + OTRUNC:
            creationDisp = CREATE_ALWAYS;
            break;
        case OTRUNC:
            creationDisp = TRUNCATE_EXISTING;
            break;
    }
    fd = CreateFileA(path, desiredAccess, shareMode, NULL, creationDisp, flagsAndAttributes, NULL);
    if (fd == INVALID_HANDLE_VALUE) janet_panicv(janet_ev_lasterr());
#else
    int open_flags = O_NONBLOCK;
#ifdef JANET_LINUX
    open_flags |= O_CLOEXEC;
#endif
    int read_flag = 0;
    int write_flag = 0;
    for (const uint8_t *c = opt_flags; *c; c++) {
        switch (*c) {
            default:
                break;
            case 'r':
                read_flag = 1;
                stream_flags |= JANET_STREAM_READABLE;
                break;
            case 'w':
                write_flag = 1;
                stream_flags |= JANET_STREAM_WRITABLE;
                break;
            case 'c':
                open_flags |= O_CREAT;
                break;
            case 'e':
                open_flags |= O_EXCL;
                break;
            case 't':
                open_flags |= O_TRUNC;
                break;
            /* posix only */
            case 'x':
                open_flags |= O_SYNC;
                break;
            case 'C':
                open_flags |= O_NOCTTY;
                break;
            case 'a':
                open_flags |= O_APPEND;
                break;
        }
    }
    /* If both read and write, fix up to O_RDWR */
    if (read_flag && !write_flag) {
        open_flags |= O_RDONLY;
    } else if (write_flag && !read_flag) {
        open_flags |= O_WRONLY;
    } else {
        open_flags = O_RDWR;
    }

    do {
        fd = open(path, open_flags, mode);
    } while (fd == -1 && errno == EINTR);
    if (fd == -1) janet_panicv(janet_ev_lasterr());
#endif
    return janet_wrap_abstract(janet_stream(fd, stream_flags, NULL));
}

JANET_CORE_FN(os_pipe,
              "(os/pipe)",
              "Create a readable stream and a writable stream that are connected. Returns a two-element "
              "tuple where the first element is a readable stream and the second element is the writable "
              "stream.") {
    (void) argv;
    janet_fixarity(argc, 0);
    JanetHandle fds[2];
    if (janet_make_pipe(fds, 0)) janet_panicv(janet_ev_lasterr());
    JanetStream *reader = janet_stream(fds[0], JANET_STREAM_READABLE, NULL);
    JanetStream *writer = janet_stream(fds[1], JANET_STREAM_WRITABLE, NULL);
    Janet tup[2] = {janet_wrap_abstract(reader), janet_wrap_abstract(writer)};
    return janet_wrap_tuple(janet_tuple_n(tup, 2));
}

#endif

#endif /* JANET_REDUCED_OS */

/* Module entry point */
void janet_lib_os(JanetTable *env) {
#if !defined(JANET_REDUCED_OS) && defined(JANET_WINDOWS) && defined(JANET_THREADS)
    /* During start up, the top-most abstract machine (thread)
     * in the thread tree sets up the critical section. */
    static volatile long env_lock_initializing = 0;
    static volatile long env_lock_initialized = 0;
    if (!InterlockedExchange(&env_lock_initializing, 1)) {
        InitializeCriticalSection(&env_lock);
        InterlockedOr(&env_lock_initialized, 1);
    } else {
        while (!InterlockedOr(&env_lock_initialized, 0)) {
            Sleep(0);
        }
    }

#endif
#ifndef JANET_NO_PROCESSES
#endif
    JanetRegExt os_cfuns[] = {
        JANET_CORE_REG("os/exit", os_exit),
        JANET_CORE_REG("os/which", os_which),
        JANET_CORE_REG("os/arch", os_arch),
#ifndef JANET_REDUCED_OS
        JANET_CORE_REG("os/environ", os_environ),
        JANET_CORE_REG("os/getenv", os_getenv),
        JANET_CORE_REG("os/dir", os_dir),
        JANET_CORE_REG("os/stat", os_stat),
        JANET_CORE_REG("os/lstat", os_lstat),
        JANET_CORE_REG("os/chmod", os_chmod),
        JANET_CORE_REG("os/touch", os_touch),
        JANET_CORE_REG("os/cd", os_cd),
        JANET_CORE_REG("os/cpu-count", os_cpu_count),
#ifndef JANET_NO_UMASK
        JANET_CORE_REG("os/umask", os_umask),
#endif
        JANET_CORE_REG("os/mkdir", os_mkdir),
        JANET_CORE_REG("os/rmdir", os_rmdir),
        JANET_CORE_REG("os/rm", os_remove),
        JANET_CORE_REG("os/link", os_link),
#ifndef JANET_NO_SYMLINKS
        JANET_CORE_REG("os/symlink", os_symlink),
        JANET_CORE_REG("os/readlink", os_readlink),
#endif
#ifndef JANET_NO_PROCESSES
        JANET_CORE_REG("os/execute", os_execute),
        JANET_CORE_REG("os/spawn", os_spawn),
        JANET_CORE_REG("os/shell", os_shell),
        JANET_CORE_REG("os/proc-wait", os_proc_wait),
        JANET_CORE_REG("os/proc-kill", os_proc_kill),
        JANET_CORE_REG("os/proc-close", os_proc_close),
#endif
        JANET_CORE_REG("os/setenv", os_setenv),
        JANET_CORE_REG("os/time", os_time),
        JANET_CORE_REG("os/mktime", os_mktime),
        JANET_CORE_REG("os/clock", os_clock),
        JANET_CORE_REG("os/sleep", os_sleep),
        JANET_CORE_REG("os/cwd", os_cwd),
        JANET_CORE_REG("os/cryptorand", os_cryptorand),
        JANET_CORE_REG("os/date", os_date),
        JANET_CORE_REG("os/rename", os_rename),
        JANET_CORE_REG("os/realpath", os_realpath),
        JANET_CORE_REG("os/perm-string", os_permission_string),
        JANET_CORE_REG("os/perm-int", os_permission_int),
#ifdef JANET_EV
        JANET_CORE_REG("os/open", os_open),
        JANET_CORE_REG("os/pipe", os_pipe),
#endif
#endif
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, os_cfuns);
}


/* src/core/parse.c */
#line 0 "src/core/parse.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#define JANET_PARSER_DEAD 0x1
#define JANET_PARSER_GENERATED_ERROR 0x2

/* Check if a character is whitespace */
static int is_whitespace(uint8_t c) {
    return c == ' '
           || c == '\t'
           || c == '\n'
           || c == '\r'
           || c == '\0'
           || c == '\v'
           || c == '\f';
}

/* Code generated by tools/symcharsgen.c.
 * The table contains 256 bits, where each bit is 1
 * if the corresponding ascii code is a symbol char, and 0
 * if not. The upper characters are also considered symbol
 * chars and are then checked for utf-8 compliance. */
static const uint32_t symchars[8] = {
    0x00000000, 0xf7ffec72, 0xc7ffffff, 0x07fffffe,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
};

/* Check if a character is a valid symbol character
 * symbol chars are A-Z, a-z, 0-9, or one of !$&*+-./:<=>@\^_| */
int janet_is_symbol_char(uint8_t c) {
    return symchars[c >> 5] & ((uint32_t)1 << (c & 0x1F));
}

/* Validate some utf8. Useful for identifiers. Only validates
 * the encoding, does not check for valid code points (they
 * are less well defined than the encoding). */
int janet_valid_utf8(const uint8_t *str, int32_t len) {
    int32_t i = 0;
    int32_t j;
    while (i < len) {
        int32_t nexti;
        uint8_t c = str[i];

        /* Check the number of bytes in code point */
        if (c < 0x80) nexti = i + 1;
        else if ((c >> 5) == 0x06) nexti = i + 2;
        else if ((c >> 4) == 0x0E) nexti = i + 3;
        else if ((c >> 3) == 0x1E) nexti = i + 4;
        /* Don't allow 5 or 6 byte code points */
        else return 0;

        /* No overflow */
        if (nexti > len) return 0;

        /* Ensure trailing bytes are well formed (10XX XXXX) */
        for (j = i + 1; j < nexti; j++) {
            if ((str[j] >> 6) != 2) return 0;
        }

        /* Check for overlong encoding */
        if ((nexti == i + 2) && str[i] < 0xC2) return 0;
        if ((str[i] == 0xE0) && str[i + 1] < 0xA0) return 0;
        if ((str[i] == 0xF0) && str[i + 1] < 0x90) return 0;

        i = nexti;
    }
    return 1;
}

/* Get hex digit from a letter */
static int to_hex(uint8_t c) {
    if (c >= '0' && c <= '9') {
        return c - '0';
    } else if (c >= 'A' && c <= 'F') {
        return 10 + c - 'A';
    } else if (c >= 'a' && c <= 'f') {
        return 10 + c - 'a';
    } else {
        return -1;
    }
}

typedef int (*Consumer)(JanetParser *p, JanetParseState *state, uint8_t c);
struct JanetParseState {
    int32_t counter;
    int32_t argn;
    int flags;
    size_t line;
    size_t column;
    Consumer consumer;
};

/* Define a stack on the main parser struct */
#define DEF_PARSER_STACK(NAME, T, STACK, STACKCOUNT, STACKCAP) \
static void NAME(JanetParser *p, T x) { \
    size_t oldcount = p->STACKCOUNT; \
    size_t newcount = oldcount + 1; \
    if (newcount > p->STACKCAP) { \
        T *next; \
        size_t newcap = 2 * newcount; \
        next = janet_realloc(p->STACK, sizeof(T) * newcap); \
        if (NULL == next) { \
            JANET_OUT_OF_MEMORY; \
        } \
        p->STACK = next; \
        p->STACKCAP = newcap; \
    } \
    p->STACK[oldcount] = x; \
    p->STACKCOUNT = newcount; \
}

DEF_PARSER_STACK(push_buf, uint8_t, buf, bufcount, bufcap)
DEF_PARSER_STACK(push_arg, Janet, args, argcount, argcap)
DEF_PARSER_STACK(_pushstate, JanetParseState, states, statecount, statecap)

#undef DEF_PARSER_STACK

#define PFLAG_CONTAINER 0x100
#define PFLAG_BUFFER 0x200
#define PFLAG_PARENS 0x400
#define PFLAG_SQRBRACKETS 0x800
#define PFLAG_CURLYBRACKETS 0x1000
#define PFLAG_STRING 0x2000
#define PFLAG_LONGSTRING 0x4000
#define PFLAG_READERMAC 0x8000
#define PFLAG_ATSYM 0x10000
#define PFLAG_COMMENT 0x20000
#define PFLAG_TOKEN 0x40000

static void pushstate(JanetParser *p, Consumer consumer, int flags) {
    JanetParseState s;
    s.counter = 0;
    s.argn = 0;
    s.flags = flags;
    s.consumer = consumer;
    s.line = p->line;
    s.column = p->column;
    _pushstate(p, s);
}

static void popstate(JanetParser *p, Janet val) {
    for (;;) {
        JanetParseState top = p->states[--p->statecount];
        JanetParseState *newtop = p->states + p->statecount - 1;
        /* Source mapping info */
        if (janet_checktype(val, JANET_TUPLE)) {
            janet_tuple_sm_line(janet_unwrap_tuple(val)) = (int32_t) top.line;
            janet_tuple_sm_column(janet_unwrap_tuple(val)) = (int32_t) top.column;
        }
        if (newtop->flags & PFLAG_CONTAINER) {
            newtop->argn++;
            /* Keep track of number of values in the root state */
            if (p->statecount == 1) {
                p->pending++;
                /* Root items are always wrapped in a tuple for source map info. */
                const Janet *tup = janet_tuple_n(&val, 1);
                janet_tuple_sm_line(tup) = (int32_t) top.line;
                janet_tuple_sm_column(tup) = (int32_t) top.column;
                val = janet_wrap_tuple(tup);
            }
            push_arg(p, val);
            return;
        } else if (newtop->flags & PFLAG_READERMAC) {
            Janet *t = janet_tuple_begin(2);
            int c = newtop->flags & 0xFF;
            const char *which =
                (c == '\'') ? "quote" :
                (c == ',') ? "unquote" :
                (c == ';') ? "splice" :
                (c == '|') ? "short-fn" :
                (c == '~') ? "quasiquote" : "<unknown>";
            t[0] = janet_csymbolv(which);
            t[1] = val;
            /* Quote source mapping info */
            janet_tuple_sm_line(t) = (int32_t) newtop->line;
            janet_tuple_sm_column(t) = (int32_t) newtop->column;
            val = janet_wrap_tuple(janet_tuple_end(t));
        } else {
            return;
        }
    }
}

static void delim_error(JanetParser *parser, size_t stack_index, char c, const char *msg) {
    JanetParseState *s = parser->states + stack_index;
    JanetBuffer *buffer = janet_buffer(40);
    if (msg) {
        janet_buffer_push_cstring(buffer, msg);
    }
    if (c) {
        janet_buffer_push_u8(buffer, c);
    }
    if (stack_index > 0) {
        janet_buffer_push_cstring(buffer, ", ");
        if (s->flags & PFLAG_PARENS) {
            janet_buffer_push_u8(buffer, '(');
        } else if (s->flags & PFLAG_SQRBRACKETS) {
            janet_buffer_push_u8(buffer, '[');
        } else if (s->flags & PFLAG_CURLYBRACKETS) {
            janet_buffer_push_u8(buffer, '{');
        } else if (s->flags & PFLAG_STRING) {
            janet_buffer_push_u8(buffer, '"');
        } else if (s->flags & PFLAG_LONGSTRING) {
            int32_t i;
            for (i = 0; i < s->argn; i++) {
                janet_buffer_push_u8(buffer, '`');
            }
        }
        janet_formatb(buffer, " opened at line %d, column %d", s->line, s->column);
    }
    parser->error = (const char *) janet_string(buffer->data, buffer->count);
    parser->flag |= JANET_PARSER_GENERATED_ERROR;
}

static int checkescape(uint8_t c) {
    switch (c) {
        default:
            return -1;
        case 'x':
        case 'u':
        case 'U':
            return 1;
        case 'n':
            return '\n';
        case 't':
            return '\t';
        case 'r':
            return '\r';
        case '0':
            return '\0';
        case 'z':
            return '\0';
        case 'f':
            return '\f';
        case 'v':
            return '\v';
        case 'e':
            return 27;
        case '"':
            return '"';
        case '\\':
            return '\\';
    }
}

/* Forward declare */
static int stringchar(JanetParser *p, JanetParseState *state, uint8_t c);

static void write_codepoint(JanetParser *p, int32_t codepoint) {
    if (codepoint <= 0x7F) {
        push_buf(p, (uint8_t) codepoint);
    } else if (codepoint <= 0x7FF) {
        push_buf(p, (uint8_t)((codepoint >>  6) & 0x1F) | 0xC0);
        push_buf(p, (uint8_t)((codepoint >>  0) & 0x3F) | 0x80);
    } else if (codepoint <= 0xFFFF) {
        push_buf(p, (uint8_t)((codepoint >> 12) & 0x0F) | 0xE0);
        push_buf(p, (uint8_t)((codepoint >>  6) & 0x3F) | 0x80);
        push_buf(p, (uint8_t)((codepoint >>  0) & 0x3F) | 0x80);
    } else {
        push_buf(p, (uint8_t)((codepoint >> 18) & 0x07) | 0xF0);
        push_buf(p, (uint8_t)((codepoint >> 12) & 0x3F) | 0x80);
        push_buf(p, (uint8_t)((codepoint >>  6) & 0x3F) | 0x80);
        push_buf(p, (uint8_t)((codepoint >>  0) & 0x3F) | 0x80);
    }
}

static int escapeh(JanetParser *p, JanetParseState *state, uint8_t c) {
    int digit = to_hex(c);
    if (digit < 0) {
        p->error = "invalid hex digit in hex escape";
        return 1;
    }
    state->argn = (state->argn << 4) + digit;
    state->counter--;
    if (!state->counter) {
        push_buf(p, (uint8_t)(state->argn & 0xFF));
        state->argn = 0;
        state->consumer = stringchar;
    }
    return 1;
}

static int escapeu(JanetParser *p, JanetParseState *state, uint8_t c) {
    int digit = to_hex(c);
    if (digit < 0) {
        p->error = "invalid hex digit in unicode escape";
        return 1;
    }
    state->argn = (state->argn << 4) + digit;
    state->counter--;
    if (!state->counter) {
        if (state->argn > 0x10FFFF) {
            p->error = "invalid unicode codepoint";
            return 1;
        }
        write_codepoint(p, state->argn);
        state->argn = 0;
        state->consumer = stringchar;
    }
    return 1;
}

static int escape1(JanetParser *p, JanetParseState *state, uint8_t c) {
    int e = checkescape(c);
    if (e < 0) {
        p->error = "invalid string escape sequence";
        return 1;
    }
    if (c == 'x') {
        state->counter = 2;
        state->argn = 0;
        state->consumer = escapeh;
    } else if (c == 'u' || c == 'U') {
        state->counter = c == 'u' ? 4 : 6;
        state->argn = 0;
        state->consumer = escapeu;
    } else {
        push_buf(p, (uint8_t) e);
        state->consumer = stringchar;
    }
    return 1;
}

static int stringend(JanetParser *p, JanetParseState *state) {
    Janet ret;
    uint8_t *bufstart = p->buf;
    int32_t buflen = (int32_t) p->bufcount;
    if (state->flags & PFLAG_LONGSTRING) {
        /* Post process to remove leading whitespace */
        JanetParseState top = p->states[p->statecount - 1];
        int32_t indent_col = (int32_t) top.column - 1;
        uint8_t *r = bufstart, *end = r + buflen;
        /* Check if there are any characters before the start column -
         * if so, do not reindent. */
        int reindent = 1;
        while (reindent && (r < end)) {
            if (*r++ == '\n') {
                for (int32_t j = 0; (r < end) && (*r != '\n') && (j < indent_col); j++, r++) {
                    if (*r != ' ') {
                        reindent = 0;
                        break;
                    }
                }
            }
        }
        /* Now reindent if able to, otherwise just drop leading newline. */
        if (!reindent) {
            if (buflen > 0 && bufstart[0] == '\n') {
                buflen--;
                bufstart++;
            }
        } else {
            uint8_t *w = bufstart;
            r = bufstart;
            while (r < end) {
                if (*r == '\n') {
                    if (r == bufstart) {
                        /* Skip leading newline */
                        r++;
                    } else {
                        *w++ = *r++;
                    }
                    for (int32_t j = 0; (r < end) && (*r != '\n') && (j < indent_col); j++, r++);
                } else {
                    *w++ = *r++;
                }
            }
            buflen = (int32_t)(w - bufstart);
        }
        /* Check for trailing newline character so we can remove it */
        if (buflen > 0 && bufstart[buflen - 1] == '\n') {
            buflen--;
        }
    }
    if (state->flags & PFLAG_BUFFER) {
        JanetBuffer *b = janet_buffer(buflen);
        janet_buffer_push_bytes(b, bufstart, buflen);
        ret = janet_wrap_buffer(b);
    } else {
        ret = janet_wrap_string(janet_string(bufstart, buflen));
    }
    p->bufcount = 0;
    popstate(p, ret);
    return 1;
}

static int stringchar(JanetParser *p, JanetParseState *state, uint8_t c) {
    /* Enter escape */
    if (c == '\\') {
        state->consumer = escape1;
        return 1;
    }
    /* String end */
    if (c == '"') {
        return stringend(p, state);
    }
    /* normal char */
    if (c != '\n' && c != '\r')
        push_buf(p, c);
    return 1;
}

/* Check for string equality in the buffer */
static int check_str_const(const char *cstr, const uint8_t *str, int32_t len) {
    int32_t index;
    for (index = 0; index < len; index++) {
        uint8_t c = str[index];
        uint8_t k = ((const uint8_t *)cstr)[index];
        if (c < k) return -1;
        if (c > k) return 1;
        if (k == '\0') break;
    }
    return (cstr[index] == '\0') ? 0 : -1;
}

static int tokenchar(JanetParser *p, JanetParseState *state, uint8_t c) {
    Janet ret;
    double numval;
    int32_t blen;
    if (janet_is_symbol_char(c)) {
        push_buf(p, (uint8_t) c);
        if (c > 127) state->argn = 1; /* Use to indicate non ascii */
        return 1;
    }
    /* Token finished */
    blen = (int32_t) p->bufcount;
    int start_dig = p->buf[0] >= '0' && p->buf[0] <= '9';
    int start_num = start_dig || p->buf[0] == '-' || p->buf[0] == '+' || p->buf[0] == '.';
    if (p->buf[0] == ':') {
        /* Don't do full utf-8 check unless we have seen non ascii characters. */
        int valid = (!state->argn) || janet_valid_utf8(p->buf + 1, blen - 1);
        if (!valid) {
            p->error = "invalid utf-8 in keyword";
            return 0;
        }
        ret = janet_keywordv(p->buf + 1, blen - 1);
    } else if (start_num && !janet_scan_number(p->buf, blen, &numval)) {
        ret = janet_wrap_number(numval);
    } else if (!check_str_const("nil", p->buf, blen)) {
        ret = janet_wrap_nil();
    } else if (!check_str_const("false", p->buf, blen)) {
        ret = janet_wrap_false();
    } else if (!check_str_const("true", p->buf, blen)) {
        ret = janet_wrap_true();
    } else {
        if (start_dig) {
            p->error = "symbol literal cannot start with a digit";
            return 0;
        } else {
            /* Don't do full utf-8 check unless we have seen non ascii characters. */
            int valid = (!state->argn) || janet_valid_utf8(p->buf, blen);
            if (!valid) {
                p->error = "invalid utf-8 in symbol";
                return 0;
            }
            ret = janet_symbolv(p->buf, blen);
        }
    }
    p->bufcount = 0;
    popstate(p, ret);
    return 0;
}

static int comment(JanetParser *p, JanetParseState *state, uint8_t c) {
    (void) state;
    if (c == '\n') {
        p->statecount--;
        p->bufcount = 0;
    } else {
        push_buf(p, c);
    }
    return 1;
}

static Janet close_tuple(JanetParser *p, JanetParseState *state, int32_t flag) {
    Janet *ret = janet_tuple_begin(state->argn);
    janet_tuple_flag(ret) |= flag;
    for (int32_t i = state->argn - 1; i >= 0; i--)
        ret[i] = p->args[--p->argcount];
    return janet_wrap_tuple(janet_tuple_end(ret));
}

static Janet close_array(JanetParser *p, JanetParseState *state) {
    JanetArray *array = janet_array(state->argn);
    for (int32_t i = state->argn - 1; i >= 0; i--)
        array->data[i] = p->args[--p->argcount];
    array->count = state->argn;
    return janet_wrap_array(array);
}

static Janet close_struct(JanetParser *p, JanetParseState *state) {
    JanetKV *st = janet_struct_begin(state->argn >> 1);
    for (size_t i = p->argcount - state->argn; i < p->argcount; i += 2) {
        Janet key = p->args[i];
        Janet value = p->args[i + 1];
        janet_struct_put(st, key, value);
    }
    p->argcount -= state->argn;
    return janet_wrap_struct(janet_struct_end(st));
}

static Janet close_table(JanetParser *p, JanetParseState *state) {
    JanetTable *table = janet_table(state->argn >> 1);
    for (size_t i = p->argcount - state->argn; i < p->argcount; i += 2) {
        Janet key = p->args[i];
        Janet value = p->args[i + 1];
        janet_table_put(table, key, value);
    }
    p->argcount -= state->argn;
    return janet_wrap_table(table);
}

#define PFLAG_INSTRING 0x100000
#define PFLAG_END_CANDIDATE 0x200000
static int longstring(JanetParser *p, JanetParseState *state, uint8_t c) {
    if (state->flags & PFLAG_INSTRING) {
        /* We are inside the long string */
        if (c == '`') {
            state->flags |= PFLAG_END_CANDIDATE;
            state->flags &= ~PFLAG_INSTRING;
            state->counter = 1; /* Use counter to keep track of number of '=' seen */
            return 1;
        }
        push_buf(p, c);
        return 1;
    } else if (state->flags & PFLAG_END_CANDIDATE) {
        int i;
        /* We are checking a potential end of the string */
        if (state->counter == state->argn) {
            stringend(p, state);
            return 0;
        }
        if (c == '`' && state->counter < state->argn) {
            state->counter++;
            return 1;
        }
        /* Failed end candidate */
        for (i = 0; i < state->counter; i++) {
            push_buf(p, '`');
        }
        push_buf(p, c);
        state->counter = 0;
        state->flags &= ~PFLAG_END_CANDIDATE;
        state->flags |= PFLAG_INSTRING;
        return 1;
    } else {
        /* We are at beginning of string */
        state->argn++;
        if (c != '`') {
            state->flags |= PFLAG_INSTRING;
            push_buf(p, c);
        }
        return 1;
    }
}

static int root(JanetParser *p, JanetParseState *state, uint8_t c);

static int atsign(JanetParser *p, JanetParseState *state, uint8_t c) {
    (void) state;
    p->statecount--;
    switch (c) {
        case '{':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_CURLYBRACKETS | PFLAG_ATSYM);
            return 1;
        case '"':
            pushstate(p, stringchar, PFLAG_BUFFER | PFLAG_STRING);
            return 1;
        case '`':
            pushstate(p, longstring, PFLAG_BUFFER | PFLAG_LONGSTRING);
            return 1;
        case '[':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_SQRBRACKETS | PFLAG_ATSYM);
            return 1;
        case '(':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_PARENS | PFLAG_ATSYM);
            return 1;
        default:
            break;
    }
    pushstate(p, tokenchar, PFLAG_TOKEN);
    push_buf(p, '@'); /* Push the leading at-sign that was dropped */
    return 0;
}

/* The root state of the parser */
static int root(JanetParser *p, JanetParseState *state, uint8_t c) {
    switch (c) {
        default:
            if (is_whitespace(c)) return 1;
            if (!janet_is_symbol_char(c)) {
                p->error = "unexpected character";
                return 1;
            }
            pushstate(p, tokenchar, PFLAG_TOKEN);
            return 0;
        case '\'':
        case ',':
        case ';':
        case '~':
        case '|':
            pushstate(p, root, PFLAG_READERMAC | c);
            return 1;
        case '"':
            pushstate(p, stringchar, PFLAG_STRING);
            return 1;
        case '#':
            pushstate(p, comment, PFLAG_COMMENT);
            return 1;
        case '@':
            pushstate(p, atsign, PFLAG_ATSYM);
            return 1;
        case '`':
            pushstate(p, longstring, PFLAG_LONGSTRING);
            return 1;
        case ')':
        case ']':
        case '}': {
            Janet ds;
            if (p->statecount == 1) {
                delim_error(p, 0, c, "unexpected closing delimiter ");
                return 1;
            }
            if ((c == ')' && (state->flags & PFLAG_PARENS)) ||
                    (c == ']' && (state->flags & PFLAG_SQRBRACKETS))) {
                if (state->flags & PFLAG_ATSYM) {
                    ds = close_array(p, state);
                } else {
                    ds = close_tuple(p, state, c == ']' ? JANET_TUPLE_FLAG_BRACKETCTOR : 0);
                }
            } else if (c == '}' && (state->flags & PFLAG_CURLYBRACKETS)) {
                if (state->argn & 1) {
                    p->error = "struct and table literals expect even number of arguments";
                    return 1;
                }
                if (state->flags & PFLAG_ATSYM) {
                    ds = close_table(p, state);
                } else {
                    ds = close_struct(p, state);
                }
            } else {
                delim_error(p, p->statecount - 1, c, "mismatched delimiter ");
                return 1;
            }
            popstate(p, ds);
        }
        return 1;
        case '(':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_PARENS);
            return 1;
        case '[':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_SQRBRACKETS);
            return 1;
        case '{':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_CURLYBRACKETS);
            return 1;
    }
}

static void janet_parser_checkdead(JanetParser *parser) {
    if (parser->flag) janet_panic("parser is dead, cannot consume");
    if (parser->error) janet_panic("parser has unchecked error, cannot consume");
}

/* Public API */

void janet_parser_consume(JanetParser *parser, uint8_t c) {
    int consumed = 0;
    janet_parser_checkdead(parser);
    if (c == '\r') {
        parser->line++;
        parser->column = 0;
    } else if (c == '\n') {
        parser->column = 0;
        if (parser->lookback != '\r')
            parser->line++;
    } else {
        parser->column++;
    }
    while (!consumed && !parser->error) {
        JanetParseState *state = parser->states + parser->statecount - 1;
        consumed = state->consumer(parser, state, c);
    }
    parser->lookback = c;
}

void janet_parser_eof(JanetParser *parser) {
    janet_parser_checkdead(parser);
    size_t oldcolumn = parser->column;
    size_t oldline = parser->line;
    janet_parser_consume(parser, '\n');
    if (parser->statecount > 1) {
        delim_error(parser, parser->statecount - 1, 0, "unexpected end of source");
    }
    parser->line = oldline;
    parser->column = oldcolumn;
    parser->flag |= JANET_PARSER_DEAD;
}

enum JanetParserStatus janet_parser_status(JanetParser *parser) {
    if (parser->error) return JANET_PARSE_ERROR;
    if (parser->flag) return JANET_PARSE_DEAD;
    if (parser->statecount > 1) return JANET_PARSE_PENDING;
    return JANET_PARSE_ROOT;
}

void janet_parser_flush(JanetParser *parser) {
    parser->argcount = 0;
    parser->statecount = 1;
    parser->bufcount = 0;
    parser->pending = 0;
}

const char *janet_parser_error(JanetParser *parser) {
    enum JanetParserStatus status = janet_parser_status(parser);
    if (status == JANET_PARSE_ERROR) {
        const char *e = parser->error;
        parser->error = NULL;
        parser->flag &= ~JANET_PARSER_GENERATED_ERROR;
        janet_parser_flush(parser);
        return e;
    }
    return NULL;
}

Janet janet_parser_produce(JanetParser *parser) {
    Janet ret;
    size_t i;
    if (parser->pending == 0) return janet_wrap_nil();
    ret = janet_unwrap_tuple(parser->args[0])[0];
    for (i = 1; i < parser->argcount; i++) {
        parser->args[i - 1] = parser->args[i];
    }
    parser->pending--;
    parser->argcount--;
    parser->states[0].argn--;
    return ret;
}

Janet janet_parser_produce_wrapped(JanetParser *parser) {
    Janet ret;
    size_t i;
    if (parser->pending == 0) return janet_wrap_nil();
    ret = parser->args[0];
    for (i = 1; i < parser->argcount; i++) {
        parser->args[i - 1] = parser->args[i];
    }
    parser->pending--;
    parser->argcount--;
    parser->states[0].argn--;
    return ret;
}

void janet_parser_init(JanetParser *parser) {
    parser->args = NULL;
    parser->states = NULL;
    parser->buf = NULL;
    parser->argcount = 0;
    parser->argcap = 0;
    parser->bufcount = 0;
    parser->bufcap = 0;
    parser->statecount = 0;
    parser->statecap = 0;
    parser->error = NULL;
    parser->lookback = -1;
    parser->line = 1;
    parser->column = 0;
    parser->pending = 0;
    parser->flag = 0;

    pushstate(parser, root, PFLAG_CONTAINER);
}

void janet_parser_deinit(JanetParser *parser) {
    janet_free(parser->args);
    janet_free(parser->buf);
    janet_free(parser->states);
}

void janet_parser_clone(const JanetParser *src, JanetParser *dest) {
    /* Misc fields */
    dest->flag = src->flag;
    dest->pending = src->pending;
    dest->lookback = src->lookback;
    dest->line = src->line;
    dest->column = src->column;
    dest->error = src->error;

    /* Keep counts */
    dest->argcount = src->argcount;
    dest->bufcount = src->bufcount;
    dest->statecount = src->statecount;

    /* Capacities are equal to counts */
    dest->bufcap = dest->bufcount;
    dest->statecap = dest->statecount;
    dest->argcap = dest->argcount;

    /* Deep cloned fields */
    dest->args = NULL;
    dest->states = NULL;
    dest->buf = NULL;
    if (dest->bufcap) {
        dest->buf = janet_malloc(dest->bufcap);
        if (!dest->buf) goto nomem;
        memcpy(dest->buf, src->buf, dest->bufcap);
    }
    if (dest->argcap) {
        dest->args = janet_malloc(sizeof(Janet) * dest->argcap);
        if (!dest->args) goto nomem;
        memcpy(dest->args, src->args, dest->argcap * sizeof(Janet));
    }
    if (dest->statecap) {
        dest->states = janet_malloc(sizeof(JanetParseState) * dest->statecap);
        if (!dest->states) goto nomem;
        memcpy(dest->states, src->states, dest->statecap * sizeof(JanetParseState));
    }

    return;

nomem:
    JANET_OUT_OF_MEMORY;
}

int janet_parser_has_more(JanetParser *parser) {
    return !!parser->pending;
}

/* C functions */

static int parsermark(void *p, size_t size) {
    size_t i;
    JanetParser *parser = (JanetParser *)p;
    (void) size;
    for (i = 0; i < parser->argcount; i++) {
        janet_mark(parser->args[i]);
    }
    if (parser->flag & JANET_PARSER_GENERATED_ERROR) {
        janet_mark(janet_wrap_string((const uint8_t *) parser->error));
    }
    return 0;
}

static int parsergc(void *p, size_t size) {
    JanetParser *parser = (JanetParser *)p;
    (void) size;
    janet_parser_deinit(parser);
    return 0;
}

static int parserget(void *p, Janet key, Janet *out);
static Janet parsernext(void *p, Janet key);

const JanetAbstractType janet_parser_type = {
    "core/parser",
    parsergc,
    parsermark,
    parserget,
    NULL, /* put */
    NULL, /* marshal */
    NULL, /* unmarshal */
    NULL, /* tostring */
    NULL, /* compare */
    NULL, /* hash */
    parsernext,
    JANET_ATEND_NEXT
};

/* C Function parser */
JANET_CORE_FN(cfun_parse_parser,
              "(parser/new)",
              "Creates and returns a new parser object. Parsers are state machines "
              "that can receive bytes and generate a stream of values.") {
    (void) argv;
    janet_fixarity(argc, 0);
    JanetParser *p = janet_abstract(&janet_parser_type, sizeof(JanetParser));
    janet_parser_init(p);
    return janet_wrap_abstract(p);
}

JANET_CORE_FN(cfun_parse_consume,
              "(parser/consume parser bytes &opt index)",
              "Input bytes into the parser and parse them. Will not throw errors "
              "if there is a parse error. Starts at the byte index given by `index`. Returns "
              "the number of bytes read.") {
    janet_arity(argc, 2, 3);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    JanetByteView view = janet_getbytes(argv, 1);
    if (argc == 3) {
        int32_t offset = janet_getinteger(argv, 2);
        if (offset < 0 || offset > view.len)
            janet_panicf("invalid offset %d out of range [0,%d]", offset, view.len);
        view.len -= offset;
        view.bytes += offset;
    }
    int32_t i;
    for (i = 0; i < view.len; i++) {
        janet_parser_consume(p, view.bytes[i]);
        switch (janet_parser_status(p)) {
            case JANET_PARSE_ROOT:
            case JANET_PARSE_PENDING:
                break;
            default:
                return janet_wrap_integer(i + 1);
        }
    }
    return janet_wrap_integer(i);
}

JANET_CORE_FN(cfun_parse_eof,
              "(parser/eof parser)",
              "Indicate to the parser that the end of file was reached. This puts the parser in the :dead state.") {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    janet_parser_eof(p);
    return argv[0];
}

JANET_CORE_FN(cfun_parse_insert,
              "(parser/insert parser value)",
              "Insert a value into the parser. This means that the parser state can be manipulated "
              "in between chunks of bytes. This would allow a user to add extra elements to arrays "
              "and tuples, for example. Returns the parser.") {
    janet_fixarity(argc, 2);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    JanetParseState *s = p->states + p->statecount - 1;
    if (s->consumer == tokenchar) {
        janet_parser_consume(p, ' ');
        p->column--;
        s = p->states + p->statecount - 1;
    }
    if (s->flags & PFLAG_COMMENT) s--;
    if (s->flags & PFLAG_CONTAINER) {
        s->argn++;
        if (p->statecount == 1) {
            p->pending++;
            Janet tup = janet_wrap_tuple(janet_tuple_n(argv + 1, 1));
            push_arg(p, tup);
        } else {
            push_arg(p, argv[1]);
        }
    } else if (s->flags & (PFLAG_STRING | PFLAG_LONGSTRING)) {
        const uint8_t *str = janet_to_string(argv[1]);
        int32_t slen = janet_string_length(str);
        size_t newcount = p->bufcount + slen;
        if (p->bufcap < newcount) {
            size_t newcap = 2 * newcount;
            p->buf = janet_realloc(p->buf, newcap);
            if (p->buf == NULL) {
                JANET_OUT_OF_MEMORY;
            }
            p->bufcap = newcap;
        }
        safe_memcpy(p->buf + p->bufcount, str, slen);
        p->bufcount = newcount;
    } else {
        janet_panic("cannot insert value into parser");
    }
    return argv[0];
}

JANET_CORE_FN(cfun_parse_has_more,
              "(parser/has-more parser)",
              "Check if the parser has more values in the value queue.") {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    return janet_wrap_boolean(janet_parser_has_more(p));
}

JANET_CORE_FN(cfun_parse_byte,
              "(parser/byte parser b)",
              "Input a single byte `b` into the parser byte stream. Returns the parser.") {
    janet_fixarity(argc, 2);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    int32_t i = janet_getinteger(argv, 1);
    janet_parser_consume(p, 0xFF & i);
    return argv[0];
}

JANET_CORE_FN(cfun_parse_status,
              "(parser/status parser)",
              "Gets the current status of the parser state machine. The status will "
              "be one of:\n\n"
              "* :pending - a value is being parsed.\n\n"
              "* :error - a parsing error was encountered.\n\n"
              "* :root - the parser can either read more values or safely terminate.") {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    const char *stat = NULL;
    switch (janet_parser_status(p)) {
        case JANET_PARSE_PENDING:
            stat = "pending";
            break;
        case JANET_PARSE_ERROR:
            stat = "error";
            break;
        case JANET_PARSE_ROOT:
            stat = "root";
            break;
        case JANET_PARSE_DEAD:
            stat = "dead";
            break;
    }
    return janet_ckeywordv(stat);
}

JANET_CORE_FN(cfun_parse_error,
              "(parser/error parser)",
              "If the parser is in the error state, returns the message associated with "
              "that error. Otherwise, returns nil. Also flushes the parser state and parser "
              "queue, so be sure to handle everything in the queue before calling "
              "`parser/error`.") {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    const char *err = janet_parser_error(p);
    if (err) {
        return (p->flag & JANET_PARSER_GENERATED_ERROR)
               ? janet_wrap_string((const uint8_t *) err)
               : janet_cstringv(err);
    }
    return janet_wrap_nil();
}

JANET_CORE_FN(cfun_parse_produce,
              "(parser/produce parser &opt wrap)",
              "Dequeue the next value in the parse queue. Will return nil if "
              "no parsed values are in the queue, otherwise will dequeue the "
              "next value. If `wrap` is truthy, will return a 1-element tuple that "
              "wraps the result. This tuple can be used for source-mapping "
              "purposes.") {
    janet_arity(argc, 1, 2);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    if (argc == 2 && janet_truthy(argv[1])) {
        return janet_parser_produce_wrapped(p);
    } else {
        return janet_parser_produce(p);
    }
}

JANET_CORE_FN(cfun_parse_flush,
              "(parser/flush parser)",
              "Clears the parser state and parse queue. Can be used to reset the parser "
              "if an error was encountered. Does not reset the line and column counter, so "
              "to begin parsing in a new context, create a new parser.") {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    janet_parser_flush(p);
    return argv[0];
}

JANET_CORE_FN(cfun_parse_where,
              "(parser/where parser &opt line col)",
              "Returns the current line number and column of the parser's internal state. If line is "
              "provided, the current line number of the parser is first set to that value. If column is "
              "also provided, the current column number of the parser is also first set to that value.") {
    janet_arity(argc, 1, 3);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    if (argc > 1) {
        int32_t line = janet_getinteger(argv, 1);
        if (line < 1)
            janet_panicf("invalid line number %d", line);
        p->line = (size_t) line;
    }
    if (argc > 2) {
        int32_t column = janet_getinteger(argv, 2);
        if (column < 0)
            janet_panicf("invalid column number %d", column);
        p->column = (size_t) column;
    }
    Janet *tup = janet_tuple_begin(2);
    tup[0] = janet_wrap_integer(p->line);
    tup[1] = janet_wrap_integer(p->column);
    return janet_wrap_tuple(janet_tuple_end(tup));
}

static Janet janet_wrap_parse_state(JanetParseState *s, Janet *args,
                                    uint8_t *buff, uint32_t bufcount) {
    JanetTable *state = janet_table(0);
    const uint8_t *buffer;
    int add_buffer = 0;
    const char *type = NULL;

    if (s->flags & PFLAG_CONTAINER) {
        JanetArray *container_args = janet_array(s->argn);
        for (int32_t i = 0; i < s->argn; i++) {
            janet_array_push(container_args, args[i]);
        }
        janet_table_put(state, janet_ckeywordv("args"),
                        janet_wrap_array(container_args));
    }

    if (s->flags & PFLAG_PARENS || s->flags & PFLAG_SQRBRACKETS) {
        if (s->flags & PFLAG_ATSYM) {
            type = "array";
        } else {
            type = "tuple";
        }
    } else if (s->flags & PFLAG_CURLYBRACKETS) {
        if (s->flags & PFLAG_ATSYM) {
            type = "table";
        } else {
            type = "struct";
        }
    } else if (s->flags & PFLAG_STRING || s->flags & PFLAG_LONGSTRING) {
        if (s->flags & PFLAG_BUFFER) {
            type = "buffer";
        } else {
            type = "string";
        }
        add_buffer = 1;
    } else if (s->flags & PFLAG_COMMENT) {
        type = "comment";
        add_buffer = 1;
    } else if (s->flags & PFLAG_TOKEN) {
        type = "token";
        add_buffer = 1;
    } else if (s->flags & PFLAG_ATSYM) {
        type = "at";
    } else if (s->flags & PFLAG_READERMAC) {
        int c = s->flags & 0xFF;
        type = (c == '\'') ? "quote" :
               (c == ',') ? "unquote" :
               (c == ';') ? "splice" :
               (c == '~') ? "quasiquote" : "<reader>";
    } else {
        type = "root";
    }

    if (type) {
        janet_table_put(state, janet_ckeywordv("type"),
                        janet_ckeywordv(type));
    }

    if (add_buffer) {
        buffer = janet_string(buff, bufcount);
        janet_table_put(state, janet_ckeywordv("buffer"), janet_wrap_string(buffer));
    }

    janet_table_put(state, janet_ckeywordv("line"), janet_wrap_integer(s->line));
    janet_table_put(state, janet_ckeywordv("column"), janet_wrap_integer(s->column));
    return janet_wrap_table(state);
}

struct ParserStateGetter {
    const char *name;
    Janet(*fn)(const JanetParser *p);
};

static Janet parser_state_delimiters(const JanetParser *_p) {
    JanetParser *p = (JanetParser *)_p;
    size_t i;
    const uint8_t *str;
    size_t oldcount;
    oldcount = p->bufcount;
    for (i = 0; i < p->statecount; i++) {
        JanetParseState *s = p->states + i;
        if (s->flags & PFLAG_PARENS) {
            push_buf(p, '(');
        } else if (s->flags & PFLAG_SQRBRACKETS) {
            push_buf(p, '[');
        } else if (s->flags & PFLAG_CURLYBRACKETS) {
            push_buf(p, '{');
        } else if (s->flags & PFLAG_STRING) {
            push_buf(p, '"');
        } else if (s->flags & PFLAG_LONGSTRING) {
            int32_t i;
            for (i = 0; i < s->argn; i++) {
                push_buf(p, '`');
            }
        }
    }
    str = janet_string(p->buf + oldcount, (int32_t)(p->bufcount - oldcount));
    p->bufcount = oldcount;
    return janet_wrap_string(str);
}

static Janet parser_state_frames(const JanetParser *p) {
    int32_t count = (int32_t) p->statecount;
    JanetArray *states = janet_array(count);
    states->count = count;
    uint8_t *buf = p->buf;
    /* Iterate arg stack backwards */
    Janet *args = p->args + p->argcount;
    for (int32_t i = count - 1; i >= 0; --i) {
        JanetParseState *s = p->states + i;
        if (s->flags & PFLAG_CONTAINER) {
            args -= s->argn;
        }
        states->data[i] = janet_wrap_parse_state(s, args, buf, (uint32_t) p->bufcount);
    }
    return janet_wrap_array(states);
}

static const struct ParserStateGetter parser_state_getters[] = {
    {"frames", parser_state_frames},
    {"delimiters", parser_state_delimiters},
    {NULL, NULL}
};

JANET_CORE_FN(cfun_parse_state,
              "(parser/state parser &opt key)",
              "Returns a representation of the internal state of the parser. If a key is passed, "
              "only that information about the state is returned. Allowed keys are:\n\n"
              "* :delimiters - Each byte in the string represents a nested data structure. For example, "
              "if the parser state is '([\"', then the parser is in the middle of parsing a "
              "string inside of square brackets inside parentheses. Can be used to augment a REPL prompt.\n\n"
              "* :frames - Each table in the array represents a 'frame' in the parser state. Frames "
              "contain information about the start of the expression being parsed as well as the "
              "type of that expression and some type-specific information.") {
    janet_arity(argc, 1, 2);
    const uint8_t *key = NULL;
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    if (argc == 2) {
        key = janet_getkeyword(argv, 1);
    }

    if (key) {
        /* Get one result */
        for (const struct ParserStateGetter *sg = parser_state_getters;
                sg->name != NULL; sg++) {
            if (janet_cstrcmp(key, sg->name)) continue;
            return sg->fn(p);
        }
        janet_panicf("unexpected keyword %v", janet_wrap_keyword(key));
        return janet_wrap_nil();
    } else {
        /* Put results in table */
        JanetTable *tab = janet_table(0);
        for (const struct ParserStateGetter *sg = parser_state_getters;
                sg->name != NULL; sg++) {
            janet_table_put(tab, janet_ckeywordv(sg->name), sg->fn(p));
        }
        return janet_wrap_table(tab);
    }
}

JANET_CORE_FN(cfun_parse_clone,
              "(parser/clone p)",
              "Creates a deep clone of a parser that is identical to the input parser. "
              "This cloned parser can be used to continue parsing from a good checkpoint "
              "if parsing later fails. Returns a new parser.") {
    janet_fixarity(argc, 1);
    JanetParser *src = janet_getabstract(argv, 0, &janet_parser_type);
    JanetParser *dest = janet_abstract(&janet_parser_type, sizeof(JanetParser));
    janet_parser_clone(src, dest);
    return janet_wrap_abstract(dest);
}

static const JanetMethod parser_methods[] = {
    {"byte", cfun_parse_byte},
    {"clone", cfun_parse_clone},
    {"consume", cfun_parse_consume},
    {"eof", cfun_parse_eof},
    {"error", cfun_parse_error},
    {"flush", cfun_parse_flush},
    {"has-more", cfun_parse_has_more},
    {"insert", cfun_parse_insert},
    {"produce", cfun_parse_produce},
    {"state", cfun_parse_state},
    {"status", cfun_parse_status},
    {"where", cfun_parse_where},
    {NULL, NULL}
};

static int parserget(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    return janet_getmethod(janet_unwrap_keyword(key), parser_methods, out);
}

static Janet parsernext(void *p, Janet key) {
    (void) p;
    return janet_nextmethod(parser_methods, key);
}

/* Load the library */
void janet_lib_parse(JanetTable *env) {
    JanetRegExt parse_cfuns[] = {
        JANET_CORE_REG("parser/new", cfun_parse_parser),
        JANET_CORE_REG("parser/clone", cfun_parse_clone),
        JANET_CORE_REG("parser/has-more", cfun_parse_has_more),
        JANET_CORE_REG("parser/produce", cfun_parse_produce),
        JANET_CORE_REG("parser/consume", cfun_parse_consume),
        JANET_CORE_REG("parser/byte", cfun_parse_byte),
        JANET_CORE_REG("parser/error", cfun_parse_error),
        JANET_CORE_REG("parser/status", cfun_parse_status),
        JANET_CORE_REG("parser/flush", cfun_parse_flush),
        JANET_CORE_REG("parser/state", cfun_parse_state),
        JANET_CORE_REG("parser/where", cfun_parse_where),
        JANET_CORE_REG("parser/eof", cfun_parse_eof),
        JANET_CORE_REG("parser/insert", cfun_parse_insert),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, parse_cfuns);
}


/* src/core/peg.c */
#line 0 "src/core/peg.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include <string.h>
#include "util.h"
#include "vector.h"
#include "util.h"
#endif

#ifdef JANET_PEG

/*
 * Runtime
 */

/* Hold captured patterns and match state */
typedef struct {
    const uint8_t *text_start;
    const uint8_t *text_end;
    const uint32_t *bytecode;
    const Janet *constants;
    JanetArray *captures;
    JanetBuffer *scratch;
    JanetBuffer *tags;
    JanetArray *tagged_captures;
    const Janet *extrav;
    int32_t *linemap;
    int32_t extrac;
    int32_t depth;
    int32_t linemaplen;
    int32_t has_backref;
    enum {
        PEG_MODE_NORMAL,
        PEG_MODE_ACCUMULATE
    } mode;
} PegState;

/* Allow backtrack with captures. We need
 * to save state at branches, and then reload
 * if one branch fails and try a new branch. */
typedef struct {
    int32_t cap;
    int32_t tcap;
    int32_t scratch;
} CapState;

/* Save the current capture state */
static CapState cap_save(PegState *s) {
    CapState cs;
    cs.scratch = s->scratch->count;
    cs.cap = s->captures->count;
    cs.tcap = s->tagged_captures->count;
    return cs;
}

/* Load a saved capture state in the case of failure */
static void cap_load(PegState *s, CapState cs) {
    s->scratch->count = cs.scratch;
    s->captures->count = cs.cap;
    s->tags->count = cs.tcap;
    s->tagged_captures->count = cs.tcap;
}

/* Load a saved capture state in the case of success. Keeps
 * tagged captures around for backref. */
static void cap_load_keept(PegState *s, CapState cs) {
    s->scratch->count = cs.scratch;
    s->captures->count = cs.cap;
}

/* Add a capture */
static void pushcap(PegState *s, Janet capture, uint32_t tag) {
    if (s->mode == PEG_MODE_ACCUMULATE) {
        janet_to_string_b(s->scratch, capture);
    }
    if (s->mode == PEG_MODE_NORMAL) {
        janet_array_push(s->captures, capture);
    }
    if (s->has_backref) {
        janet_array_push(s->tagged_captures, capture);
        janet_buffer_push_u8(s->tags, tag);
    }
}

/* Lazily generate line map to get line and column information for PegState.
 * line and column are 1-indexed. */
typedef struct {
    int32_t line;
    int32_t col;
} LineCol;
static LineCol get_linecol_from_position(PegState *s, int32_t position) {
    /* Generate if not made yet */
    if (s->linemaplen < 0) {
        int32_t newline_count = 0;
        for (const uint8_t *c = s->text_start; c < s->text_end; c++) {
            if (*c == '\n') newline_count++;
        }
        int32_t *mem = janet_smalloc(sizeof(int32_t) * newline_count);
        size_t index = 0;
        for (const uint8_t *c = s->text_start; c < s->text_end; c++) {
            if (*c == '\n') mem[index++] = (int32_t)(c - s->text_start);
        }
        s->linemaplen = newline_count;
        s->linemap = mem;
    }
    /* Do binary search for line. Slightly modified from classic binary search:
     * - if we find that our current character is a line break, just return immediately.
     *   a newline character is consider to be on the same line as the character before
     *   (\n is line terminator, not line separator).
     * - in the not-found case, we still want to find the greatest-indexed newline that
     *   is before position. we use that to calcuate the line and column.
     * - in the case that lo = 0 and s->linemap[0] is still greater than position, we
     *   are on the first line and our column is position + 1. */
    int32_t hi = s->linemaplen; /* hi is greater than the actual line */
    int32_t lo = 0; /* lo is less than or equal to the actual line */
    LineCol ret;
    while (lo + 1 < hi) {
        int32_t mid = lo + (hi - lo) / 2;
        if (s->linemap[mid] >= position) {
            hi = mid;
        } else {
            lo = mid;
        }
    }
    /* first line case */
    if (s->linemaplen == 0 || (lo == 0 && s->linemap[0] >= position)) {
        ret.line = 1;
        ret.col = position + 1;
    } else {
        ret.line = lo + 2;
        ret.col = position - s->linemap[lo];
    }
    return ret;
}

/* Convert a uint64_t to a int64_t by wrapping to a maximum number of bytes */
static int64_t peg_convert_u64_s64(uint64_t from, int width) {
    int shift = 8 * (8 - width);
    return ((int64_t)(from << shift)) >> shift;
}

/* Prevent stack overflow */
#define down1(s) do { \
    if (0 == --((s)->depth)) janet_panic("peg/match recursed too deeply"); \
} while (0)
#define up1(s) ((s)->depth++)

/* Evaluate a peg rule
 * Pre-conditions: s is in a valid state
 * Post-conditions: If there is a match, returns a pointer to the next text.
 * All captures on the capture stack are valid. If there is no match,
 * returns NULL. Extra captures from successful child expressions can be
 * left on the capture stack.
 */
static const uint8_t *peg_rule(
    PegState *s,
    const uint32_t *rule,
    const uint8_t *text) {
tail:
    switch (*rule & 0x1F) {
        default:
            janet_panic("unexpected opcode");
            return NULL;

        case RULE_LITERAL: {
            uint32_t len = rule[1];
            if (text + len > s->text_end) return NULL;
            return memcmp(text, rule + 2, len) ? NULL : text + len;
        }

        case RULE_NCHAR: {
            uint32_t n = rule[1];
            return (text + n > s->text_end) ? NULL : text + n;
        }

        case RULE_NOTNCHAR: {
            uint32_t n = rule[1];
            return (text + n > s->text_end) ? text : NULL;
        }

        case RULE_RANGE: {
            uint8_t lo = rule[1] & 0xFF;
            uint8_t hi = (rule[1] >> 16) & 0xFF;
            return (text < s->text_end &&
                    text[0] >= lo &&
                    text[0] <= hi)
                   ? text + 1
                   : NULL;
        }

        case RULE_SET: {
            if (text >= s->text_end) return NULL;
            uint32_t word = rule[1 + (text[0] >> 5)];
            uint32_t mask = (uint32_t)1 << (text[0] & 0x1F);
            return (word & mask)
                   ? text + 1
                   : NULL;
        }

        case RULE_LOOK: {
            text += ((int32_t *)rule)[1];
            if (text < s->text_start || text > s->text_end) return NULL;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[2], text);
            up1(s);
            text -= ((int32_t *)rule)[1];
            return result ? text : NULL;
        }

        case RULE_CHOICE: {
            uint32_t len = rule[1];
            const uint32_t *args = rule + 2;
            if (len == 0) return NULL;
            down1(s);
            CapState cs = cap_save(s);
            for (uint32_t i = 0; i < len - 1; i++) {
                const uint8_t *result = peg_rule(s, s->bytecode + args[i], text);
                if (result) {
                    up1(s);
                    return result;
                }
                cap_load(s, cs);
            }
            up1(s);
            rule = s->bytecode + args[len - 1];
            goto tail;
        }

        case RULE_SEQUENCE: {
            uint32_t len = rule[1];
            const uint32_t *args = rule + 2;
            if (len == 0) return text;
            down1(s);
            for (uint32_t i = 0; text && i < len - 1; i++)
                text = peg_rule(s, s->bytecode + args[i], text);
            up1(s);
            if (!text) return NULL;
            rule = s->bytecode + args[len - 1];
            goto tail;
        }

        case RULE_IF: {
            const uint32_t *rule_a = s->bytecode + rule[1];
            const uint32_t *rule_b = s->bytecode + rule[2];
            down1(s);
            const uint8_t *result = peg_rule(s, rule_a, text);
            up1(s);
            if (!result) return NULL;
            rule = rule_b;
            goto tail;
        }
        case RULE_IFNOT: {
            const uint32_t *rule_a = s->bytecode + rule[1];
            const uint32_t *rule_b = s->bytecode + rule[2];
            down1(s);
            CapState cs = cap_save(s);
            const uint8_t *result = peg_rule(s, rule_a, text);
            if (!!result) {
                up1(s);
                return NULL;
            } else {
                cap_load(s, cs);
                up1(s);
                rule = rule_b;
                goto tail;
            }
        }

        case RULE_NOT: {
            const uint32_t *rule_a = s->bytecode + rule[1];
            down1(s);
            CapState cs = cap_save(s);
            const uint8_t *result = peg_rule(s, rule_a, text);
            if (result) {
                up1(s);
                return NULL;
            } else {
                cap_load(s, cs);
                up1(s);
                return text;
            }
        }

        case RULE_THRU:
        case RULE_TO: {
            const uint32_t *rule_a = s->bytecode + rule[1];
            const uint8_t *next_text = NULL;
            CapState cs = cap_save(s);
            down1(s);
            while (text <= s->text_end) {
                CapState cs2 = cap_save(s);
                next_text = peg_rule(s, rule_a, text);
                if (next_text) {
                    if (rule[0] == RULE_TO) cap_load(s, cs2);
                    break;
                }
                cap_load(s, cs2);
                text++;
            }
            up1(s);
            if (text > s->text_end) {
                cap_load(s, cs);
                return NULL;
            }
            return rule[0] == RULE_TO ? text : next_text;
        }

        case RULE_BETWEEN: {
            uint32_t lo = rule[1];
            uint32_t hi = rule[2];
            const uint32_t *rule_a = s->bytecode + rule[3];
            uint32_t captured = 0;
            const uint8_t *next_text;
            CapState cs = cap_save(s);
            down1(s);
            while (captured < hi) {
                CapState cs2 = cap_save(s);
                next_text = peg_rule(s, rule_a, text);
                if (!next_text || next_text == text) {
                    cap_load(s, cs2);
                    break;
                }
                captured++;
                text = next_text;
            }
            up1(s);
            if (captured < lo) {
                cap_load(s, cs);
                return NULL;
            }
            return text;
        }

        /* Capturing rules */

        case RULE_GETTAG: {
            uint32_t search = rule[1];
            uint32_t tag = rule[2];
            for (int32_t i = s->tags->count - 1; i >= 0; i--) {
                if (s->tags->data[i] == search) {
                    pushcap(s, s->tagged_captures->data[i], tag);
                    return text;
                }
            }
            return NULL;
        }

        case RULE_POSITION: {
            pushcap(s, janet_wrap_number((double)(text - s->text_start)), rule[1]);
            return text;
        }

        case RULE_LINE: {
            LineCol lc = get_linecol_from_position(s, (int32_t)(text - s->text_start));
            pushcap(s, janet_wrap_number((double)(lc.line)), rule[1]);
            return text;
        }

        case RULE_COLUMN: {
            LineCol lc = get_linecol_from_position(s, (int32_t)(text - s->text_start));
            pushcap(s, janet_wrap_number((double)(lc.col)), rule[1]);
            return text;
        }

        case RULE_ARGUMENT: {
            int32_t index = ((int32_t *)rule)[1];
            Janet capture = (index >= s->extrac) ? janet_wrap_nil() : s->extrav[index];
            pushcap(s, capture, rule[2]);
            return text;
        }

        case RULE_CONSTANT: {
            pushcap(s, s->constants[rule[1]], rule[2]);
            return text;
        }

        case RULE_CAPTURE: {
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            if (!result) return NULL;
            /* Specialized pushcap - avoid intermediate string creation */
            if (!s->has_backref && s->mode == PEG_MODE_ACCUMULATE) {
                janet_buffer_push_bytes(s->scratch, text, (int32_t)(result - text));
            } else {
                uint32_t tag = rule[2];
                pushcap(s, janet_stringv(text, (int32_t)(result - text)), tag);
            }
            return result;
        }

        case RULE_CAPTURE_NUM: {
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            if (!result) return NULL;
            /* check number parsing */
            double x = 0.0;
            int32_t base = (int32_t) rule[2];
            if (janet_scan_number_base(text, (int32_t)(result - text), base, &x)) return NULL;
            /* Specialized pushcap - avoid intermediate string creation */
            if (!s->has_backref && s->mode == PEG_MODE_ACCUMULATE) {
                janet_buffer_push_bytes(s->scratch, text, (int32_t)(result - text));
            } else {
                uint32_t tag = rule[3];
                pushcap(s, janet_wrap_number(x), tag);
            }
            return result;
        }

        case RULE_ACCUMULATE: {
            uint32_t tag = rule[2];
            int oldmode = s->mode;
            if (!tag && oldmode == PEG_MODE_ACCUMULATE) {
                rule = s->bytecode + rule[1];
                goto tail;
            }
            CapState cs = cap_save(s);
            s->mode = PEG_MODE_ACCUMULATE;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            s->mode = oldmode;
            if (!result) return NULL;
            Janet cap = janet_stringv(s->scratch->data + cs.scratch,
                                      s->scratch->count - cs.scratch);
            cap_load_keept(s, cs);
            pushcap(s, cap, tag);
            return result;
        }

        case RULE_DROP: {
            CapState cs = cap_save(s);
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            if (!result) return NULL;
            cap_load(s, cs);
            return result;
        }

        case RULE_GROUP: {
            uint32_t tag = rule[2];
            int oldmode = s->mode;
            CapState cs = cap_save(s);
            s->mode = PEG_MODE_NORMAL;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            s->mode = oldmode;
            if (!result) return NULL;
            int32_t num_sub_captures = s->captures->count - cs.cap;
            JanetArray *sub_captures = janet_array(num_sub_captures);
            safe_memcpy(sub_captures->data,
                        s->captures->data + cs.cap,
                        sizeof(Janet) * num_sub_captures);
            sub_captures->count = num_sub_captures;
            cap_load_keept(s, cs);
            pushcap(s, janet_wrap_array(sub_captures), tag);
            return result;
        }

        case RULE_REPLACE:
        case RULE_MATCHTIME: {
            uint32_t tag = rule[3];
            int oldmode = s->mode;
            CapState cs = cap_save(s);
            s->mode = PEG_MODE_NORMAL;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            s->mode = oldmode;
            if (!result) return NULL;

            Janet cap = janet_wrap_nil();
            Janet constant = s->constants[rule[2]];
            switch (janet_type(constant)) {
                default:
                    cap = constant;
                    break;
                case JANET_STRUCT:
                    if (s->captures->count) {
                        cap = janet_struct_get(janet_unwrap_struct(constant),
                                               s->captures->data[s->captures->count - 1]);
                    }
                    break;
                case JANET_TABLE:
                    if (s->captures->count) {
                        cap = janet_table_get(janet_unwrap_table(constant),
                                              s->captures->data[s->captures->count - 1]);
                    }
                    break;
                case JANET_CFUNCTION:
                    cap = janet_unwrap_cfunction(constant)(s->captures->count - cs.cap,
                                                           s->captures->data + cs.cap);
                    break;
                case JANET_FUNCTION:
                    cap = janet_call(janet_unwrap_function(constant),
                                     s->captures->count - cs.cap,
                                     s->captures->data + cs.cap);
                    break;
            }
            cap_load_keept(s, cs);
            if (rule[0] == RULE_MATCHTIME && !janet_truthy(cap)) return NULL;
            pushcap(s, cap, tag);
            return result;
        }

        case RULE_ERROR: {
            int oldmode = s->mode;
            s->mode = PEG_MODE_NORMAL;
            int32_t old_cap = s->captures->count;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            s->mode = oldmode;
            if (!result) return NULL;
            if (s->captures->count > old_cap) {
                /* Throw last capture */
                janet_panicv(s->captures->data[s->captures->count - 1]);
            } else {
                /* Throw generic error */
                int32_t start = (int32_t)(text - s->text_start);
                LineCol lc = get_linecol_from_position(s, start);
                janet_panicf("match error at line %d, column %d", lc.line, lc.col);
            }
            return NULL;
        }

        case RULE_BACKMATCH: {
            uint32_t search = rule[1];
            for (int32_t i = s->tags->count - 1; i >= 0; i--) {
                if (s->tags->data[i] == search) {
                    Janet capture = s->tagged_captures->data[i];
                    if (!janet_checktype(capture, JANET_STRING))
                        return NULL;
                    const uint8_t *bytes = janet_unwrap_string(capture);
                    int32_t len = janet_string_length(bytes);
                    if (text + len > s->text_end)
                        return NULL;
                    return memcmp(text, bytes, len) ? NULL : text + len;
                }
            }
            return NULL;
        }

        case RULE_LENPREFIX: {
            int oldmode = s->mode;
            s->mode = PEG_MODE_NORMAL;
            const uint8_t *next_text;
            CapState cs = cap_save(s);
            down1(s);
            next_text = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            if (NULL == next_text) return NULL;
            s->mode = oldmode;
            int32_t num_sub_captures = s->captures->count - cs.cap;
            Janet lencap;
            if (num_sub_captures <= 0 ||
                    (lencap = s->captures->data[cs.cap], !janet_checkint(lencap))) {
                cap_load(s, cs);
                return NULL;
            }
            int32_t nrep = janet_unwrap_integer(lencap);
            /* drop captures from len pattern */
            cap_load(s, cs);
            for (int32_t i = 0; i < nrep; i++) {
                down1(s);
                next_text = peg_rule(s, s->bytecode + rule[2], next_text);
                up1(s);
                if (NULL == next_text) {
                    cap_load(s, cs);
                    return NULL;
                }
            }
            return next_text;
        }

        case RULE_READINT: {
            uint32_t tag = rule[2];
            uint32_t signedness = rule[1] & 0x10;
            uint32_t endianess = rule[1] & 0x20;
            int width = (int)(rule[1] & 0xF);
            if (text + width > s->text_end) return NULL;
            uint64_t accum = 0;
            if (endianess) {
                /* BE */
                for (int i = 0; i < width; i++) accum = (accum << 8) | text[i];
            } else {
                /* LE */
                for (int i = width - 1; i >= 0; i--) accum = (accum << 8) | text[i];
            }

            Janet capture_value;
            /* We can only parse integeres of greater than 6 bytes reliable if int-types are enabled.
             * Otherwise, we may lose precision, so 6 is the maximum size when int-types are disabled. */
#ifdef JANET_INT_TYPES
            if (width > 6) {
                if (signedness) {
                    capture_value = janet_wrap_s64(peg_convert_u64_s64(accum, width));
                } else {
                    capture_value = janet_wrap_u64(accum);
                }
            } else
#endif
            {
                double double_value;
                if (signedness) {
                    double_value = (double)(peg_convert_u64_s64(accum, width));
                } else {
                    double_value = (double)accum;
                }
                capture_value = janet_wrap_number(double_value);
            }

            pushcap(s, capture_value, tag);
            return text + width;
        }

        case RULE_UNREF: {
            int32_t tcap = s->tags->count;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            if (!result) return NULL;
            int32_t final_tcap = s->tags->count;
            /* Truncate tagged captures to not include items of the given tag */
            int32_t w = tcap;
            /* If no tag is given, drop ALL tagged captures */
            if (rule[2]) {
                for (int32_t i = tcap; i < final_tcap; i++) {
                    if (s->tags->data[i] != (0xFF & rule[2])) {
                        s->tags->data[w] = s->tags->data[i];
                        s->tagged_captures->data[w] = s->tagged_captures->data[i];
                        w++;
                    }
                }
            }
            s->tags->count = w;
            s->tagged_captures->count = w;
            return result;
        }

    }
}

/*
 * Compilation
 */

typedef struct {
    JanetTable *grammar;
    JanetTable *default_grammar;
    JanetTable *tags;
    Janet *constants;
    uint32_t *bytecode;
    Janet form;
    int depth;
    uint32_t nexttag;
    int has_backref;
} Builder;

/* Forward declaration to allow recursion */
static uint32_t peg_compile1(Builder *b, Janet peg);

/*
 * Errors
 */

static void builder_cleanup(Builder *b) {
    janet_v_free(b->constants);
    janet_v_free(b->bytecode);
}

JANET_NO_RETURN static void peg_panic(Builder *b, const char *msg) {
    builder_cleanup(b);
    janet_panicf("grammar error in %p, %s", b->form, msg);
}

#define peg_panicf(b,...) peg_panic((b), (const char *) janet_formatc(__VA_ARGS__))

static void peg_fixarity(Builder *b, int32_t argc, int32_t arity) {
    if (argc != arity) {
        peg_panicf(b, "expected %d argument%s, got %d",
                   arity,
                   arity == 1 ? "" : "s",
                   argc);
    }
}

static void peg_arity(Builder *b, int32_t arity, int32_t min, int32_t max) {
    if (min >= 0 && arity < min)
        peg_panicf(b, "arity mismatch, expected at least %d, got %d", min, arity);
    if (max >= 0 && arity > max)
        peg_panicf(b, "arity mismatch, expected at most %d, got %d", max, arity);
}

static const uint8_t *peg_getset(Builder *b, Janet x) {
    if (!janet_checktype(x, JANET_STRING))
        peg_panic(b, "expected string for character set");
    const uint8_t *str = janet_unwrap_string(x);
    return str;
}

static const uint8_t *peg_getrange(Builder *b, Janet x) {
    if (!janet_checktype(x, JANET_STRING))
        peg_panic(b, "expected string for character range");
    const uint8_t *str = janet_unwrap_string(x);
    if (janet_string_length(str) != 2)
        peg_panicf(b, "expected string to have length 2, got %v", x);
    if (str[1] < str[0])
        peg_panicf(b, "range %v is empty", x);
    return str;
}

static int32_t peg_getinteger(Builder *b, Janet x) {
    if (!janet_checkint(x))
        peg_panicf(b, "expected integer, got %v", x);
    return janet_unwrap_integer(x);
}

static int32_t peg_getnat(Builder *b, Janet x) {
    int32_t i = peg_getinteger(b, x);
    if (i < 0)
        peg_panicf(b, "expected non-negative integer, got %v", x);
    return i;
}

/*
 * Emission
 */

static uint32_t emit_constant(Builder *b, Janet c) {
    uint32_t cindex = (uint32_t) janet_v_count(b->constants);
    janet_v_push(b->constants, c);
    return cindex;
}

static uint32_t emit_tag(Builder *b, Janet t) {
    if (!janet_checktype(t, JANET_KEYWORD))
        peg_panicf(b, "expected keyword for capture tag, got %v", t);
    Janet check = janet_table_get(b->tags, t);
    if (janet_checktype(check, JANET_NIL)) {
        uint32_t tag = b->nexttag++;
        if (tag > 255) {
            peg_panic(b, "too many tags - up to 255 tags are supported per peg");
        }
        Janet val = janet_wrap_number(tag);
        janet_table_put(b->tags, t, val);
        return tag;
    } else {
        return (uint32_t) janet_unwrap_number(check);
    }
}

/* Reserve space in bytecode for a rule. When a special emits a rule,
 * it must place that rule immediately on the bytecode stack. This lets
 * the compiler know where the rule is going to be before it is complete,
 * allowing recursive rules. */
typedef struct {
    Builder *builder;
    uint32_t index;
    int32_t size;
} Reserve;

static Reserve reserve(Builder *b, int32_t size) {
    Reserve r;
    r.index = janet_v_count(b->bytecode);
    r.builder = b;
    r.size = size;
    for (int32_t i = 0; i < size; i++)
        janet_v_push(b->bytecode, 0);
    return r;
}

/* Emit a rule in the builder. Returns the index of the new rule */
static void emit_rule(Reserve r, int32_t op, int32_t n, const uint32_t *body) {
    janet_assert(r.size == n + 1, "bad reserve");
    r.builder->bytecode[r.index] = op;
    memcpy(r.builder->bytecode + r.index + 1, body, n * sizeof(uint32_t));
}

/* For RULE_LITERAL */
static void emit_bytes(Builder *b, uint32_t op, int32_t len, const uint8_t *bytes) {
    uint32_t next_rule = janet_v_count(b->bytecode);
    janet_v_push(b->bytecode, op);
    janet_v_push(b->bytecode, len);
    int32_t words = ((len + 3) >> 2);
    for (int32_t i = 0; i < words; i++)
        janet_v_push(b->bytecode, 0);
    memcpy(b->bytecode + next_rule + 2, bytes, len);
}

/* For fixed arity rules of arities 1, 2, and 3 */
static void emit_1(Reserve r, uint32_t op, uint32_t arg) {
    emit_rule(r, op, 1, &arg);
}
static void emit_2(Reserve r, uint32_t op, uint32_t arg1, uint32_t arg2) {
    uint32_t arr[2] = {arg1, arg2};
    emit_rule(r, op, 2, arr);
}
static void emit_3(Reserve r, uint32_t op, uint32_t arg1, uint32_t arg2, uint32_t arg3) {
    uint32_t arr[3] = {arg1, arg2, arg3};
    emit_rule(r, op, 3, arr);
}

/*
 * Specials
 */

static void bitmap_set(uint32_t *bitmap, uint8_t c) {
    bitmap[c >> 5] |= ((uint32_t)1) << (c & 0x1F);
}

static void spec_range(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, -1);
    if (argc == 1) {
        Reserve r = reserve(b, 2);
        const uint8_t *str = peg_getrange(b, argv[0]);
        uint32_t arg = str[0] | (str[1] << 16);
        emit_1(r, RULE_RANGE, arg);
    } else {
        /* Compile as a set */
        Reserve r = reserve(b, 9);
        uint32_t bitmap[8] = {0};
        for (int32_t i = 0; i < argc; i++) {
            const uint8_t *str = peg_getrange(b, argv[i]);
            for (uint32_t c = str[0]; c <= str[1]; c++)
                bitmap_set(bitmap, c);
        }
        emit_rule(r, RULE_SET, 8, bitmap);
    }
}

static void spec_set(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 1);
    Reserve r = reserve(b, 9);
    const uint8_t *str = peg_getset(b, argv[0]);
    uint32_t bitmap[8] = {0};
    for (int32_t i = 0; i < janet_string_length(str); i++)
        bitmap_set(bitmap, str[i]);
    emit_rule(r, RULE_SET, 8, bitmap);
}

static void spec_look(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    int32_t rulearg = argc == 2 ? 1 : 0;
    int32_t offset = argc == 2 ? peg_getinteger(b, argv[0]) : 0;
    uint32_t subrule = peg_compile1(b, argv[rulearg]);
    emit_2(r, RULE_LOOK, (uint32_t) offset, subrule);
}

/* Rule of the form [len, rules...] */
static void spec_variadic(Builder *b, int32_t argc, const Janet *argv, uint32_t op) {
    uint32_t rule = janet_v_count(b->bytecode);
    janet_v_push(b->bytecode, op);
    janet_v_push(b->bytecode, argc);
    for (int32_t i = 0; i < argc; i++)
        janet_v_push(b->bytecode, 0);
    for (int32_t i = 0; i < argc; i++) {
        uint32_t rulei = peg_compile1(b, argv[i]);
        b->bytecode[rule + 2 + i] = rulei;
    }
}

static void spec_choice(Builder *b, int32_t argc, const Janet *argv) {
    spec_variadic(b, argc, argv, RULE_CHOICE);
}
static void spec_sequence(Builder *b, int32_t argc, const Janet *argv) {
    spec_variadic(b, argc, argv, RULE_SEQUENCE);
}

/* For (if a b) and (if-not a b) */
static void spec_branch(Builder *b, int32_t argc, const Janet *argv, uint32_t rule) {
    peg_fixarity(b, argc, 2);
    Reserve r = reserve(b, 3);
    uint32_t rule_a = peg_compile1(b, argv[0]);
    uint32_t rule_b = peg_compile1(b, argv[1]);
    emit_2(r, rule, rule_a, rule_b);
}

static void spec_if(Builder *b, int32_t argc, const Janet *argv) {
    spec_branch(b, argc, argv, RULE_IF);
}
static void spec_ifnot(Builder *b, int32_t argc, const Janet *argv) {
    spec_branch(b, argc, argv, RULE_IFNOT);
}
static void spec_lenprefix(Builder *b, int32_t argc, const Janet *argv) {
    spec_branch(b, argc, argv, RULE_LENPREFIX);
}

static void spec_between(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 3);
    Reserve r = reserve(b, 4);
    int32_t lo = peg_getnat(b, argv[0]);
    int32_t hi = peg_getnat(b, argv[1]);
    uint32_t subrule = peg_compile1(b, argv[2]);
    emit_3(r, RULE_BETWEEN, lo, hi, subrule);
}

static void spec_repeater(Builder *b, int32_t argc, const Janet *argv, int32_t min) {
    peg_fixarity(b, argc, 1);
    Reserve r = reserve(b, 4);
    uint32_t subrule = peg_compile1(b, argv[0]);
    emit_3(r, RULE_BETWEEN, min, UINT32_MAX, subrule);
}

static void spec_some(Builder *b, int32_t argc, const Janet *argv) {
    spec_repeater(b, argc, argv, 1);
}
static void spec_any(Builder *b, int32_t argc, const Janet *argv) {
    spec_repeater(b, argc, argv, 0);
}

static void spec_atleast(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 2);
    Reserve r = reserve(b, 4);
    int32_t n = peg_getnat(b, argv[0]);
    uint32_t subrule = peg_compile1(b, argv[1]);
    emit_3(r, RULE_BETWEEN, n, UINT32_MAX, subrule);
}

static void spec_atmost(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 2);
    Reserve r = reserve(b, 4);
    int32_t n = peg_getnat(b, argv[0]);
    uint32_t subrule = peg_compile1(b, argv[1]);
    emit_3(r, RULE_BETWEEN, 0, n, subrule);
}

static void spec_opt(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 1);
    Reserve r = reserve(b, 4);
    uint32_t subrule = peg_compile1(b, argv[0]);
    emit_3(r, RULE_BETWEEN, 0, 1, subrule);
}

static void spec_repeat(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 2);
    Reserve r = reserve(b, 4);
    int32_t n = peg_getnat(b, argv[0]);
    uint32_t subrule = peg_compile1(b, argv[1]);
    emit_3(r, RULE_BETWEEN, n, n, subrule);
}

/* Rule of the form [rule] */
static void spec_onerule(Builder *b, int32_t argc, const Janet *argv, uint32_t op) {
    peg_fixarity(b, argc, 1);
    Reserve r = reserve(b, 2);
    uint32_t rule = peg_compile1(b, argv[0]);
    emit_1(r, op, rule);
}

static void spec_not(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_NOT);
}
static void spec_error(Builder *b, int32_t argc, const Janet *argv) {
    if (argc == 0) {
        Reserve r = reserve(b, 2);
        uint32_t rule = peg_compile1(b, janet_wrap_number(0));
        emit_1(r, RULE_ERROR, rule);
    } else {
        spec_onerule(b, argc, argv, RULE_ERROR);
    }
}
static void spec_to(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_TO);
}
static void spec_thru(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_THRU);
}
static void spec_drop(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_DROP);
}

/* Rule of the form [rule, tag] */
static void spec_cap1(Builder *b, int32_t argc, const Janet *argv, uint32_t op) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    uint32_t rule = peg_compile1(b, argv[0]);
    emit_2(r, op, rule, tag);
}

static void spec_capture(Builder *b, int32_t argc, const Janet *argv) {
    spec_cap1(b, argc, argv, RULE_CAPTURE);
}
static void spec_accumulate(Builder *b, int32_t argc, const Janet *argv) {
    spec_cap1(b, argc, argv, RULE_ACCUMULATE);
}
static void spec_group(Builder *b, int32_t argc, const Janet *argv) {
    spec_cap1(b, argc, argv, RULE_GROUP);
}
static void spec_unref(Builder *b, int32_t argc, const Janet *argv) {
    spec_cap1(b, argc, argv, RULE_UNREF);
}

static void spec_capture_number(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, 3);
    Reserve r = reserve(b, 4);
    uint32_t base = 0;
    if (argc >= 2) {
        if (!janet_checktype(argv[1], JANET_NIL)) {
            if (!janet_checkint(argv[1])) goto error;
            base = (uint32_t) janet_unwrap_integer(argv[1]);
            if (base < 2 || base > 36) goto error;
        }
    }
    uint32_t tag = (argc == 3) ? emit_tag(b, argv[2]) : 0;
    uint32_t rule = peg_compile1(b, argv[0]);
    emit_3(r, RULE_CAPTURE_NUM, rule, base, tag);
    return;
error:
    peg_panicf(b, "expected integer between 2 and 36, got %v", argv[2]);
}

static void spec_reference(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t search = emit_tag(b, argv[0]);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    b->has_backref = 1;
    emit_2(r, RULE_GETTAG, search, tag);
}

static void spec_tag1(Builder *b, int32_t argc, const Janet *argv, uint32_t op) {
    peg_arity(b, argc, 0, 1);
    Reserve r = reserve(b, 2);
    uint32_t tag = (argc) ? emit_tag(b, argv[0]) : 0;
    (void) argv;
    emit_1(r, op, tag);
}

static void spec_position(Builder *b, int32_t argc, const Janet *argv) {
    spec_tag1(b, argc, argv, RULE_POSITION);
}
static void spec_line(Builder *b, int32_t argc, const Janet *argv) {
    spec_tag1(b, argc, argv, RULE_LINE);
}
static void spec_column(Builder *b, int32_t argc, const Janet *argv) {
    spec_tag1(b, argc, argv, RULE_COLUMN);
}

static void spec_backmatch(Builder *b, int32_t argc, const Janet *argv) {
    b->has_backref = 1;
    spec_tag1(b, argc, argv, RULE_BACKMATCH);
}

static void spec_argument(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    int32_t index = peg_getnat(b, argv[0]);
    emit_2(r, RULE_ARGUMENT, index, tag);
}

static void spec_constant(Builder *b, int32_t argc, const Janet *argv) {
    janet_arity(argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    emit_2(r, RULE_CONSTANT, emit_constant(b, argv[0]), tag);
}

static void spec_replace(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 2, 3);
    Reserve r = reserve(b, 4);
    uint32_t subrule = peg_compile1(b, argv[0]);
    uint32_t constant = emit_constant(b, argv[1]);
    uint32_t tag = (argc == 3) ? emit_tag(b, argv[2]) : 0;
    emit_3(r, RULE_REPLACE, subrule, constant, tag);
}

static void spec_matchtime(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 2, 3);
    Reserve r = reserve(b, 4);
    uint32_t subrule = peg_compile1(b, argv[0]);
    Janet fun = argv[1];
    if (!janet_checktype(fun, JANET_FUNCTION) &&
            !janet_checktype(fun, JANET_CFUNCTION)) {
        peg_panicf(b, "expected function|cfunction, got %v", fun);
    }
    uint32_t tag = (argc == 3) ? emit_tag(b, argv[2]) : 0;
    uint32_t cindex = emit_constant(b, fun);
    emit_3(r, RULE_MATCHTIME, subrule, cindex, tag);
}

#ifdef JANET_INT_TYPES
#define JANET_MAX_READINT_WIDTH 8
#else
#define JANET_MAX_READINT_WIDTH 6
#endif

static void spec_readint(Builder *b, int32_t argc, const Janet *argv, uint32_t mask) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    int32_t width = peg_getnat(b, argv[0]);
    if ((width < 0) || (width > JANET_MAX_READINT_WIDTH)) {
        peg_panicf(b, "width must be between 0 and %d, got %d", JANET_MAX_READINT_WIDTH, width);
    }
    emit_2(r, RULE_READINT, mask | ((uint32_t) width), tag);
}

static void spec_uint_le(Builder *b, int32_t argc, const Janet *argv) {
    spec_readint(b, argc, argv, 0x0u);
}
static void spec_int_le(Builder *b, int32_t argc, const Janet *argv) {
    spec_readint(b, argc, argv, 0x10u);
}
static void spec_uint_be(Builder *b, int32_t argc, const Janet *argv) {
    spec_readint(b, argc, argv, 0x20u);
}
static void spec_int_be(Builder *b, int32_t argc, const Janet *argv) {
    spec_readint(b, argc, argv, 0x30u);
}

/* Special compiler form */
typedef void (*Special)(Builder *b, int32_t argc, const Janet *argv);
typedef struct {
    const char *name;
    Special special;
} SpecialPair;

/* Keep in lexical order (vim :sort works well) */
static const SpecialPair peg_specials[] = {
    {"!", spec_not},
    {"$", spec_position},
    {"%", spec_accumulate},
    {"*", spec_sequence},
    {"+", spec_choice},
    {"->", spec_reference},
    {"/", spec_replace},
    {"<-", spec_capture},
    {">", spec_look},
    {"?", spec_opt},
    {"accumulate", spec_accumulate},
    {"any", spec_any},
    {"argument", spec_argument},
    {"at-least", spec_atleast},
    {"at-most", spec_atmost},
    {"backmatch", spec_backmatch},
    {"backref", spec_reference},
    {"between", spec_between},
    {"capture", spec_capture},
    {"choice", spec_choice},
    {"cmt", spec_matchtime},
    {"column", spec_column},
    {"constant", spec_constant},
    {"drop", spec_drop},
    {"error", spec_error},
    {"group", spec_group},
    {"if", spec_if},
    {"if-not", spec_ifnot},
    {"int", spec_int_le},
    {"int-be", spec_int_be},
    {"lenprefix", spec_lenprefix},
    {"line", spec_line},
    {"look", spec_look},
    {"not", spec_not},
    {"number", spec_capture_number},
    {"opt", spec_opt},
    {"position", spec_position},
    {"quote", spec_capture},
    {"range", spec_range},
    {"repeat", spec_repeat},
    {"replace", spec_replace},
    {"sequence", spec_sequence},
    {"set", spec_set},
    {"some", spec_some},
    {"thru", spec_thru},
    {"to", spec_to},
    {"uint", spec_uint_le},
    {"uint-be", spec_uint_be},
    {"unref", spec_unref},
};

/* Compile a janet value into a rule and return the rule index. */
static uint32_t peg_compile1(Builder *b, Janet peg) {

    /* Keep track of the form being compiled for error purposes */
    Janet old_form = b->form;
    JanetTable *old_grammar = b->grammar;
    b->form = peg;

    /* Resolve keyword references */
    int i = JANET_RECURSION_GUARD;
    JanetTable *grammar = old_grammar;
    for (; i > 0 && janet_checktype(peg, JANET_KEYWORD); --i) {
        Janet nextPeg = janet_table_get_ex(grammar, peg, &grammar);
        if (!grammar || janet_checktype(nextPeg, JANET_NIL)) {
            nextPeg = (b->default_grammar == NULL)
                      ? janet_wrap_nil()
                      : janet_table_get(b->default_grammar, peg);
            if (janet_checktype(nextPeg, JANET_NIL)) {
                peg_panic(b, "unknown rule");
            }
        }
        peg = nextPeg;
        b->form = peg;
        b->grammar = grammar;
    }
    if (i == 0)
        peg_panic(b, "reference chain too deep");

    /* Check cache - for tuples we check only the local cache, as
     * in a different grammar, the same tuple can compile to a different
     * rule - for example, (+ :a :b) depends on whatever :a and :b are bound to. */
    Janet check = janet_checktype(peg, JANET_TUPLE)
                  ? janet_table_rawget(grammar, peg)
                  : janet_table_get(grammar, peg);
    if (!janet_checktype(check, JANET_NIL)) {
        b->form = old_form;
        b->grammar = old_grammar;
        return (uint32_t) janet_unwrap_number(check);
    }

    /* Check depth */
    if (b->depth-- == 0)
        peg_panic(b, "peg grammar recursed too deeply");

    /* The final rule to return */
    uint32_t rule = janet_v_count(b->bytecode);

    /* Add to cache. Do not cache structs, as we don't yet know
     * what rule they will return! We can just as effectively cache
     * the structs main rule. */
    if (!janet_checktype(peg, JANET_STRUCT)) {
        JanetTable *which_grammar = grammar;
        /* If we are a primitive pattern, add to the global cache (root grammar table) */
        if (!janet_checktype(peg, JANET_TUPLE)) {
            while (which_grammar->proto)
                which_grammar = which_grammar->proto;
        }
        janet_table_put(which_grammar, peg, janet_wrap_number(rule));
    }

    switch (janet_type(peg)) {
        default:
            peg_panic(b, "unexpected peg source");
            return 0;
        case JANET_NUMBER: {
            int32_t n = peg_getinteger(b, peg);
            Reserve r = reserve(b, 2);
            if (n < 0) {
                emit_1(r, RULE_NOTNCHAR, -n);
            } else {
                emit_1(r, RULE_NCHAR, n);
            }
            break;
        }
        case JANET_STRING: {
            const uint8_t *str = janet_unwrap_string(peg);
            int32_t len = janet_string_length(str);
            emit_bytes(b, RULE_LITERAL, len, str);
            break;
        }
        case JANET_TABLE: {
            /* Build grammar table */
            JanetTable *new_grammar = janet_table_clone(janet_unwrap_table(peg));
            new_grammar->proto = grammar;
            b->grammar = grammar = new_grammar;
            /* Run the main rule */
            Janet main_rule = janet_table_rawget(grammar, janet_ckeywordv("main"));
            if (janet_checktype(main_rule, JANET_NIL))
                peg_panic(b, "grammar requires :main rule");
            rule = peg_compile1(b, main_rule);
            break;
        }
        case JANET_STRUCT: {
            /* Build grammar table */
            const JanetKV *st = janet_unwrap_struct(peg);
            JanetTable *new_grammar = janet_table(2 * janet_struct_capacity(st));
            for (int32_t i = 0; i < janet_struct_capacity(st); i++) {
                if (janet_checktype(st[i].key, JANET_KEYWORD)) {
                    janet_table_put(new_grammar, st[i].key, st[i].value);
                }
            }
            new_grammar->proto = grammar;
            b->grammar = grammar = new_grammar;
            /* Run the main rule */
            Janet main_rule = janet_table_rawget(grammar, janet_ckeywordv("main"));
            if (janet_checktype(main_rule, JANET_NIL))
                peg_panic(b, "grammar requires :main rule");
            rule = peg_compile1(b, main_rule);
            break;
        }
        case JANET_TUPLE: {
            const Janet *tup = janet_unwrap_tuple(peg);
            int32_t len = janet_tuple_length(tup);
            if (len == 0) peg_panic(b, "tuple in grammar must have non-zero length");
            if (janet_checkint(tup[0])) {
                int32_t n = janet_unwrap_integer(tup[0]);
                if (n < 0) {
                    peg_panicf(b, "expected non-negative integer, got %d", n);
                }
                spec_repeat(b, len, tup);
                break;
            }
            if (!janet_checktype(tup[0], JANET_SYMBOL))
                peg_panicf(b, "expected grammar command, found %v", tup[0]);
            const uint8_t *sym = janet_unwrap_symbol(tup[0]);
            const SpecialPair *sp = janet_strbinsearch(
                                        &peg_specials,
                                        sizeof(peg_specials) / sizeof(SpecialPair),
                                        sizeof(SpecialPair),
                                        sym);
            if (sp) {
                sp->special(b, len - 1, tup + 1);
            } else {
                peg_panicf(b, "unknown special %S", sym);
            }
            break;
        }
    }

    /* Increase depth again */
    b->depth++;
    b->form = old_form;
    b->grammar = old_grammar;
    return rule;
}

/*
 * Post-Compilation
 */

static int peg_mark(void *p, size_t size) {
    (void) size;
    JanetPeg *peg = (JanetPeg *)p;
    if (NULL != peg->constants)
        for (uint32_t i = 0; i < peg->num_constants; i++)
            janet_mark(peg->constants[i]);
    return 0;
}

static void peg_marshal(void *p, JanetMarshalContext *ctx) {
    JanetPeg *peg = (JanetPeg *)p;
    janet_marshal_size(ctx, peg->bytecode_len);
    janet_marshal_int(ctx, (int32_t)peg->num_constants);
    janet_marshal_abstract(ctx, p);
    for (size_t i = 0; i < peg->bytecode_len; i++)
        janet_marshal_int(ctx, (int32_t) peg->bytecode[i]);
    for (uint32_t j = 0; j < peg->num_constants; j++)
        janet_marshal_janet(ctx, peg->constants[j]);
}

/* Used to ensure that if we place several arrays in one memory chunk, each
 * array will be correctly aligned */
static size_t size_padded(size_t offset, size_t size) {
    size_t x = size + offset - 1;
    return x - (x % size);
}

static void *peg_unmarshal(JanetMarshalContext *ctx) {
    size_t bytecode_len = janet_unmarshal_size(ctx);
    uint32_t num_constants = (uint32_t) janet_unmarshal_int(ctx);

    /* Calculate offsets. Should match those in make_peg */
    size_t bytecode_start = size_padded(sizeof(JanetPeg), sizeof(uint32_t));
    size_t bytecode_size = bytecode_len * sizeof(uint32_t);
    size_t constants_start = size_padded(bytecode_start + bytecode_size, sizeof(Janet));
    size_t total_size = constants_start + sizeof(Janet) * (size_t) num_constants;

    /* DOS prevention? I.E. we could read bytecode and constants before
     * hand so we don't allocated a ton of memory on bad, short input */

    /* Allocate PEG */
    char *mem = janet_unmarshal_abstract(ctx, total_size);
    JanetPeg *peg = (JanetPeg *)mem;
    uint32_t *bytecode = (uint32_t *)(mem + bytecode_start);
    Janet *constants = (Janet *)(mem + constants_start);
    peg->bytecode = NULL;
    peg->constants = NULL;
    peg->bytecode_len = bytecode_len;
    peg->num_constants = num_constants;

    for (size_t i = 0; i < peg->bytecode_len; i++)
        bytecode[i] = (uint32_t) janet_unmarshal_int(ctx);
    for (uint32_t j = 0; j < peg->num_constants; j++)
        constants[j] = janet_unmarshal_janet(ctx);

    /* After here, no panics except for the bad: label. */

    /* Keep track at each index if an instruction was
     * reference (0x01) or is in a main bytecode position
     * (0x02). This lets us do a linear scan and not
     * need to a depth first traversal. It is stricter
     * than a dfs by not allowing certain kinds of unused
     * bytecode. */
    uint32_t blen = (int32_t) peg->bytecode_len;
    uint32_t clen = peg->num_constants;
    uint8_t *op_flags = janet_calloc(1, blen);
    if (NULL == op_flags) {
        JANET_OUT_OF_MEMORY;
    }

    /* verify peg bytecode */
    int32_t has_backref = 0;
    uint32_t i = 0;
    while (i < blen) {
        uint32_t instr = bytecode[i];
        uint32_t *rule = bytecode + i;
        op_flags[i] |= 0x02;
        switch (instr & 0x1F) {
            case RULE_LITERAL:
                i += 2 + ((rule[1] + 3) >> 2);
                break;
            case RULE_NCHAR:
            case RULE_NOTNCHAR:
            case RULE_RANGE:
            case RULE_POSITION:
            case RULE_LINE:
            case RULE_COLUMN:
                /* [1 word] */
                i += 2;
                break;
            case RULE_BACKMATCH:
                /* [1 word] */
                i += 2;
                has_backref = 1;
                break;
            case RULE_SET:
                /* [8 words] */
                i += 9;
                break;
            case RULE_LOOK:
                /* [offset, rule] */
                if (rule[2] >= blen) goto bad;
                op_flags[rule[2]] |= 0x1;
                i += 3;
                break;
            case RULE_CHOICE:
            case RULE_SEQUENCE:
                /* [len, rules...] */
            {
                uint32_t len = rule[1];
                for (uint32_t j = 0; j < len; j++) {
                    if (rule[2 + j] >= blen) goto bad;
                    op_flags[rule[2 + j]] |= 0x1;
                }
                i += 2 + len;
            }
            break;
            case RULE_IF:
            case RULE_IFNOT:
            case RULE_LENPREFIX:
                /* [rule_a, rule_b (b if not a)] */
                if (rule[1] >= blen) goto bad;
                if (rule[2] >= blen) goto bad;
                op_flags[rule[1]] |= 0x01;
                op_flags[rule[2]] |= 0x01;
                i += 3;
                break;
            case RULE_BETWEEN:
                /* [lo, hi, rule] */
                if (rule[3] >= blen) goto bad;
                op_flags[rule[3]] |= 0x01;
                i += 4;
                break;
            case RULE_ARGUMENT:
                /* [searchtag, tag] */
                i += 3;
                break;
            case RULE_GETTAG:
                /* [searchtag, tag] */
                i += 3;
                has_backref = 1;
                break;
            case RULE_CONSTANT:
                /* [constant, tag] */
                if (rule[1] >= clen) goto bad;
                i += 3;
                break;
            case RULE_CAPTURE_NUM:
                /* [rule, base, tag] */
                if (rule[1] >= blen) goto bad;
                op_flags[rule[1]] |= 0x01;
                i += 4;
                break;
            case RULE_ACCUMULATE:
            case RULE_GROUP:
            case RULE_CAPTURE:
            case RULE_UNREF:
                /* [rule, tag] */
                if (rule[1] >= blen) goto bad;
                op_flags[rule[1]] |= 0x01;
                i += 3;
                break;
            case RULE_REPLACE:
            case RULE_MATCHTIME:
                /* [rule, constant, tag] */
                if (rule[1] >= blen) goto bad;
                if (rule[2] >= clen) goto bad;
                op_flags[rule[1]] |= 0x01;
                i += 4;
                break;
            case RULE_ERROR:
            case RULE_DROP:
            case RULE_NOT:
            case RULE_TO:
            case RULE_THRU:
                /* [rule] */
                if (rule[1] >= blen) goto bad;
                op_flags[rule[1]] |= 0x01;
                i += 2;
                break;
            case RULE_READINT:
                /* [ width | (endianess << 5) | (signedness << 6), tag ] */
                if (rule[1] > JANET_MAX_READINT_WIDTH) goto bad;
                i += 3;
                break;
            default:
                goto bad;
        }
    }

    /* last instruction cannot overflow */
    if (i != blen) goto bad;

    /* Make sure all referenced instructions are actually
     * in instruction positions. */
    for (i = 0; i < blen; i++)
        if (op_flags[i] == 0x01) goto bad;

    /* Good return */
    peg->bytecode = bytecode;
    peg->constants = constants;
    peg->has_backref = has_backref;
    janet_free(op_flags);
    return peg;

bad:
    janet_free(op_flags);
    janet_panic("invalid peg bytecode");
}

static int cfun_peg_getter(JanetAbstract a, Janet key, Janet *out);
static Janet peg_next(void *p, Janet key);

const JanetAbstractType janet_peg_type = {
    "core/peg",
    NULL,
    peg_mark,
    cfun_peg_getter,
    NULL, /* put */
    peg_marshal,
    peg_unmarshal,
    NULL, /* tostring */
    NULL, /* compare */
    NULL, /* hash */
    peg_next,
    JANET_ATEND_NEXT
};

/* Convert Builder to JanetPeg (Janet Abstract Value) */
static JanetPeg *make_peg(Builder *b) {
    size_t bytecode_start = size_padded(sizeof(JanetPeg), sizeof(uint32_t));
    size_t bytecode_size = janet_v_count(b->bytecode) * sizeof(uint32_t);
    size_t constants_start = size_padded(bytecode_start + bytecode_size, sizeof(Janet));
    size_t constants_size = janet_v_count(b->constants) * sizeof(Janet);
    size_t total_size = constants_start + constants_size;
    char *mem = janet_abstract(&janet_peg_type, total_size);
    JanetPeg *peg = (JanetPeg *)mem;
    peg->bytecode = (uint32_t *)(mem + bytecode_start);
    peg->constants = (Janet *)(mem + constants_start);
    peg->num_constants = janet_v_count(b->constants);
    safe_memcpy(peg->bytecode, b->bytecode, bytecode_size);
    safe_memcpy(peg->constants, b->constants, constants_size);
    peg->bytecode_len = janet_v_count(b->bytecode);
    peg->has_backref = b->has_backref;
    return peg;
}

/* Compiler entry point */
static JanetPeg *compile_peg(Janet x) {
    Builder builder;
    builder.grammar = janet_table(0);
    builder.default_grammar = NULL;
    {
        Janet default_grammarv = janet_dyn("peg-grammar");
        if (janet_checktype(default_grammarv, JANET_TABLE)) {
            builder.default_grammar = janet_unwrap_table(default_grammarv);
        }
    }
    builder.tags = janet_table(0);
    builder.constants = NULL;
    builder.bytecode = NULL;
    builder.nexttag = 1;
    builder.form = x;
    builder.depth = JANET_RECURSION_GUARD;
    builder.has_backref = 0;
    peg_compile1(&builder, x);
    JanetPeg *peg = make_peg(&builder);
    builder_cleanup(&builder);
    return peg;
}

/*
 * C Functions
 */

JANET_CORE_FN(cfun_peg_compile,
              "(peg/compile peg)",
              "Compiles a peg source data structure into a <core/peg>. This will speed up matching "
              "if the same peg will be used multiple times. Will also use `(dyn :peg-grammar)` to suppliment "
              "the grammar of the peg for otherwise undefined peg keywords.") {
    janet_fixarity(argc, 1);
    JanetPeg *peg = compile_peg(argv[0]);
    return janet_wrap_abstract(peg);
}

/* Common data for peg cfunctions */
typedef struct {
    JanetPeg *peg;
    PegState s;
    JanetByteView bytes;
    JanetByteView repl;
    int32_t start;
} PegCall;

/* Initialize state for peg cfunctions */
static PegCall peg_cfun_init(int32_t argc, Janet *argv, int get_replace) {
    PegCall ret;
    int32_t min = get_replace ? 3 : 2;
    janet_arity(argc, get_replace, -1);
    if (janet_checktype(argv[0], JANET_ABSTRACT) &&
            janet_abstract_type(janet_unwrap_abstract(argv[0])) == &janet_peg_type) {
        ret.peg = janet_unwrap_abstract(argv[0]);
    } else {
        ret.peg = compile_peg(argv[0]);
    }
    if (get_replace) {
        ret.repl = janet_getbytes(argv, 1);
        ret.bytes = janet_getbytes(argv, 2);
    } else {
        ret.bytes = janet_getbytes(argv, 1);
    }
    if (argc > min) {
        ret.start = janet_gethalfrange(argv, min, ret.bytes.len, "offset");
        ret.s.extrac = argc - min - 1;
        ret.s.extrav = janet_tuple_n(argv + min + 1, argc - min - 1);
    } else {
        ret.start = 0;
        ret.s.extrac = 0;
        ret.s.extrav = NULL;
    }
    ret.s.mode = PEG_MODE_NORMAL;
    ret.s.text_start = ret.bytes.bytes;
    ret.s.text_end = ret.bytes.bytes + ret.bytes.len;
    ret.s.depth = JANET_RECURSION_GUARD;
    ret.s.captures = janet_array(0);
    ret.s.tagged_captures = janet_array(0);
    ret.s.scratch = janet_buffer(10);
    ret.s.tags = janet_buffer(10);
    ret.s.constants = ret.peg->constants;
    ret.s.bytecode = ret.peg->bytecode;
    ret.s.linemap = NULL;
    ret.s.linemaplen = -1;
    ret.s.has_backref = ret.peg->has_backref;
    return ret;
}

static void peg_call_reset(PegCall *c) {
    c->s.depth = JANET_RECURSION_GUARD;
    c->s.captures->count = 0;
    c->s.tagged_captures->count = 0;
    c->s.scratch->count = 0;
    c->s.tags->count = 0;
}

JANET_CORE_FN(cfun_peg_match,
              "(peg/match peg text &opt start & args)",
              "Match a Parsing Expression Grammar to a byte string and return an array of captured values. "
              "Returns nil if text does not match the language defined by peg. The syntax of PEGs is documented on the Janet website.") {
    PegCall c = peg_cfun_init(argc, argv, 0);
    const uint8_t *result = peg_rule(&c.s, c.s.bytecode, c.bytes.bytes + c.start);
    return result ? janet_wrap_array(c.s.captures) : janet_wrap_nil();
}

JANET_CORE_FN(cfun_peg_find,
              "(peg/find peg text &opt start & args)",
              "Find first index where the peg matches in text. Returns an integer, or nil if not found.") {
    PegCall c = peg_cfun_init(argc, argv, 0);
    for (int32_t i = c.start; i < c.bytes.len; i++) {
        peg_call_reset(&c);
        if (peg_rule(&c.s, c.s.bytecode, c.bytes.bytes + i))
            return janet_wrap_integer(i);
    }
    return janet_wrap_nil();
}

JANET_CORE_FN(cfun_peg_find_all,
              "(peg/find-all peg text &opt start & args)",
              "Find all indexes where the peg matches in text. Returns an array of integers.") {
    PegCall c = peg_cfun_init(argc, argv, 0);
    JanetArray *ret = janet_array(0);
    for (int32_t i = c.start; i < c.bytes.len; i++) {
        peg_call_reset(&c);
        if (peg_rule(&c.s, c.s.bytecode, c.bytes.bytes + i))
            janet_array_push(ret, janet_wrap_integer(i));
    }
    return janet_wrap_array(ret);
}

static Janet cfun_peg_replace_generic(int32_t argc, Janet *argv, int only_one) {
    PegCall c = peg_cfun_init(argc, argv, 1);
    JanetBuffer *ret = janet_buffer(0);
    int32_t trail = 0;
    for (int32_t i = c.start; i < c.bytes.len;) {
        peg_call_reset(&c);
        const uint8_t *result = peg_rule(&c.s, c.s.bytecode, c.bytes.bytes + i);
        if (NULL != result) {
            if (trail < i) {
                janet_buffer_push_bytes(ret, c.bytes.bytes + trail, (i - trail));
                trail = i;
            }
            int32_t nexti = (int32_t)(result - c.bytes.bytes);
            janet_buffer_push_bytes(ret, c.repl.bytes, c.repl.len);
            trail = nexti;
            if (nexti == i) nexti++;
            i = nexti;
            if (only_one) break;
        } else {
            i++;
        }
    }
    if (trail < c.bytes.len) {
        janet_buffer_push_bytes(ret, c.bytes.bytes + trail, (c.bytes.len - trail));
    }
    return janet_wrap_buffer(ret);
}

JANET_CORE_FN(cfun_peg_replace_all,
              "(peg/replace-all peg repl text &opt start & args)",
              "Replace all matches of peg in text with repl, returning a new buffer. The peg does not need to make captures to do replacement.") {
    return cfun_peg_replace_generic(argc, argv, 0);
}

JANET_CORE_FN(cfun_peg_replace,
              "(peg/replace peg repl text &opt start & args)",
              "Replace first match of peg in text with repl, returning a new buffer. The peg does not need to make captures to do replacement. "
              "If no matches are found, returns the input string in a new buffer.") {
    return cfun_peg_replace_generic(argc, argv, 1);
}

static JanetMethod peg_methods[] = {
    {"match", cfun_peg_match},
    {"find", cfun_peg_find},
    {"find-all", cfun_peg_find_all},
    {"replace", cfun_peg_replace},
    {"replace-all", cfun_peg_replace_all},
    {NULL, NULL}
};

static int cfun_peg_getter(JanetAbstract a, Janet key, Janet *out) {
    (void) a;
    if (!janet_checktype(key, JANET_KEYWORD))
        return 0;
    return janet_getmethod(janet_unwrap_keyword(key), peg_methods, out);
}

static Janet peg_next(void *p, Janet key) {
    (void) p;
    return janet_nextmethod(peg_methods, key);
}

/* Load the peg module */
void janet_lib_peg(JanetTable *env) {
    JanetRegExt cfuns[] = {
        JANET_CORE_REG("peg/compile", cfun_peg_compile),
        JANET_CORE_REG("peg/match", cfun_peg_match),
        JANET_CORE_REG("peg/find", cfun_peg_find),
        JANET_CORE_REG("peg/find-all", cfun_peg_find_all),
        JANET_CORE_REG("peg/replace", cfun_peg_replace),
        JANET_CORE_REG("peg/replace-all", cfun_peg_replace_all),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, cfuns);
    janet_register_abstract_type(&janet_peg_type);
}

#endif /* ifdef JANET_PEG */


/* src/core/pp.c */
#line 0 "src/core/pp.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#include "state.h"
#include <math.h>
#endif

#include <string.h>
#include <ctype.h>
#include <inttypes.h>

/* Implements a pretty printer for Janet. The pretty printer
 * is simple and not that flexible, but fast. */

/* Temporary buffer size */
#define BUFSIZE 64

static void number_to_string_b(JanetBuffer *buffer, double x) {
    janet_buffer_ensure(buffer, buffer->count + BUFSIZE, 2);
    const char *fmt = (x == floor(x) &&
                       x <= JANET_INTMAX_DOUBLE &&
                       x >= JANET_INTMIN_DOUBLE) ? "%.0f" : "%g";
    int count;
    if (x == 0.0) {
        /* Prevent printing of '-0' */
        count = 1;
        buffer->data[buffer->count] = '0';
    } else {
        count = snprintf((char *) buffer->data + buffer->count, BUFSIZE, fmt, x);
    }
    buffer->count += count;
}

/* expects non positive x */
static int count_dig10(int32_t x) {
    int result = 1;
    for (;;) {
        if (x > -10) return result;
        if (x > -100) return result + 1;
        if (x > -1000) return result + 2;
        if (x > -10000) return result + 3;
        x /= 10000;
        result += 4;
    }
}

static void integer_to_string_b(JanetBuffer *buffer, int32_t x) {
    janet_buffer_extra(buffer, BUFSIZE);
    uint8_t *buf = buffer->data + buffer->count;
    int32_t neg = 0;
    int32_t len = 0;
    if (x == 0) {
        buf[0] = '0';
        buffer->count++;
        return;
    }
    if (x > 0) {
        x = -x;
    } else {
        neg = 1;
        *buf++ = '-';
    }
    len = count_dig10(x);
    buf += len;
    while (x) {
        uint8_t digit = (uint8_t) - (x % 10);
        *(--buf) = '0' + digit;
        x /= 10;
    }
    buffer->count += len + neg;
}

#define HEX(i) (((uint8_t *) janet_base64)[(i)])

/* Returns a string description for a pointer. Truncates
 * title to 32 characters */
static void string_description_b(JanetBuffer *buffer, const char *title, void *pointer) {
    janet_buffer_ensure(buffer, buffer->count + BUFSIZE, 2);
    uint8_t *c = buffer->data + buffer->count;
    int32_t i;
    union {
        uint8_t bytes[sizeof(void *)];
        void *p;
    } pbuf;

    pbuf.p = pointer;
    *c++ = '<';
    /* Maximum of 32 bytes for abstract type name */
    for (i = 0; title[i] && i < 32; ++i)
        *c++ = ((uint8_t *)title) [i];
    *c++ = ' ';
    *c++ = '0';
    *c++ = 'x';
#if defined(JANET_64)
#define POINTSIZE 6
#else
#define POINTSIZE (sizeof(void *))
#endif
    for (i = POINTSIZE; i > 0; --i) {
        uint8_t byte = pbuf.bytes[i - 1];
        *c++ = HEX(byte >> 4);
        *c++ = HEX(byte & 0xF);
    }
    *c++ = '>';
    buffer->count = (int32_t)(c - buffer->data);
#undef POINTSIZE
}

static void janet_escape_string_impl(JanetBuffer *buffer, const uint8_t *str, int32_t len) {
    janet_buffer_push_u8(buffer, '"');
    for (int32_t i = 0; i < len; ++i) {
        uint8_t c = str[i];
        switch (c) {
            case '"':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\\"", 2);
                break;
            case '\n':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\n", 2);
                break;
            case '\r':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\r", 2);
                break;
            case '\0':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\0", 2);
                break;
            case '\f':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\f", 2);
                break;
            case '\v':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\v", 2);
                break;
            case 27:
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\e", 2);
                break;
            case '\\':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\\\", 2);
                break;
            case '\t':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\t", 2);
                break;
            default:
                if (c < 32 || c > 126) {
                    uint8_t buf[4];
                    buf[0] = '\\';
                    buf[1] = 'x';
                    buf[2] = janet_base64[(c >> 4) & 0xF];
                    buf[3] = janet_base64[c & 0xF];
                    janet_buffer_push_bytes(buffer, buf, 4);
                } else {
                    janet_buffer_push_u8(buffer, c);
                }
                break;
        }
    }
    janet_buffer_push_u8(buffer, '"');
}

static void janet_escape_string_b(JanetBuffer *buffer, const uint8_t *str) {
    janet_escape_string_impl(buffer, str, janet_string_length(str));
}

static void janet_escape_buffer_b(JanetBuffer *buffer, JanetBuffer *bx) {
    if (bx == buffer) {
        /* Ensures buffer won't resize while escaping */
        janet_buffer_ensure(bx, bx->count + 5 * bx->count + 3, 1);
    }
    janet_buffer_push_u8(buffer, '@');
    janet_escape_string_impl(buffer, bx->data, bx->count);
}

void janet_to_string_b(JanetBuffer *buffer, Janet x) {
    switch (janet_type(x)) {
        case JANET_NIL:
            janet_buffer_push_cstring(buffer, "");
            break;
        case JANET_BOOLEAN:
            janet_buffer_push_cstring(buffer,
                                      janet_unwrap_boolean(x) ? "true" : "false");
            break;
        case JANET_NUMBER:
            number_to_string_b(buffer, janet_unwrap_number(x));
            break;
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            janet_buffer_push_bytes(buffer,
                                    janet_unwrap_string(x),
                                    janet_string_length(janet_unwrap_string(x)));
            break;
        case JANET_BUFFER: {
            JanetBuffer *to = janet_unwrap_buffer(x);
            /* Prevent resizing buffer while appending */
            if (buffer == to) janet_buffer_extra(buffer, to->count);
            janet_buffer_push_bytes(buffer, to->data, to->count);
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstract p = janet_unwrap_abstract(x);
            const JanetAbstractType *t = janet_abstract_type(p);
            if (t->tostring != NULL) {
                t->tostring(p, buffer);
            } else {
                string_description_b(buffer, t->name, p);
            }
        }
        return;
        case JANET_CFUNCTION: {
            JanetCFunRegistry *reg = janet_registry_get(janet_unwrap_cfunction(x));
            if (NULL != reg) {
                janet_buffer_push_cstring(buffer, "<cfunction ");
                if (NULL != reg->name_prefix) {
                    janet_buffer_push_cstring(buffer, reg->name_prefix);
                    janet_buffer_push_u8(buffer, '/');
                }
                janet_buffer_push_cstring(buffer, reg->name);
                janet_buffer_push_u8(buffer, '>');
                break;
            }
            goto fallthrough;
        }
        case JANET_FUNCTION: {
            JanetFunction *fun = janet_unwrap_function(x);
            JanetFuncDef *def = fun->def;
            if (def->name) {
                const uint8_t *n = def->name;
                janet_buffer_push_cstring(buffer, "<function ");
                janet_buffer_push_bytes(buffer, n, janet_string_length(n));
                janet_buffer_push_u8(buffer, '>');
                break;
            }
            goto fallthrough;
        }
    fallthrough:
        default:
            string_description_b(buffer, janet_type_names[janet_type(x)], janet_unwrap_pointer(x));
            break;
    }
}

/* See parse.c for full table */

/* Check if a symbol or keyword contains no symbol characters */
static int contains_bad_chars(const uint8_t *sym, int issym) {
    int32_t len = janet_string_length(sym);
    if (len && issym && sym[0] >= '0' && sym[0] <= '9') return 1;
    if (!janet_valid_utf8(sym, len)) return 1;
    for (int32_t i = 0; i < len; i++) {
        if (!janet_is_symbol_char(sym[i])) return 1;
    }
    return 0;
}

void janet_description_b(JanetBuffer *buffer, Janet x) {
    switch (janet_type(x)) {
        default:
            break;
        case JANET_NIL:
            janet_buffer_push_cstring(buffer, "nil");
            return;
        case JANET_KEYWORD:
            janet_buffer_push_u8(buffer, ':');
            break;
        case JANET_STRING:
            janet_escape_string_b(buffer, janet_unwrap_string(x));
            return;
        case JANET_BUFFER: {
            JanetBuffer *b = janet_unwrap_buffer(x);
            janet_escape_buffer_b(buffer, b);
            return;
        }
        case JANET_ABSTRACT: {
            JanetAbstract p = janet_unwrap_abstract(x);
            const JanetAbstractType *t = janet_abstract_type(p);
            if (t->tostring != NULL) {
                janet_buffer_push_cstring(buffer, "<");
                janet_buffer_push_cstring(buffer, t->name);
                janet_buffer_push_cstring(buffer, " ");
                t->tostring(p, buffer);
                janet_buffer_push_cstring(buffer, ">");
            } else {
                string_description_b(buffer, t->name, p);
            }
            return;
        }
    }
    janet_to_string_b(buffer, x);
}

const uint8_t *janet_description(Janet x) {
    JanetBuffer b;
    janet_buffer_init(&b, 10);
    janet_description_b(&b, x);
    const uint8_t *ret = janet_string(b.data, b.count);
    janet_buffer_deinit(&b);
    return ret;
}

/* Convert any value to a janet string. Similar to description, but
 * strings, symbols, and buffers will return their content. */
const uint8_t *janet_to_string(Janet x) {
    switch (janet_type(x)) {
        default: {
            JanetBuffer b;
            janet_buffer_init(&b, 10);
            janet_to_string_b(&b, x);
            const uint8_t *ret = janet_string(b.data, b.count);
            janet_buffer_deinit(&b);
            return ret;
        }
        case JANET_BUFFER:
            return janet_string(janet_unwrap_buffer(x)->data, janet_unwrap_buffer(x)->count);
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            return janet_unwrap_string(x);
    }
}

/* Hold state for pretty printer. */
struct pretty {
    JanetBuffer *buffer;
    int depth;
    int indent;
    int flags;
    int32_t bufstartlen;
    int32_t *keysort_buffer;
    int32_t keysort_capacity;
    int32_t keysort_start;
    JanetTable seen;
};

/* Print jdn format */
static int print_jdn_one(struct pretty *S, Janet x, int depth) {
    if (depth == 0) return 1;
    switch (janet_type(x)) {
        case JANET_NIL:
        case JANET_BOOLEAN:
        case JANET_BUFFER:
        case JANET_STRING:
            janet_description_b(S->buffer, x);
            break;
        case JANET_NUMBER:
            janet_buffer_ensure(S->buffer, S->buffer->count + BUFSIZE, 2);
            int count = snprintf((char *) S->buffer->data + S->buffer->count, BUFSIZE, "%.17g", janet_unwrap_number(x));
            S->buffer->count += count;
            break;
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            if (contains_bad_chars(janet_unwrap_keyword(x), janet_type(x) == JANET_SYMBOL)) return 1;
            janet_description_b(S->buffer, x);
            break;
        case JANET_TUPLE: {
            JanetTuple t = janet_unwrap_tuple(x);
            int isb = janet_tuple_flag(t) & JANET_TUPLE_FLAG_BRACKETCTOR;
            janet_buffer_push_u8(S->buffer, isb ? '[' : '(');
            for (int32_t i = 0; i < janet_tuple_length(t); i++) {
                if (i) janet_buffer_push_u8(S->buffer, ' ');
                if (print_jdn_one(S, t[i], depth - 1)) return 1;
            }
            janet_buffer_push_u8(S->buffer, isb ? ']' : ')');
        }
        break;
        case JANET_ARRAY: {
            janet_table_put(&S->seen, x, janet_wrap_true());
            JanetArray *a = janet_unwrap_array(x);
            janet_buffer_push_cstring(S->buffer, "@[");
            for (int32_t i = 0; i < a->count; i++) {
                if (i) janet_buffer_push_u8(S->buffer, ' ');
                if (print_jdn_one(S, a->data[i], depth - 1)) return 1;
            }
            janet_buffer_push_u8(S->buffer, ']');
        }
        break;
        case JANET_TABLE: {
            janet_table_put(&S->seen, x, janet_wrap_true());
            JanetTable *tab = janet_unwrap_table(x);
            janet_buffer_push_cstring(S->buffer, "@{");
            int isFirst = 1;
            for (int32_t i = 0; i < tab->capacity; i++) {
                const JanetKV *kv = tab->data + i;
                if (janet_checktype(kv->key, JANET_NIL)) continue;
                if (!isFirst) janet_buffer_push_u8(S->buffer, ' ');
                isFirst = 0;
                if (print_jdn_one(S, kv->key, depth - 1)) return 1;
                janet_buffer_push_u8(S->buffer, ' ');
                if (print_jdn_one(S, kv->value, depth - 1)) return 1;
            }
            janet_buffer_push_u8(S->buffer, '}');
        }
        break;
        case JANET_STRUCT: {
            JanetStruct st = janet_unwrap_struct(x);
            janet_buffer_push_u8(S->buffer, '{');
            int isFirst = 1;
            for (int32_t i = 0; i < janet_struct_capacity(st); i++) {
                const JanetKV *kv = st + i;
                if (janet_checktype(kv->key, JANET_NIL)) continue;
                if (!isFirst) janet_buffer_push_u8(S->buffer, ' ');
                isFirst = 0;
                if (print_jdn_one(S, kv->key, depth - 1)) return 1;
                janet_buffer_push_u8(S->buffer, ' ');
                if (print_jdn_one(S, kv->value, depth - 1)) return 1;
            }
            janet_buffer_push_u8(S->buffer, '}');
        }
        break;
        default:
            return 1;
    }
    return 0;
}

static void print_newline(struct pretty *S, int just_a_space) {
    int i;
    if (just_a_space || (S->flags & JANET_PRETTY_ONELINE)) {
        janet_buffer_push_u8(S->buffer, ' ');
        return;
    }
    janet_buffer_push_u8(S->buffer, '\n');
    for (i = 0; i < S->indent; i++) {
        janet_buffer_push_u8(S->buffer, ' ');
    }
}

/* Color coding for types */
static const char janet_cycle_color[] = "\x1B[36m";
static const char janet_class_color[] = "\x1B[34m";
static const char *janet_pretty_colors[] = {
    "\x1B[32m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[35m",
    "\x1B[34m",
    "\x1B[33m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[35m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m"
};

#define JANET_PRETTY_DICT_ONELINE 4
#define JANET_PRETTY_IND_ONELINE 10
#define JANET_PRETTY_DICT_LIMIT 30
#define JANET_PRETTY_ARRAY_LIMIT 160

/* Helper for pretty printing */
static void janet_pretty_one(struct pretty *S, Janet x, int is_dict_value) {
    /* Add to seen */
    switch (janet_type(x)) {
        case JANET_NIL:
        case JANET_NUMBER:
        case JANET_SYMBOL:
        case JANET_BOOLEAN:
            break;
        default: {
            Janet seenid = janet_table_get(&S->seen, x);
            if (janet_checktype(seenid, JANET_NUMBER)) {
                if (S->flags & JANET_PRETTY_COLOR) {
                    janet_buffer_push_cstring(S->buffer, janet_cycle_color);
                }
                janet_buffer_push_cstring(S->buffer, "<cycle ");
                integer_to_string_b(S->buffer, janet_unwrap_integer(seenid));
                janet_buffer_push_u8(S->buffer, '>');
                if (S->flags & JANET_PRETTY_COLOR) {
                    janet_buffer_push_cstring(S->buffer, "\x1B[0m");
                }
                return;
            } else {
                janet_table_put(&S->seen, x, janet_wrap_integer(S->seen.count));
                break;
            }
        }
    }

    switch (janet_type(x)) {
        default: {
            const char *color = janet_pretty_colors[janet_type(x)];
            if (color && (S->flags & JANET_PRETTY_COLOR)) {
                janet_buffer_push_cstring(S->buffer, color);
            }
            if (janet_checktype(x, JANET_BUFFER) && janet_unwrap_buffer(x) == S->buffer) {
                janet_buffer_ensure(S->buffer, S->buffer->count + S->bufstartlen * 4 + 3, 1);
                janet_buffer_push_u8(S->buffer, '@');
                janet_escape_string_impl(S->buffer, S->buffer->data, S->bufstartlen);
            } else {
                janet_description_b(S->buffer, x);
            }
            if (color && (S->flags & JANET_PRETTY_COLOR)) {
                janet_buffer_push_cstring(S->buffer, "\x1B[0m");
            }
            break;
        }
        case JANET_ARRAY:
        case JANET_TUPLE: {
            int32_t i = 0, len = 0;
            const Janet *arr = NULL;
            int isarray = janet_checktype(x, JANET_ARRAY);
            janet_indexed_view(x, &arr, &len);
            int hasbrackets = !isarray && (janet_tuple_flag(arr) & JANET_TUPLE_FLAG_BRACKETCTOR);
            const char *startstr = isarray ? "@[" : hasbrackets ? "[" : "(";
            const char endchar = isarray ? ']' : hasbrackets ? ']' : ')';
            janet_buffer_push_cstring(S->buffer, startstr);
            S->depth--;
            S->indent += 2;
            if (S->depth == 0) {
                janet_buffer_push_cstring(S->buffer, "...");
            } else {
                if (!isarray && !(S->flags & JANET_PRETTY_ONELINE) && len >= JANET_PRETTY_IND_ONELINE)
                    janet_buffer_push_u8(S->buffer, ' ');
                if (is_dict_value && len >= JANET_PRETTY_IND_ONELINE) print_newline(S, 0);
                if (len > JANET_PRETTY_ARRAY_LIMIT && !(S->flags & JANET_PRETTY_NOTRUNC)) {
                    for (i = 0; i < 3; i++) {
                        if (i) print_newline(S, 0);
                        janet_pretty_one(S, arr[i], 0);
                    }
                    print_newline(S, 0);
                    janet_buffer_push_cstring(S->buffer, "...");
                    for (i = 0; i < 3; i++) {
                        print_newline(S, 0);
                        janet_pretty_one(S, arr[len - 3 + i], 0);
                    }
                } else {
                    for (i = 0; i < len; i++) {
                        if (i) print_newline(S, len < JANET_PRETTY_IND_ONELINE);
                        janet_pretty_one(S, arr[i], 0);
                    }
                }
            }
            S->indent -= 2;
            S->depth++;
            janet_buffer_push_u8(S->buffer, endchar);
            break;
        }
        case JANET_STRUCT:
        case JANET_TABLE: {
            int istable = janet_checktype(x, JANET_TABLE);

            /* For object-like tables, print class name */
            if (istable) {
                JanetTable *t = janet_unwrap_table(x);
                JanetTable *proto = t->proto;
                janet_buffer_push_cstring(S->buffer, "@");
                if (NULL != proto) {
                    Janet name = janet_table_get(proto, janet_ckeywordv("_name"));
                    const uint8_t *n;
                    int32_t len;
                    if (janet_bytes_view(name, &n, &len)) {
                        if (S->flags & JANET_PRETTY_COLOR) {
                            janet_buffer_push_cstring(S->buffer, janet_class_color);
                        }
                        janet_buffer_push_bytes(S->buffer, n, len);
                        if (S->flags & JANET_PRETTY_COLOR) {
                            janet_buffer_push_cstring(S->buffer, "\x1B[0m");
                        }
                    }
                }
            } else {
                JanetStruct st = janet_unwrap_struct(x);
                JanetStruct proto = janet_struct_proto(st);
                if (NULL != proto) {
                    Janet name = janet_struct_get(proto, janet_ckeywordv("_name"));
                    const uint8_t *n;
                    int32_t len;
                    if (janet_bytes_view(name, &n, &len)) {
                        if (S->flags & JANET_PRETTY_COLOR) {
                            janet_buffer_push_cstring(S->buffer, janet_class_color);
                        }
                        janet_buffer_push_bytes(S->buffer, n, len);
                        if (S->flags & JANET_PRETTY_COLOR) {
                            janet_buffer_push_cstring(S->buffer, "\x1B[0m");
                        }
                    }
                }
            }
            janet_buffer_push_cstring(S->buffer, "{");

            S->depth--;
            S->indent += 2;
            if (S->depth == 0) {
                janet_buffer_push_cstring(S->buffer, "...");
            } else {
                int32_t i = 0, len = 0, cap = 0;
                const JanetKV *kvs = NULL;
                janet_dictionary_view(x, &kvs, &len, &cap);
                if (!istable && !(S->flags & JANET_PRETTY_ONELINE) && len >= JANET_PRETTY_DICT_ONELINE)
                    janet_buffer_push_u8(S->buffer, ' ');
                if (is_dict_value && len >= JANET_PRETTY_DICT_ONELINE) print_newline(S, 0);
                int32_t ks_start = S->keysort_start;

                /* Ensure buffer is large enough to sort keys. */
                int truncated = 0;
                int64_t mincap = (int64_t) len + (int64_t) ks_start;
                if (mincap > INT32_MAX) {
                    truncated = 1;
                    len = 0;
                    mincap = ks_start;
                }

                if (S->keysort_capacity < mincap) {
                    if (mincap >= INT32_MAX / 2) {
                        S->keysort_capacity = INT32_MAX;
                    } else {
                        S->keysort_capacity = (int32_t)(mincap * 2);
                    }
                    S->keysort_buffer = janet_srealloc(S->keysort_buffer, sizeof(int32_t) * S->keysort_capacity);
                    if (NULL == S->keysort_buffer) {
                        JANET_OUT_OF_MEMORY;
                    }
                }

                janet_sorted_keys(kvs, cap, S->keysort_buffer + ks_start);
                S->keysort_start += len;
                if (!(S->flags & JANET_PRETTY_NOTRUNC) && (len > JANET_PRETTY_DICT_LIMIT)) {
                    len = JANET_PRETTY_DICT_LIMIT;
                    truncated = 1;
                }

                for (i = 0; i < len; i++) {
                    if (i) print_newline(S, len < JANET_PRETTY_DICT_ONELINE);
                    int32_t j = S->keysort_buffer[i + ks_start];
                    janet_pretty_one(S, kvs[j].key, 0);
                    janet_buffer_push_u8(S->buffer, ' ');
                    janet_pretty_one(S, kvs[j].value, 1);
                }

                if (truncated) {
                    print_newline(S, 0);
                    janet_buffer_push_cstring(S->buffer, "...");
                }

                S->keysort_start = ks_start;
            }
            S->indent -= 2;
            S->depth++;
            janet_buffer_push_u8(S->buffer, '}');
            break;
        }
    }
    /* Remove from seen */
    janet_table_remove(&S->seen, x);
    return;
}

static JanetBuffer *janet_pretty_(JanetBuffer *buffer, int depth, int flags, Janet x, int32_t startlen) {
    struct pretty S;
    if (NULL == buffer) {
        buffer = janet_buffer(0);
    }
    S.buffer = buffer;
    S.depth = depth;
    S.indent = 0;
    S.flags = flags;
    S.bufstartlen = startlen;
    S.keysort_capacity = 0;
    S.keysort_buffer = NULL;
    S.keysort_start = 0;
    janet_table_init(&S.seen, 10);
    janet_pretty_one(&S, x, 0);
    janet_table_deinit(&S.seen);
    return S.buffer;
}

/* Helper for printing a janet value in a pretty form. Not meant to be used
 * for serialization or anything like that. */
JanetBuffer *janet_pretty(JanetBuffer *buffer, int depth, int flags, Janet x) {
    return janet_pretty_(buffer, depth, flags, x, buffer ? buffer->count : 0);
}

static JanetBuffer *janet_jdn_(JanetBuffer *buffer, int depth, Janet x, int32_t startlen) {
    struct pretty S;
    if (NULL == buffer) {
        buffer = janet_buffer(0);
    }
    S.buffer = buffer;
    S.depth = depth;
    S.indent = 0;
    S.flags = 0;
    S.bufstartlen = startlen;
    S.keysort_capacity = 0;
    S.keysort_buffer = NULL;
    S.keysort_start = 0;
    janet_table_init(&S.seen, 10);
    int res = print_jdn_one(&S, x, depth);
    janet_table_deinit(&S.seen);
    if (res) {
        janet_panic("could not print to jdn format");
    }
    return S.buffer;
}

JanetBuffer *janet_jdn(JanetBuffer *buffer, int depth, Janet x) {
    return janet_jdn_(buffer, depth, x, buffer ? buffer->count : 0);
}

static const char *typestr(Janet x) {
    JanetType t = janet_type(x);
    return (t == JANET_ABSTRACT)
           ? janet_abstract_type(janet_unwrap_abstract(x))->name
           : janet_type_names[t];
}

static void pushtypes(JanetBuffer *buffer, int types) {
    int first = 1;
    int i = 0;
    while (types) {
        if (1 & types) {
            if (first) {
                first = 0;
            } else {
                janet_buffer_push_u8(buffer, '|');
            }
            janet_buffer_push_cstring(buffer, janet_type_names[i]);
        }
        i++;
        types >>= 1;
    }
}

/*
 * code adapted from lua/lstrlib.c http://lua.org
 */

#define MAX_ITEM  256
#define FMT_FLAGS "-+ #0"
#define FMT_REPLACE_INTTYPES "diouxX"
#define MAX_FORMAT 32

struct FmtMapping {
    char c;
    const char *mapping;
};

/* Janet uses fixed width integer types for most things, so map
 * format specifiers to these fixed sizes */
static const struct FmtMapping format_mappings[] = {
    {'d', PRId64},
    {'i', PRIi64},
    {'o', PRIo64},
    {'u', PRIu64},
    {'x', PRIx64},
    {'X', PRIX64},
};

static const char *get_fmt_mapping(char c) {
    for (size_t i = 0; i < (sizeof(format_mappings) / sizeof(struct FmtMapping)); i++) {
        if (format_mappings[i].c == c)
            return format_mappings[i].mapping;
    }
    return NULL;
}

static const char *scanformat(
    const char *strfrmt,
    char *form,
    char width[3],
    char precision[3]) {
    const char *p = strfrmt;

    /* Parse strfrmt */
    memset(width, '\0', 3);
    memset(precision, '\0', 3);
    while (*p != '\0' && strchr(FMT_FLAGS, *p) != NULL)
        p++; /* skip flags */
    if ((size_t)(p - strfrmt) >= sizeof(FMT_FLAGS)) janet_panic("invalid format (repeated flags)");
    if (isdigit((int)(*p)))
        width[0] = *p++; /* skip width */
    if (isdigit((int)(*p)))
        width[1] = *p++; /* (2 digits at most) */
    if (*p == '.') {
        p++;
        if (isdigit((int)(*p)))
            precision[0] = *p++; /* skip precision */
        if (isdigit((int)(*p)))
            precision[1] = *p++; /* (2 digits at most) */
    }
    if (isdigit((int)(*p)))
        janet_panic("invalid format (width or precision too long)");

    /* Write to form - replace characters with fixed size stuff */
    *(form++) = '%';
    const char *p2 = strfrmt;
    while (p2 <= p) {
        if (strchr(FMT_REPLACE_INTTYPES, *p2) != NULL) {
            const char *mapping = get_fmt_mapping(*p2++);
            size_t len = strlen(mapping);
            strcpy(form, mapping);
            form += len;
        } else {
            *(form++) = *(p2++);
        }
    }
    *form = '\0';

    return p;
}

void janet_formatbv(JanetBuffer *b, const char *format, va_list args) {
    const char *format_end = format + strlen(format);
    const char *c = format;
    int32_t startlen = b->count;
    while (c < format_end) {
        if (*c != '%') {
            janet_buffer_push_u8(b, (uint8_t) *c++);
        } else if (*++c == '%') {
            janet_buffer_push_u8(b, (uint8_t) *c++);
        } else {
            char form[MAX_FORMAT], item[MAX_ITEM];
            char width[3], precision[3];
            int nb = 0; /* number of bytes in added item */
            c = scanformat(c, form, width, precision);
            switch (*c++) {
                case 'c': {
                    int n = va_arg(args, long);
                    nb = snprintf(item, MAX_ITEM, form, n);
                    break;
                }
                case 'd':
                case 'i': {
                    int64_t n = va_arg(args, long);
                    nb = snprintf(item, MAX_ITEM, form, n);
                    break;
                }
                case 'x':
                case 'X':
                case 'o':
                case 'u': {
                    uint64_t n = va_arg(args, unsigned long);
                    nb = snprintf(item, MAX_ITEM, form, n);
                    break;
                }
                case 'a':
                case 'A':
                case 'e':
                case 'E':
                case 'f':
                case 'g':
                case 'G': {
                    double d = va_arg(args, double);
                    nb = snprintf(item, MAX_ITEM, form, d);
                    break;
                }
                case 's':
                case 'S': {
                    const char *str = va_arg(args, const char *);
                    int32_t len = c[-1] == 's'
                                  ? (int32_t) strlen(str)
                                  : janet_string_length((JanetString) str);
                    if (form[2] == '\0')
                        janet_buffer_push_bytes(b, (const uint8_t *) str, len);
                    else {
                        if (len != (int32_t) strlen((const char *) str))
                            janet_panic("string contains zeros");
                        if (!strchr(form, '.') && len >= 100) {
                            janet_panic("no precision and string is too long to be formatted");
                        } else {
                            nb = snprintf(item, MAX_ITEM, form, str);
                        }
                    }
                    break;
                }
                case 'V':
                    janet_to_string_b(b, va_arg(args, Janet));
                    break;
                case 'v':
                    janet_description_b(b, va_arg(args, Janet));
                    break;
                case 't':
                    janet_buffer_push_cstring(b, typestr(va_arg(args, Janet)));
                    break;
                case 'T': {
                    int types = va_arg(args, long);
                    pushtypes(b, types);
                    break;
                }
                case 'M':
                case 'm':
                case 'N':
                case 'n':
                case 'Q':
                case 'q':
                case 'P':
                case 'p': { /* janet pretty , precision = depth */
                    int depth = atoi(precision);
                    if (depth < 1) depth = JANET_RECURSION_GUARD;
                    char d = c[-1];
                    int has_color = (d == 'P') || (d == 'Q') || (d == 'M') || (d == 'N');
                    int has_oneline = (d == 'Q') || (d == 'q') || (d == 'N') || (d == 'n');
                    int has_notrunc = (d == 'M') || (d == 'm') || (d == 'N') || (d == 'n');
                    int flags = 0;
                    flags |= has_color ? JANET_PRETTY_COLOR : 0;
                    flags |= has_oneline ? JANET_PRETTY_ONELINE : 0;
                    flags |= has_notrunc ? JANET_PRETTY_NOTRUNC : 0;
                    janet_pretty_(b, depth, flags, va_arg(args, Janet), startlen);
                    break;
                }
                case 'j': {
                    int depth = atoi(precision);
                    if (depth < 1)
                        depth = JANET_RECURSION_GUARD;
                    janet_jdn_(b, depth, va_arg(args, Janet), startlen);
                    break;
                }
                default: {
                    /* also treat cases 'nLlh' */
                    janet_panicf("invalid conversion '%s' to 'format'",
                                 form);
                }
            }
            if (nb >= MAX_ITEM)
                janet_panic("format buffer overflow");
            if (nb > 0)
                janet_buffer_push_bytes(b, (uint8_t *) item, nb);
        }

    }
}

/* Helper function for formatting strings. Useful for generating error messages and the like.
 * Similar to printf, but specialized for operating with janet. */
const uint8_t *janet_formatc(const char *format, ...) {
    va_list args;
    const uint8_t *ret;
    JanetBuffer buffer;
    int32_t len = 0;

    /* Calculate length, init buffer and args */
    while (format[len]) len++;
    janet_buffer_init(&buffer, len);
    va_start(args, format);

    /* Run format */
    janet_formatbv(&buffer, format, args);

    /* Iterate length */
    va_end(args);

    ret = janet_string(buffer.data, buffer.count);
    janet_buffer_deinit(&buffer);
    return ret;
}

JanetBuffer *janet_formatb(JanetBuffer *buffer, const char *format, ...) {
    va_list args;
    va_start(args, format);
    janet_formatbv(buffer, format, args);
    va_end(args);
    return buffer;
}

/* Shared implementation between string/format and
 * buffer/format */
void janet_buffer_format(
    JanetBuffer *b,
    const char *strfrmt,
    int32_t argstart,
    int32_t argc,
    Janet *argv) {
    size_t sfl = strlen(strfrmt);
    const char *strfrmt_end = strfrmt + sfl;
    int32_t arg = argstart;
    int32_t startlen = b->count;
    while (strfrmt < strfrmt_end) {
        if (*strfrmt != '%')
            janet_buffer_push_u8(b, (uint8_t) * strfrmt++);
        else if (*++strfrmt == '%')
            janet_buffer_push_u8(b, (uint8_t) * strfrmt++); /* %% */
        else { /* format item */
            char form[MAX_FORMAT], item[MAX_ITEM];
            char width[3], precision[3];
            int nb = 0; /* number of bytes in added item */
            if (++arg >= argc)
                janet_panic("not enough values for format");
            strfrmt = scanformat(strfrmt, form, width, precision);
            switch (*strfrmt++) {
                case 'c': {
                    nb = snprintf(item, MAX_ITEM, form, (int)
                                  janet_getinteger(argv, arg));
                    break;
                }
                case 'd':
                case 'i': {
                    int64_t n = janet_getinteger64(argv, arg);
                    nb = snprintf(item, MAX_ITEM, form, n);
                    break;
                }
                case 'x':
                case 'X':
                case 'o':
                case 'u': {
                    uint64_t n = janet_getuinteger64(argv, arg);
                    nb = snprintf(item, MAX_ITEM, form, n);
                    break;
                }
                case 'a':
                case 'A':
                case 'e':
                case 'E':
                case 'f':
                case 'g':
                case 'G': {
                    double d = janet_getnumber(argv, arg);
                    nb = snprintf(item, MAX_ITEM, form, d);
                    break;
                }
                case 's': {
                    JanetByteView bytes = janet_getbytes(argv, arg);
                    const uint8_t *s = bytes.bytes;
                    int32_t l = bytes.len;
                    if (form[2] == '\0')
                        janet_buffer_push_bytes(b, s, l);
                    else {
                        if (l != (int32_t) strlen((const char *) s))
                            janet_panic("string contains zeros");
                        if (!strchr(form, '.') && l >= 100) {
                            janet_panic("no precision and string is too long to be formatted");
                        } else {
                            nb = snprintf(item, MAX_ITEM, form, s);
                        }
                    }
                    break;
                }
                case 'V': {
                    janet_to_string_b(b, argv[arg]);
                    break;
                }
                case 'v': {
                    janet_description_b(b, argv[arg]);
                    break;
                }
                case 't':
                    janet_buffer_push_cstring(b, typestr(argv[arg]));
                    break;
                case 'M':
                case 'm':
                case 'N':
                case 'n':
                case 'Q':
                case 'q':
                case 'P':
                case 'p': { /* janet pretty , precision = depth */
                    int depth = atoi(precision);
                    if (depth < 1) depth = JANET_RECURSION_GUARD;
                    char d = strfrmt[-1];
                    int has_color = (d == 'P') || (d == 'Q') || (d == 'M') || (d == 'N');
                    int has_oneline = (d == 'Q') || (d == 'q') || (d == 'N') || (d == 'n');
                    int has_notrunc = (d == 'M') || (d == 'm') || (d == 'N') || (d == 'n');
                    int flags = 0;
                    flags |= has_color ? JANET_PRETTY_COLOR : 0;
                    flags |= has_oneline ? JANET_PRETTY_ONELINE : 0;
                    flags |= has_notrunc ? JANET_PRETTY_NOTRUNC : 0;
                    janet_pretty_(b, depth, flags, argv[arg], startlen);
                    break;
                }
                case 'j': {
                    int depth = atoi(precision);
                    if (depth < 1)
                        depth = JANET_RECURSION_GUARD;
                    janet_jdn_(b, depth, argv[arg], startlen);
                    break;
                }
                default: {
                    /* also treat cases 'nLlh' */
                    janet_panicf("invalid conversion '%s' to 'format'",
                                 form);
                }
            }
            if (nb >= MAX_ITEM)
                janet_panic("format buffer overflow");
            if (nb > 0)
                janet_buffer_push_bytes(b, (uint8_t *) item, nb);
        }
    }
}

#undef HEX
#undef BUFSIZE


/* src/core/regalloc.c */
#line 0 "src/core/regalloc.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "regalloc.h"
#include "util.h"
#endif

void janetc_regalloc_init(JanetcRegisterAllocator *ra) {
    ra->chunks = NULL;
    ra->count = 0;
    ra->capacity = 0;
    ra->max = 0;
    ra->regtemps = 0;
}

void janetc_regalloc_deinit(JanetcRegisterAllocator *ra) {
    janet_free(ra->chunks);
}

/* Fallbacks for when ctz not available */
#ifdef __GNUC__
#define count_trailing_zeros(x) __builtin_ctz(x)
#define count_trailing_ones(x) __builtin_ctz(~(x))
#else
static int32_t count_trailing_ones(uint32_t x) {
    int32_t ret = 0;
    while (x & 1) {
        ret++;
        x >>= 1;
    }
    return ret;
}
#define count_trailing_zeros(x) count_trailing_ones(~(x))
#endif

/* Get ith bit */
#define ithbit(I) ((uint32_t)1 << (I))

/* Get N bits */
#define nbits(N) (ithbit(N) - 1)

/* Copy a register allocator */
void janetc_regalloc_clone(JanetcRegisterAllocator *dest, JanetcRegisterAllocator *src) {
    size_t size;
    dest->count = src->count;
    dest->capacity = src->capacity;
    dest->max = src->max;
    size = sizeof(uint32_t) * (size_t) dest->capacity;
    dest->regtemps = 0;
    if (size) {
        dest->chunks = janet_malloc(size);
        if (!dest->chunks) {
            JANET_OUT_OF_MEMORY;
        }
        memcpy(dest->chunks, src->chunks, size);
    } else {
        dest->chunks = NULL;
    }
}

/* Allocate one more chunk in chunks */
static void pushchunk(JanetcRegisterAllocator *ra) {
    /* Registers 240-255 are always allocated (reserved) */
    uint32_t chunk = ra->count == 7 ? 0xFFFF0000 : 0;
    int32_t newcount = ra->count + 1;
    if (newcount > ra->capacity) {
        int32_t newcapacity = newcount * 2;
        ra->chunks = janet_realloc(ra->chunks, (size_t) newcapacity * sizeof(uint32_t));
        if (!ra->chunks) {
            JANET_OUT_OF_MEMORY;
        }
        ra->capacity = newcapacity;
    }
    ra->chunks[ra->count] = chunk;
    ra->count = newcount;
}

/* Reallocate a given register */
void janetc_regalloc_touch(JanetcRegisterAllocator *ra, int32_t reg) {
    int32_t chunk = reg >> 5;
    int32_t bit = reg & 0x1F;
    while (chunk >= ra->count) pushchunk(ra);
    ra->chunks[chunk] |= ithbit(bit);
}

/* Allocate one register. */
int32_t janetc_regalloc_1(JanetcRegisterAllocator *ra) {
    /* Get the nth bit in the array */
    int32_t bit, chunk, nchunks, reg;
    bit = -1;
    nchunks = ra->count;
    for (chunk = 0; chunk < nchunks; chunk++) {
        uint32_t block = ra->chunks[chunk];
        if (block == 0xFFFFFFFF) continue;
        bit = count_trailing_ones(block);
        break;
    }
    /* No reg found */
    if (bit == -1) {
        pushchunk(ra);
        bit = 0;
        chunk = nchunks;
    }
    /* set the bit at index bit in chunk */
    ra->chunks[chunk] |= ithbit(bit);
    reg = (chunk << 5) + bit;
    if (reg > ra->max)
        ra->max = reg;
    return reg;
}

/* Free a register. The register must have been previously allocated
 * without being freed. */
void janetc_regalloc_free(JanetcRegisterAllocator *ra, int32_t reg) {
    int32_t chunk = reg >> 5;
    int32_t bit = reg & 0x1F;
    ra->chunks[chunk] &= ~ithbit(bit);
}

/* Get a register that will fit in 8 bits (< 256). Do not call this
 * twice with the same value of nth without calling janetc_regalloc_free
 * on the returned register before. */
int32_t janetc_regalloc_temp(JanetcRegisterAllocator *ra, JanetcRegisterTemp nth) {
    int32_t oldmax = ra->max;
    if (ra->regtemps & (1 << nth)) {
        JANET_EXIT("regtemp already allocated");
    }
    ra->regtemps |= 1 << nth;
    int32_t reg = janetc_regalloc_1(ra);
    if (reg > 0xFF) {
        reg = 0xF0 + nth;
        ra->max = (reg > oldmax) ? reg : oldmax;
    }
    return reg;
}

void janetc_regalloc_freetemp(JanetcRegisterAllocator *ra, int32_t reg, JanetcRegisterTemp nth) {
    ra->regtemps &= ~(1 << nth);
    if (reg < 0xF0)
        janetc_regalloc_free(ra, reg);
}


/* src/core/run.c */
#line 0 "src/core/run.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#endif

/* Run a string */
int janet_dobytes(JanetTable *env, const uint8_t *bytes, int32_t len, const char *sourcePath, Janet *out) {
    JanetParser parser;
    int errflags = 0, done = 0;
    int32_t index = 0;
    Janet ret = janet_wrap_nil();
    const uint8_t *where = sourcePath ? janet_cstring(sourcePath) : NULL;

    if (where) janet_gcroot(janet_wrap_string(where));
    if (NULL == sourcePath) sourcePath = "<unknown>";
    janet_parser_init(&parser);

    /* While we haven't seen an error */
    while (!done) {

        /* Evaluate parsed values */
        while (janet_parser_has_more(&parser)) {
            Janet form = janet_parser_produce(&parser);
            JanetCompileResult cres = janet_compile(form, env, where);
            if (cres.status == JANET_COMPILE_OK) {
                JanetFunction *f = janet_thunk(cres.funcdef);
                JanetFiber *fiber = janet_fiber(f, 64, 0, NULL);
                fiber->env = env;
                JanetSignal status = janet_continue(fiber, janet_wrap_nil(), &ret);
                if (status != JANET_SIGNAL_OK && status != JANET_SIGNAL_EVENT) {
                    janet_stacktrace_ext(fiber, ret, "");
                    errflags |= 0x01;
                    done = 1;
                }
            } else {
                ret = janet_wrap_string(cres.error);
                if (cres.macrofiber) {
                    janet_eprintf("compile error in %s: ", sourcePath);
                    janet_stacktrace_ext(cres.macrofiber, ret, "");
                } else {
                    janet_eprintf("compile error in %s: %s\n", sourcePath,
                                  (const char *)cres.error);
                }
                errflags |= 0x02;
                done = 1;
            }
        }

        if (done) break;

        /* Dispatch based on parse state */
        switch (janet_parser_status(&parser)) {
            case JANET_PARSE_DEAD:
                done = 1;
                break;
            case JANET_PARSE_ERROR: {
                const char *e = janet_parser_error(&parser);
                errflags |= 0x04;
                ret = janet_cstringv(e);
                int32_t line = (int32_t) parser.line;
                int32_t col = (int32_t) parser.column;
                janet_eprintf("%s:%d:%d: parse error: %s\n", sourcePath, line, col, e);
                done = 1;
                break;
            }
            case JANET_PARSE_ROOT:
            case JANET_PARSE_PENDING:
                if (index >= len) {
                    janet_parser_eof(&parser);
                } else {
                    janet_parser_consume(&parser, bytes[index++]);
                }
                break;
        }

    }

    /* Clean up and return errors */
    janet_parser_deinit(&parser);
    if (where) janet_gcunroot(janet_wrap_string(where));
#ifdef JANET_EV
    /* Enter the event loop if we are not already in it */
    if (janet_vm.stackn == 0) {
        janet_gcroot(ret);
        janet_loop();
        janet_gcunroot(ret);
    }
#endif
    if (out) *out = ret;
    return errflags;
}

int janet_dostring(JanetTable *env, const char *str, const char *sourcePath, Janet *out) {
    int32_t len = 0;
    while (str[len]) ++len;
    return janet_dobytes(env, (const uint8_t *)str, len, sourcePath, out);
}

/* Run a fiber to completion (use event loop if enabled). Return the status. */
int janet_loop_fiber(JanetFiber *fiber) {
    int status;
#ifdef JANET_EV
    janet_schedule(fiber, janet_wrap_nil());
    janet_loop();
    status = janet_fiber_status(fiber);
#else
    Janet out;
    status = janet_continue(fiber, janet_wrap_nil(), &out);
    if (status != JANET_SIGNAL_OK && status != JANET_SIGNAL_EVENT) {
        janet_stacktrace_ext(fiber, out, "");
    }
#endif
    return status;
}


/* src/core/specials.c */
#line 0 "src/core/specials.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "compile.h"
#include "util.h"
#include "vector.h"
#include "emit.h"
#endif

static JanetSlot janetc_quote(JanetFopts opts, int32_t argn, const Janet *argv) {
    if (argn != 1) {
        janetc_cerror(opts.compiler, "expected 1 argument to quote");
        return janetc_cslot(janet_wrap_nil());
    }
    return janetc_cslot(argv[0]);
}

static JanetSlot janetc_splice(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetSlot ret;
    if (argn != 1) {
        janetc_cerror(opts.compiler, "expected 1 argument to splice");
        return janetc_cslot(janet_wrap_nil());
    }
    ret = janetc_value(opts, argv[0]);
    ret.flags |= JANET_SLOT_SPLICED;
    return ret;
}

static JanetSlot qq_slots(JanetFopts opts, JanetSlot *slots, int makeop) {
    JanetSlot target = janetc_gettarget(opts);
    janetc_pushslots(opts.compiler, slots);
    janetc_freeslots(opts.compiler, slots);
    janetc_emit_s(opts.compiler, makeop, target, 1);
    return target;
}

static JanetSlot quasiquote(JanetFopts opts, Janet x, int depth, int level) {
    if (depth == 0) {
        janetc_cerror(opts.compiler, "quasiquote too deeply nested");
        return janetc_cslot(janet_wrap_nil());
    }
    JanetSlot *slots = NULL;
    JanetFopts subopts = opts;
    subopts.flags &= ~JANET_FOPTS_HINT;
    switch (janet_type(x)) {
        default:
            return janetc_cslot(x);
        case JANET_TUPLE: {
            int32_t i, len;
            const Janet *tup = janet_unwrap_tuple(x);
            len = janet_tuple_length(tup);
            if (len > 1 && janet_checktype(tup[0], JANET_SYMBOL)) {
                const uint8_t *head = janet_unwrap_symbol(tup[0]);
                if (!janet_cstrcmp(head, "unquote")) {
                    if (level == 0) {
                        return janetc_value(janetc_fopts_default(opts.compiler), tup[1]);
                    } else {
                        level--;
                    }
                } else if (!janet_cstrcmp(head, "quasiquote")) {
                    level++;
                }
            }
            for (i = 0; i < len; i++)
                janet_v_push(slots, quasiquote(subopts, tup[i], depth - 1, level));
            return qq_slots(opts, slots, (janet_tuple_flag(tup) & JANET_TUPLE_FLAG_BRACKETCTOR)
                            ? JOP_MAKE_BRACKET_TUPLE
                            : JOP_MAKE_TUPLE);
        }
        case JANET_ARRAY: {
            int32_t i;
            JanetArray *array = janet_unwrap_array(x);
            for (i = 0; i < array->count; i++)
                janet_v_push(slots, quasiquote(subopts, array->data[i], depth - 1, level));
            return qq_slots(opts, slots, JOP_MAKE_ARRAY);
        }
        case JANET_TABLE:
        case JANET_STRUCT: {
            const JanetKV *kv = NULL, *kvs = NULL;
            int32_t len, cap = 0;
            janet_dictionary_view(x, &kvs, &len, &cap);
            while ((kv = janet_dictionary_next(kvs, cap, kv))) {
                JanetSlot key = quasiquote(subopts, kv->key, depth - 1, level);
                JanetSlot value =  quasiquote(subopts, kv->value, depth - 1, level);
                key.flags &= ~JANET_SLOT_SPLICED;
                value.flags &= ~JANET_SLOT_SPLICED;
                janet_v_push(slots, key);
                janet_v_push(slots, value);
            }
            return qq_slots(opts, slots,
                            janet_checktype(x, JANET_TABLE) ? JOP_MAKE_TABLE : JOP_MAKE_STRUCT);
        }
    }
}

static JanetSlot janetc_quasiquote(JanetFopts opts, int32_t argn, const Janet *argv) {
    if (argn != 1) {
        janetc_cerror(opts.compiler, "expected 1 argument to quasiquote");
        return janetc_cslot(janet_wrap_nil());
    }
    return quasiquote(opts, argv[0], JANET_RECURSION_GUARD, 0);
}

static JanetSlot janetc_unquote(JanetFopts opts, int32_t argn, const Janet *argv) {
    (void) argn;
    (void) argv;
    janetc_cerror(opts.compiler, "cannot use unquote here");
    return janetc_cslot(janet_wrap_nil());
}

/* Perform destructuring. Be careful to
 * keep the order registers are freed.
 * Returns if the slot 'right' can be freed. */
static int destructure(JanetCompiler *c,
                       Janet left,
                       JanetSlot right,
                       int (*leaf)(JanetCompiler *c,
                                   const uint8_t *sym,
                                   JanetSlot s,
                                   JanetTable *attr),
                       JanetTable *attr) {
    switch (janet_type(left)) {
        default:
            janetc_error(c, janet_formatc("unexpected type in destruction, got %v", left));
            return 1;
        case JANET_SYMBOL:
            /* Leaf, assign right to left */
            return leaf(c, janet_unwrap_symbol(left), right, attr);
        case JANET_TUPLE:
        case JANET_ARRAY: {
            int32_t len = 0;
            const Janet *values = NULL;
            janet_indexed_view(left, &values, &len);
            for (int32_t i = 0; i < len; i++) {
                JanetSlot nextright = janetc_farslot(c);
                Janet subval = values[i];

                if (janet_checktype(subval, JANET_SYMBOL) && !janet_cstrcmp(janet_unwrap_symbol(subval), "&")) {
                    if (i + 1 >= len) {
                        janetc_cerror(c, "expected symbol following '& in destructuring pattern");
                        return 1;
                    }

                    if (i + 2 < len) {
                        int32_t num_extra = len - i - 1;
                        Janet *extra = janet_tuple_begin(num_extra);
                        janet_tuple_flag(extra) |= JANET_TUPLE_FLAG_BRACKETCTOR;

                        for (int32_t j = 0; j < num_extra; ++j) {
                            extra[j] = values[j + i + 1];
                        }

                        janetc_error(c, janet_formatc("expected a single symbol follow '& in destructuring pattern, found %q", janet_wrap_tuple(janet_tuple_end(extra))));
                        return 1;
                    }


                    if (!janet_checktype(values[i + 1], JANET_SYMBOL)) {
                        janetc_error(c, janet_formatc("expected symbol following '& in destructuring pattern, found %q", values[i + 1]));
                        return 1;
                    }

                    JanetSlot argi = janetc_farslot(c);
                    JanetSlot arg  = janetc_farslot(c);
                    JanetSlot len  = janetc_farslot(c);

                    janetc_emit_si(c, JOP_LOAD_INTEGER, argi, i, 0);
                    janetc_emit_ss(c, JOP_LENGTH, len, right, 0);

                    /* loop condition - reuse arg slot for the condition result */
                    int32_t label_loop_start = janetc_emit_sss(c, JOP_LESS_THAN, arg, argi, len, 0);
                    int32_t label_loop_cond_jump = janetc_emit_si(c, JOP_JUMP_IF_NOT, arg, 0, 0);

                    /* loop body */
                    janetc_emit_sss(c, JOP_GET, arg, right, argi, 0);
                    janetc_emit_s(c, JOP_PUSH, arg, 0);
                    janetc_emit_ssi(c, JOP_ADD_IMMEDIATE, argi, argi, 1, 0);

                    /* loop - jump back to the start of the loop */
                    int32_t label_loop_loop = janet_v_count(c->buffer);
                    janetc_emit(c, JOP_JUMP);
                    int32_t label_loop_exit = janet_v_count(c->buffer);

                    c->buffer[label_loop_cond_jump] |= (label_loop_exit - label_loop_cond_jump) << 16;
                    c->buffer[label_loop_loop] |= (label_loop_start - label_loop_loop) << 8;

                    janetc_freeslot(c, argi);
                    janetc_freeslot(c, arg);
                    janetc_freeslot(c, len);

                    janetc_emit_s(c, JOP_MAKE_TUPLE, nextright, 1);

                    leaf(c, janet_unwrap_symbol(values[i + 1]), nextright, attr);
                    janetc_freeslot(c, nextright);
                    break;
                }

                if (i < 0x100) {
                    janetc_emit_ssu(c, JOP_GET_INDEX, nextright, right, (uint8_t) i, 1);
                } else {
                    JanetSlot k = janetc_cslot(janet_wrap_integer(i));
                    janetc_emit_sss(c, JOP_IN, nextright, right, k, 1);
                }
                if (destructure(c, subval, nextright, leaf, attr))
                    janetc_freeslot(c, nextright);
            }
        }
        return 1;
        case JANET_TABLE:
        case JANET_STRUCT: {
            const JanetKV *kvs = NULL;
            int32_t cap = 0, len = 0;
            janet_dictionary_view(left, &kvs, &len, &cap);
            for (int32_t i = 0; i < cap; i++) {
                if (janet_checktype(kvs[i].key, JANET_NIL)) continue;
                JanetSlot nextright = janetc_farslot(c);
                JanetSlot k = janetc_value(janetc_fopts_default(c), kvs[i].key);
                janetc_emit_sss(c, JOP_IN, nextright, right, k, 1);
                if (destructure(c, kvs[i].value, nextright, leaf, attr))
                    janetc_freeslot(c, nextright);
            }
        }
        return 1;
    }
}

/* Create a source map for definitions. */
static const Janet *janetc_make_sourcemap(JanetCompiler *c) {
    Janet *tup = janet_tuple_begin(3);
    tup[0] = c->source ? janet_wrap_string(c->source) : janet_wrap_nil();
    tup[1] = janet_wrap_integer(c->current_mapping.line);
    tup[2] = janet_wrap_integer(c->current_mapping.column);
    return janet_tuple_end(tup);
}

static JanetSlot janetc_varset(JanetFopts opts, int32_t argn, const Janet *argv) {
    if (argn != 2) {
        janetc_cerror(opts.compiler, "expected 2 arguments");
        return janetc_cslot(janet_wrap_nil());
    }
    JanetFopts subopts = janetc_fopts_default(opts.compiler);
    if (janet_checktype(argv[0], JANET_SYMBOL)) {
        /* Normal var - (set a 1) */
        const uint8_t *sym = janet_unwrap_symbol(argv[0]);
        JanetSlot dest = janetc_resolve(opts.compiler, sym);
        if (!(dest.flags & JANET_SLOT_MUTABLE)) {
            janetc_cerror(opts.compiler, "cannot set constant");
            return janetc_cslot(janet_wrap_nil());
        }
        subopts.flags = JANET_FOPTS_HINT;
        subopts.hint = dest;
        JanetSlot ret = janetc_value(subopts, argv[1]);
        janetc_copy(opts.compiler, dest, ret);
        return ret;
    } else if (janet_checktype(argv[0], JANET_TUPLE)) {
        /* Set a field (setf behavior) - (set (tab :key) 2) */
        const Janet *tup = janet_unwrap_tuple(argv[0]);
        /* Tuple must have 2 elements */
        if (janet_tuple_length(tup) != 2) {
            janetc_cerror(opts.compiler, "expected 2 element tuple for l-value to set");
            return janetc_cslot(janet_wrap_nil());
        }
        JanetSlot ds = janetc_value(subopts, tup[0]);
        JanetSlot key = janetc_value(subopts, tup[1]);
        /* Can't be tail position because we will emit a PUT instruction afterwards */
        /* Also can't drop either */
        opts.flags &= ~(JANET_FOPTS_TAIL | JANET_FOPTS_DROP);
        JanetSlot rvalue = janetc_value(opts, argv[1]);
        /* Emit the PUT instruction */
        janetc_emit_sss(opts.compiler, JOP_PUT, ds, key, rvalue, 0);
        return rvalue;
    } else {
        /* Error */
        janetc_cerror(opts.compiler, "expected symbol or tuple for l-value to set");
        return janetc_cslot(janet_wrap_nil());
    }
}

/* Add attributes to a global def or var table */
static JanetTable *handleattr(JanetCompiler *c, int32_t argn, const Janet *argv) {
    int32_t i;
    JanetTable *tab = janet_table(2);
    const char *binding_name = janet_type(argv[0]) == JANET_SYMBOL
                               ? ((const char *)janet_unwrap_symbol(argv[0]))
                               : "<multiple bindings>";
    for (i = 1; i < argn - 1; i++) {
        Janet attr = argv[i];
        switch (janet_type(attr)) {
            case JANET_TUPLE:
                janetc_cerror(c, "unexpected form - did you intend to use defn?");
                break;
            default:
                janetc_error(c, janet_formatc("cannot add metadata %v to binding %s", attr, binding_name));
                break;
            case JANET_KEYWORD:
                janet_table_put(tab, attr, janet_wrap_true());
                break;
            case JANET_STRING:
                janet_table_put(tab, janet_ckeywordv("doc"), attr);
                break;
            case JANET_STRUCT:
                janet_table_merge_struct(tab, janet_unwrap_struct(attr));
                break;
        }
    }
    return tab;
}

static JanetSlot dohead(JanetCompiler *c, JanetFopts opts, Janet *head, int32_t argn, const Janet *argv) {
    JanetFopts subopts = janetc_fopts_default(c);
    JanetSlot ret;
    if (argn < 2) {
        janetc_cerror(c, "expected at least 2 arguments");
        return janetc_cslot(janet_wrap_nil());
    }
    *head = argv[0];
    subopts.flags = opts.flags & ~(JANET_FOPTS_TAIL | JANET_FOPTS_DROP);
    subopts.hint = opts.hint;
    ret = janetc_value(subopts, argv[argn - 1]);
    return ret;
}

/* Def or var a symbol in a local scope */
static int namelocal(JanetCompiler *c, const uint8_t *head, int32_t flags, JanetSlot ret) {
    int isUnnamedRegister = !(ret.flags & JANET_SLOT_NAMED) &&
                            ret.index > 0 &&
                            ret.envindex >= 0;
    if (!isUnnamedRegister) {
        /* Slot is not able to be named */
        JanetSlot localslot = janetc_farslot(c);
        janetc_copy(c, localslot, ret);
        ret = localslot;
    }
    ret.flags |= flags;
    janetc_nameslot(c, head, ret);
    return !isUnnamedRegister;
}

static int varleaf(
    JanetCompiler *c,
    const uint8_t *sym,
    JanetSlot s,
    JanetTable *reftab) {
    if (c->scope->flags & JANET_SCOPE_TOP) {
        /* Global var, generate var */
        JanetSlot refslot;
        JanetTable *entry = janet_table_clone(reftab);

        Janet redef_kw = janet_ckeywordv("redef");
        int is_redef = janet_truthy(janet_table_get(c->env, redef_kw));

        JanetArray *ref;
        JanetBinding old_binding;
        if (is_redef && (old_binding = janet_resolve_ext(c->env, sym),
                         old_binding.type == JANET_BINDING_VAR)) {
            ref = janet_unwrap_array(old_binding.value);
        } else {
            ref = janet_array(1);
            janet_array_push(ref, janet_wrap_nil());
        }

        janet_table_put(entry, janet_ckeywordv("ref"), janet_wrap_array(ref));
        janet_table_put(entry, janet_ckeywordv("source-map"),
                        janet_wrap_tuple(janetc_make_sourcemap(c)));
        janet_table_put(c->env, janet_wrap_symbol(sym), janet_wrap_table(entry));
        refslot = janetc_cslot(janet_wrap_array(ref));
        janetc_emit_ssu(c, JOP_PUT_INDEX, refslot, s, 0, 0);
        return 1;
    } else {
        return namelocal(c, sym, JANET_SLOT_MUTABLE, s);
    }
}

static JanetSlot janetc_var(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    Janet head;
    JanetTable *attr_table = handleattr(c, argn, argv);
    JanetSlot ret = dohead(c, opts, &head, argn, argv);
    if (c->result.status == JANET_COMPILE_ERROR)
        return janetc_cslot(janet_wrap_nil());
    destructure(c, argv[0], ret, varleaf, attr_table);
    return ret;
}

static int defleaf(
    JanetCompiler *c,
    const uint8_t *sym,
    JanetSlot s,
    JanetTable *tab) {
    if (c->scope->flags & JANET_SCOPE_TOP) {
        JanetTable *entry = janet_table_clone(tab);
        janet_table_put(entry, janet_ckeywordv("source-map"),
                        janet_wrap_tuple(janetc_make_sourcemap(c)));

        Janet redef_kw = janet_ckeywordv("redef");
        int is_redef = janet_truthy(janet_table_get(c->env, redef_kw));
        if (is_redef) janet_table_put(entry, redef_kw, janet_wrap_true());

        if (is_redef) {
            JanetBinding binding = janet_resolve_ext(c->env, sym);
            JanetArray *ref;
            if (binding.type == JANET_BINDING_DYNAMIC_DEF || binding.type == JANET_BINDING_DYNAMIC_MACRO) {
                ref = janet_unwrap_array(binding.value);
            } else {
                ref = janet_array(1);
                janet_array_push(ref, janet_wrap_nil());
            }
            janet_table_put(entry, janet_ckeywordv("ref"), janet_wrap_array(ref));
            JanetSlot refslot = janetc_cslot(janet_wrap_array(ref));
            janetc_emit_ssu(c, JOP_PUT_INDEX, refslot, s, 0, 0);
        } else {
            JanetSlot valsym = janetc_cslot(janet_ckeywordv("value"));
            JanetSlot tabslot = janetc_cslot(janet_wrap_table(entry));
            janetc_emit_sss(c, JOP_PUT, tabslot, valsym, s, 0);
        }

        /* Add env entry to env */
        janet_table_put(c->env, janet_wrap_symbol(sym), janet_wrap_table(entry));
    }
    return namelocal(c, sym, 0, s);
}

static JanetSlot janetc_def(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    Janet head;
    opts.flags &= ~JANET_FOPTS_HINT;
    JanetTable *attr_table = handleattr(c, argn, argv);
    JanetSlot ret = dohead(c, opts, &head, argn, argv);
    if (c->result.status == JANET_COMPILE_ERROR)
        return janetc_cslot(janet_wrap_nil());
    destructure(c, argv[0], ret, defleaf, attr_table);
    return ret;
}

/*
 * :condition
 * ...
 * jump-if-not condition :right
 * :left
 * ...
 * jump done (only if not tail)
 * :right
 * ...
 * :done
 */
static JanetSlot janetc_if(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    int32_t labelr, labeljr, labeld, labeljd;
    JanetFopts condopts, bodyopts;
    JanetSlot cond, left, right, target;
    Janet truebody, falsebody;
    JanetScope condscope, tempscope;
    const int tail = opts.flags & JANET_FOPTS_TAIL;
    const int drop = opts.flags & JANET_FOPTS_DROP;

    if (argn < 2 || argn > 3) {
        janetc_cerror(c, "expected 2 or 3 arguments to if");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Get the bodies of the if expression */
    truebody = argv[1];
    falsebody = argn > 2 ? argv[2] : janet_wrap_nil();

    /* Get options */
    condopts = janetc_fopts_default(c);
    bodyopts = opts;

    /* Set target for compilation */
    target = (drop || tail)
             ? janetc_cslot(janet_wrap_nil())
             : janetc_gettarget(opts);

    /* Compile condition */
    janetc_scope(&condscope, c, 0, "if");
    cond = janetc_value(condopts, argv[0]);

    /* Check constant condition. */
    /* TODO: Use type info for more short circuits */
    if (cond.flags & JANET_SLOT_CONSTANT) {
        if (!janet_truthy(cond.constant)) {
            /* Swap the true and false bodies */
            Janet temp = falsebody;
            falsebody = truebody;
            truebody = temp;
        }
        janetc_scope(&tempscope, c, 0, "if-true");
        right = janetc_value(bodyopts, truebody);
        if (!drop && !tail) janetc_copy(c, target, right);
        janetc_popscope(c);
        if (!janet_checktype(falsebody, JANET_NIL)) {
            janetc_throwaway(bodyopts, falsebody);
        }
        janetc_popscope(c);
        return target;
    }

    /* Compile jump to right */
    labeljr = janetc_emit_si(c, JOP_JUMP_IF_NOT, cond, 0, 0);

    /* Condition left body */
    janetc_scope(&tempscope, c, 0, "if-true");
    left = janetc_value(bodyopts, truebody);
    if (!drop && !tail) janetc_copy(c, target, left);
    janetc_popscope(c);

    /* Compile jump to done */
    labeljd = janet_v_count(c->buffer);
    if (!tail) janetc_emit(c, JOP_JUMP);

    /* Compile right body */
    labelr = janet_v_count(c->buffer);
    janetc_scope(&tempscope, c, 0, "if-false");
    right = janetc_value(bodyopts, falsebody);
    if (!drop && !tail) janetc_copy(c, target, right);
    janetc_popscope(c);

    /* Pop main scope */
    janetc_popscope(c);

    /* Write jumps - only add jump lengths if jump actually emitted */
    labeld = janet_v_count(c->buffer);
    c->buffer[labeljr] |= (labelr - labeljr) << 16;
    if (!tail) c->buffer[labeljd] |= (labeld - labeljd) << 8;

    if (tail) target.flags |= JANET_SLOT_RETURNED;
    return target;
}

/* Compile a do form. Do forms execute their body sequentially and
 * evaluate to the last expression in the body. */
static JanetSlot janetc_do(JanetFopts opts, int32_t argn, const Janet *argv) {
    int32_t i;
    JanetSlot ret = janetc_cslot(janet_wrap_nil());
    JanetCompiler *c = opts.compiler;
    JanetFopts subopts = janetc_fopts_default(c);
    JanetScope tempscope;
    janetc_scope(&tempscope, c, 0, "do");
    for (i = 0; i < argn; i++) {
        if (i != argn - 1) {
            subopts.flags = JANET_FOPTS_DROP;
        } else {
            subopts = opts;
        }
        ret = janetc_value(subopts, argv[i]);
        if (i != argn - 1) {
            janetc_freeslot(c, ret);
        }
    }
    janetc_popscope_keepslot(c, ret);
    return ret;
}


/* Compile an upscope form. Upscope forms execute their body sequentially and
 * evaluate to the last expression in the body, but without lexical scope. */
static JanetSlot janetc_upscope(JanetFopts opts, int32_t argn, const Janet *argv) {
    int32_t i;
    JanetSlot ret = janetc_cslot(janet_wrap_nil());
    JanetCompiler *c = opts.compiler;
    JanetFopts subopts = janetc_fopts_default(c);
    for (i = 0; i < argn; i++) {
        if (i != argn - 1) {
            subopts.flags = JANET_FOPTS_DROP;
        } else {
            subopts = opts;
        }
        ret = janetc_value(subopts, argv[i]);
        if (i != argn - 1) {
            janetc_freeslot(c, ret);
        }
    }
    return ret;
}

/* Add a funcdef to the top most function scope */
static int32_t janetc_addfuncdef(JanetCompiler *c, JanetFuncDef *def) {
    JanetScope *scope = c->scope;
    while (scope) {
        if (scope->flags & JANET_SCOPE_FUNCTION)
            break;
        scope = scope->parent;
    }
    janet_assert(scope, "could not add funcdef");
    janet_v_push(scope->defs, def);
    return janet_v_count(scope->defs) - 1;
}

/*
 * break
 *
 * jump :end or retn if in function
 */
static JanetSlot janetc_break(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    JanetScope *scope = c->scope;
    if (argn > 1) {
        janetc_cerror(c, "expected at most 1 argument");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Find scope to break from */
    while (scope) {
        if (scope->flags & (JANET_SCOPE_FUNCTION | JANET_SCOPE_WHILE))
            break;
        scope = scope->parent;
    }
    if (NULL == scope) {
        janetc_cerror(c, "break must occur in while loop or closure");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Emit code to break from that scope */
    JanetFopts subopts = janetc_fopts_default(c);
    if (scope->flags & JANET_SCOPE_FUNCTION) {
        if (!(scope->flags & JANET_SCOPE_WHILE) && argn) {
            /* Closure body with return argument */
            subopts.flags |= JANET_FOPTS_TAIL;
            JanetSlot ret = janetc_value(subopts, argv[0]);
            ret.flags |= JANET_SLOT_RETURNED;
            return ret;
        } else {
            /* while loop IIFE or no argument */
            if (argn) {
                subopts.flags |= JANET_FOPTS_DROP;
                janetc_value(subopts, argv[0]);
            }
            janetc_emit(c, JOP_RETURN_NIL);
            JanetSlot s = janetc_cslot(janet_wrap_nil());
            s.flags |= JANET_SLOT_RETURNED;
            return s;
        }
    } else {
        if (argn) {
            subopts.flags |= JANET_FOPTS_DROP;
            janetc_value(subopts, argv[0]);
        }
        /* Tag the instruction so the while special can turn it into a proper jump */
        janetc_emit(c, 0x80 | JOP_JUMP);
        return janetc_cslot(janet_wrap_nil());
    }
}

/* Check if a form matches the pattern (not= nil _) */
static int janetc_check_notnil_form(Janet x, Janet *capture) {
    if (!janet_checktype(x, JANET_TUPLE)) return 0;
    JanetTuple tup = janet_unwrap_tuple(x);
    if (!janet_checktype(tup[0], JANET_FUNCTION)) return 0;
    if (3 != janet_tuple_length(tup)) return 0;
    JanetFunction *fun = janet_unwrap_function(tup[0]);
    uint32_t tag = fun->def->flags & JANET_FUNCDEF_FLAG_TAG;
    if (tag != JANET_FUN_NEQ) return 0;
    if (!janet_checktype(tup[1], JANET_NIL)) return 0;
    *capture = tup[2];
    return 1;
}

/*
 * :whiletop
 * ...
 * :condition
 * jump-if-not cond :done
 * ...
 * jump :whiletop
 * :done
 */
static JanetSlot janetc_while(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    JanetSlot cond;
    JanetFopts subopts = janetc_fopts_default(c);
    JanetScope tempscope;
    int32_t labelwt, labeld, labeljt, labelc, i;
    int infinite = 0;
    int is_notnil_form = 0;
    uint8_t ifjmp = JOP_JUMP_IF;
    uint8_t ifnjmp = JOP_JUMP_IF_NOT;

    if (argn < 2) {
        janetc_cerror(c, "expected at least 2 arguments");
        return janetc_cslot(janet_wrap_nil());
    }

    labelwt = janet_v_count(c->buffer);

    janetc_scope(&tempscope, c, JANET_SCOPE_WHILE, "while");

    /* Check for `(not= nil _)` in condition, and if so, use the
     * jmpnl or jmpnn instructions. This let's us implement `(each ...)`
     * more efficiently. */
    Janet condform = argv[0];
    if (janetc_check_notnil_form(condform, &condform)) {
        is_notnil_form = 1;
        ifjmp = JOP_JUMP_IF_NOT_NIL;
        ifnjmp = JOP_JUMP_IF_NIL;
    }

    /* Compile condition */
    cond = janetc_value(subopts, condform);

    /* Check for constant condition */
    if (cond.flags & JANET_SLOT_CONSTANT) {
        /* Loop never executes */
        int never_executes = is_notnil_form
                             ? janet_checktype(cond.constant, JANET_NIL)
                             : !janet_truthy(cond.constant);
        if (never_executes) {
            janetc_popscope(c);
            return janetc_cslot(janet_wrap_nil());
        }
        /* Infinite loop */
        infinite = 1;
    }

    /* Infinite loop does not need to check condition */
    labelc = infinite
             ? 0
             : janetc_emit_si(c, ifnjmp, cond, 0, 0);

    /* Compile body */
    for (i = 1; i < argn; i++) {
        subopts.flags = JANET_FOPTS_DROP;
        janetc_freeslot(c, janetc_value(subopts, argv[i]));
    }

    /* Check if closure created in while scope. If so,
     * recompile in a function scope. */
    if (tempscope.flags & JANET_SCOPE_CLOSURE) {
        subopts = janetc_fopts_default(c);
        tempscope.flags |= JANET_SCOPE_UNUSED;
        janetc_popscope(c);
        if (c->buffer) janet_v__cnt(c->buffer) = labelwt;
        if (c->mapbuffer) janet_v__cnt(c->mapbuffer) = labelwt;

        janetc_scope(&tempscope, c, JANET_SCOPE_FUNCTION, "while-iife");

        /* Recompile in the function scope */
        cond = janetc_value(subopts, condform);
        if (!(cond.flags & JANET_SLOT_CONSTANT)) {
            /* If not an infinite loop, return nil when condition false */
            janetc_emit_si(c, ifjmp, cond, 2, 0);
            janetc_emit(c, JOP_RETURN_NIL);
        }
        for (i = 1; i < argn; i++) {
            subopts.flags = JANET_FOPTS_DROP;
            janetc_freeslot(c, janetc_value(subopts, argv[i]));
        }
        /* But now add tail recursion */
        int32_t tempself = janetc_regalloc_temp(&tempscope.ra, JANETC_REGTEMP_0);
        janetc_emit(c, JOP_LOAD_SELF | (tempself << 8));
        janetc_emit(c, JOP_TAILCALL | (tempself << 8));
        janetc_regalloc_freetemp(&c->scope->ra, tempself, JANETC_REGTEMP_0);
        /* Compile function */
        JanetFuncDef *def = janetc_pop_funcdef(c);
        def->name = janet_cstring("_while");
        janet_def_addflags(def);
        int32_t defindex = janetc_addfuncdef(c, def);
        /* And then load the closure and call it. */
        int32_t cloreg = janetc_regalloc_temp(&c->scope->ra, JANETC_REGTEMP_0);
        janetc_emit(c, JOP_CLOSURE | (cloreg << 8) | (defindex << 16));
        janetc_emit(c, JOP_CALL | (cloreg << 8) | (cloreg << 16));
        janetc_regalloc_freetemp(&c->scope->ra, cloreg, JANETC_REGTEMP_0);
        c->scope->flags |= JANET_SCOPE_CLOSURE;
        return janetc_cslot(janet_wrap_nil());
    }

    /* Compile jump to :whiletop */
    labeljt = janet_v_count(c->buffer);
    janetc_emit(c, JOP_JUMP);

    /* Calculate jumps */
    labeld = janet_v_count(c->buffer);
    if (!infinite) c->buffer[labelc] |= (uint32_t)(labeld - labelc) << 16;
    c->buffer[labeljt] |= (uint32_t)(labelwt - labeljt) << 8;

    /* Calculate breaks */
    for (int32_t i = labelwt; i < labeld; i++) {
        if (c->buffer[i] == (0x80 | JOP_JUMP)) {
            c->buffer[i] = JOP_JUMP | ((labeld - i) << 8);
        }
    }

    /* Pop scope and return nil slot */
    janetc_popscope(c);

    return janetc_cslot(janet_wrap_nil());
}

static JanetSlot janetc_fn(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    JanetFuncDef *def;
    JanetSlot ret;
    Janet head;
    JanetScope fnscope;
    int32_t paramcount, argi, parami, arity, min_arity = 0, max_arity, defindex, i;
    JanetFopts subopts = janetc_fopts_default(c);
    const Janet *params;
    const char *errmsg = NULL;

    /* Function flags */
    int vararg = 0;
    int structarg = 0;
    int allow_extra = 0;
    int selfref = 0;
    int seenamp = 0;
    int seenopt = 0;
    int namedargs = 0;

    /* Begin function */
    c->scope->flags |= JANET_SCOPE_CLOSURE;
    janetc_scope(&fnscope, c, JANET_SCOPE_FUNCTION, "function");

    if (argn == 0) {
        errmsg = "expected at least 1 argument to function literal";
        goto error;
    }

    /* Read function parameters */
    parami = 0;
    head = argv[0];
    if (janet_checktype(head, JANET_SYMBOL)) {
        selfref = 1;
        parami = 1;
    }
    if (parami >= argn || !janet_checktype(argv[parami], JANET_TUPLE)) {
        errmsg = "expected function parameters";
        goto error;
    }

    /* Keep track of destructured parameters */
    JanetSlot *destructed_params = NULL;
    JanetSlot *named_params = NULL;
    JanetTable *named_table = NULL;
    JanetSlot named_slot;

    /* Compile function parameters */
    params = janet_unwrap_tuple(argv[parami]);
    paramcount = janet_tuple_length(params);
    arity = paramcount;
    for (i = 0; i < paramcount; i++) {
        Janet param = params[i];
        if (namedargs) {
            arity--;
            if (!janet_checktype(param, JANET_SYMBOL)) {
                errmsg = "only named arguments can follow &named";
                goto error;
            }
            Janet key = janet_wrap_keyword(janet_unwrap_symbol(param));
            janet_table_put(named_table, key, param);
            janet_v_push(named_params, janetc_farslot(c));
        } else if (janet_checktype(param, JANET_SYMBOL)) {
            /* Check for varargs and unfixed arity */
            const uint8_t *sym = janet_unwrap_symbol(param);
            if (sym[0] == '&') {
                if (!janet_cstrcmp(sym, "&")) {
                    if (seenamp) {
                        errmsg = "& in unexpected location";
                        goto error;
                    } else if (i == paramcount - 1) {
                        allow_extra = 1;
                        arity--;
                    } else if (i == paramcount - 2) {
                        vararg = 1;
                        arity -= 2;
                    } else {
                        errmsg = "& in unexpected location";
                        goto error;
                    }
                    seenamp = 1;
                } else if (!janet_cstrcmp(sym, "&opt")) {
                    if (seenopt) {
                        errmsg = "only one &opt allowed";
                        goto error;
                    } else if (i == paramcount - 1) {
                        errmsg = "&opt cannot be last item in parameter list";
                        goto error;
                    }
                    min_arity = i;
                    arity--;
                    seenopt = 1;
                } else if (!janet_cstrcmp(sym, "&keys")) {
                    if (seenamp) {
                        errmsg = "&keys in unexpected location";
                        goto error;
                    } else if (i == paramcount - 2) {
                        vararg = 1;
                        structarg = 1;
                        arity -= 2;
                    } else {
                        errmsg = "&keys in unexpected location";
                        goto error;
                    }
                    seenamp = 1;
                } else if (!janet_cstrcmp(sym, "&named")) {
                    if (seenamp) {
                        errmsg = "&named in unexpected location";
                        goto error;
                    }
                    vararg = 1;
                    structarg = 1;
                    arity--;
                    seenamp = 1;
                    namedargs = 1;
                    named_table = janet_table(10);
                    named_slot = janetc_farslot(c);
                } else {
                    janetc_nameslot(c, sym, janetc_farslot(c));
                }
            } else {
                janetc_nameslot(c, sym, janetc_farslot(c));
            }
        } else {
            janet_v_push(destructed_params, janetc_farslot(c));
        }
    }

    /* Compile destructed params */
    int32_t j = 0;
    for (i = 0; i < paramcount; i++) {
        Janet param = params[i];
        if (!janet_checktype(param, JANET_SYMBOL)) {
            JanetSlot reg = destructed_params[j++];
            destructure(c, param, reg, defleaf, NULL);
            janetc_freeslot(c, reg);
        }
    }
    janet_v_free(destructed_params);

    /* Compile named arguments */
    if (namedargs) {
        Janet param = janet_wrap_table(named_table);
        destructure(c, param, named_slot, defleaf, NULL);
        janetc_freeslot(c, named_slot);
        janet_v_free(named_params);
    }

    max_arity = (vararg || allow_extra) ? INT32_MAX : arity;
    if (!seenopt) min_arity = arity;

    /* Check for self ref */
    if (selfref) {
        JanetSlot slot = janetc_farslot(c);
        slot.flags = JANET_SLOT_NAMED | JANET_FUNCTION;
        janetc_emit_s(c, JOP_LOAD_SELF, slot, 1);
        janetc_nameslot(c, janet_unwrap_symbol(head), slot);
    }

    /* Compile function body */
    if (parami + 1 == argn) {
        janetc_emit(c, JOP_RETURN_NIL);
    } else {
        for (argi = parami + 1; argi < argn; argi++) {
            subopts.flags = (argi == (argn - 1)) ? JANET_FOPTS_TAIL : JANET_FOPTS_DROP;
            janetc_value(subopts, argv[argi]);
            if (c->result.status == JANET_COMPILE_ERROR)
                goto error2;
        }
    }

    /* Build function */
    def = janetc_pop_funcdef(c);
    def->arity = arity;
    def->min_arity = min_arity;
    def->max_arity = max_arity;
    if (vararg) def->flags |= JANET_FUNCDEF_FLAG_VARARG;
    if (structarg) def->flags |= JANET_FUNCDEF_FLAG_STRUCTARG;

    if (selfref) def->name = janet_unwrap_symbol(head);
    janet_def_addflags(def);
    defindex = janetc_addfuncdef(c, def);

    /* Ensure enough slots for vararg function. */
    if (arity + vararg > def->slotcount) def->slotcount = arity + vararg;

    /* Instantiate closure */
    ret = janetc_gettarget(opts);
    janetc_emit_su(c, JOP_CLOSURE, ret, defindex, 1);
    return ret;

error:
    janetc_cerror(c, errmsg);
error2:
    janetc_popscope(c);
    return janetc_cslot(janet_wrap_nil());
}

/* Keep in lexicographic order */
static const JanetSpecial janetc_specials[] = {
    {"break", janetc_break},
    {"def", janetc_def},
    {"do", janetc_do},
    {"fn", janetc_fn},
    {"if", janetc_if},
    {"quasiquote", janetc_quasiquote},
    {"quote", janetc_quote},
    {"set", janetc_varset},
    {"splice", janetc_splice},
    {"unquote", janetc_unquote},
    {"upscope", janetc_upscope},
    {"var", janetc_var},
    {"while", janetc_while}
};

/* Find a special */
const JanetSpecial *janetc_special(const uint8_t *name) {
    return janet_strbinsearch(
               &janetc_specials,
               sizeof(janetc_specials) / sizeof(JanetSpecial),
               sizeof(JanetSpecial),
               name);
}



/* src/core/state.c */
#line 0 "src/core/state.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#endif

JANET_THREAD_LOCAL JanetVM janet_vm;

JanetVM *janet_local_vm(void) {
    return &janet_vm;
}

JanetVM *janet_vm_alloc(void) {
    JanetVM *mem = janet_malloc(sizeof(JanetVM));
    if (NULL == mem) {
        JANET_OUT_OF_MEMORY;
    }
    return mem;
}

void janet_vm_free(JanetVM *vm) {
    janet_free(vm);
}

void janet_vm_save(JanetVM *into) {
    *into = janet_vm;
}

void janet_vm_load(JanetVM *from) {
    janet_vm = *from;
}

/* Trigger suspension of the Janet vm by trying to
 * exit the interpeter loop when convenient. You can optionally
 * use NULL to interrupt the current VM when convenient */
void janet_interpreter_interrupt(JanetVM *vm) {
    vm = vm ? vm : &janet_vm;
    vm->auto_suspend = 1;
}


/* src/core/string.c */
#line 0 "src/core/string.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include "state.h"
#endif

#include <string.h>

/* Begin building a string */
uint8_t *janet_string_begin(int32_t length) {
    JanetStringHead *head = janet_gcalloc(JANET_MEMORY_STRING, sizeof(JanetStringHead) + (size_t) length + 1);
    head->length = length;
    uint8_t *data = (uint8_t *)head->data;
    data[length] = 0;
    return data;
}

/* Finish building a string */
const uint8_t *janet_string_end(uint8_t *str) {
    janet_string_hash(str) = janet_string_calchash(str, janet_string_length(str));
    return str;
}

/* Load a buffer as a string */
const uint8_t *janet_string(const uint8_t *buf, int32_t len) {
    JanetStringHead *head = janet_gcalloc(JANET_MEMORY_STRING, sizeof(JanetStringHead) + (size_t) len + 1);
    head->length = len;
    head->hash = janet_string_calchash(buf, len);
    uint8_t *data = (uint8_t *)head->data;
    safe_memcpy(data, buf, len);
    data[len] = 0;
    return data;
}

/* Compare two strings */
int janet_string_compare(const uint8_t *lhs, const uint8_t *rhs) {
    int32_t xlen = janet_string_length(lhs);
    int32_t ylen = janet_string_length(rhs);
    int32_t len = xlen > ylen ? ylen : xlen;
    int res = memcmp(lhs, rhs, len);
    if (res) return res > 0 ? 1 : -1;
    if (xlen == ylen) return 0;
    return xlen < ylen ? -1 : 1;
}

/* Compare a janet string with a piece of memory */
int janet_string_equalconst(const uint8_t *lhs, const uint8_t *rhs, int32_t rlen, int32_t rhash) {
    int32_t lhash = janet_string_hash(lhs);
    int32_t llen = janet_string_length(lhs);
    if (lhs == rhs)
        return 1;
    if (lhash != rhash || llen != rlen)
        return 0;
    return !memcmp(lhs, rhs, rlen);
}

/* Check if two strings are equal */
int janet_string_equal(const uint8_t *lhs, const uint8_t *rhs) {
    return janet_string_equalconst(lhs, rhs,
                                   janet_string_length(rhs), janet_string_hash(rhs));
}

/* Load a c string */
const uint8_t *janet_cstring(const char *str) {
    return janet_string((const uint8_t *)str, (int32_t)strlen(str));
}

/* Knuth Morris Pratt Algorithm */

struct kmp_state {
    int32_t i;
    int32_t j;
    int32_t textlen;
    int32_t patlen;
    int32_t *lookup;
    const uint8_t *text;
    const uint8_t *pat;
};

static void kmp_init(
    struct kmp_state *s,
    const uint8_t *text, int32_t textlen,
    const uint8_t *pat, int32_t patlen) {
    if (patlen == 0) {
        janet_panic("expected non-empty pattern");
    }
    int32_t *lookup = janet_calloc(patlen, sizeof(int32_t));
    if (!lookup) {
        JANET_OUT_OF_MEMORY;
    }
    s->lookup = lookup;
    s->i = 0;
    s->j = 0;
    s->text = text;
    s->pat = pat;
    s->textlen = textlen;
    s->patlen = patlen;
    /* Init state machine */
    {
        int32_t i, j;
        for (i = 1, j = 0; i < patlen; i++) {
            while (j && pat[j] != pat[i]) j = lookup[j - 1];
            if (pat[j] == pat[i]) j++;
            lookup[i] = j;
        }
    }
}

static void kmp_deinit(struct kmp_state *state) {
    janet_free(state->lookup);
}

static void kmp_seti(struct kmp_state *state, int32_t i) {
    state->i = i;
    state->j = 0;
}

static int32_t kmp_next(struct kmp_state *state) {
    int32_t i = state->i;
    int32_t j = state->j;
    int32_t textlen = state->textlen;
    int32_t patlen = state->patlen;
    const uint8_t *text = state->text;
    const uint8_t *pat = state->pat;
    int32_t *lookup = state->lookup;
    while (i < textlen) {
        if (text[i] == pat[j]) {
            if (j == patlen - 1) {
                state->i = i + 1;
                state->j = lookup[j];
                return i - j;
            } else {
                i++;
                j++;
            }
        } else {
            if (j > 0) {
                j = lookup[j - 1];
            } else {
                i++;
            }
        }
    }
    return -1;
}

/* CFuns */

JANET_CORE_FN(cfun_string_slice,
              "(string/slice bytes &opt start end)",
              "Returns a substring from a byte sequence. The substring is from "
              "index `start` inclusive to index `end`, exclusive. All indexing "
              "is from 0. `start` and `end` can also be negative to indicate indexing "
              "from the end of the string. Note that index -1 is synonymous with "
              "index `(length bytes)` to allow a full negative slice range. ") {
    JanetByteView view = janet_getbytes(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    return janet_stringv(view.bytes + range.start, range.end - range.start);
}

JANET_CORE_FN(cfun_symbol_slice,
              "(symbol/slice bytes &opt start end)",
              "Same as string/slice, but returns a symbol.") {
    JanetByteView view = janet_getbytes(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    return janet_symbolv(view.bytes + range.start, range.end - range.start);
}

JANET_CORE_FN(cfun_keyword_slice,
              "(keyword/slice bytes &opt start end)",
              "Same as string/slice, but returns a keyword.") {
    JanetByteView view = janet_getbytes(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    return janet_keywordv(view.bytes + range.start, range.end - range.start);
}

JANET_CORE_FN(cfun_string_repeat,
              "(string/repeat bytes n)",
              "Returns a string that is `n` copies of `bytes` concatenated.") {
    janet_fixarity(argc, 2);
    JanetByteView view = janet_getbytes(argv, 0);
    int32_t rep = janet_getinteger(argv, 1);
    if (rep < 0) janet_panic("expected non-negative number of repetitions");
    if (rep == 0) return janet_cstringv("");
    int64_t mulres = (int64_t) rep * view.len;
    if (mulres > INT32_MAX) janet_panic("result string is too long");
    uint8_t *newbuf = janet_string_begin((int32_t) mulres);
    uint8_t *end = newbuf + mulres;
    for (uint8_t *p = newbuf; p < end; p += view.len) {
        safe_memcpy(p, view.bytes, view.len);
    }
    return janet_wrap_string(janet_string_end(newbuf));
}

JANET_CORE_FN(cfun_string_bytes,
              "(string/bytes str)",
              "Returns a tuple of integers that are the byte values of the string.") {
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    Janet *tup = janet_tuple_begin(view.len);
    int32_t i;
    for (i = 0; i < view.len; i++) {
        tup[i] = janet_wrap_integer((int32_t) view.bytes[i]);
    }
    return janet_wrap_tuple(janet_tuple_end(tup));
}

JANET_CORE_FN(cfun_string_frombytes,
              "(string/from-bytes & byte-vals)",
              "Creates a string from integer parameters with byte values. All integers "
              "will be coerced to the range of 1 byte 0-255.") {
    int32_t i;
    uint8_t *buf = janet_string_begin(argc);
    for (i = 0; i < argc; i++) {
        int32_t c = janet_getinteger(argv, i);
        buf[i] = c & 0xFF;
    }
    return janet_wrap_string(janet_string_end(buf));
}

JANET_CORE_FN(cfun_string_asciilower,
              "(string/ascii-lower str)",
              "Returns a new string where all bytes are replaced with the "
              "lowercase version of themselves in ASCII. Does only a very simple "
              "case check, meaning no unicode support.") {
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    uint8_t *buf = janet_string_begin(view.len);
    for (int32_t i = 0; i < view.len; i++) {
        uint8_t c = view.bytes[i];
        if (c >= 65 && c <= 90) {
            buf[i] = c + 32;
        } else {
            buf[i] = c;
        }
    }
    return janet_wrap_string(janet_string_end(buf));
}

JANET_CORE_FN(cfun_string_asciiupper,
              "(string/ascii-upper str)",
              "Returns a new string where all bytes are replaced with the "
              "uppercase version of themselves in ASCII. Does only a very simple "
              "case check, meaning no unicode support.") {
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    uint8_t *buf = janet_string_begin(view.len);
    for (int32_t i = 0; i < view.len; i++) {
        uint8_t c = view.bytes[i];
        if (c >= 97 && c <= 122) {
            buf[i] = c - 32;
        } else {
            buf[i] = c;
        }
    }
    return janet_wrap_string(janet_string_end(buf));
}

JANET_CORE_FN(cfun_string_reverse,
              "(string/reverse str)",
              "Returns a string that is the reversed version of `str`.") {
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    uint8_t *buf = janet_string_begin(view.len);
    int32_t i, j;
    for (i = 0, j = view.len - 1; i < view.len; i++, j--) {
        buf[i] = view.bytes[j];
    }
    return janet_wrap_string(janet_string_end(buf));
}

static void findsetup(int32_t argc, Janet *argv, struct kmp_state *s, int32_t extra) {
    janet_arity(argc, 2, 3 + extra);
    JanetByteView pat = janet_getbytes(argv, 0);
    JanetByteView text = janet_getbytes(argv, 1);
    int32_t start = 0;
    if (argc >= 3) {
        start = janet_getinteger(argv, 2);
        if (start < 0) janet_panic("expected non-negative start index");
    }
    kmp_init(s, text.bytes, text.len, pat.bytes, pat.len);
    s->i = start;
}

JANET_CORE_FN(cfun_string_find,
              "(string/find patt str &opt start-index)",
              "Searches for the first instance of pattern `patt` in string "
              "`str`. Returns the index of the first character in `patt` if found, "
              "otherwise returns nil.") {
    int32_t result;
    struct kmp_state state;
    findsetup(argc, argv, &state, 0);
    result = kmp_next(&state);
    kmp_deinit(&state);
    return result < 0
           ? janet_wrap_nil()
           : janet_wrap_integer(result);
}

JANET_CORE_FN(cfun_string_hasprefix,
              "(string/has-prefix? pfx str)",
              "Tests whether `str` starts with `pfx`.") {
    janet_fixarity(argc, 2);
    JanetByteView prefix = janet_getbytes(argv, 0);
    JanetByteView str = janet_getbytes(argv, 1);
    return str.len < prefix.len
           ? janet_wrap_false()
           : janet_wrap_boolean(memcmp(prefix.bytes, str.bytes, prefix.len) == 0);
}

JANET_CORE_FN(cfun_string_hassuffix,
              "(string/has-suffix? sfx str)",
              "Tests whether `str` ends with `sfx`.") {
    janet_fixarity(argc, 2);
    JanetByteView suffix = janet_getbytes(argv, 0);
    JanetByteView str = janet_getbytes(argv, 1);
    return str.len < suffix.len
           ? janet_wrap_false()
           : janet_wrap_boolean(memcmp(suffix.bytes,
                                       str.bytes + str.len - suffix.len,
                                       suffix.len) == 0);
}

JANET_CORE_FN(cfun_string_findall,
              "(string/find-all patt str &opt start-index)",
              "Searches for all instances of pattern `patt` in string "
              "`str`. Returns an array of all indices of found patterns. Overlapping "
              "instances of the pattern are counted individually, meaning a byte in `str` "
              "may contribute to multiple found patterns.") {
    int32_t result;
    struct kmp_state state;
    findsetup(argc, argv, &state, 0);
    JanetArray *array = janet_array(0);
    while ((result = kmp_next(&state)) >= 0) {
        janet_array_push(array, janet_wrap_integer(result));
    }
    kmp_deinit(&state);
    return janet_wrap_array(array);
}

struct replace_state {
    struct kmp_state kmp;
    const uint8_t *subst;
    int32_t substlen;
};

static void replacesetup(int32_t argc, Janet *argv, struct replace_state *s) {
    janet_arity(argc, 3, 4);
    JanetByteView pat = janet_getbytes(argv, 0);
    JanetByteView subst = janet_getbytes(argv, 1);
    JanetByteView text = janet_getbytes(argv, 2);
    int32_t start = 0;
    if (argc == 4) {
        start = janet_getinteger(argv, 3);
        if (start < 0) janet_panic("expected non-negative start index");
    }
    kmp_init(&s->kmp, text.bytes, text.len, pat.bytes, pat.len);
    s->kmp.i = start;
    s->subst = subst.bytes;
    s->substlen = subst.len;
}

JANET_CORE_FN(cfun_string_replace,
              "(string/replace patt subst str)",
              "Replace the first occurrence of `patt` with `subst` in the string `str`. "
              "Will return the new string if `patt` is found, otherwise returns `str`.") {
    int32_t result;
    struct replace_state s;
    uint8_t *buf;
    replacesetup(argc, argv, &s);
    result = kmp_next(&s.kmp);
    if (result < 0) {
        kmp_deinit(&s.kmp);
        return janet_stringv(s.kmp.text, s.kmp.textlen);
    }
    buf = janet_string_begin(s.kmp.textlen - s.kmp.patlen + s.substlen);
    safe_memcpy(buf, s.kmp.text, result);
    safe_memcpy(buf + result, s.subst, s.substlen);
    safe_memcpy(buf + result + s.substlen,
                s.kmp.text + result + s.kmp.patlen,
                s.kmp.textlen - result - s.kmp.patlen);
    kmp_deinit(&s.kmp);
    return janet_wrap_string(janet_string_end(buf));
}

JANET_CORE_FN(cfun_string_replaceall,
              "(string/replace-all patt subst str)",
              "Replace all instances of `patt` with `subst` in the string `str`. Overlapping "
              "matches will not be counted, only the first match in such a span will be replaced. "
              "Will return the new string if `patt` is found, otherwise returns `str`.") {
    int32_t result;
    struct replace_state s;
    JanetBuffer b;
    int32_t lastindex = 0;
    replacesetup(argc, argv, &s);
    janet_buffer_init(&b, s.kmp.textlen);
    while ((result = kmp_next(&s.kmp)) >= 0) {
        janet_buffer_push_bytes(&b, s.kmp.text + lastindex, result - lastindex);
        janet_buffer_push_bytes(&b, s.subst, s.substlen);
        lastindex = result + s.kmp.patlen;
        kmp_seti(&s.kmp, lastindex);
    }
    janet_buffer_push_bytes(&b, s.kmp.text + lastindex, s.kmp.textlen - lastindex);
    const uint8_t *ret = janet_string(b.data, b.count);
    janet_buffer_deinit(&b);
    kmp_deinit(&s.kmp);
    return janet_wrap_string(ret);
}

JANET_CORE_FN(cfun_string_split,
              "(string/split delim str &opt start limit)",
              "Splits a string `str` with delimiter `delim` and returns an array of "
              "substrings. The substrings will not contain the delimiter `delim`. If `delim` "
              "is not found, the returned array will have one element. Will start searching "
              "for `delim` at the index `start` (if provided), and return up to a maximum "
              "of `limit` results (if provided).") {
    int32_t result;
    JanetArray *array;
    struct kmp_state state;
    int32_t limit = -1, lastindex = 0;
    if (argc == 4) {
        limit = janet_getinteger(argv, 3);
    }
    findsetup(argc, argv, &state, 1);
    array = janet_array(0);
    while ((result = kmp_next(&state)) >= 0 && --limit) {
        const uint8_t *slice = janet_string(state.text + lastindex, result - lastindex);
        janet_array_push(array, janet_wrap_string(slice));
        lastindex = result + state.patlen;
        kmp_seti(&state, lastindex);
    }
    const uint8_t *slice = janet_string(state.text + lastindex, state.textlen - lastindex);
    janet_array_push(array, janet_wrap_string(slice));
    kmp_deinit(&state);
    return janet_wrap_array(array);
}

JANET_CORE_FN(cfun_string_checkset,
              "(string/check-set set str)",
              "Checks that the string `str` only contains bytes that appear in the string `set`. "
              "Returns true if all bytes in `str` appear in `set`, false if some bytes in `str` do "
              "not appear in `set`.") {
    uint32_t bitset[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    janet_fixarity(argc, 2);
    JanetByteView set = janet_getbytes(argv, 0);
    JanetByteView str = janet_getbytes(argv, 1);
    /* Populate set */
    for (int32_t i = 0; i < set.len; i++) {
        int index = set.bytes[i] >> 5;
        uint32_t mask = 1 << (set.bytes[i] & 0x1F);
        bitset[index] |= mask;
    }
    /* Check set */
    for (int32_t i = 0; i < str.len; i++) {
        int index = str.bytes[i] >> 5;
        uint32_t mask = 1 << (str.bytes[i] & 0x1F);
        if (!(bitset[index] & mask)) {
            return janet_wrap_false();
        }
    }
    return janet_wrap_true();
}

JANET_CORE_FN(cfun_string_join,
              "(string/join parts &opt sep)",
              "Joins an array of strings into one string, optionally separated by "
              "a separator string `sep`.") {
    janet_arity(argc, 1, 2);
    JanetView parts = janet_getindexed(argv, 0);
    JanetByteView joiner;
    if (argc == 2) {
        joiner = janet_getbytes(argv, 1);
    } else {
        joiner.bytes = NULL;
        joiner.len = 0;
    }
    /* Check args */
    int32_t i;
    int64_t finallen = 0;
    for (i = 0; i < parts.len; i++) {
        const uint8_t *chunk;
        int32_t chunklen = 0;
        if (!janet_bytes_view(parts.items[i], &chunk, &chunklen)) {
            janet_panicf("item %d of parts is not a byte sequence, got %v", i, parts.items[i]);
        }
        if (i) finallen += joiner.len;
        finallen += chunklen;
        if (finallen > INT32_MAX)
            janet_panic("result string too long");
    }
    uint8_t *buf, *out;
    out = buf = janet_string_begin((int32_t) finallen);
    for (i = 0; i < parts.len; i++) {
        const uint8_t *chunk = NULL;
        int32_t chunklen = 0;
        if (i) {
            safe_memcpy(out, joiner.bytes, joiner.len);
            out += joiner.len;
        }
        janet_bytes_view(parts.items[i], &chunk, &chunklen);
        safe_memcpy(out, chunk, chunklen);
        out += chunklen;
    }
    return janet_wrap_string(janet_string_end(buf));
}

JANET_CORE_FN(cfun_string_format,
              "(string/format format & values)",
              "Similar to C's `snprintf`, but specialized for operating with Janet values. Returns "
              "a new string.") {
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_buffer(0);
    const char *strfrmt = (const char *) janet_getstring(argv, 0);
    janet_buffer_format(buffer, strfrmt, 0, argc, argv);
    return janet_stringv(buffer->data, buffer->count);
}

static int trim_help_checkset(JanetByteView set, uint8_t x) {
    for (int32_t j = 0; j < set.len; j++)
        if (set.bytes[j] == x)
            return 1;
    return 0;
}

static int32_t trim_help_leftedge(JanetByteView str, JanetByteView set) {
    for (int32_t i = 0; i < str.len; i++)
        if (!trim_help_checkset(set, str.bytes[i]))
            return i;
    return str.len;
}

static int32_t trim_help_rightedge(JanetByteView str, JanetByteView set) {
    for (int32_t i = str.len - 1; i >= 0; i--)
        if (!trim_help_checkset(set, str.bytes[i]))
            return i + 1;
    return 0;
}

static void trim_help_args(int32_t argc, Janet *argv, JanetByteView *str, JanetByteView *set) {
    janet_arity(argc, 1, 2);
    *str = janet_getbytes(argv, 0);
    if (argc >= 2) {
        *set = janet_getbytes(argv, 1);
    } else {
        set->bytes = (const uint8_t *)(" \t\r\n\v\f");
        set->len = 6;
    }
}

JANET_CORE_FN(cfun_string_trim,
              "(string/trim str &opt set)",
              "Trim leading and trailing whitespace from a byte sequence. If the argument "
              "`set` is provided, consider only characters in `set` to be whitespace.") {
    JanetByteView str, set;
    trim_help_args(argc, argv, &str, &set);
    int32_t left_edge = trim_help_leftedge(str, set);
    int32_t right_edge = trim_help_rightedge(str, set);
    if (right_edge < left_edge)
        return janet_stringv(NULL, 0);
    return janet_stringv(str.bytes + left_edge, right_edge - left_edge);
}

JANET_CORE_FN(cfun_string_triml,
              "(string/triml str &opt set)",
              "Trim leading whitespace from a byte sequence. If the argument "
              "`set` is provided, consider only characters in `set` to be whitespace.") {
    JanetByteView str, set;
    trim_help_args(argc, argv, &str, &set);
    int32_t left_edge = trim_help_leftedge(str, set);
    return janet_stringv(str.bytes + left_edge, str.len - left_edge);
}

JANET_CORE_FN(cfun_string_trimr,
              "(string/trimr str &opt set)",
              "Trim trailing whitespace from a byte sequence. If the argument "
              "`set` is provided, consider only characters in `set` to be whitespace.") {
    JanetByteView str, set;
    trim_help_args(argc, argv, &str, &set);
    int32_t right_edge = trim_help_rightedge(str, set);
    return janet_stringv(str.bytes, right_edge);
}

/* Module entry point */
void janet_lib_string(JanetTable *env) {
    JanetRegExt string_cfuns[] = {
        JANET_CORE_REG("string/slice", cfun_string_slice),
        JANET_CORE_REG("keyword/slice", cfun_keyword_slice),
        JANET_CORE_REG("symbol/slice", cfun_symbol_slice),
        JANET_CORE_REG("string/repeat", cfun_string_repeat),
        JANET_CORE_REG("string/bytes", cfun_string_bytes),
        JANET_CORE_REG("string/from-bytes", cfun_string_frombytes),
        JANET_CORE_REG("string/ascii-lower", cfun_string_asciilower),
        JANET_CORE_REG("string/ascii-upper", cfun_string_asciiupper),
        JANET_CORE_REG("string/reverse", cfun_string_reverse),
        JANET_CORE_REG("string/find", cfun_string_find),
        JANET_CORE_REG("string/find-all", cfun_string_findall),
        JANET_CORE_REG("string/has-prefix?", cfun_string_hasprefix),
        JANET_CORE_REG("string/has-suffix?", cfun_string_hassuffix),
        JANET_CORE_REG("string/replace", cfun_string_replace),
        JANET_CORE_REG("string/replace-all", cfun_string_replaceall),
        JANET_CORE_REG("string/split", cfun_string_split),
        JANET_CORE_REG("string/check-set", cfun_string_checkset),
        JANET_CORE_REG("string/join", cfun_string_join),
        JANET_CORE_REG("string/format", cfun_string_format),
        JANET_CORE_REG("string/trim", cfun_string_trim),
        JANET_CORE_REG("string/triml", cfun_string_triml),
        JANET_CORE_REG("string/trimr", cfun_string_trimr),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, string_cfuns);
}


/* src/core/strtod.c */
#line 0 "src/core/strtod.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

/* Use a custom double parser instead of libc's strtod for better portability
 * and control.
 *
 * This version has been modified for much greater flexibility in parsing, such
 * as choosing the radix and supporting scientific notation with any radix.
 *
 * Numbers are of the form [-+]R[rR]I.F[eE&][-+]X in pseudo-regex form, where R
 * is the radix, I is the integer part, F is the fractional part, and X is the
 * exponent. All signs, radix, decimal point, fractional part, and exponent can
 * be omitted.  The radix is assumed to be 10 if omitted, and the E or e
 * separator for the exponent can only be used when the radix is 10. This is
 * because E is a valid digit in bases 15 or greater. For bases greater than
 * 10, the letters are used as digits. A through Z correspond to the digits 10
 * through 35, and the lowercase letters have the same values. The radix number
 * is always in base 10. For example, a hexidecimal number could be written
 * '16rdeadbeef'. janet_scan_number also supports some c style syntax for
 * hexidecimal literals. The previous number could also be written
 * '0xdeadbeef'.
 */

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#include <math.h>
#include <string.h>

/* Lookup table for getting values of characters when parsing numbers. Handles
 * digits 0-9 and a-z (and A-Z). A-Z have values of 10 to 35. */
static uint8_t digit_lookup[128] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0xff, 0xff, 0xff, 0xff, 0xff
};

#define BIGNAT_NBIT 31
#define BIGNAT_BASE 0x80000000U

/* Allow for large mantissa. BigNat is a natural number. */
struct BigNat {
    uint32_t first_digit; /* First digit so we don't need to allocate when not needed. */
    int32_t n; /* n digits */
    int32_t cap; /* allocated digit capacity */
    uint32_t *digits; /* Each digit is base (2 ^ 31). Digits are least significant first. */
};

/* Initialize a bignat to 0 */
static void bignat_zero(struct BigNat *x) {
    x->first_digit = 0;
    x->n = 0;
    x->cap = 0;
    x->digits = NULL;
}

/* Allocate n more digits for mant. Return a pointer to these digits. */
static uint32_t *bignat_extra(struct BigNat *mant, int32_t n) {
    int32_t oldn = mant->n;
    int32_t newn = oldn + n;
    if (mant->cap < newn) {
        int32_t newcap = 2 * newn;
        uint32_t *mem = janet_realloc(mant->digits, (size_t) newcap * sizeof(uint32_t));
        if (NULL == mem) {
            JANET_OUT_OF_MEMORY;
        }
        mant->cap = newcap;
        mant->digits = mem;
    }
    mant->n = newn;
    return mant->digits + oldn;
}

/* Append a digit */
static void bignat_append(struct BigNat *mant, uint32_t dig) {
    bignat_extra(mant, 1)[0] = dig;
}

/* Multiply the mantissa mant by a factor and the add a term
 * in one operation. factor will be between 2 and 36^4,
 * term will be between 0 and 36. */
static void bignat_muladd(struct BigNat *mant, uint32_t factor, uint32_t term) {
    int32_t i;
    uint64_t carry = ((uint64_t) mant->first_digit) * factor + term;
    mant->first_digit = carry % BIGNAT_BASE;
    carry /= BIGNAT_BASE;
    for (i = 0; i < mant->n; i++) {
        carry += ((uint64_t) mant->digits[i]) * factor;
        mant->digits[i] = carry % BIGNAT_BASE;
        carry /= BIGNAT_BASE;
    }
    if (carry) bignat_append(mant, (uint32_t) carry);
}

/* Divide the mantissa mant by a factor. Drop the remainder. */
static void bignat_div(struct BigNat *mant, uint32_t divisor) {
    int32_t i;
    uint32_t quotient, remainder;
    uint64_t dividend;
    remainder = 0, quotient = 0;
    for (i = mant->n - 1; i >= 0; i--) {
        dividend = ((uint64_t)remainder * BIGNAT_BASE) + mant->digits[i];
        if (i < mant->n - 1) mant->digits[i + 1] = quotient;
        quotient = (uint32_t)(dividend / divisor);
        remainder = (uint32_t)(dividend % divisor);
        mant->digits[i] = remainder;
    }
    dividend = ((uint64_t)remainder * BIGNAT_BASE) + mant->first_digit;
    if (mant->n && mant->digits[mant->n - 1] == 0) mant->n--;
    mant->first_digit = (uint32_t)(dividend / divisor);
}

/* Shift left by a multiple of BIGNAT_NBIT */
static void bignat_lshift_n(struct BigNat *mant, int n) {
    if (!n) return;
    int32_t oldn = mant->n;
    bignat_extra(mant, n);
    memmove(mant->digits + n, mant->digits, sizeof(uint32_t) * oldn);
    memset(mant->digits, 0, sizeof(uint32_t) * (n - 1));
    mant->digits[n - 1] = mant->first_digit;
    mant->first_digit = 0;
}

#ifdef __GNUC__
#define clz(x) __builtin_clz(x)
#else
static int clz(uint32_t x) {
    int n = 0;
    if (x <= 0x0000ffff) n += 16, x <<= 16;
    if (x <= 0x00ffffff) n += 8, x <<= 8;
    if (x <= 0x0fffffff) n += 4, x <<= 4;
    if (x <= 0x3fffffff) n += 2, x <<= 2;
    if (x <= 0x7fffffff) n ++;
    return n;
}
#endif

/* Extract double value from mantissa */
static double bignat_extract(struct BigNat *mant, int32_t exponent2) {
    uint64_t top53;
    int32_t n = mant->n;
    /* Get most significant 53 bits from mant. Bit 52 (0 indexed) should
     * always be 1. This is essentially a large right shift on mant.*/
    if (n) {
        /* Two or more digits */
        uint64_t d1 = mant->digits[n - 1]; /* MSD (non-zero) */
        uint64_t d2 = (n == 1) ? mant->first_digit : mant->digits[n - 2];
        uint64_t d3 = (n > 2) ? mant->digits[n - 3] : (n == 2) ? mant->first_digit : 0;
        int lz = clz((uint32_t) d1);
        int nbits = 32 - lz;
        /* First get 54 bits */
        top53 = (d2 << (54 - BIGNAT_NBIT)) + (d3 >> (2 * BIGNAT_NBIT - 54));
        top53 >>= nbits;
        top53 |= (d1 << (54 - nbits));
        /* Rounding based on lowest bit of 54 */
        if (top53 & 1) top53++;
        top53 >>= 1;
        if (top53 > 0x1FffffFFFFffffUL) {
            top53 >>= 1;
            exponent2++;
        }
        /* Correct exponent - to correct for large right shift to mantissa. */
        exponent2 += (nbits - 53) + BIGNAT_NBIT * n;
    } else {
        /* One digit */
        top53 = mant->first_digit;
    }
    return ldexp((double)top53, exponent2);
}

/* Read in a mantissa and exponent of a certain base, and give
 * back the double value. Should properly handle 0s, infinities, and
 * denormalized numbers. (When the exponent values are too large or small) */
static double convert(
    int negative,
    struct BigNat *mant,
    int32_t base,
    int32_t exponent) {

    int32_t exponent2 = 0;

    /* Approximate exponent in base 2 of mant and exponent. This should get us a good estimate of the final size of the
     * number, within * 2^32 or so. */
    int64_t mant_exp2_approx = mant->n * 32 + 16;
    int64_t exp_exp2_approx = (int64_t)(floor(log2(base) * exponent));
    int64_t exp2_approx = mant_exp2_approx + exp_exp2_approx;

    /* Short circuit zero, huge, and small numbers. We use the exponent range of valid IEEE754 doubles (-1022, 1023)
     * with a healthy buffer to allow for inaccuracies in the approximation and denormailzed numbers. */
    if (mant->n == 0 && mant->first_digit == 0)
        return negative ? -0.0 : 0.0;
    if (exp2_approx > 1176)
        return negative ? -INFINITY : INFINITY;
    if (exp2_approx < -1175)
        return negative ? -0.0 : 0.0;

    /* Final value is X = mant * base ^ exponent * 2 ^ exponent2
     * Get exponent to zero while holding X constant. */

    /* Positive exponents are simple */
    for (; exponent > 3; exponent -= 4) bignat_muladd(mant, base * base * base * base, 0);
    for (; exponent > 1; exponent -= 2) bignat_muladd(mant, base * base, 0);
    for (; exponent > 0; exponent -= 1) bignat_muladd(mant, base, 0);

    /* Negative exponents are tricky - we don't want to loose bits
     * from integer division, so we need to premultiply. */
    if (exponent < 0) {
        int32_t shamt = 5 - exponent / 4;
        bignat_lshift_n(mant, shamt);
        exponent2 -= shamt * BIGNAT_NBIT;
        for (; exponent < -3; exponent += 4) bignat_div(mant, base * base * base * base);
        for (; exponent < -1; exponent += 2) bignat_div(mant, base * base);
        for (; exponent <  0; exponent += 1) bignat_div(mant, base);
    }

    return negative
           ? -bignat_extract(mant, exponent2)
           : bignat_extract(mant, exponent2);
}

/* Scan a real (double) from a string. If the string cannot be converted into
 * and integer, return 0. */
int janet_scan_number_base(
    const uint8_t *str,
    int32_t len,
    int32_t base,
    double *out) {
    const uint8_t *end = str + len;
    int seenadigit = 0;
    int ex = 0;
    int seenpoint = 0;
    int foundexp = 0;
    int neg = 0;
    struct BigNat mant;
    bignat_zero(&mant);

    /* Prevent some kinds of overflow bugs relating to the exponent
     * overflowing.  For example, if a string was passed 2GB worth of 0s after
     * the decimal point, exponent could wrap around and become positive. It's
     * easier to reject ridiculously large inputs than to check for overflows.
     * */
    if (len > INT32_MAX / 40) goto error;

    /* Get sign */
    if (str >= end) goto error;
    if (*str == '-') {
        neg = 1;
        str++;
    } else if (*str == '+') {
        str++;
    }

    /* Check for leading 0x or digit digit r */
    if (base == 0) {
        if (str + 1 < end && str[0] == '0' && str[1] == 'x') {
            base = 16;
            str += 2;
        } else if (str + 1 < end  &&
                   str[0] >= '0' && str[0] <= '9' &&
                   str[1] == 'r') {
            base = str[0] - '0';
            str += 2;
        } else if (str + 2 < end  &&
                   str[0] >= '0' && str[0] <= '9' &&
                   str[1] >= '0' && str[1] <= '9' &&
                   str[2] == 'r') {
            base = 10 * (str[0] - '0') + (str[1] - '0');
            if (base < 2 || base > 36) goto error;
            str += 3;
        }
    }

    /* If still base is 0, set to default (10) */
    if (base == 0) {
        base = 10;
    }

    /* Skip leading zeros */
    while (str < end && (*str == '0' || *str == '.')) {
        if (seenpoint) ex--;
        if (*str == '.') {
            if (seenpoint) goto error;
            seenpoint = 1;
        } else {
            seenadigit = 1;
        }
        str++;
    }

    /* Parse significant digits */
    while (str < end) {
        if (*str == '.') {
            if (seenpoint) goto error;
            seenpoint = 1;
        } else if (*str == '&') {
            foundexp = 1;
            break;
        } else if (base == 10 && (*str == 'E' || *str == 'e')) {
            foundexp = 1;
            break;
        } else if (*str == '_') {
            if (!seenadigit) goto error;
        } else {
            int digit = digit_lookup[*str & 0x7F];
            if (*str > 127 || digit >= base) goto error;
            if (seenpoint) ex--;
            bignat_muladd(&mant, base, digit);
            seenadigit = 1;
        }
        str++;
    }

    if (!seenadigit)
        goto error;

    /* Read exponent */
    if (str < end && foundexp) {
        int eneg = 0;
        int32_t ee = 0;
        seenadigit = 0;
        str++;
        if (str >= end) goto error;
        if (*str == '-') {
            eneg = 1;
            str++;
        } else if (*str == '+') {
            str++;
        }
        /* Skip leading 0s in exponent */
        while (str < end && *str == '0') {
            str++;
            seenadigit = 1;
        }
        while (str < end) {
            int digit = digit_lookup[*str & 0x7F];
            if (*str > 127 || digit >= base) goto error;
            if (ee < (INT32_MAX / 40)) {
                ee = base * ee + digit;
            }
            str++;
            seenadigit = 1;
        }
        if (eneg) ex -= ee;
        else ex += ee;
    }

    if (!seenadigit)
        goto error;

    *out = convert(neg, &mant, base, ex);
    janet_free(mant.digits);
    return 0;

error:
    janet_free(mant.digits);
    return 1;
}

int janet_scan_number(
    const uint8_t *str,
    int32_t len,
    double *out) {
    return janet_scan_number_base(str, len, 0, out);
}

#ifdef JANET_INT_TYPES

static int scan_uint64(
    const uint8_t *str,
    int32_t len,
    uint64_t *out,
    int *neg) {
    const uint8_t *end = str + len;
    int seenadigit = 0;
    int base = 10;
    *neg = 0;
    *out = 0;
    uint64_t accum = 0;
    /* len max is INT64_MAX in base 2 with _ between each bits */
    /* '2r' + 64 bits + 63 _  + sign = 130 => 150 for some leading  */
    /* zeros */
    if (len > 150) return 0;
    /* Get sign */
    if (str >= end) return 0;
    if (*str == '-') {
        *neg = 1;
        str++;
    } else if (*str == '+') {
        str++;
    }
    /* Check for leading 0x or digit digit r */
    if (str + 1 < end && str[0] == '0' && str[1] == 'x') {
        base = 16;
        str += 2;
    } else if (str + 1 < end  &&
               str[0] >= '0' && str[0] <= '9' &&
               str[1] == 'r') {
        base = str[0] - '0';
        str += 2;
    } else if (str + 2 < end  &&
               str[0] >= '0' && str[0] <= '9' &&
               str[1] >= '0' && str[1] <= '9' &&
               str[2] == 'r') {
        base = 10 * (str[0] - '0') + (str[1] - '0');
        if (base < 2 || base > 36) return 0;
        str += 3;
    }

    /* Skip leading zeros */
    while (str < end && *str == '0') {
        seenadigit = 1;
        str++;
    }
    /* Parse significant digits */
    while (str < end) {
        if (*str == '_') {
            if (!seenadigit) return 0;
        } else {
            int digit = digit_lookup[*str & 0x7F];
            if (*str > 127 || digit >= base) return 0;
            if (accum > (UINT64_MAX - digit) / base) return 0;
            accum = accum * base + digit;
            seenadigit = 1;
        }
        str++;
    }

    if (!seenadigit) return 0;
    *out = accum;
    return 1;
}

int janet_scan_int64(const uint8_t *str, int32_t len, int64_t *out) {
    int neg;
    uint64_t bi;
    if (scan_uint64(str, len, &bi, &neg)) {
        if (neg && bi <= ((UINT64_MAX / 2) + 1)) {
            if (bi > INT64_MAX) {
                *out = INT64_MIN;
            } else {
                *out = -((int64_t) bi);
            }
            return 1;
        }
        if (!neg && bi <= INT64_MAX) {
            *out = (int64_t) bi;
            return 1;
        }
    }
    return 0;
}

int janet_scan_uint64(const uint8_t *str, int32_t len, uint64_t *out) {
    int neg;
    uint64_t bi;
    if (scan_uint64(str, len, &bi, &neg)) {
        if (!neg) {
            *out = bi;
            return 1;
        }
    }
    return 0;
}

#endif


/* src/core/struct.c */
#line 0 "src/core/struct.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include <math.h>
#endif

/* Begin creation of a struct */
JanetKV *janet_struct_begin(int32_t count) {
    /* Calculate capacity as power of 2 after 2 * count. */
    int32_t capacity = janet_tablen(2 * count);
    if (capacity < 0) capacity = janet_tablen(count + 1);

    size_t size = sizeof(JanetStructHead) + (size_t) capacity * sizeof(JanetKV);
    JanetStructHead *head = janet_gcalloc(JANET_MEMORY_STRUCT, size);
    head->length = count;
    head->capacity = capacity;
    head->hash = 0;
    head->proto = NULL;

    JanetKV *st = (JanetKV *)(head->data);
    janet_memempty(st, capacity);
    return st;
}

/* Find an item in a struct without looking for prototypes. Should be similar to janet_dict_find, but
 * specialized to structs (slightly more compact). */
const JanetKV *janet_struct_find(const JanetKV *st, Janet key) {
    int32_t cap = janet_struct_capacity(st);
    int32_t index = janet_maphash(cap, janet_hash(key));
    int32_t i;
    for (i = index; i < cap; i++)
        if (janet_checktype(st[i].key, JANET_NIL) || janet_equals(st[i].key, key))
            return st + i;
    for (i = 0; i < index; i++)
        if (janet_checktype(st[i].key, JANET_NIL) || janet_equals(st[i].key, key))
            return st + i;
    return NULL;
}

/* Put a kv pair into a struct that has not yet been fully constructed.
 * Nil keys and values are ignored, extra keys are ignore, and duplicate keys are
 * ignored.
 *
 * Runs will be in sorted order, as the collisions resolver essentially
 * preforms an in-place insertion sort. This ensures the internal structure of the
 * hash map is independent of insertion order.
 */
void janet_struct_put_ext(JanetKV *st, Janet key, Janet value, int replace) {
    int32_t cap = janet_struct_capacity(st);
    int32_t hash = janet_hash(key);
    int32_t index = janet_maphash(cap, hash);
    int32_t i, j, dist;
    int32_t bounds[4] = {index, cap, 0, index};
    if (janet_checktype(key, JANET_NIL) || janet_checktype(value, JANET_NIL)) return;
    if (janet_checktype(key, JANET_NUMBER) && isnan(janet_unwrap_number(key))) return;
    /* Avoid extra items */
    if (janet_struct_hash(st) == janet_struct_length(st)) return;
    for (dist = 0, j = 0; j < 4; j += 2)
        for (i = bounds[j]; i < bounds[j + 1]; i++, dist++) {
            int status;
            int32_t otherhash;
            int32_t otherindex, otherdist;
            JanetKV *kv = st + i;
            /* We found an empty slot, so just add key and value */
            if (janet_checktype(kv->key, JANET_NIL)) {
                kv->key = key;
                kv->value = value;
                /* Update the temporary count */
                janet_struct_hash(st)++;
                return;
            }
            /* Robinhood hashing - check if colliding kv pair
             * is closer to their source than current. We use robinhood
             * hashing to ensure that equivalent structs that are constructed
             * with different order have the same internal layout, and therefor
             * will compare properly - i.e., {1 2 3 4} should equal {3 4 1 2}.
             * Collisions are resolved via an insertion sort insertion. */
            otherhash = janet_hash(kv->key);
            otherindex = janet_maphash(cap, otherhash);
            otherdist = (i + cap - otherindex) & (cap - 1);
            if (dist < otherdist)
                status = -1;
            else if (otherdist < dist)
                status = 1;
            else if (hash < otherhash)
                status = -1;
            else if (otherhash < hash)
                status = 1;
            else
                status = janet_compare(key, kv->key);
            /* If other is closer to their ideal slot */
            if (status == 1) {
                /* Swap current kv pair with pair in slot */
                JanetKV temp = *kv;
                kv->key = key;
                kv->value = value;
                key = temp.key;
                value = temp.value;
                /* Save dist and hash of new kv pair */
                dist = otherdist;
                hash = otherhash;
            } else if (status == 0) {
                if (replace) {
                    /* A key was added to the struct more than once - replace old value */
                    kv->value = value;
                }
                return;
            }
        }
}

void janet_struct_put(JanetKV *st, Janet key, Janet value) {
    janet_struct_put_ext(st, key, value, 1);
}

/* Finish building a struct */
const JanetKV *janet_struct_end(JanetKV *st) {
    if (janet_struct_hash(st) != janet_struct_length(st)) {
        /* Error building struct, probably duplicate values. We need to rebuild
         * the struct using only the values that went in. The second creation should always
         * succeed. */
        JanetKV *newst = janet_struct_begin(janet_struct_hash(st));
        for (int32_t i = 0; i < janet_struct_capacity(st); i++) {
            JanetKV *kv = st + i;
            if (!janet_checktype(kv->key, JANET_NIL)) {
                janet_struct_put(newst, kv->key, kv->value);
            }
        }
        janet_struct_proto(newst) = janet_struct_proto(st);
        st = newst;
    }
    janet_struct_hash(st) = janet_kv_calchash(st, janet_struct_capacity(st));
    if (janet_struct_proto(st)) {
        janet_struct_hash(st) += 2654435761u * janet_struct_hash(janet_struct_proto(st));
    }
    return (const JanetKV *)st;
}

/* Get an item from a struct without looking into prototypes. */
Janet janet_struct_rawget(const JanetKV *st, Janet key) {
    const JanetKV *kv = janet_struct_find(st, key);
    return kv ? kv->value : janet_wrap_nil();
}

/* Get an item from a struct */
Janet janet_struct_get(const JanetKV *st, Janet key) {
    for (int i = JANET_MAX_PROTO_DEPTH; st && i; --i, st = janet_struct_proto(st)) {
        const JanetKV *kv = janet_struct_find(st, key);
        if (NULL != kv && !janet_checktype(kv->key, JANET_NIL)) {
            return kv->value;
        }
    }
    return janet_wrap_nil();
}

/* Get an item from a struct, and record which prototype the item came from. */
Janet janet_struct_get_ex(const JanetKV *st, Janet key, JanetStruct *which) {
    for (int i = JANET_MAX_PROTO_DEPTH; st && i; --i, st = janet_struct_proto(st)) {
        const JanetKV *kv = janet_struct_find(st, key);
        if (NULL != kv && !janet_checktype(kv->key, JANET_NIL)) {
            *which = st;
            return kv->value;
        }
    }
    return janet_wrap_nil();
}

/* Convert struct to table */
JanetTable *janet_struct_to_table(const JanetKV *st) {
    JanetTable *table = janet_table(janet_struct_capacity(st));
    int32_t i;
    for (i = 0; i < janet_struct_capacity(st); i++) {
        const JanetKV *kv = st + i;
        if (!janet_checktype(kv->key, JANET_NIL)) {
            janet_table_put(table, kv->key, kv->value);
        }
    }
    return table;
}

/* C Functions */

JANET_CORE_FN(cfun_struct_with_proto,
              "(struct/with-proto proto & kvs)",
              "Create a structure, as with the usual struct constructor but set the "
              "struct prototype as well.") {
    janet_arity(argc, 1, -1);
    JanetStruct proto = janet_optstruct(argv, argc, 0, NULL);
    if (!(argc & 1))
        janet_panic("expected odd number of arguments");
    JanetKV *st = janet_struct_begin(argc / 2);
    for (int32_t i = 1; i < argc; i += 2) {
        janet_struct_put(st, argv[i], argv[i + 1]);
    }
    janet_struct_proto(st) = proto;
    return janet_wrap_struct(janet_struct_end(st));
}

JANET_CORE_FN(cfun_struct_getproto,
              "(struct/getproto st)",
              "Return the prototype of a struct, or nil if it doesn't have one.") {
    janet_fixarity(argc, 1);
    JanetStruct st = janet_getstruct(argv, 0);
    return janet_struct_proto(st)
           ? janet_wrap_struct(janet_struct_proto(st))
           : janet_wrap_nil();
}

JANET_CORE_FN(cfun_struct_flatten,
              "(struct/proto-flatten st)",
              "Convert a struct with prototypes to a struct with no prototypes by merging "
              "all key value pairs from recursive prototypes into one new struct.") {
    janet_fixarity(argc, 1);
    JanetStruct st = janet_getstruct(argv, 0);

    /* get an upper bounds on the number of items in the final struct */
    int64_t pair_count = 0;
    JanetStruct cursor = st;
    while (cursor) {
        pair_count += janet_struct_length(cursor);
        cursor = janet_struct_proto(cursor);
    }

    if (pair_count > INT32_MAX) {
        janet_panic("struct too large");
    }

    JanetKV *accum = janet_struct_begin((int32_t) pair_count);
    cursor = st;
    while (cursor) {
        for (int32_t i = 0; i < janet_struct_capacity(cursor); i++) {
            const JanetKV *kv = cursor + i;
            if (!janet_checktype(kv->key, JANET_NIL)) {
                janet_struct_put_ext(accum, kv->key, kv->value, 0);
            }
        }
        cursor = janet_struct_proto(cursor);
    }
    return janet_wrap_struct(janet_struct_end(accum));
}

JANET_CORE_FN(cfun_struct_to_table,
              "(struct/to-table st &opt recursive)",
              "Convert a struct to a table. If recursive is true, also convert the "
              "table's prototypes into the new struct's prototypes as well.") {
    janet_arity(argc, 1, 2);
    JanetStruct st = janet_getstruct(argv, 0);
    int recursive = argc > 1 && janet_truthy(argv[1]);
    JanetTable *tab = NULL;
    JanetStruct cursor = st;
    JanetTable *tab_cursor = tab;
    do {
        if (tab) {
            tab_cursor->proto = janet_table(janet_struct_length(cursor));
            tab_cursor = tab_cursor->proto;
        } else {
            tab = janet_table(janet_struct_length(cursor));
            tab_cursor = tab;
        }
        /* TODO - implement as memcpy since struct memory should be compatible
         * with table memory */
        for (int32_t i = 0; i < janet_struct_capacity(cursor); i++) {
            const JanetKV *kv = cursor + i;
            if (!janet_checktype(kv->key, JANET_NIL)) {
                janet_table_put(tab_cursor, kv->key, kv->value);
            }
        }
        cursor = janet_struct_proto(cursor);
    } while (recursive && cursor);
    return janet_wrap_table(tab);
}

/* Load the struct module */
void janet_lib_struct(JanetTable *env) {
    JanetRegExt struct_cfuns[] = {
        JANET_CORE_REG("struct/with-proto", cfun_struct_with_proto),
        JANET_CORE_REG("struct/getproto", cfun_struct_getproto),
        JANET_CORE_REG("struct/proto-flatten", cfun_struct_flatten),
        JANET_CORE_REG("struct/to-table", cfun_struct_to_table),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, struct_cfuns);
}


/* src/core/symcache.c */
#line 0 "src/core/symcache.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

/* The symbol cache is an open hashtable with all active symbols in the program
 * stored in it. As the primary use of symbols is table lookups and equality
 * checks, all symbols are interned so that there is a single copy of it in the
 * whole program. Equality is then just a pointer check. */

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "gc.h"
#include "util.h"
#include "symcache.h"
#endif

#include <string.h>

/* Initialize the cache (allocate cache memory) */
void janet_symcache_init() {
    janet_vm.cache_capacity = 1024;
    janet_vm.cache = janet_calloc(1, (size_t) janet_vm.cache_capacity * sizeof(const uint8_t *));
    if (NULL == janet_vm.cache) {
        JANET_OUT_OF_MEMORY;
    }
    memset(&janet_vm.gensym_counter, '0', sizeof(janet_vm.gensym_counter));
    janet_vm.gensym_counter[0] = '_';
    janet_vm.cache_count = 0;
    janet_vm.cache_deleted = 0;
}

/* Deinitialize the cache (free the cache memory) */
void janet_symcache_deinit() {
    janet_free((void *)janet_vm.cache);
    janet_vm.cache = NULL;
    janet_vm.cache_capacity = 0;
    janet_vm.cache_count = 0;
    janet_vm.cache_deleted = 0;
}

/* Mark an entry in the table as deleted. */
static const uint8_t JANET_SYMCACHE_DELETED[1] = {0};

/* Find an item in the cache and return its location.
 * If the item is not found, return the location
 * where one would put it. */
static const uint8_t **janet_symcache_findmem(
    const uint8_t *str,
    int32_t len,
    int32_t hash,
    int *success) {
    uint32_t bounds[4];
    uint32_t i, j, index;
    const uint8_t **firstEmpty = NULL;

    /* We will search two ranges - index to the end,
     * and 0 to the index. */
    index = (uint32_t)hash & (janet_vm.cache_capacity - 1);
    bounds[0] = index;
    bounds[1] = janet_vm.cache_capacity;
    bounds[2] = 0;
    bounds[3] = index;
    for (j = 0; j < 4; j += 2)
        for (i = bounds[j]; i < bounds[j + 1]; ++i) {
            const uint8_t *test = janet_vm.cache[i];
            /* Check empty spots */
            if (NULL == test) {
                if (NULL == firstEmpty)
                    firstEmpty = janet_vm.cache + i;
                goto notfound;
            }
            /* Check for marked deleted */
            if (JANET_SYMCACHE_DELETED == test) {
                if (firstEmpty == NULL)
                    firstEmpty = janet_vm.cache + i;
                continue;
            }
            if (janet_string_equalconst(test, str, len, hash)) {
                /* Replace first deleted */
                *success = 1;
                if (firstEmpty != NULL) {
                    *firstEmpty = test;
                    janet_vm.cache[i] = JANET_SYMCACHE_DELETED;
                    return firstEmpty;
                }
                return janet_vm.cache + i;
            }
        }
notfound:
    *success = 0;
    return firstEmpty;
}

#define janet_symcache_find(str, success) \
    janet_symcache_findmem((str), janet_string_length(str), janet_string_hash(str), (success))

/* Resize the cache. */
static void janet_cache_resize(uint32_t newCapacity) {
    uint32_t i, oldCapacity;
    const uint8_t **oldCache = janet_vm.cache;
    const uint8_t **newCache = janet_calloc(1, (size_t) newCapacity * sizeof(const uint8_t *));
    if (newCache == NULL) {
        JANET_OUT_OF_MEMORY;
    }
    oldCapacity = janet_vm.cache_capacity;
    janet_vm.cache = newCache;
    janet_vm.cache_capacity = newCapacity;
    janet_vm.cache_deleted = 0;
    /* Add all of the old cache entries back */
    for (i = 0; i < oldCapacity; ++i) {
        int status;
        const uint8_t **bucket;
        const uint8_t *x = oldCache[i];
        if (x != NULL && x != JANET_SYMCACHE_DELETED) {
            bucket = janet_symcache_find(x, &status);
            if (status || bucket == NULL) {
                /* there was a problem with the algorithm. */
                break;
            }
            *bucket = x;
        }
    }
    /* Free the old cache */
    janet_free((void *)oldCache);
}

/* Add an item to the cache */
static void janet_symcache_put(const uint8_t *x, const uint8_t **bucket) {
    if ((janet_vm.cache_count + janet_vm.cache_deleted) * 2 > janet_vm.cache_capacity) {
        int status;
        janet_cache_resize(janet_tablen((2 * janet_vm.cache_count + 1)));
        bucket = janet_symcache_find(x, &status);
    }
    /* Add x to the cache */
    janet_vm.cache_count++;
    *bucket = x;
}

/* Remove a symbol from the symcache */
void janet_symbol_deinit(const uint8_t *sym) {
    int status = 0;
    const uint8_t **bucket = janet_symcache_find(sym, &status);
    if (status) {
        janet_vm.cache_count--;
        janet_vm.cache_deleted++;
        *bucket = JANET_SYMCACHE_DELETED;
    }
}

/* Create a symbol from a byte string */
const uint8_t *janet_symbol(const uint8_t *str, int32_t len) {
    int32_t hash = janet_string_calchash(str, len);
    uint8_t *newstr;
    int success = 0;
    const uint8_t **bucket = janet_symcache_findmem(str, len, hash, &success);
    if (success)
        return *bucket;
    JanetStringHead *head = janet_gcalloc(JANET_MEMORY_SYMBOL, sizeof(JanetStringHead) + (size_t) len + 1);
    head->hash = hash;
    head->length = len;
    newstr = (uint8_t *)(head->data);
    safe_memcpy(newstr, str, len);
    newstr[len] = 0;
    janet_symcache_put((const uint8_t *)newstr, bucket);
    return newstr;
}

/* Get a symbol from a cstring */
const uint8_t *janet_csymbol(const char *cstr) {
    return janet_symbol((const uint8_t *)cstr, (int32_t) strlen(cstr));
}

/* Increment the gensym buffer */
static void inc_gensym(void) {
    for (int i = sizeof(janet_vm.gensym_counter) - 2; i; i--) {
        if (janet_vm.gensym_counter[i] == '9') {
            janet_vm.gensym_counter[i] = 'a';
            break;
        } else if (janet_vm.gensym_counter[i] == 'z') {
            janet_vm.gensym_counter[i] = 'A';
            break;
        } else if (janet_vm.gensym_counter[i] == 'Z') {
            janet_vm.gensym_counter[i] = '0';
        } else {
            janet_vm.gensym_counter[i]++;
            break;
        }
    }
}

/* Generate a unique symbol. This is used in the library function gensym. The
 * symbol will be of the format _XXXXXX, where X is a base64 digit, and
 * prefix is the argument passed. No prefix for speed. */
const uint8_t *janet_symbol_gen(void) {
    const uint8_t **bucket = NULL;
    uint8_t *sym;
    int32_t hash = 0;
    int status;
    /* Leave spaces for 6 base 64 digits and two dashes. That means 64^6 possible suffixes, which
     * is enough for resolving collisions. */
    do {
        hash = janet_string_calchash(
                   janet_vm.gensym_counter,
                   sizeof(janet_vm.gensym_counter) - 1);
        bucket = janet_symcache_findmem(
                     janet_vm.gensym_counter,
                     sizeof(janet_vm.gensym_counter) - 1,
                     hash,
                     &status);
    } while (status && (inc_gensym(), 1));
    JanetStringHead *head = janet_gcalloc(JANET_MEMORY_SYMBOL, sizeof(JanetStringHead) + sizeof(janet_vm.gensym_counter));
    head->length = sizeof(janet_vm.gensym_counter) - 1;
    head->hash = hash;
    sym = (uint8_t *)(head->data);
    memcpy(sym, janet_vm.gensym_counter, sizeof(janet_vm.gensym_counter));
    janet_symcache_put((const uint8_t *)sym, bucket);
    return (const uint8_t *)sym;
}


/* src/core/table.c */
#line 0 "src/core/table.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include <math.h>
#endif

#define JANET_TABLE_FLAG_STACK 0x10000

static void *janet_memalloc_empty_local(int32_t count) {
    int32_t i;
    void *mem = janet_smalloc((size_t) count * sizeof(JanetKV));
    JanetKV *mmem = (JanetKV *)mem;
    for (i = 0; i < count; i++) {
        JanetKV *kv = mmem + i;
        kv->key = janet_wrap_nil();
        kv->value = janet_wrap_nil();
    }
    return mem;
}

static JanetTable *janet_table_init_impl(JanetTable *table, int32_t capacity, int stackalloc) {
    JanetKV *data;
    capacity = janet_tablen(capacity);
    if (stackalloc) table->gc.flags = JANET_TABLE_FLAG_STACK;
    if (capacity) {
        if (stackalloc) {
            data = janet_memalloc_empty_local(capacity);
        } else {
            data = (JanetKV *) janet_memalloc_empty(capacity);
            if (NULL == data) {
                JANET_OUT_OF_MEMORY;
            }
        }
        table->data = data;
        table->capacity = capacity;
    } else {
        table->data = NULL;
        table->capacity = 0;
    }
    table->count = 0;
    table->deleted = 0;
    table->proto = NULL;
    return table;
}

/* Initialize a table (for use withs scratch memory) */
JanetTable *janet_table_init(JanetTable *table, int32_t capacity) {
    return janet_table_init_impl(table, capacity, 1);
}

/* Initialize a table without using scratch memory */
JanetTable *janet_table_init_raw(JanetTable *table, int32_t capacity) {
    return janet_table_init_impl(table, capacity, 0);
}

/* Deinitialize a table */
void janet_table_deinit(JanetTable *table) {
    if (table->gc.flags & JANET_TABLE_FLAG_STACK) {
        janet_sfree(table->data);
    } else {
        janet_free(table->data);
    }
}

/* Create a new table */
JanetTable *janet_table(int32_t capacity) {
    JanetTable *table = janet_gcalloc(JANET_MEMORY_TABLE, sizeof(JanetTable));
    return janet_table_init_impl(table, capacity, 0);
}

/* Find the bucket that contains the given key. Will also return
 * bucket where key should go if not in the table. */
JanetKV *janet_table_find(JanetTable *t, Janet key) {
    return (JanetKV *) janet_dict_find(t->data, t->capacity, key);
}

/* Resize the dictionary table. */
static void janet_table_rehash(JanetTable *t, int32_t size) {
    JanetKV *olddata = t->data;
    JanetKV *newdata;
    int islocal = t->gc.flags & JANET_TABLE_FLAG_STACK;
    if (islocal) {
        newdata = (JanetKV *) janet_memalloc_empty_local(size);
    } else {
        newdata = (JanetKV *) janet_memalloc_empty(size);
        if (NULL == newdata) {
            JANET_OUT_OF_MEMORY;
        }
    }
    int32_t i, oldcapacity;
    oldcapacity = t->capacity;
    t->data = newdata;
    t->capacity = size;
    t->deleted = 0;
    for (i = 0; i < oldcapacity; i++) {
        JanetKV *kv = olddata + i;
        if (!janet_checktype(kv->key, JANET_NIL)) {
            JanetKV *newkv = janet_table_find(t, kv->key);
            *newkv = *kv;
        }
    }
    if (islocal) {
        janet_sfree(olddata);
    } else {
        janet_free(olddata);
    }
}

/* Get a value out of the table */
Janet janet_table_get(JanetTable *t, Janet key) {
    for (int i = JANET_MAX_PROTO_DEPTH; t && i; t = t->proto, --i) {
        JanetKV *bucket = janet_table_find(t, key);
        if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))
            return bucket->value;
    }
    return janet_wrap_nil();
}

/* Get a value out of the table, and record which prototype it was from. */
Janet janet_table_get_ex(JanetTable *t, Janet key, JanetTable **which) {
    for (int i = JANET_MAX_PROTO_DEPTH; t && i; t = t->proto, --i) {
        JanetKV *bucket = janet_table_find(t, key);
        if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {
            *which = t;
            return bucket->value;
        }
    }
    return janet_wrap_nil();
}

/* Get a value out of the table. Don't check prototype tables. */
Janet janet_table_rawget(JanetTable *t, Janet key) {
    JanetKV *bucket = janet_table_find(t, key);
    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))
        return bucket->value;
    else
        return janet_wrap_nil();
}

/* Remove an entry from the dictionary. Return the value that
 * was removed. */
Janet janet_table_remove(JanetTable *t, Janet key) {
    JanetKV *bucket = janet_table_find(t, key);
    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {
        Janet ret = bucket->value;
        t->count--;
        t->deleted++;
        bucket->key = janet_wrap_nil();
        bucket->value = janet_wrap_false();
        return ret;
    } else {
        return janet_wrap_nil();
    }
}

/* Put a value into the object */
void janet_table_put(JanetTable *t, Janet key, Janet value) {
    if (janet_checktype(key, JANET_NIL)) return;
    if (janet_checktype(key, JANET_NUMBER) && isnan(janet_unwrap_number(key))) return;
    if (janet_checktype(value, JANET_NIL)) {
        janet_table_remove(t, key);
    } else {
        JanetKV *bucket = janet_table_find(t, key);
        if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {
            bucket->value = value;
        } else {
            if (NULL == bucket || 2 * (t->count + t->deleted + 1) > t->capacity) {
                janet_table_rehash(t, janet_tablen(2 * t->count + 2));
            }
            bucket = janet_table_find(t, key);
            if (janet_checktype(bucket->value, JANET_BOOLEAN))
                --t->deleted;
            bucket->key = key;
            bucket->value = value;
            ++t->count;
        }
    }
}

/* Used internally so don't check arguments
 * Put into a table, but if the key already exists do nothing. */
static void janet_table_put_no_overwrite(JanetTable *t, Janet key, Janet value) {
    JanetKV *bucket = janet_table_find(t, key);
    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))
        return;
    if (NULL == bucket || 2 * (t->count + t->deleted + 1) > t->capacity) {
        janet_table_rehash(t, janet_tablen(2 * t->count + 2));
    }
    bucket = janet_table_find(t, key);
    if (janet_checktype(bucket->value, JANET_BOOLEAN))
        --t->deleted;
    bucket->key = key;
    bucket->value = value;
    ++t->count;
}

/* Clear a table */
void janet_table_clear(JanetTable *t) {
    int32_t capacity = t->capacity;
    JanetKV *data = t->data;
    janet_memempty(data, capacity);
    t->count = 0;
    t->deleted = 0;
}

/* Clone a table. */
JanetTable *janet_table_clone(JanetTable *table) {
    JanetTable *newTable = janet_gcalloc(JANET_MEMORY_TABLE, sizeof(JanetTable));
    newTable->count = table->count;
    newTable->capacity = table->capacity;
    newTable->deleted = table->deleted;
    newTable->proto = table->proto;
    newTable->data = janet_malloc(newTable->capacity * sizeof(JanetKV));
    if (NULL == newTable->data) {
        JANET_OUT_OF_MEMORY;
    }
    memcpy(newTable->data, table->data, (size_t) table->capacity * sizeof(JanetKV));
    return newTable;
}

/* Merge a table or struct into a table */
static void janet_table_mergekv(JanetTable *table, const JanetKV *kvs, int32_t cap) {
    int32_t i;
    for (i = 0; i < cap; i++) {
        const JanetKV *kv = kvs + i;
        if (!janet_checktype(kv->key, JANET_NIL)) {
            janet_table_put(table, kv->key, kv->value);
        }
    }
}

/* Merge a table into another table */
void janet_table_merge_table(JanetTable *table, JanetTable *other) {
    janet_table_mergekv(table, other->data, other->capacity);
}

/* Merge a struct into a table */
void janet_table_merge_struct(JanetTable *table, const JanetKV *other) {
    janet_table_mergekv(table, other, janet_struct_capacity(other));
}

/* Convert table to struct */
const JanetKV *janet_table_to_struct(JanetTable *t) {
    JanetKV *st = janet_struct_begin(t->count);
    JanetKV *kv = t->data;
    JanetKV *end = t->data + t->capacity;
    while (kv < end) {
        if (!janet_checktype(kv->key, JANET_NIL))
            janet_struct_put(st, kv->key, kv->value);
        kv++;
    }
    return janet_struct_end(st);
}

JanetTable *janet_table_proto_flatten(JanetTable *t) {
    JanetTable *newTable = janet_table(0);
    while (t) {
        JanetKV *kv = t->data;
        JanetKV *end = t->data + t->capacity;
        while (kv < end) {
            if (!janet_checktype(kv->key, JANET_NIL))
                janet_table_put_no_overwrite(newTable, kv->key, kv->value);
            kv++;
        }
        t = t->proto;
    }
    return newTable;
}

/* C Functions */

JANET_CORE_FN(cfun_table_new,
              "(table/new capacity)",
              "Creates a new empty table with pre-allocated memory "
              "for `capacity` entries. This means that if one knows the number of "
              "entries going into a table on creation, extra memory allocation "
              "can be avoided. Returns the new table.") {
    janet_fixarity(argc, 1);
    int32_t cap = janet_getnat(argv, 0);
    return janet_wrap_table(janet_table(cap));
}

JANET_CORE_FN(cfun_table_getproto,
              "(table/getproto tab)",
              "Get the prototype table of a table. Returns nil if the table "
              "has no prototype, otherwise returns the prototype.") {
    janet_fixarity(argc, 1);
    JanetTable *t = janet_gettable(argv, 0);
    return t->proto
           ? janet_wrap_table(t->proto)
           : janet_wrap_nil();
}

JANET_CORE_FN(cfun_table_setproto,
              "(table/setproto tab proto)",
              "Set the prototype of a table. Returns the original table `tab`.") {
    janet_fixarity(argc, 2);
    JanetTable *table = janet_gettable(argv, 0);
    JanetTable *proto = NULL;
    if (!janet_checktype(argv[1], JANET_NIL)) {
        proto = janet_gettable(argv, 1);
    }
    table->proto = proto;
    return argv[0];
}

JANET_CORE_FN(cfun_table_tostruct,
              "(table/to-struct tab)",
              "Convert a table to a struct. Returns a new struct. This function "
              "does not take into account prototype tables.") {
    janet_fixarity(argc, 1);
    JanetTable *t = janet_gettable(argv, 0);
    return janet_wrap_struct(janet_table_to_struct(t));
}

JANET_CORE_FN(cfun_table_rawget,
              "(table/rawget tab key)",
              "Gets a value from a table `tab` without looking at the prototype table. "
              "If `tab` does not contain the key directly, the function will return "
              "nil without checking the prototype. Returns the value in the table.") {
    janet_fixarity(argc, 2);
    JanetTable *table = janet_gettable(argv, 0);
    return janet_table_rawget(table, argv[1]);
}

JANET_CORE_FN(cfun_table_clone,
              "(table/clone tab)",
              "Create a copy of a table. Updates to the new table will not change the old table, "
              "and vice versa.") {
    janet_fixarity(argc, 1);
    JanetTable *table = janet_gettable(argv, 0);
    return janet_wrap_table(janet_table_clone(table));
}

JANET_CORE_FN(cfun_table_clear,
              "(table/clear tab)",
              "Remove all key-value pairs in a table and return the modified table `tab`.") {
    janet_fixarity(argc, 1);
    JanetTable *table = janet_gettable(argv, 0);
    janet_table_clear(table);
    return janet_wrap_table(table);
}

JANET_CORE_FN(cfun_table_proto_flatten,
              "(table/proto-flatten tab)",
              "Create a new table that is the result of merging all prototypes into a new table.") {
    janet_fixarity(argc, 1);
    JanetTable *table = janet_gettable(argv, 0);
    return janet_wrap_table(janet_table_proto_flatten(table));
}

/* Load the table module */
void janet_lib_table(JanetTable *env) {
    JanetRegExt table_cfuns[] = {
        JANET_CORE_REG("table/new", cfun_table_new),
        JANET_CORE_REG("table/to-struct", cfun_table_tostruct),
        JANET_CORE_REG("table/getproto", cfun_table_getproto),
        JANET_CORE_REG("table/setproto", cfun_table_setproto),
        JANET_CORE_REG("table/rawget", cfun_table_rawget),
        JANET_CORE_REG("table/clone", cfun_table_clone),
        JANET_CORE_REG("table/clear", cfun_table_clear),
        JANET_CORE_REG("table/proto-flatten", cfun_table_proto_flatten),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, table_cfuns);
}


/* src/core/tuple.c */
#line 0 "src/core/tuple.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "symcache.h"
#include "gc.h"
#include "util.h"
#endif

/* Create a new empty tuple of the given size. This will return memory
 * which should be filled with Janets. The memory will not be collected until
 * janet_tuple_end is called. */
Janet *janet_tuple_begin(int32_t length) {
    size_t size = sizeof(JanetTupleHead) + ((size_t) length * sizeof(Janet));
    JanetTupleHead *head = janet_gcalloc(JANET_MEMORY_TUPLE, size);
    head->sm_line = -1;
    head->sm_column = -1;
    head->length = length;
    return (Janet *)(head->data);
}

/* Finish building a tuple */
const Janet *janet_tuple_end(Janet *tuple) {
    janet_tuple_hash(tuple) = janet_array_calchash(tuple, janet_tuple_length(tuple));
    return (const Janet *)tuple;
}

/* Build a tuple with n values */
const Janet *janet_tuple_n(const Janet *values, int32_t n) {
    Janet *t = janet_tuple_begin(n);
    safe_memcpy(t, values, sizeof(Janet) * n);
    return janet_tuple_end(t);
}

/* C Functions */

JANET_CORE_FN(cfun_tuple_brackets,
              "(tuple/brackets & xs)",
              "Creates a new bracketed tuple containing the elements xs.") {
    const Janet *tup = janet_tuple_n(argv, argc);
    janet_tuple_flag(tup) |= JANET_TUPLE_FLAG_BRACKETCTOR;
    return janet_wrap_tuple(tup);
}

JANET_CORE_FN(cfun_tuple_slice,
              "(tuple/slice arrtup [,start=0 [,end=(length arrtup)]])",
              "Take a sub-sequence of an array or tuple from index `start` "
              "inclusive to index `end` exclusive. If `start` or `end` are not provided, "
              "they default to 0 and the length of `arrtup`, respectively. "
              "`start` and `end` can also be negative to indicate indexing "
              "from the end of the input. Note that index -1 is synonymous with "
              "index `(length arrtup)` to allow a full negative slice range. "
              "Returns the new tuple.") {
    JanetView view = janet_getindexed(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    return janet_wrap_tuple(janet_tuple_n(view.items + range.start, range.end - range.start));
}

JANET_CORE_FN(cfun_tuple_type,
              "(tuple/type tup)",
              "Checks how the tuple was constructed. Will return the keyword "
              ":brackets if the tuple was parsed with brackets, and :parens "
              "otherwise. The two types of tuples will behave the same most of "
              "the time, but will print differently and be treated differently by "
              "the compiler.") {
    janet_fixarity(argc, 1);
    const Janet *tup = janet_gettuple(argv, 0);
    if (janet_tuple_flag(tup) & JANET_TUPLE_FLAG_BRACKETCTOR) {
        return janet_ckeywordv("brackets");
    } else {
        return janet_ckeywordv("parens");
    }
}

JANET_CORE_FN(cfun_tuple_sourcemap,
              "(tuple/sourcemap tup)",
              "Returns the sourcemap metadata attached to a tuple, "
              "which is another tuple (line, column).") {
    janet_fixarity(argc, 1);
    const Janet *tup = janet_gettuple(argv, 0);
    Janet contents[2];
    contents[0] = janet_wrap_integer(janet_tuple_head(tup)->sm_line);
    contents[1] = janet_wrap_integer(janet_tuple_head(tup)->sm_column);
    return janet_wrap_tuple(janet_tuple_n(contents, 2));
}

JANET_CORE_FN(cfun_tuple_setmap,
              "(tuple/setmap tup line column)",
              "Set the sourcemap metadata on a tuple. line and column indicate "
              "should be integers.") {
    janet_fixarity(argc, 3);
    const Janet *tup = janet_gettuple(argv, 0);
    janet_tuple_head(tup)->sm_line = janet_getinteger(argv, 1);
    janet_tuple_head(tup)->sm_column = janet_getinteger(argv, 2);
    return argv[0];
}

/* Load the tuple module */
void janet_lib_tuple(JanetTable *env) {
    JanetRegExt tuple_cfuns[] = {
        JANET_CORE_REG("tuple/brackets", cfun_tuple_brackets),
        JANET_CORE_REG("tuple/slice", cfun_tuple_slice),
        JANET_CORE_REG("tuple/type", cfun_tuple_type),
        JANET_CORE_REG("tuple/sourcemap", cfun_tuple_sourcemap),
        JANET_CORE_REG("tuple/setmap", cfun_tuple_setmap),
        JANET_REG_END
    };
    janet_core_cfuns_ext(env, NULL, tuple_cfuns);
}


/* src/core/util.c */
#line 0 "src/core/util.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#include "state.h"
#include "gc.h"
#ifdef JANET_WINDOWS
#include <windows.h>
#else
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#endif
#endif

#ifdef JANET_WINDOWS
#ifdef JANET_DYNAMIC_MODULES
#include <psapi.h>
#pragma comment (lib, "Psapi.lib")
#endif
#endif

#ifdef JANET_APPLE
#include <AvailabilityMacros.h>
#endif

#include <inttypes.h>

/* Base 64 lookup table for digits */
const char janet_base64[65] =
    "0123456789"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "abcdefghijklmnopqrstuvwxyz"
    "_=";

/* The JANET value types in order. These types can be used as
 * mnemonics instead of a bit pattern for type checking */
const char *const janet_type_names[16] = {
    "number",
    "nil",
    "boolean",
    "fiber",
    "string",
    "symbol",
    "keyword",
    "array",
    "tuple",
    "table",
    "struct",
    "buffer",
    "function",
    "cfunction",
    "abstract",
    "pointer"
};

const char *const janet_signal_names[14] = {
    "ok",
    "error",
    "debug",
    "yield",
    "user0",
    "user1",
    "user2",
    "user3",
    "user4",
    "user5",
    "user6",
    "user7",
    "user8",
    "user9"
};

const char *const janet_status_names[16] = {
    "dead",
    "error",
    "debug",
    "pending",
    "user0",
    "user1",
    "user2",
    "user3",
    "user4",
    "user5",
    "user6",
    "user7",
    "user8",
    "user9",
    "new",
    "alive"
};

#ifndef JANET_PRF

int32_t janet_string_calchash(const uint8_t *str, int32_t len) {
    const uint8_t *end = str + len;
    uint32_t hash = 5381;
    while (str < end)
        hash = (hash << 5) + hash + *str++;
    return (int32_t) hash;
}

#else

/*
  Public domain siphash implementation sourced from:

  https://raw.githubusercontent.com/veorq/SipHash/master/halfsiphash.c

  We have made a few alterations, such as hardcoding the output size
  and then removing dead code.
*/
#define cROUNDS 2
#define dROUNDS 4

#define ROTL(x, b) (uint32_t)(((x) << (b)) | ((x) >> (32 - (b))))

#define U8TO32_LE(p)                                                           \
    (((uint32_t)((p)[0])) | ((uint32_t)((p)[1]) << 8) |                        \
     ((uint32_t)((p)[2]) << 16) | ((uint32_t)((p)[3]) << 24))

#define SIPROUND                                                               \
    do {                                                                       \
        v0 += v1;                                                              \
        v1 = ROTL(v1, 5);                                                      \
        v1 ^= v0;                                                              \
        v0 = ROTL(v0, 16);                                                     \
        v2 += v3;                                                              \
        v3 = ROTL(v3, 8);                                                      \
        v3 ^= v2;                                                              \
        v0 += v3;                                                              \
        v3 = ROTL(v3, 7);                                                      \
        v3 ^= v0;                                                              \
        v2 += v1;                                                              \
        v1 = ROTL(v1, 13);                                                     \
        v1 ^= v2;                                                              \
        v2 = ROTL(v2, 16);                                                     \
    } while (0)

static uint32_t halfsiphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {

    uint32_t v0 = 0;
    uint32_t v1 = 0;
    uint32_t v2 = UINT32_C(0x6c796765);
    uint32_t v3 = UINT32_C(0x74656462);
    uint32_t k0 = U8TO32_LE(k);
    uint32_t k1 = U8TO32_LE(k + 4);
    uint32_t m;
    int i;
    const uint8_t *end = in + inlen - (inlen % sizeof(uint32_t));
    const int left = inlen & 3;
    uint32_t b = ((uint32_t)inlen) << 24;
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    for (; in != end; in += 4) {
        m = U8TO32_LE(in);
        v3 ^= m;

        for (i = 0; i < cROUNDS; ++i)
            SIPROUND;

        v0 ^= m;
    }

    switch (left) {
        case 3:
            b |= ((uint32_t)in[2]) << 16;
        /* fallthrough */
        case 2:
            b |= ((uint32_t)in[1]) << 8;
        /* fallthrough */
        case 1:
            b |= ((uint32_t)in[0]);
            break;
        case 0:
            break;
    }

    v3 ^= b;

    for (i = 0; i < cROUNDS; ++i)
        SIPROUND;

    v0 ^= b;

    v2 ^= 0xff;

    for (i = 0; i < dROUNDS; ++i)
        SIPROUND;

    b = v1 ^ v3;
    return b;
}
/* end of siphash */

static uint8_t hash_key[JANET_HASH_KEY_SIZE] = {0};

void janet_init_hash_key(uint8_t new_key[JANET_HASH_KEY_SIZE]) {
    memcpy(hash_key, new_key, sizeof(hash_key));
}

/* Calculate hash for string */

int32_t janet_string_calchash(const uint8_t *str, int32_t len) {
    uint32_t hash;
    hash = halfsiphash(str, len, hash_key);
    return (int32_t)hash;
}

#endif

uint32_t janet_hash_mix(uint32_t input, uint32_t more) {
    uint32_t mix1 = (more + 0x9e3779b9 + (input << 6) + (input >> 2));
    return input ^ (0x9e3779b9 + (mix1 << 6) + (mix1 >> 2));
}

/* Computes hash of an array of values */
int32_t janet_array_calchash(const Janet *array, int32_t len) {
    const Janet *end = array + len;
    uint32_t hash = 33;
    while (array < end) {
        hash = janet_hash_mix(hash, janet_hash(*array++));
    }
    return (int32_t) hash;
}

/* Computes hash of an array of values */
int32_t janet_kv_calchash(const JanetKV *kvs, int32_t len) {
    const JanetKV *end = kvs + len;
    uint32_t hash = 33;
    while (kvs < end) {
        hash = janet_hash_mix(hash, janet_hash(kvs->key));
        hash = janet_hash_mix(hash, janet_hash(kvs->value));
        kvs++;
    }
    return (int32_t) hash;
}

/* Calculate next power of 2. May overflow. If n is 0,
 * will return 0. */
int32_t janet_tablen(int32_t n) {
    if (n < 0) return 0;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    return n + 1;
}

/* Avoid some undefined behavior that was common in the code base. */
void safe_memcpy(void *dest, const void *src, size_t len) {
    if (!len) return;
    memcpy(dest, src, len);
}

/* Helper to find a value in a Janet struct or table. Returns the bucket
 * containing the key, or the first empty bucket if there is no such key. */
const JanetKV *janet_dict_find(const JanetKV *buckets, int32_t cap, Janet key) {
    int32_t index = janet_maphash(cap, janet_hash(key));
    int32_t i;
    const JanetKV *first_bucket = NULL;
    /* Higher half */
    for (i = index; i < cap; i++) {
        const JanetKV *kv = buckets + i;
        if (janet_checktype(kv->key, JANET_NIL)) {
            if (janet_checktype(kv->value, JANET_NIL)) {
                return kv;
            } else if (NULL == first_bucket) {
                first_bucket = kv;
            }
        } else if (janet_equals(kv->key, key)) {
            return buckets + i;
        }
    }
    /* Lower half */
    for (i = 0; i < index; i++) {
        const JanetKV *kv = buckets + i;
        if (janet_checktype(kv->key, JANET_NIL)) {
            if (janet_checktype(kv->value, JANET_NIL)) {
                return kv;
            } else if (NULL == first_bucket) {
                first_bucket = kv;
            }
        } else if (janet_equals(kv->key, key)) {
            return buckets + i;
        }
    }
    return first_bucket;
}

/* Get a value from a janet struct or table. */
Janet janet_dictionary_get(const JanetKV *data, int32_t cap, Janet key) {
    const JanetKV *kv = janet_dict_find(data, cap, key);
    if (kv && !janet_checktype(kv->key, JANET_NIL)) {
        return kv->value;
    }
    return janet_wrap_nil();
}

/* Iterate through a struct or dictionary generically */
const JanetKV *janet_dictionary_next(const JanetKV *kvs, int32_t cap, const JanetKV *kv) {
    const JanetKV *end = kvs + cap;
    kv = (kv == NULL) ? kvs : kv + 1;
    while (kv < end) {
        if (!janet_checktype(kv->key, JANET_NIL))
            return kv;
        kv++;
    }
    return NULL;
}

/* Compare a janet string with a cstring. More efficient than loading
 * c string as a janet string. */
int janet_cstrcmp(const uint8_t *str, const char *other) {
    int32_t len = janet_string_length(str);
    int32_t index;
    for (index = 0; index < len; index++) {
        uint8_t c = str[index];
        uint8_t k = ((const uint8_t *)other)[index];
        if (c < k) return -1;
        if (c > k) return 1;
        if (k == '\0') break;
    }
    return (other[index] == '\0') ? 0 : -1;
}

/* Do a binary search on a static array of structs. Each struct must
 * have a string as its first element, and the struct must be sorted
 * lexicographically by that element. */
const void *janet_strbinsearch(
    const void *tab,
    size_t tabcount,
    size_t itemsize,
    const uint8_t *key) {
    size_t low = 0;
    size_t hi = tabcount;
    const char *t = (const char *)tab;
    while (low < hi) {
        size_t mid = low + ((hi - low) / 2);
        const char **item = (const char **)(t + mid * itemsize);
        const char *name = *item;
        int comp = janet_cstrcmp(key, name);
        if (comp < 0) {
            hi = mid;
        } else if (comp > 0) {
            low = mid + 1;
        } else {
            return (const void *)item;
        }
    }
    return NULL;
}

/* Add sourcemapping and documentation to a binding table */
static void janet_add_meta(JanetTable *table, const char *doc, const char *source_file, int32_t source_line) {
    if (doc) {
        janet_table_put(table, janet_ckeywordv("doc"), janet_cstringv(doc));
    }
    if (source_file && source_line) {
        Janet triple[3];
        triple[0] = janet_cstringv(source_file);
        triple[1] = janet_wrap_integer(source_line);
        triple[2] = janet_wrap_integer(1);
        Janet value = janet_wrap_tuple(janet_tuple_n(triple, 3));
        janet_table_put(table, janet_ckeywordv("source-map"), value);
    }
}

/* Add a def to an environment */
void janet_def_sm(JanetTable *env, const char *name, Janet val, const char *doc, const char *source_file, int32_t source_line) {
    JanetTable *subt = janet_table(2);
    janet_table_put(subt, janet_ckeywordv("value"), val);
    janet_add_meta(subt, doc, source_file, source_line);
    janet_table_put(env, janet_csymbolv(name), janet_wrap_table(subt));
}
void janet_def(JanetTable *env, const char *name, Janet value, const char *doc) {
    janet_def_sm(env, name, value, doc, NULL, 0);
}

/* Add a var to the environment */
void janet_var_sm(JanetTable *env, const char *name, Janet val, const char *doc, const char *source_file, int32_t source_line) {
    JanetArray *array = janet_array(1);
    JanetTable *subt = janet_table(2);
    janet_array_push(array, val);
    janet_table_put(subt, janet_ckeywordv("ref"), janet_wrap_array(array));
    janet_add_meta(subt, doc, source_file, source_line);
    janet_table_put(env, janet_csymbolv(name), janet_wrap_table(subt));
}
void janet_var(JanetTable *env, const char *name, Janet val, const char *doc) {
    janet_var_sm(env, name, val, doc, NULL, 0);
}

/* Registry functions */

/* Put the registry in sorted order. */
static void janet_registry_sort(void) {
    for (size_t i = 1; i < janet_vm.registry_count; i++) {
        JanetCFunRegistry reg = janet_vm.registry[i];
        size_t j;
        for (j = i; j > 0; j--) {
            if ((void *)(janet_vm.registry[j - 1].cfun) < (void *)(reg.cfun)) break;
            janet_vm.registry[j] = janet_vm.registry[j - 1];
        }
        janet_vm.registry[j] = reg;
    }
    janet_vm.registry_dirty = 0;
}

void janet_registry_put(
    JanetCFunction key,
    const char *name,
    const char *name_prefix,
    const char *source_file,
    int32_t source_line) {
    if (janet_vm.registry_count == janet_vm.registry_cap) {
        size_t newcap = (janet_vm.registry_count + 1) * 2;
        /* Size it nicely with core by default */
        if (newcap < 512) {
            newcap = 512;
        }
        void *newmem = janet_realloc(janet_vm.registry, newcap * sizeof(JanetCFunRegistry));
        if (NULL == newmem) {
            JANET_OUT_OF_MEMORY;
        }
        janet_vm.registry = newmem;
        janet_vm.registry_cap = newcap;
    }
    JanetCFunRegistry value = {
        key,
        name,
        name_prefix,
        source_file,
        source_line
    };
    janet_vm.registry[janet_vm.registry_count++] = value;
    janet_vm.registry_dirty = 1;
}

JanetCFunRegistry *janet_registry_get(JanetCFunction key) {
    if (janet_vm.registry_dirty) {
        janet_registry_sort();
    }
    for (size_t i = 0; i < janet_vm.registry_count; i++) {
        if (janet_vm.registry[i].cfun == key) {
            return janet_vm.registry + i;
        }
    }
    JanetCFunRegistry *lo = janet_vm.registry;
    JanetCFunRegistry *hi = lo + janet_vm.registry_count;
    while (lo < hi) {
        JanetCFunRegistry *mid = lo + (hi - lo) / 2;
        if (mid->cfun == key) {
            return mid;
        }
        if ((void *)(mid->cfun) > (void *)(key)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return NULL;
}

typedef struct {
    char *buf;
    size_t plen;
} NameBuf;

static void namebuf_init(NameBuf *namebuf, const char *prefix) {
    size_t plen = strlen(prefix);
    namebuf->plen = plen;
    namebuf->buf = janet_malloc(namebuf->plen + 256);
    if (NULL == namebuf->buf) {
        JANET_OUT_OF_MEMORY;
    }
    memcpy(namebuf->buf, prefix, plen);
    namebuf->buf[plen] = '/';
}

static void namebuf_deinit(NameBuf *namebuf) {
    janet_free(namebuf->buf);
}

static char *namebuf_name(NameBuf *namebuf, const char *suffix) {
    size_t slen = strlen(suffix);
    namebuf->buf = janet_realloc(namebuf->buf, namebuf->plen + 2 + slen);
    if (NULL == namebuf->buf) {
        JANET_OUT_OF_MEMORY;
    }
    memcpy(namebuf->buf + namebuf->plen + 1, suffix, slen);
    namebuf->buf[namebuf->plen + 1 + slen] = '\0';
    return (char *)(namebuf->buf);
}

void janet_cfuns(JanetTable *env, const char *regprefix, const JanetReg *cfuns) {
    while (cfuns->name) {
        Janet fun = janet_wrap_cfunction(cfuns->cfun);
        if (env) janet_def(env, cfuns->name, fun, cfuns->documentation);
        janet_registry_put(cfuns->cfun, cfuns->name, regprefix, NULL, 0);
        cfuns++;
    }
}

void janet_cfuns_ext(JanetTable *env, const char *regprefix, const JanetRegExt *cfuns) {
    while (cfuns->name) {
        Janet fun = janet_wrap_cfunction(cfuns->cfun);
        if (env) janet_def_sm(env, cfuns->name, fun, cfuns->documentation, cfuns->source_file, cfuns->source_line);
        janet_registry_put(cfuns->cfun, cfuns->name, regprefix, cfuns->source_file, cfuns->source_line);
        cfuns++;
    }
}

void janet_cfuns_prefix(JanetTable *env, const char *regprefix, const JanetReg *cfuns) {
    NameBuf nb;
    if (env) namebuf_init(&nb, regprefix);
    while (cfuns->name) {
        Janet fun = janet_wrap_cfunction(cfuns->cfun);
        if (env) janet_def(env, namebuf_name(&nb, cfuns->name), fun, cfuns->documentation);
        janet_registry_put(cfuns->cfun, cfuns->name, regprefix, NULL, 0);
        cfuns++;
    }
    if (env) namebuf_deinit(&nb);
}

void janet_cfuns_ext_prefix(JanetTable *env, const char *regprefix, const JanetRegExt *cfuns) {
    NameBuf nb;
    if (env) namebuf_init(&nb, regprefix);
    while (cfuns->name) {
        Janet fun = janet_wrap_cfunction(cfuns->cfun);
        if (env) janet_def_sm(env, namebuf_name(&nb, cfuns->name), fun, cfuns->documentation, cfuns->source_file, cfuns->source_line);
        janet_registry_put(cfuns->cfun, cfuns->name, regprefix, cfuns->source_file, cfuns->source_line);
        cfuns++;
    }
    if (env) namebuf_deinit(&nb);
}

/* Register a value in the global registry */
void janet_register(const char *name, JanetCFunction cfun) {
    janet_registry_put(cfun, name, NULL, NULL, 0);
}

/* Abstract type introspection */

void janet_register_abstract_type(const JanetAbstractType *at) {
    Janet sym = janet_csymbolv(at->name);
    Janet check = janet_table_get(janet_vm.abstract_registry, sym);
    if (!janet_checktype(check, JANET_NIL) && at != janet_unwrap_pointer(check)) {
        janet_panicf("cannot register abstract type %s, "
                     "a type with the same name exists", at->name);
    }
    janet_table_put(janet_vm.abstract_registry, sym, janet_wrap_pointer((void *) at));
}

const JanetAbstractType *janet_get_abstract_type(Janet key) {
    Janet wrapped = janet_table_get(janet_vm.abstract_registry, key);
    if (janet_checktype(wrapped, JANET_NIL)) {
        return NULL;
    }
    return (JanetAbstractType *)(janet_unwrap_pointer(wrapped));
}

#ifndef JANET_BOOTSTRAP
void janet_core_def_sm(JanetTable *env, const char *name, Janet x, const void *p, const void *sf, int32_t sl) {
    (void) sf;
    (void) sl;
    (void) p;
    Janet key = janet_csymbolv(name);
    janet_table_put(env, key, x);
    if (janet_checktype(x, JANET_CFUNCTION)) {
        janet_registry_put(janet_unwrap_cfunction(x), name, NULL, NULL, 0);
    }
}

void janet_core_cfuns_ext(JanetTable *env, const char *regprefix, const JanetRegExt *cfuns) {
    (void) regprefix;
    while (cfuns->name) {
        Janet fun = janet_wrap_cfunction(cfuns->cfun);
        janet_table_put(env, janet_csymbolv(cfuns->name), fun);
        janet_registry_put(cfuns->cfun, cfuns->name, regprefix, cfuns->source_file, cfuns->source_line);
        cfuns++;
    }
}
#endif

JanetBinding janet_binding_from_entry(Janet entry) {
    JanetTable *entry_table;
    JanetBinding binding = {
        JANET_BINDING_NONE,
        janet_wrap_nil(),
        JANET_BINDING_DEP_NONE
    };

    /* Check environment for entry */
    if (!janet_checktype(entry, JANET_TABLE))
        return binding;
    entry_table = janet_unwrap_table(entry);

    /* deprecation check */
    Janet deprecate = janet_table_get(entry_table, janet_ckeywordv("deprecated"));
    if (janet_checktype(deprecate, JANET_KEYWORD)) {
        JanetKeyword depkw = janet_unwrap_keyword(deprecate);
        if (!janet_cstrcmp(depkw, "relaxed")) {
            binding.deprecation = JANET_BINDING_DEP_RELAXED;
        } else if (!janet_cstrcmp(depkw, "normal")) {
            binding.deprecation = JANET_BINDING_DEP_NORMAL;
        } else if (!janet_cstrcmp(depkw, "strict")) {
            binding.deprecation = JANET_BINDING_DEP_STRICT;
        }
    } else if (!janet_checktype(deprecate, JANET_NIL)) {
        binding.deprecation = JANET_BINDING_DEP_NORMAL;
    }

    int macro = janet_truthy(janet_table_get(entry_table, janet_ckeywordv("macro")));
    Janet value = janet_table_get(entry_table, janet_ckeywordv("value"));
    Janet ref = janet_table_get(entry_table, janet_ckeywordv("ref"));
    int ref_is_valid = janet_checktype(ref, JANET_ARRAY);
    int redef = ref_is_valid && janet_truthy(janet_table_get(entry_table, janet_ckeywordv("redef")));

    if (macro) {
        binding.value = redef ? ref : value;
        binding.type = redef ? JANET_BINDING_DYNAMIC_MACRO : JANET_BINDING_MACRO;
        return binding;
    }

    if (ref_is_valid) {
        binding.value = ref;
        binding.type = redef ? JANET_BINDING_DYNAMIC_DEF : JANET_BINDING_VAR;
    } else {
        binding.value = value;
        binding.type = JANET_BINDING_DEF;
    }

    return binding;
}

JanetBinding janet_resolve_ext(JanetTable *env, const uint8_t *sym) {
    Janet entry = janet_table_get(env, janet_wrap_symbol(sym));
    return janet_binding_from_entry(entry);
}

JanetBindingType janet_resolve(JanetTable *env, const uint8_t *sym, Janet *out) {
    JanetBinding binding = janet_resolve_ext(env, sym);
    if (binding.type == JANET_BINDING_DYNAMIC_DEF || binding.type == JANET_BINDING_DYNAMIC_MACRO) {
        *out = janet_array_peek(janet_unwrap_array(binding.value));
    } else {
        *out = binding.value;
    }
    return binding.type;
}

/* Resolve a symbol in the core environment. */
Janet janet_resolve_core(const char *name) {
    JanetTable *env = janet_core_env(NULL);
    Janet out = janet_wrap_nil();
    janet_resolve(env, janet_csymbol(name), &out);
    return out;
}

/* Read both tuples and arrays as c pointers + int32_t length. Return 1 if the
 * view can be constructed, 0 if an invalid type. */
int janet_indexed_view(Janet seq, const Janet **data, int32_t *len) {
    if (janet_checktype(seq, JANET_ARRAY)) {
        *data = janet_unwrap_array(seq)->data;
        *len = janet_unwrap_array(seq)->count;
        return 1;
    } else if (janet_checktype(seq, JANET_TUPLE)) {
        *data = janet_unwrap_tuple(seq);
        *len = janet_tuple_length(janet_unwrap_tuple(seq));
        return 1;
    }
    return 0;
}

/* Read both strings and buffer as unsigned character array + int32_t len.
 * Returns 1 if the view can be constructed and 0 if the type is invalid. */
int janet_bytes_view(Janet str, const uint8_t **data, int32_t *len) {
    JanetType t = janet_type(str);
    if (t == JANET_STRING || t == JANET_SYMBOL || t == JANET_KEYWORD) {
        *data = janet_unwrap_string(str);
        *len = janet_string_length(janet_unwrap_string(str));
        return 1;
    } else if (t == JANET_BUFFER) {
        *data = janet_unwrap_buffer(str)->data;
        *len = janet_unwrap_buffer(str)->count;
        return 1;
    } else if (t == JANET_ABSTRACT) {
        void *abst = janet_unwrap_abstract(str);
        const JanetAbstractType *atype = janet_abstract_type(abst);
        if (NULL == atype->bytes) {
            return 0;
        }
        JanetByteView view = atype->bytes(abst, janet_abstract_size(abst));
        *data = view.bytes;
        *len = view.len;
        return 1;
    }
    return 0;
}

/* Read both structs and tables as the entries of a hashtable with
 * identical structure. Returns 1 if the view can be constructed and
 * 0 if the type is invalid. */
int janet_dictionary_view(Janet tab, const JanetKV **data, int32_t *len, int32_t *cap) {
    if (janet_checktype(tab, JANET_TABLE)) {
        *data = janet_unwrap_table(tab)->data;
        *cap = janet_unwrap_table(tab)->capacity;
        *len = janet_unwrap_table(tab)->count;
        return 1;
    } else if (janet_checktype(tab, JANET_STRUCT)) {
        *data = janet_unwrap_struct(tab);
        *cap = janet_struct_capacity(janet_unwrap_struct(tab));
        *len = janet_struct_length(janet_unwrap_struct(tab));
        return 1;
    }
    return 0;
}

int janet_checkint(Janet x) {
    if (!janet_checktype(x, JANET_NUMBER))
        return 0;
    double dval = janet_unwrap_number(x);
    return janet_checkintrange(dval);
}

int janet_checkint64(Janet x) {
    if (!janet_checktype(x, JANET_NUMBER))
        return 0;
    double dval = janet_unwrap_number(x);
    return janet_checkint64range(dval);
}

int janet_checkuint64(Janet x) {
    if (!janet_checktype(x, JANET_NUMBER))
        return 0;
    double dval = janet_unwrap_number(x);
    return dval >= 0 && dval <= JANET_INTMAX_DOUBLE && dval == (uint64_t) dval;
}

int janet_checksize(Janet x) {
    if (!janet_checktype(x, JANET_NUMBER))
        return 0;
    double dval = janet_unwrap_number(x);
    if (dval != (double)((size_t) dval)) return 0;
    if (SIZE_MAX > JANET_INTMAX_INT64) {
        return dval <= JANET_INTMAX_INT64;
    } else {
        return dval <= SIZE_MAX;
    }
}

JanetTable *janet_get_core_table(const char *name) {
    JanetTable *env = janet_core_env(NULL);
    Janet out = janet_wrap_nil();
    JanetBindingType bt = janet_resolve(env, janet_csymbol(name), &out);
    if (bt == JANET_BINDING_NONE) return NULL;
    if (!janet_checktype(out, JANET_TABLE)) return NULL;
    return janet_unwrap_table(out);
}

/* Sort keys of a dictionary type */
int32_t janet_sorted_keys(const JanetKV *dict, int32_t cap, int32_t *index_buffer) {

    /* First, put populated indices into index_buffer */
    int32_t next_index = 0;
    for (int32_t i = 0; i < cap; i++) {
        if (!janet_checktype(dict[i].key, JANET_NIL)) {
            index_buffer[next_index++] = i;
        }
    }

    /* Next, sort those (simple insertion sort here for now) */
    for (int32_t i = 1; i < next_index; i++) {
        int32_t index_to_insert = index_buffer[i];
        Janet lhs = dict[index_to_insert].key;
        for (int32_t j = i - 1; j >= 0; j--) {
            index_buffer[j + 1] = index_buffer[j];
            Janet rhs = dict[index_buffer[j]].key;
            if (janet_compare(lhs, rhs) >= 0) {
                index_buffer[j + 1] = index_to_insert;
                break;
            } else if (j == 0) {
                index_buffer[0] = index_to_insert;
            }
        }
    }

    /* Return number of indices found */
    return next_index;

}

/* Clock shims for various platforms */
#ifdef JANET_GETTIME
#ifdef JANET_WINDOWS
int janet_gettime(struct timespec *spec) {
    FILETIME ftime;
    GetSystemTimeAsFileTime(&ftime);
    int64_t wintime = (int64_t)(ftime.dwLowDateTime) | ((int64_t)(ftime.dwHighDateTime) << 32);
    /* Windows epoch is January 1, 1601 apparently */
    wintime -= 116444736000000000LL;
    spec->tv_sec  = wintime / 10000000LL;
    /* Resolution is 100 nanoseconds. */
    spec->tv_nsec = wintime % 10000000LL * 100;
    return 0;
}
/* clock_gettime() wasn't available on Mac until 10.12. */
#elif defined(JANET_APPLE) && !defined(MAC_OS_X_VERSION_10_12)
#include <mach/clock.h>
#include <mach/mach.h>
int janet_gettime(struct timespec *spec) {
    clock_serv_t cclock;
    mach_timespec_t mts;
    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);
    clock_get_time(cclock, &mts);
    mach_port_deallocate(mach_task_self(), cclock);
    spec->tv_sec = mts.tv_sec;
    spec->tv_nsec = mts.tv_nsec;
    return 0;
}
#else
int janet_gettime(struct timespec *spec) {
    return clock_gettime(CLOCK_REALTIME, spec);
}
#endif
#endif

/* Setting C99 standard makes this not available, but it should
 * work/link properly if we detect a BSD */
#if defined(JANET_BSD) || defined(MAC_OS_X_VERSION_10_7)
void arc4random_buf(void *buf, size_t nbytes);
#endif

int janet_cryptorand(uint8_t *out, size_t n) {
#ifdef JANET_WINDOWS
    for (size_t i = 0; i < n; i += sizeof(unsigned int)) {
        unsigned int v;
        if (rand_s(&v))
            return -1;
        for (int32_t j = 0; (j < sizeof(unsigned int)) && (i + j < n); j++) {
            out[i + j] = v & 0xff;
            v = v >> 8;
        }
    }
    return 0;
#elif defined(JANET_LINUX) || ( defined(JANET_APPLE) && !defined(MAC_OS_X_VERSION_10_7) )
    /* We should be able to call getrandom on linux, but it doesn't seem
       to be uniformly supported on linux distros.
       On Mac, arc4random_buf wasn't available on until 10.7.
       In these cases, use this fallback path for now... */
    int rc;
    int randfd;
    RETRY_EINTR(randfd, open("/dev/urandom", O_RDONLY | O_CLOEXEC));
    if (randfd < 0)
        return -1;
    while (n > 0) {
        ssize_t nread;
        RETRY_EINTR(nread, read(randfd, out, n));
        if (nread <= 0) {
            RETRY_EINTR(rc, close(randfd));
            return -1;
        }
        out += nread;
        n -= nread;
    }
    RETRY_EINTR(rc, close(randfd));
    return 0;
#elif defined(JANET_BSD) || defined(MAC_OS_X_VERSION_10_7)
    arc4random_buf(out, n);
    return 0;
#else
    (void) n;
    (void) out;
    return -1;
#endif
}

/* Dynamic library loading */

char *get_processed_name(const char *name) {
    if (name[0] == '.') return (char *) name;
    const char *c;
    for (c = name; *c; c++) {
        if (*c == '/') return (char *) name;
    }
    size_t l = (size_t)(c - name);
    char *ret = janet_malloc(l + 3);
    if (NULL == ret) {
        JANET_OUT_OF_MEMORY;
    }
    ret[0] = '.';
    ret[1] = '/';
    memcpy(ret + 2, name, l + 1);
    return ret;
}

#if defined(JANET_WINDOWS)

static char error_clib_buf[256];
char *error_clib(void) {
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   error_clib_buf, sizeof(error_clib_buf), NULL);
    error_clib_buf[strlen(error_clib_buf) - 1] = '\0';
    return error_clib_buf;
}

Clib load_clib(const char *name) {
    if (name == NULL) {
        return GetModuleHandle(NULL);
    } else {
        return LoadLibrary(name);
    }
}

void free_clib(HINSTANCE clib) {
    if (clib != GetModuleHandle(NULL)) {
        FreeLibrary(clib);
    }
}

void *symbol_clib(HINSTANCE clib, const char *sym) {
    if (clib != GetModuleHandle(NULL)) {
        return GetProcAddress(clib, sym);
    } else {
        /* Look up symbols from all loaded modules */
        HMODULE hMods[1024];
        DWORD needed = 0;
        if (EnumProcessModules(GetCurrentProcess(), hMods, sizeof(hMods), &needed)) {
            needed /= sizeof(HMODULE);
            for (DWORD i = 0; i < needed; i++) {
                void *address = GetProcAddress(hMods[i], sym);
                if (NULL != address) {
                    return address;
                }
            }
        } else {
            janet_panicf("ffi: %s", error_clib());
        }
        return NULL;
    }
}

#endif

/* Alloc function macro fills */
void *(janet_malloc)(size_t size) {
    return janet_malloc(size);
}

void (janet_free)(void *ptr) {
    janet_free(ptr);
}

void *(janet_calloc)(size_t nmemb, size_t size) {
    return janet_calloc(nmemb, size);
}

void *(janet_realloc)(void *ptr, size_t size) {
    return janet_realloc(ptr, size);
}


/* src/core/value.c */
#line 0 "src/core/value.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include "util.h"
#include "state.h"
#include "gc.h"
#include "fiber.h"
#include <janet.h>
#endif

#include <math.h>

static void push_traversal_node(void *lhs, void *rhs, int32_t index2) {
    JanetTraversalNode node;
    node.self = (JanetGCObject *) lhs;
    node.other = (JanetGCObject *) rhs;
    node.index = 0;
    node.index2 = index2;
    int is_new = janet_vm.traversal_base == NULL;
    if (is_new || (janet_vm.traversal + 1 >= janet_vm.traversal_top)) {
        size_t oldsize = is_new ? 0 : (janet_vm.traversal - janet_vm.traversal_base);
        size_t newsize = 2 * oldsize + 1;
        if (newsize < 128) {
            newsize = 128;
        }
        JanetTraversalNode *tn = janet_realloc(janet_vm.traversal_base, newsize * sizeof(JanetTraversalNode));
        if (tn == NULL) {
            JANET_OUT_OF_MEMORY;
        }
        janet_vm.traversal_base = tn;
        janet_vm.traversal_top = janet_vm.traversal_base + newsize;
        janet_vm.traversal = janet_vm.traversal_base + oldsize;
    }
    *(++janet_vm.traversal) = node;
}

/*
 * Used for travsersing structs and tuples without recursion
 * Returns:
 * 0 - next node found
 * 1 - early stop - lhs < rhs
 * 2 - no next node found
 * 3 - early stop - lhs > rhs
 */
static int traversal_next(Janet *x, Janet *y) {
    JanetTraversalNode *t = janet_vm.traversal;
    while (t && t > janet_vm.traversal_base) {
        JanetGCObject *self = t->self;
        JanetTupleHead *tself = (JanetTupleHead *)self;
        JanetStructHead *sself = (JanetStructHead *)self;
        JanetGCObject *other = t->other;
        JanetTupleHead *tother = (JanetTupleHead *)other;
        JanetStructHead *sother = (JanetStructHead *)other;
        if ((self->flags & JANET_MEM_TYPEBITS) == JANET_MEMORY_TUPLE) {
            /* Node is a tuple at index t->index */
            if (t->index < tself->length && t->index < tother->length) {
                int32_t index = t->index++;
                *x = tself->data[index];
                *y = tother->data[index];
                janet_vm.traversal = t;
                return 0;
            }
            if (t->index2 && tself->length != tother->length) {
                return tself->length > tother->length ? 3 : 1;
            }
        } else {
            /* Node is a struct at index t->index: if t->index2 is true, we should return the values. */
            if (t->index2) {
                t->index2 = 0;
                int32_t index = t->index++;
                *x = sself->data[index].value;
                *y = sother->data[index].value;
                janet_vm.traversal = t;
                return 0;
            }
            for (int32_t i = t->index; i < sself->capacity; i++) {
                t->index2 = 1;
                *x = sself->data[t->index].key;
                *y = sother->data[t->index].key;
                janet_vm.traversal = t;
                return 0;
            }
            /* Traverse prototype */
            JanetStruct sproto = sself->proto;
            JanetStruct oproto = sother->proto;
            if (sproto && !oproto) return 3;
            if (!sproto && oproto) return 1;
            if (oproto && sproto) {
                *x = janet_wrap_struct(sproto);
                *y = janet_wrap_struct(oproto);
                janet_vm.traversal = t - 1;
                return 0;
            }
        }
        t--;
    }
    janet_vm.traversal = t;
    return 2;
}

/*
 * Define a number of functions that can be used internally on ANY Janet.
 */

Janet janet_next(Janet ds, Janet key) {
    return janet_next_impl(ds, key, 0);
}

Janet janet_next_impl(Janet ds, Janet key, int is_interpreter) {
    JanetType t = janet_type(ds);
    switch (t) {
        default:
            janet_panicf("expected iterable type, got %v", ds);
        case JANET_TABLE:
        case JANET_STRUCT: {
            const JanetKV *start;
            int32_t cap;
            if (t == JANET_TABLE) {
                JanetTable *tab = janet_unwrap_table(ds);
                cap = tab->capacity;
                start = tab->data;
            } else {
                JanetStruct st = janet_unwrap_struct(ds);
                cap = janet_struct_capacity(st);
                start = st;
            }
            const JanetKV *end = start + cap;
            const JanetKV *kv = janet_checktype(key, JANET_NIL)
                                ? start
                                : janet_dict_find(start, cap, key) + 1;
            while (kv < end) {
                if (!janet_checktype(kv->key, JANET_NIL)) return kv->key;
                kv++;
            }
            break;
        }
        case JANET_STRING:
        case JANET_KEYWORD:
        case JANET_SYMBOL:
        case JANET_BUFFER:
        case JANET_ARRAY:
        case JANET_TUPLE: {
            int32_t i;
            if (janet_checktype(key, JANET_NIL)) {
                i = 0;
            } else if (janet_checkint(key)) {
                i = janet_unwrap_integer(key) + 1;
            } else {
                break;
            }
            int32_t len;
            if (t == JANET_BUFFER) {
                len = janet_unwrap_buffer(ds)->count;
            } else if (t == JANET_ARRAY) {
                len = janet_unwrap_array(ds)->count;
            } else if (t == JANET_TUPLE) {
                len = janet_tuple_length(janet_unwrap_tuple(ds));
            } else {
                len = janet_string_length(janet_unwrap_string(ds));
            }
            if (i < len && i >= 0) {
                return janet_wrap_integer(i);
            }
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstract abst = janet_unwrap_abstract(ds);
            const JanetAbstractType *at = janet_abstract_type(abst);
            if (NULL == at->next) break;
            return at->next(abst, key);
        }
        case JANET_FIBER: {
            JanetFiber *child = janet_unwrap_fiber(ds);
            Janet retreg;
            JanetFiberStatus status = janet_fiber_status(child);
            if (status == JANET_STATUS_ALIVE ||
                    status == JANET_STATUS_DEAD ||
                    status == JANET_STATUS_ERROR ||
                    status == JANET_STATUS_USER0 ||
                    status == JANET_STATUS_USER1 ||
                    status == JANET_STATUS_USER2 ||
                    status == JANET_STATUS_USER3 ||
                    status == JANET_STATUS_USER4) {
                return janet_wrap_nil();
            }
            janet_vm.fiber->child = child;
            JanetSignal sig = janet_continue(child, janet_wrap_nil(), &retreg);
            if (sig != JANET_SIGNAL_OK && !(child->flags & (1 << sig))) {
                if (is_interpreter) {
                    janet_signalv(sig, retreg);
                } else {
                    janet_vm.fiber->child = NULL;
                    janet_panicv(retreg);
                }
            }
            janet_vm.fiber->child = NULL;
            if (sig == JANET_SIGNAL_OK ||
                    sig == JANET_SIGNAL_ERROR ||
                    sig == JANET_SIGNAL_USER0 ||
                    sig == JANET_SIGNAL_USER1 ||
                    sig == JANET_SIGNAL_USER2 ||
                    sig == JANET_SIGNAL_USER3 ||
                    sig == JANET_SIGNAL_USER4) {
                /* Fiber cannot be resumed, so discard last value. */
                return janet_wrap_nil();
            } else {
                return janet_wrap_integer(0);
            }
        }
    }
    return janet_wrap_nil();
}

/* Compare two abstract values */
static int janet_compare_abstract(JanetAbstract xx, JanetAbstract yy) {
    if (xx == yy) return 0;
    const JanetAbstractType *xt = janet_abstract_type(xx);
    const JanetAbstractType *yt = janet_abstract_type(yy);
    if (xt != yt) {
        return xt > yt ? 1 : -1;
    }
    if (xt->compare == NULL) {
        return xx > yy ? 1 : -1;
    }
    return xt->compare(xx, yy);
}

int janet_equals(Janet x, Janet y) {
    janet_vm.traversal = janet_vm.traversal_base;
    do {
        if (janet_type(x) != janet_type(y)) return 0;
        switch (janet_type(x)) {
            case JANET_NIL:
                break;
            case JANET_BOOLEAN:
                if (janet_unwrap_boolean(x) != janet_unwrap_boolean(y)) return 0;
                break;
            case JANET_NUMBER:
                if (janet_unwrap_number(x) != janet_unwrap_number(y)) return 0;
                break;
            case JANET_STRING:
                if (!janet_string_equal(janet_unwrap_string(x), janet_unwrap_string(y))) return 0;
                break;
            case JANET_ABSTRACT:
                if (janet_compare_abstract(janet_unwrap_abstract(x), janet_unwrap_abstract(y))) return 0;
                break;
            default:
                if (janet_unwrap_pointer(x) != janet_unwrap_pointer(y)) return 0;
                break;
            case JANET_TUPLE: {
                const Janet *t1 = janet_unwrap_tuple(x);
                const Janet *t2 = janet_unwrap_tuple(y);
                if (t1 == t2) break;
                if (janet_tuple_hash(t1) != janet_tuple_hash(t2)) return 0;
                if (janet_tuple_length(t1) != janet_tuple_length(t2)) return 0;
                push_traversal_node(janet_tuple_head(t1), janet_tuple_head(t2), 0);
                break;
            }
            break;
            case JANET_STRUCT: {
                const JanetKV *s1 = janet_unwrap_struct(x);
                const JanetKV *s2 = janet_unwrap_struct(y);
                if (s1 == s2) break;
                if (janet_struct_hash(s1) != janet_struct_hash(s2)) return 0;
                if (janet_struct_length(s1) != janet_struct_length(s2)) return 0;
                if (janet_struct_proto(s1) && !janet_struct_proto(s2)) return 0;
                if (!janet_struct_proto(s1) && janet_struct_proto(s2)) return 0;
                push_traversal_node(janet_struct_head(s1), janet_struct_head(s2), 0);
                break;
            }
            break;
        }
    } while (!traversal_next(&x, &y));
    return 1;
}

static uint64_t murmur64(uint64_t h) {
    h ^= h >> 33;
    h *= 0xff51afd7ed558ccdUL;
    h ^= h >> 33;
    h *= 0xc4ceb9fe1a85ec53UL;
    h ^= h >> 33;
    return h;
}

/* Computes a hash value for a function */
int32_t janet_hash(Janet x) {
    int32_t hash = 0;
    switch (janet_type(x)) {
        case JANET_NIL:
            hash = 0;
            break;
        case JANET_BOOLEAN:
            hash = janet_unwrap_boolean(x);
            break;
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            hash = janet_string_hash(janet_unwrap_string(x));
            break;
        case JANET_TUPLE:
            hash = janet_tuple_hash(janet_unwrap_tuple(x));
            break;
        case JANET_STRUCT:
            hash = janet_struct_hash(janet_unwrap_struct(x));
            break;
        case JANET_NUMBER: {
            union {
                double d;
                uint64_t u;
            } as;
            as.d = janet_unwrap_number(x);
            as.d += 0.0; /* normalize negative 0 */
            uint32_t lo = (uint32_t)(as.u & 0xFFFFFFFF);
            uint32_t hi = (uint32_t)(as.u >> 32);
            uint32_t hilo = (hi ^ lo) * 2654435769u;
            hash = (int32_t)((hilo << 16) | (hilo >> 16));
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstract xx = janet_unwrap_abstract(x);
            const JanetAbstractType *at = janet_abstract_type(xx);
            if (at->hash != NULL) {
                hash = at->hash(xx, janet_abstract_size(xx));
                break;
            }
        }
        /* fallthrough */
        default:
            if (sizeof(double) == sizeof(void *)) {
                /* Assuming 8 byte pointer (8 byte aligned) */
                uint64_t i = murmur64(janet_u64(x));
                hash = (int32_t)(i >> 32);
            } else {
                /* Assuming 4 byte pointer (or smaller) */
                uintptr_t diff = (uintptr_t) janet_unwrap_pointer(x);
                uint32_t hilo = (uint32_t) diff * 2654435769u;
                hash = (int32_t)((hilo << 16) | (hilo >> 16));
            }
            break;
    }
    return hash;
}

/* Compares x to y. If they are equal returns 0. If x is less, returns -1.
 * If y is less, returns 1. All types are comparable
 * and should have strict ordering, excepts NaNs. */
int janet_compare(Janet x, Janet y) {
    janet_vm.traversal = janet_vm.traversal_base;
    int status;
    do {
        JanetType tx = janet_type(x);
        JanetType ty = janet_type(y);
        if (tx != ty) return tx < ty ? -1 : 1;
        switch (tx) {
            case JANET_NIL:
                break;
            case JANET_BOOLEAN: {
                int diff = janet_unwrap_boolean(x) - janet_unwrap_boolean(y);
                if (diff) return diff;
                break;
            }
            case JANET_NUMBER: {
                double xx = janet_unwrap_number(x);
                double yy = janet_unwrap_number(y);
                if (xx == yy) {
                    break;
                } else {
                    return (xx < yy) ? -1 : 1;
                }
            }
            case JANET_STRING:
            case JANET_SYMBOL:
            case JANET_KEYWORD: {
                int diff = janet_string_compare(janet_unwrap_string(x), janet_unwrap_string(y));
                if (diff) return diff;
                break;
            }
            case JANET_ABSTRACT: {
                int diff = janet_compare_abstract(janet_unwrap_abstract(x), janet_unwrap_abstract(y));
                if (diff) return diff;
                break;
            }
            default: {
                if (janet_unwrap_pointer(x) == janet_unwrap_pointer(y)) {
                    break;
                } else {
                    return janet_unwrap_pointer(x) > janet_unwrap_pointer(y) ? 1 : -1;
                }
            }
            case JANET_TUPLE: {
                const Janet *lhs = janet_unwrap_tuple(x);
                const Janet *rhs = janet_unwrap_tuple(y);
                push_traversal_node(janet_tuple_head(lhs), janet_tuple_head(rhs), 1);
                break;
            }
            case JANET_STRUCT: {
                const JanetKV *lhs = janet_unwrap_struct(x);
                const JanetKV *rhs = janet_unwrap_struct(y);
                int32_t llen = janet_struct_capacity(lhs);
                int32_t rlen = janet_struct_capacity(rhs);
                int32_t lhash = janet_struct_hash(lhs);
                int32_t rhash = janet_struct_hash(rhs);
                if (llen < rlen) return -1;
                if (llen > rlen) return 1;
                if (lhash < rhash) return -1;
                if (lhash > rhash) return 1;
                push_traversal_node(janet_struct_head(lhs), janet_struct_head(rhs), 0);
                break;
            }
        }
    } while (!(status = traversal_next(&x, &y)));
    return status - 2;
}

static int32_t getter_checkint(Janet key, int32_t max) {
    if (!janet_checkint(key)) goto bad;
    int32_t ret = janet_unwrap_integer(key);
    if (ret < 0) goto bad;
    if (ret >= max) goto bad;
    return ret;
bad:
    janet_panicf("expected integer key in range [0, %d), got %v", max, key);
}

/* Gets a value and returns. Can panic. */
Janet janet_in(Janet ds, Janet key) {
    Janet value;
    switch (janet_type(ds)) {
        default:
            janet_panicf("expected %T, got %v", JANET_TFLAG_LENGTHABLE, ds);
            break;
        case JANET_STRUCT:
            value = janet_struct_get(janet_unwrap_struct(ds), key);
            break;
        case JANET_TABLE:
            value = janet_table_get(janet_unwrap_table(ds), key);
            break;
        case JANET_ARRAY: {
            JanetArray *array = janet_unwrap_array(ds);
            int32_t index = getter_checkint(key, array->count);
            value = array->data[index];
            break;
        }
        case JANET_TUPLE: {
            const Janet *tuple = janet_unwrap_tuple(ds);
            int32_t len = janet_tuple_length(tuple);
            value = tuple[getter_checkint(key, len)];
            break;
        }
        case JANET_BUFFER: {
            JanetBuffer *buffer = janet_unwrap_buffer(ds);
            int32_t index = getter_checkint(key, buffer->count);
            value = janet_wrap_integer(buffer->data[index]);
            break;
        }
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD: {
            const uint8_t *str = janet_unwrap_string(ds);
            int32_t index = getter_checkint(key, janet_string_length(str));
            value = janet_wrap_integer(str[index]);
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(janet_unwrap_abstract(ds));
            if (type->get) {
                if (!(type->get)(janet_unwrap_abstract(ds), key, &value))
                    janet_panicf("key %v not found in %v ", key, ds);
            } else {
                janet_panicf("no getter for %v ", ds);
            }
            break;
        }
        case JANET_FIBER: {
            /* Bit of a hack to allow iterating over fibers. */
            if (janet_equals(key, janet_wrap_integer(0))) {
                return janet_unwrap_fiber(ds)->last_value;
            } else {
                janet_panicf("expected key 0, got %v", key);
            }
        }
    }
    return value;
}

Janet janet_get(Janet ds, Janet key) {
    JanetType t = janet_type(ds);
    switch (t) {
        default:
            return janet_wrap_nil();
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD: {
            if (!janet_checkint(key)) return janet_wrap_nil();
            int32_t index = janet_unwrap_integer(key);
            if (index < 0) return janet_wrap_nil();
            const uint8_t *str = janet_unwrap_string(ds);
            if (index >= janet_string_length(str)) return janet_wrap_nil();
            return janet_wrap_integer(str[index]);
        }
        case JANET_ABSTRACT: {
            Janet value;
            void *abst = janet_unwrap_abstract(ds);
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(abst);
            if (!type->get) return janet_wrap_nil();
            if ((type->get)(abst, key, &value))
                return value;
            return janet_wrap_nil();
        }
        case JANET_ARRAY:
        case JANET_TUPLE:
        case JANET_BUFFER: {
            if (!janet_checkint(key)) return janet_wrap_nil();
            int32_t index = janet_unwrap_integer(key);
            if (index < 0) return janet_wrap_nil();
            if (t == JANET_ARRAY) {
                JanetArray *a = janet_unwrap_array(ds);
                if (index >= a->count) return janet_wrap_nil();
                return a->data[index];
            } else if (t == JANET_BUFFER) {
                JanetBuffer *b = janet_unwrap_buffer(ds);
                if (index >= b->count) return janet_wrap_nil();
                return janet_wrap_integer(b->data[index]);
            } else {
                const Janet *t = janet_unwrap_tuple(ds);
                if (index >= janet_tuple_length(t)) return janet_wrap_nil();
                return t[index];
            }
        }
        case JANET_TABLE: {
            return janet_table_get(janet_unwrap_table(ds), key);
        }
        case JANET_STRUCT: {
            const JanetKV *st = janet_unwrap_struct(ds);
            return janet_struct_get(st, key);
        }
        case JANET_FIBER: {
            /* Bit of a hack to allow iterating over fibers. */
            if (janet_equals(key, janet_wrap_integer(0))) {
                return janet_unwrap_fiber(ds)->last_value;
            } else {
                return janet_wrap_nil();
            }
        }
    }
}

Janet janet_getindex(Janet ds, int32_t index) {
    Janet value;
    if (index < 0) janet_panic("expected non-negative index");
    switch (janet_type(ds)) {
        default:
            janet_panicf("expected %T, got %v", JANET_TFLAG_LENGTHABLE, ds);
            break;
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            if (index >= janet_string_length(janet_unwrap_string(ds))) {
                value = janet_wrap_nil();
            } else {
                value = janet_wrap_integer(janet_unwrap_string(ds)[index]);
            }
            break;
        case JANET_ARRAY:
            if (index >= janet_unwrap_array(ds)->count) {
                value = janet_wrap_nil();
            } else {
                value = janet_unwrap_array(ds)->data[index];
            }
            break;
        case JANET_BUFFER:
            if (index >= janet_unwrap_buffer(ds)->count) {
                value = janet_wrap_nil();
            } else {
                value = janet_wrap_integer(janet_unwrap_buffer(ds)->data[index]);
            }
            break;
        case JANET_TUPLE:
            if (index >= janet_tuple_length(janet_unwrap_tuple(ds))) {
                value = janet_wrap_nil();
            } else {
                value = janet_unwrap_tuple(ds)[index];
            }
            break;
        case JANET_TABLE:
            value = janet_table_get(janet_unwrap_table(ds), janet_wrap_integer(index));
            break;
        case JANET_STRUCT:
            value = janet_struct_get(janet_unwrap_struct(ds), janet_wrap_integer(index));
            break;
        case JANET_ABSTRACT: {
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(janet_unwrap_abstract(ds));
            if (type->get) {
                if (!(type->get)(janet_unwrap_abstract(ds), janet_wrap_integer(index), &value))
                    value = janet_wrap_nil();
            } else {
                janet_panicf("no getter for %v ", ds);
            }
            break;
        }
        case JANET_FIBER: {
            if (index == 0) {
                value = janet_unwrap_fiber(ds)->last_value;
            } else {
                value = janet_wrap_nil();
            }
            break;
        }
    }
    return value;
}

int32_t janet_length(Janet x) {
    switch (janet_type(x)) {
        default:
            janet_panicf("expected %T, got %v", JANET_TFLAG_LENGTHABLE, x);
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            return janet_string_length(janet_unwrap_string(x));
        case JANET_ARRAY:
            return janet_unwrap_array(x)->count;
        case JANET_BUFFER:
            return janet_unwrap_buffer(x)->count;
        case JANET_TUPLE:
            return janet_tuple_length(janet_unwrap_tuple(x));
        case JANET_STRUCT:
            return janet_struct_length(janet_unwrap_struct(x));
        case JANET_TABLE:
            return janet_unwrap_table(x)->count;
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(x);
            const JanetAbstractType *type = janet_abstract_type(abst);
            if (type->length != NULL) {
                size_t len = type->length(abst, janet_abstract_size(abst));
                if (len > INT32_MAX) {
                    janet_panicf("invalid integer length %u", len);
                }
                return (int32_t)(len);
            }
            Janet argv[1] = { x };
            Janet len = janet_mcall("length", 1, argv);
            if (!janet_checkint(len))
                janet_panicf("invalid integer length %v", len);
            return janet_unwrap_integer(len);
        }
    }
}

Janet janet_lengthv(Janet x) {
    switch (janet_type(x)) {
        default:
            janet_panicf("expected %T, got %v", JANET_TFLAG_LENGTHABLE, x);
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            return janet_wrap_integer(janet_string_length(janet_unwrap_string(x)));
        case JANET_ARRAY:
            return janet_wrap_integer(janet_unwrap_array(x)->count);
        case JANET_BUFFER:
            return janet_wrap_integer(janet_unwrap_buffer(x)->count);
        case JANET_TUPLE:
            return janet_wrap_integer(janet_tuple_length(janet_unwrap_tuple(x)));
        case JANET_STRUCT:
            return janet_wrap_integer(janet_struct_length(janet_unwrap_struct(x)));
        case JANET_TABLE:
            return janet_wrap_integer(janet_unwrap_table(x)->count);
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(x);
            const JanetAbstractType *type = janet_abstract_type(abst);
            if (type->length != NULL) {
                size_t len = type->length(abst, janet_abstract_size(abst));
                if ((uint64_t) len <= (uint64_t) JANET_INTMAX_INT64) {
                    return janet_wrap_number((double) len);
                } else {
                    janet_panicf("integer length %u too large", len);
                }
            }
            Janet argv[1] = { x };
            return janet_mcall("length", 1, argv);
        }
    }
}

void janet_putindex(Janet ds, int32_t index, Janet value) {
    switch (janet_type(ds)) {
        default:
            janet_panicf("expected %T, got %v",
                         JANET_TFLAG_ARRAY | JANET_TFLAG_BUFFER | JANET_TFLAG_TABLE, ds);
        case JANET_ARRAY: {
            JanetArray *array = janet_unwrap_array(ds);
            if (index >= array->count) {
                janet_array_ensure(array, index + 1, 2);
                array->count = index + 1;
            }
            array->data[index] = value;
            break;
        }
        case JANET_BUFFER: {
            JanetBuffer *buffer = janet_unwrap_buffer(ds);
            if (!janet_checkint(value))
                janet_panicf("can only put integers in buffers, got %v", value);
            if (index >= buffer->count) {
                janet_buffer_ensure(buffer, index + 1, 2);
                buffer->count = index + 1;
            }
            buffer->data[index] = (uint8_t)(janet_unwrap_integer(value) & 0xFF);
            break;
        }
        case JANET_TABLE: {
            JanetTable *table = janet_unwrap_table(ds);
            janet_table_put(table, janet_wrap_integer(index), value);
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(janet_unwrap_abstract(ds));
            if (type->put) {
                (type->put)(janet_unwrap_abstract(ds), janet_wrap_integer(index), value);
            } else {
                janet_panicf("no setter for %v ", ds);
            }
            break;
        }
    }
}

void janet_put(Janet ds, Janet key, Janet value) {
    switch (janet_type(ds)) {
        default:
            janet_panicf("expected %T, got %v",
                         JANET_TFLAG_ARRAY | JANET_TFLAG_BUFFER | JANET_TFLAG_TABLE, ds);
        case JANET_ARRAY: {
            JanetArray *array = janet_unwrap_array(ds);
            int32_t index = getter_checkint(key, INT32_MAX - 1);
            if (index >= array->count) {
                janet_array_setcount(array, index + 1);
            }
            array->data[index] = value;
            break;
        }
        case JANET_BUFFER: {
            JanetBuffer *buffer = janet_unwrap_buffer(ds);
            int32_t index = getter_checkint(key, INT32_MAX - 1);
            if (!janet_checkint(value))
                janet_panicf("can only put integers in buffers, got %v", value);
            if (index >= buffer->count) {
                janet_buffer_setcount(buffer, index + 1);
            }
            buffer->data[index] = (uint8_t)(janet_unwrap_integer(value) & 0xFF);
            break;
        }
        case JANET_TABLE:
            janet_table_put(janet_unwrap_table(ds), key, value);
            break;
        case JANET_ABSTRACT: {
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(janet_unwrap_abstract(ds));
            if (type->put) {
                (type->put)(janet_unwrap_abstract(ds), key, value);
            } else {
                janet_panicf("no setter for %v ", ds);
            }
            break;
        }
    }
}


/* src/core/vector.c */
#line 0 "src/core/vector.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include "vector.h"
#include "util.h"
#endif

/* Grow the buffer dynamically. Used for push operations. */
void *janet_v_grow(void *v, int32_t increment, int32_t itemsize) {
    int32_t dbl_cur = (NULL != v) ? 2 * janet_v__cap(v) : 0;
    int32_t min_needed = janet_v_count(v) + increment;
    int32_t m = dbl_cur > min_needed ? dbl_cur : min_needed;
    size_t newsize = ((size_t) itemsize) * m + sizeof(int32_t) * 2;
    int32_t *p = (int32_t *) janet_srealloc(v ? janet_v__raw(v) : 0, newsize);
    if (!v) p[1] = 0;
    p[0] = m;
    return p + 2;
}

/* Convert a buffer to normal allocated memory (forget capacity) */
void *janet_v_flattenmem(void *v, int32_t itemsize) {
    int32_t *p;
    if (NULL == v) return NULL;
    size_t size = (size_t) itemsize * janet_v__cnt(v);
    p = janet_malloc(size);
    if (NULL != p) {
        safe_memcpy(p, v, size);
        return p;
    } else {
        JANET_OUT_OF_MEMORY;
    }
}



/* src/core/vm.c */
#line 0 "src/core/vm.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "fiber.h"
#include "gc.h"
#include "symcache.h"
#include "util.h"
#endif

#include <math.h>

/* Virtual registers
 *
 * One instruction word
 * CC | BB | AA | OP
 * DD | DD | DD | OP
 * EE | EE | AA | OP
 */
#define A ((*pc >> 8)  & 0xFF)
#define B ((*pc >> 16) & 0xFF)
#define C (*pc >> 24)
#define D (*pc >> 8)
#define E (*pc >> 16)

/* Signed interpretations of registers */
#define CS (*((int32_t *)pc) >> 24)
#define DS (*((int32_t *)pc) >> 8)
#define ES (*((int32_t *)pc) >> 16)

/* How we dispatch instructions. By default, we use
 * a switch inside an infinite loop. For GCC/clang, we use
 * computed gotos. */
#if defined(__GNUC__) && !defined(__EMSCRIPTEN__)
#define JANET_USE_COMPUTED_GOTOS
#endif

#ifdef JANET_USE_COMPUTED_GOTOS
#define VM_START() { goto *op_lookup[first_opcode];
#define VM_END() }
#define VM_OP(op) label_##op :
#define VM_DEFAULT() label_unknown_op:
#define vm_next() goto *op_lookup[*pc & 0xFF]
#define opcode (*pc & 0xFF)
#else
#define VM_START() uint8_t opcode = first_opcode; for (;;) {switch(opcode) {
#define VM_END() }}
#define VM_OP(op) case op :
#define VM_DEFAULT() default:
#define vm_next() opcode = *pc & 0xFF; continue
#endif

/* Commit and restore VM state before possible longjmp */
#define vm_commit() do { janet_stack_frame(stack)->pc = pc; } while (0)
#define vm_restore() do { \
    stack = fiber->data + fiber->frame; \
    pc = janet_stack_frame(stack)->pc; \
    func = janet_stack_frame(stack)->func; \
} while (0)
#define vm_return(sig, val) do { \
    janet_vm.return_reg[0] = (val); \
    vm_commit(); \
    return (sig); \
} while (0)
#define vm_return_no_restore(sig, val) do { \
    janet_vm.return_reg[0] = (val); \
    return (sig); \
} while (0)

/* Next instruction variations */
#define maybe_collect() do {\
    if (janet_vm.next_collection >= janet_vm.gc_interval) janet_collect(); } while (0)
#define vm_checkgc_next() maybe_collect(); vm_next()
#define vm_pcnext() pc++; vm_next()
#define vm_checkgc_pcnext() maybe_collect(); vm_pcnext()

/* Handle certain errors in main vm loop */
#define vm_throw(e) do { vm_commit(); janet_panic(e); } while (0)
#define vm_assert(cond, e) do {if (!(cond)) vm_throw((e)); } while (0)
#define vm_assert_type(X, T) do { \
    if (!(janet_checktype((X), (T)))) { \
        vm_commit(); \
        janet_panicf("expected %T, got %v", (1 << (T)), (X)); \
    } \
} while (0)
#define vm_assert_types(X, TS) do { \
    if (!(janet_checktypes((X), (TS)))) { \
        vm_commit(); \
        janet_panicf("expected %T, got %v", (TS), (X)); \
    } \
} while (0)
#ifdef JANET_NO_INTERPRETER_INTERRUPT
#define vm_maybe_auto_suspend(COND)
#else
#define vm_maybe_auto_suspend(COND) do { \
    if ((COND) && janet_vm.auto_suspend) { \
        janet_vm.auto_suspend = 0; \
        fiber->flags |= (JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP); \
        vm_return(JANET_SIGNAL_INTERRUPT, janet_wrap_nil()); \
    } \
} while (0)
#endif

/* Templates for certain patterns in opcodes */
#define vm_binop_immediate(op)\
    {\
        Janet op1 = stack[B];\
        if (!janet_checktype(op1, JANET_NUMBER)) {\
            vm_commit();\
            Janet _argv[2] = { op1, janet_wrap_number(CS) };\
            stack[A] = janet_mcall(#op, 2, _argv);\
            vm_checkgc_pcnext();\
        } else {\
            double x1 = janet_unwrap_number(op1);\
            stack[A] = janet_wrap_number(x1 op CS);\
            vm_pcnext();\
        }\
    }
#define _vm_bitop_immediate(op, type1)\
    {\
        Janet op1 = stack[B];\
        if (!janet_checktype(op1, JANET_NUMBER)) {\
            vm_commit();\
            Janet _argv[2] = { op1, janet_wrap_number(CS) };\
            stack[A] = janet_mcall(#op, 2, _argv);\
            vm_checkgc_pcnext();\
        } else {\
            type1 x1 = (type1) janet_unwrap_integer(op1);\
            stack[A] = janet_wrap_integer(x1 op CS);\
            vm_pcnext();\
        }\
    }
#define vm_bitop_immediate(op) _vm_bitop_immediate(op, int32_t);
#define vm_bitopu_immediate(op) _vm_bitop_immediate(op, uint32_t);
#define _vm_binop(op, wrap)\
    {\
        Janet op1 = stack[B];\
        Janet op2 = stack[C];\
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {\
            double x1 = janet_unwrap_number(op1);\
            double x2 = janet_unwrap_number(op2);\
            stack[A] = wrap(x1 op x2);\
            vm_pcnext();\
        } else {\
            vm_commit();\
            stack[A] = janet_binop_call(#op, "r" #op, op1, op2);\
            vm_checkgc_pcnext();\
        }\
    }
#define vm_binop(op) _vm_binop(op, janet_wrap_number)
#define _vm_bitop(op, type1)\
    {\
        Janet op1 = stack[B];\
        Janet op2 = stack[C];\
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {\
            type1 x1 = (type1) janet_unwrap_integer(op1);\
            int32_t x2 = janet_unwrap_integer(op2);\
            stack[A] = janet_wrap_integer(x1 op x2);\
            vm_pcnext();\
        } else {\
            vm_commit();\
            stack[A] = janet_binop_call(#op, "r" #op, op1, op2);\
            vm_checkgc_pcnext();\
        }\
    }
#define vm_bitop(op) _vm_bitop(op, int32_t)
#define vm_bitopu(op) _vm_bitop(op, uint32_t)
#define vm_compop(op) \
    {\
        Janet op1 = stack[B];\
        Janet op2 = stack[C];\
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {\
            double x1 = janet_unwrap_number(op1);\
            double x2 = janet_unwrap_number(op2);\
            stack[A] = janet_wrap_boolean(x1 op x2);\
            vm_pcnext();\
        } else {\
            vm_commit();\
            stack[A] = janet_wrap_boolean(janet_compare(op1, op2) op 0);\
            vm_checkgc_pcnext();\
        }\
    }
#define vm_compop_imm(op) \
    {\
        Janet op1 = stack[B];\
        if (janet_checktype(op1, JANET_NUMBER)) {\
            double x1 = janet_unwrap_number(op1);\
            double x2 = (double) CS; \
            stack[A] = janet_wrap_boolean(x1 op x2);\
            vm_pcnext();\
        } else {\
            vm_commit();\
            stack[A] = janet_wrap_boolean(janet_compare(op1, janet_wrap_integer(CS)) op 0);\
            vm_checkgc_pcnext();\
        }\
    }

/* Trace a function call */
static void vm_do_trace(JanetFunction *func, int32_t argc, const Janet *argv) {
    if (func->def->name) {
        janet_eprintf("trace (%S", func->def->name);
    } else {
        janet_eprintf("trace (%p", janet_wrap_function(func));
    }
    for (int32_t i = 0; i < argc; i++) {
        janet_eprintf(" %p", argv[i]);
    }
    janet_eprintf(")\n");
}

/* Invoke a method once we have looked it up */
static Janet janet_method_invoke(Janet method, int32_t argc, Janet *argv) {
    switch (janet_type(method)) {
        case JANET_CFUNCTION:
            return (janet_unwrap_cfunction(method))(argc, argv);
        case JANET_FUNCTION: {
            JanetFunction *fun = janet_unwrap_function(method);
            return janet_call(fun, argc, argv);
        }
        case JANET_ABSTRACT: {
            JanetAbstract abst = janet_unwrap_abstract(method);
            const JanetAbstractType *at = janet_abstract_type(abst);
            if (NULL != at->call) {
                return at->call(abst, argc, argv);
            }
        }
        /* fallthrough */
        case JANET_STRING:
        case JANET_BUFFER:
        case JANET_TABLE:
        case JANET_STRUCT:
        case JANET_ARRAY:
        case JANET_TUPLE: {
            if (argc != 1) {
                janet_panicf("%v called with %d arguments, possibly expected 1", method, argc);
            }
            return janet_in(method, argv[0]);
        }
        default: {
            if (argc != 1) {
                janet_panicf("%v called with %d arguments, possibly expected 1", method, argc);
            }
            return janet_in(argv[0], method);
        }
    }
}

/* Call a non function type from a JOP_CALL or JOP_TAILCALL instruction.
 * Assumes that the arguments are on the fiber stack. */
static Janet call_nonfn(JanetFiber *fiber, Janet callee) {
    int32_t argc = fiber->stacktop - fiber->stackstart;
    fiber->stacktop = fiber->stackstart;
    return janet_method_invoke(callee, argc, fiber->data + fiber->stacktop);
}

/* Method lookup could potentially handle tables specially... */
static Janet method_to_fun(Janet method, Janet obj) {
    return janet_get(obj, method);
}

/* Get a callable from a keyword method name and ensure that it is valid. */
static Janet resolve_method(Janet name, JanetFiber *fiber) {
    int32_t argc = fiber->stacktop - fiber->stackstart;
    if (argc < 1) janet_panicf("method call (%v) takes at least 1 argument, got 0", name);
    Janet callee = method_to_fun(name, fiber->data[fiber->stackstart]);
    if (janet_checktype(callee, JANET_NIL))
        janet_panicf("unknown method %v invoked on %v", name, fiber->data[fiber->stackstart]);
    return callee;
}

/* Lookup method on value x */
static Janet janet_method_lookup(Janet x, const char *name) {
    return method_to_fun(janet_ckeywordv(name), x);
}

/* Call a method first on the righthand side, and then on the left hand side with a prefix */
static Janet janet_binop_call(const char *lmethod, const char *rmethod, Janet lhs, Janet rhs) {
    Janet lm = janet_method_lookup(lhs, lmethod);
    if (janet_checktype(lm, JANET_NIL)) {
        /* Invert order for rmethod */
        Janet lr = janet_method_lookup(rhs, rmethod);
        Janet argv[2] = { rhs, lhs };
        if (janet_checktype(lr, JANET_NIL)) {
            janet_panicf("could not find method :%s for %v, or :%s for %v",
                         lmethod, lhs,
                         rmethod, rhs);
        }
        return janet_method_invoke(lr, 2, argv);
    } else {
        Janet argv[2] = { lhs, rhs };
        return janet_method_invoke(lm, 2, argv);
    }
}

/* Forward declaration */
static JanetSignal janet_check_can_resume(JanetFiber *fiber, Janet *out, int is_cancel);
static JanetSignal janet_continue_no_check(JanetFiber *fiber, Janet in, Janet *out);

/* Interpreter main loop */
static JanetSignal run_vm(JanetFiber *fiber, Janet in) {

    /* opcode -> label lookup if using clang/GCC */
#ifdef JANET_USE_COMPUTED_GOTOS
    static void *op_lookup[255] = {
        &&label_JOP_NOOP,
        &&label_JOP_ERROR,
        &&label_JOP_TYPECHECK,
        &&label_JOP_RETURN,
        &&label_JOP_RETURN_NIL,
        &&label_JOP_ADD_IMMEDIATE,
        &&label_JOP_ADD,
        &&label_JOP_SUBTRACT,
        &&label_JOP_MULTIPLY_IMMEDIATE,
        &&label_JOP_MULTIPLY,
        &&label_JOP_DIVIDE_IMMEDIATE,
        &&label_JOP_DIVIDE,
        &&label_JOP_MODULO,
        &&label_JOP_REMAINDER,
        &&label_JOP_BAND,
        &&label_JOP_BOR,
        &&label_JOP_BXOR,
        &&label_JOP_BNOT,
        &&label_JOP_SHIFT_LEFT,
        &&label_JOP_SHIFT_LEFT_IMMEDIATE,
        &&label_JOP_SHIFT_RIGHT,
        &&label_JOP_SHIFT_RIGHT_IMMEDIATE,
        &&label_JOP_SHIFT_RIGHT_UNSIGNED,
        &&label_JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE,
        &&label_JOP_MOVE_FAR,
        &&label_JOP_MOVE_NEAR,
        &&label_JOP_JUMP,
        &&label_JOP_JUMP_IF,
        &&label_JOP_JUMP_IF_NOT,
        &&label_JOP_JUMP_IF_NIL,
        &&label_JOP_JUMP_IF_NOT_NIL,
        &&label_JOP_GREATER_THAN,
        &&label_JOP_GREATER_THAN_IMMEDIATE,
        &&label_JOP_LESS_THAN,
        &&label_JOP_LESS_THAN_IMMEDIATE,
        &&label_JOP_EQUALS,
        &&label_JOP_EQUALS_IMMEDIATE,
        &&label_JOP_COMPARE,
        &&label_JOP_LOAD_NIL,
        &&label_JOP_LOAD_TRUE,
        &&label_JOP_LOAD_FALSE,
        &&label_JOP_LOAD_INTEGER,
        &&label_JOP_LOAD_CONSTANT,
        &&label_JOP_LOAD_UPVALUE,
        &&label_JOP_LOAD_SELF,
        &&label_JOP_SET_UPVALUE,
        &&label_JOP_CLOSURE,
        &&label_JOP_PUSH,
        &&label_JOP_PUSH_2,
        &&label_JOP_PUSH_3,
        &&label_JOP_PUSH_ARRAY,
        &&label_JOP_CALL,
        &&label_JOP_TAILCALL,
        &&label_JOP_RESUME,
        &&label_JOP_SIGNAL,
        &&label_JOP_PROPAGATE,
        &&label_JOP_IN,
        &&label_JOP_GET,
        &&label_JOP_PUT,
        &&label_JOP_GET_INDEX,
        &&label_JOP_PUT_INDEX,
        &&label_JOP_LENGTH,
        &&label_JOP_MAKE_ARRAY,
        &&label_JOP_MAKE_BUFFER,
        &&label_JOP_MAKE_STRING,
        &&label_JOP_MAKE_STRUCT,
        &&label_JOP_MAKE_TABLE,
        &&label_JOP_MAKE_TUPLE,
        &&label_JOP_MAKE_BRACKET_TUPLE,
        &&label_JOP_GREATER_THAN_EQUAL,
        &&label_JOP_LESS_THAN_EQUAL,
        &&label_JOP_NEXT,
        &&label_JOP_NOT_EQUALS,
        &&label_JOP_NOT_EQUALS_IMMEDIATE,
        &&label_JOP_CANCEL,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op
    };
#endif

    /* Interpreter state */
    register Janet *stack;
    register uint32_t *pc;
    register JanetFunction *func;

    if (fiber->flags & JANET_FIBER_RESUME_SIGNAL) {
        JanetSignal sig = (fiber->gc.flags & JANET_FIBER_STATUS_MASK) >> JANET_FIBER_STATUS_OFFSET;
        fiber->gc.flags &= ~JANET_FIBER_STATUS_MASK;
        fiber->flags &= ~(JANET_FIBER_RESUME_SIGNAL | JANET_FIBER_FLAG_MASK);
        janet_vm.return_reg[0] = in;
        return sig;
    }

    vm_restore();

    if (fiber->flags & JANET_FIBER_DID_LONGJUMP) {
        if (janet_fiber_frame(fiber)->func == NULL) {
            /* Inside a c function */
            janet_fiber_popframe(fiber);
            vm_restore();
        }
        /* Check if we were at a tail call instruction. If so, do implicit return */
        if ((*pc & 0xFF) == JOP_TAILCALL) {
            /* Tail call resume */
            int entrance_frame = janet_stack_frame(stack)->flags & JANET_STACKFRAME_ENTRANCE;
            janet_fiber_popframe(fiber);
            if (entrance_frame) {
                fiber->flags &= ~JANET_FIBER_FLAG_MASK;
                vm_return(JANET_SIGNAL_OK, in);
            }
            vm_restore();
        }
    }

    if (!(fiber->flags & JANET_FIBER_RESUME_NO_USEVAL)) stack[A] = in;
    if (!(fiber->flags & JANET_FIBER_RESUME_NO_SKIP)) pc++;

    uint8_t first_opcode = *pc & ((fiber->flags & JANET_FIBER_BREAKPOINT) ? 0x7F : 0xFF);

    fiber->flags &= ~JANET_FIBER_FLAG_MASK;

    /* Main interpreter loop. Semantically is a switch on
     * (*pc & 0xFF) inside of an infinite loop. */
    VM_START();

    VM_DEFAULT();
    fiber->flags |= JANET_FIBER_BREAKPOINT | JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP;
    vm_return(JANET_SIGNAL_DEBUG, janet_wrap_nil());

    VM_OP(JOP_NOOP)
    vm_pcnext();

    VM_OP(JOP_ERROR)
    vm_return(JANET_SIGNAL_ERROR, stack[A]);

    VM_OP(JOP_TYPECHECK)
    vm_assert_types(stack[A], E);
    vm_pcnext();

    VM_OP(JOP_RETURN) {
        Janet retval = stack[D];
        int entrance_frame = janet_stack_frame(stack)->flags & JANET_STACKFRAME_ENTRANCE;
        janet_fiber_popframe(fiber);
        if (entrance_frame) vm_return_no_restore(JANET_SIGNAL_OK, retval);
        vm_restore();
        stack[A] = retval;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_RETURN_NIL) {
        Janet retval = janet_wrap_nil();
        int entrance_frame = janet_stack_frame(stack)->flags & JANET_STACKFRAME_ENTRANCE;
        janet_fiber_popframe(fiber);
        if (entrance_frame) vm_return_no_restore(JANET_SIGNAL_OK, retval);
        vm_restore();
        stack[A] = retval;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_ADD_IMMEDIATE)
    vm_binop_immediate(+);

    VM_OP(JOP_ADD)
    vm_binop(+);

    VM_OP(JOP_SUBTRACT)
    vm_binop(-);

    VM_OP(JOP_MULTIPLY_IMMEDIATE)
    vm_binop_immediate(*);

    VM_OP(JOP_MULTIPLY)
    vm_binop(*);

    VM_OP(JOP_DIVIDE_IMMEDIATE)
    vm_binop_immediate( /);

    VM_OP(JOP_DIVIDE)
    vm_binop( /);

    VM_OP(JOP_MODULO) {
        Janet op1 = stack[B];
        Janet op2 = stack[C];
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {
            double x1 = janet_unwrap_number(op1);
            double x2 = janet_unwrap_number(op2);
            double intres = x2 * floor(x1 / x2);
            stack[A] = janet_wrap_number(x1 - intres);
            vm_pcnext();
        } else {
            vm_commit();
            stack[A] = janet_binop_call("mod", "rmod", op1, op2);
            vm_checkgc_pcnext();
        }
    }

    VM_OP(JOP_REMAINDER) {
        Janet op1 = stack[B];
        Janet op2 = stack[C];
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {
            double x1 = janet_unwrap_number(op1);
            double x2 = janet_unwrap_number(op2);
            stack[A] = janet_wrap_number(fmod(x1, x2));
            vm_pcnext();
        } else {
            vm_commit();
            stack[A] = janet_binop_call("%", "r%", op1, op2);
            vm_checkgc_pcnext();
        }
    }

    VM_OP(JOP_BAND)
    vm_bitop(&);

    VM_OP(JOP_BOR)
    vm_bitop( |);

    VM_OP(JOP_BXOR)
    vm_bitop(^);

    VM_OP(JOP_BNOT) {
        Janet op = stack[E];
        vm_assert_type(op, JANET_NUMBER);
        stack[A] = janet_wrap_integer(~janet_unwrap_integer(op));
        vm_pcnext();
    }

    VM_OP(JOP_SHIFT_RIGHT_UNSIGNED)
    vm_bitopu( >>);

    VM_OP(JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE)
    vm_bitopu_immediate( >>);

    VM_OP(JOP_SHIFT_RIGHT)
    vm_bitop( >>);

    VM_OP(JOP_SHIFT_RIGHT_IMMEDIATE)
    vm_bitop_immediate( >>);

    VM_OP(JOP_SHIFT_LEFT)
    vm_bitop( <<);

    VM_OP(JOP_SHIFT_LEFT_IMMEDIATE)
    vm_bitop_immediate( <<);

    VM_OP(JOP_MOVE_NEAR)
    stack[A] = stack[E];
    vm_pcnext();

    VM_OP(JOP_MOVE_FAR)
    stack[E] = stack[A];
    vm_pcnext();

    VM_OP(JOP_JUMP)
    pc += DS;
    vm_maybe_auto_suspend(DS < 0);
    vm_next();

    VM_OP(JOP_JUMP_IF)
    if (janet_truthy(stack[A])) {
        pc += ES;
        vm_maybe_auto_suspend(ES < 0);
    } else {
        pc++;
    }
    vm_next();

    VM_OP(JOP_JUMP_IF_NOT)
    if (janet_truthy(stack[A])) {
        pc++;
    } else {
        pc += ES;
        vm_maybe_auto_suspend(ES < 0);
    }
    vm_next();

    VM_OP(JOP_JUMP_IF_NIL)
    if (janet_checktype(stack[A], JANET_NIL)) {
        pc += ES;
        vm_maybe_auto_suspend(ES < 0);
    } else {
        pc++;
    }
    vm_next();

    VM_OP(JOP_JUMP_IF_NOT_NIL)
    if (janet_checktype(stack[A], JANET_NIL)) {
        pc++;
    } else {
        pc += ES;
        vm_maybe_auto_suspend(ES < 0);
    }
    vm_next();

    VM_OP(JOP_LESS_THAN)
    vm_compop( <);

    VM_OP(JOP_LESS_THAN_EQUAL)
    vm_compop( <=);

    VM_OP(JOP_LESS_THAN_IMMEDIATE)
    vm_compop_imm( <);

    VM_OP(JOP_GREATER_THAN)
    vm_compop( >);

    VM_OP(JOP_GREATER_THAN_EQUAL)
    vm_compop( >=);

    VM_OP(JOP_GREATER_THAN_IMMEDIATE)
    vm_compop_imm( >);

    VM_OP(JOP_EQUALS)
    stack[A] = janet_wrap_boolean(janet_equals(stack[B], stack[C]));
    vm_pcnext();

    VM_OP(JOP_EQUALS_IMMEDIATE)
    stack[A] = janet_wrap_boolean(janet_unwrap_number(stack[B]) == (double) CS);
    vm_pcnext();

    VM_OP(JOP_NOT_EQUALS)
    stack[A] = janet_wrap_boolean(!janet_equals(stack[B], stack[C]));
    vm_pcnext();

    VM_OP(JOP_NOT_EQUALS_IMMEDIATE)
    stack[A] = janet_wrap_boolean(janet_unwrap_number(stack[B]) != (double) CS);
    vm_pcnext();

    VM_OP(JOP_COMPARE)
    stack[A] = janet_wrap_integer(janet_compare(stack[B], stack[C]));
    vm_pcnext();

    VM_OP(JOP_NEXT)
    vm_commit();
    {
        Janet temp = janet_next_impl(stack[B], stack[C], 1);
        vm_restore();
        stack[A] = temp;
    }
    vm_pcnext();

    VM_OP(JOP_LOAD_NIL)
    stack[D] = janet_wrap_nil();
    vm_pcnext();

    VM_OP(JOP_LOAD_TRUE)
    stack[D] = janet_wrap_true();
    vm_pcnext();

    VM_OP(JOP_LOAD_FALSE)
    stack[D] = janet_wrap_false();
    vm_pcnext();

    VM_OP(JOP_LOAD_INTEGER)
    stack[A] = janet_wrap_integer(ES);
    vm_pcnext();

    VM_OP(JOP_LOAD_CONSTANT) {
        int32_t cindex = (int32_t)E;
        vm_assert(cindex < func->def->constants_length, "invalid constant");
        stack[A] = func->def->constants[cindex];
        vm_pcnext();
    }

    VM_OP(JOP_LOAD_SELF)
    stack[D] = janet_wrap_function(func);
    vm_pcnext();

    VM_OP(JOP_LOAD_UPVALUE) {
        int32_t eindex = B;
        int32_t vindex = C;
        JanetFuncEnv *env;
        vm_assert(func->def->environments_length > eindex, "invalid upvalue environment");
        env = func->envs[eindex];
        vm_assert(env->length > vindex, "invalid upvalue index");
        vm_assert(janet_env_valid(env), "invalid upvalue environment");
        if (env->offset > 0) {
            /* On stack */
            stack[A] = env->as.fiber->data[env->offset + vindex];
        } else {
            /* Off stack */
            stack[A] = env->as.values[vindex];
        }
        vm_pcnext();
    }

    VM_OP(JOP_SET_UPVALUE) {
        int32_t eindex = B;
        int32_t vindex = C;
        JanetFuncEnv *env;
        vm_assert(func->def->environments_length > eindex, "invalid upvalue environment");
        env = func->envs[eindex];
        vm_assert(env->length > vindex, "invalid upvalue index");
        vm_assert(janet_env_valid(env), "invalid upvalue environment");
        if (env->offset > 0) {
            env->as.fiber->data[env->offset + vindex] = stack[A];
        } else {
            env->as.values[vindex] = stack[A];
        }
        vm_pcnext();
    }

    VM_OP(JOP_CLOSURE) {
        JanetFuncDef *fd;
        JanetFunction *fn;
        int32_t elen;
        int32_t defindex = (int32_t)E;
        vm_assert(defindex < func->def->defs_length, "invalid funcdef");
        fd = func->def->defs[defindex];
        elen = fd->environments_length;
        fn = janet_gcalloc(JANET_MEMORY_FUNCTION, sizeof(JanetFunction) + ((size_t) elen * sizeof(JanetFuncEnv *)));
        fn->def = fd;
        {
            int32_t i;
            for (i = 0; i < elen; ++i) {
                int32_t inherit = fd->environments[i];
                if (inherit == -1) {
                    JanetStackFrame *frame = janet_stack_frame(stack);
                    if (!frame->env) {
                        /* Lazy capture of current stack frame */
                        JanetFuncEnv *env = janet_gcalloc(JANET_MEMORY_FUNCENV, sizeof(JanetFuncEnv));
                        env->offset = fiber->frame;
                        env->as.fiber = fiber;
                        env->length = func->def->slotcount;
                        frame->env = env;
                    }
                    fn->envs[i] = frame->env;
                } else {
                    fn->envs[i] = func->envs[inherit];
                }
            }
        }
        stack[A] = janet_wrap_function(fn);
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_PUSH)
    janet_fiber_push(fiber, stack[D]);
    stack = fiber->data + fiber->frame;
    vm_checkgc_pcnext();

    VM_OP(JOP_PUSH_2)
    janet_fiber_push2(fiber, stack[A], stack[E]);
    stack = fiber->data + fiber->frame;
    vm_checkgc_pcnext();

    VM_OP(JOP_PUSH_3)
    janet_fiber_push3(fiber, stack[A], stack[B], stack[C]);
    stack = fiber->data + fiber->frame;
    vm_checkgc_pcnext();

    VM_OP(JOP_PUSH_ARRAY) {
        const Janet *vals;
        int32_t len;
        if (janet_indexed_view(stack[D], &vals, &len)) {
            janet_fiber_pushn(fiber, vals, len);
        } else {
            janet_panicf("expected %T, got %v", JANET_TFLAG_INDEXED, stack[D]);
        }
    }
    stack = fiber->data + fiber->frame;
    vm_checkgc_pcnext();

    VM_OP(JOP_CALL) {
        vm_maybe_auto_suspend(1);
        Janet callee = stack[E];
        if (fiber->stacktop > fiber->maxstack) {
            vm_throw("stack overflow");
        }
        if (janet_checktype(callee, JANET_KEYWORD)) {
            vm_commit();
            callee = resolve_method(callee, fiber);
        }
        if (janet_checktype(callee, JANET_FUNCTION)) {
            func = janet_unwrap_function(callee);
            if (func->gc.flags & JANET_FUNCFLAG_TRACE) {
                vm_do_trace(func, fiber->stacktop - fiber->stackstart, fiber->data + fiber->stackstart);
            }
            janet_stack_frame(stack)->pc = pc;
            if (janet_fiber_funcframe(fiber, func)) {
                int32_t n = fiber->stacktop - fiber->stackstart;
                janet_panicf("%v called with %d argument%s, expected %d",
                             callee, n, n == 1 ? "" : "s", func->def->arity);
            }
            stack = fiber->data + fiber->frame;
            pc = func->def->bytecode;
            vm_checkgc_next();
        } else if (janet_checktype(callee, JANET_CFUNCTION)) {
            vm_commit();
            int32_t argc = fiber->stacktop - fiber->stackstart;
            janet_fiber_cframe(fiber, janet_unwrap_cfunction(callee));
            Janet ret = janet_unwrap_cfunction(callee)(argc, fiber->data + fiber->frame);
            janet_fiber_popframe(fiber);
            stack = fiber->data + fiber->frame;
            stack[A] = ret;
            vm_checkgc_pcnext();
        } else {
            vm_commit();
            stack[A] = call_nonfn(fiber, callee);
            vm_pcnext();
        }
    }

    VM_OP(JOP_TAILCALL) {
        vm_maybe_auto_suspend(1);
        Janet callee = stack[D];
        if (fiber->stacktop > fiber->maxstack) {
            vm_throw("stack overflow");
        }
        if (janet_checktype(callee, JANET_KEYWORD)) {
            vm_commit();
            callee = resolve_method(callee, fiber);
        }
        if (janet_checktype(callee, JANET_FUNCTION)) {
            func = janet_unwrap_function(callee);
            if (func->gc.flags & JANET_FUNCFLAG_TRACE) {
                vm_do_trace(func, fiber->stacktop - fiber->stackstart, fiber->data + fiber->stackstart);
            }
            if (janet_fiber_funcframe_tail(fiber, func)) {
                janet_stack_frame(fiber->data + fiber->frame)->pc = pc;
                int32_t n = fiber->stacktop - fiber->stackstart;
                janet_panicf("%v called with %d argument%s, expected %d",
                             callee, n, n == 1 ? "" : "s", func->def->arity);
            }
            stack = fiber->data + fiber->frame;
            pc = func->def->bytecode;
            vm_checkgc_next();
        } else {
            Janet retreg;
            int entrance_frame = janet_stack_frame(stack)->flags & JANET_STACKFRAME_ENTRANCE;
            vm_commit();
            if (janet_checktype(callee, JANET_CFUNCTION)) {
                int32_t argc = fiber->stacktop - fiber->stackstart;
                janet_fiber_cframe(fiber, janet_unwrap_cfunction(callee));
                retreg = janet_unwrap_cfunction(callee)(argc, fiber->data + fiber->frame);
                janet_fiber_popframe(fiber);
            } else {
                retreg = call_nonfn(fiber, callee);
            }
            janet_fiber_popframe(fiber);
            if (entrance_frame) {
                vm_return_no_restore(JANET_SIGNAL_OK, retreg);
            }
            vm_restore();
            stack[A] = retreg;
            vm_checkgc_pcnext();
        }
    }

    VM_OP(JOP_RESUME) {
        Janet retreg;
        vm_maybe_auto_suspend(1);
        vm_assert_type(stack[B], JANET_FIBER);
        JanetFiber *child = janet_unwrap_fiber(stack[B]);
        if (janet_check_can_resume(child, &retreg, 0)) {
            vm_commit();
            janet_panicv(retreg);
        }
        fiber->child = child;
        JanetSignal sig = janet_continue_no_check(child, stack[C], &retreg);
        if (sig != JANET_SIGNAL_OK && !(child->flags & (1 << sig))) {
            vm_return(sig, retreg);
        }
        fiber->child = NULL;
        stack = fiber->data + fiber->frame;
        stack[A] = retreg;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_SIGNAL) {
        int32_t s = C;
        if (s > JANET_SIGNAL_USER9) s = JANET_SIGNAL_USER9;
        if (s < 0) s = 0;
        vm_return(s, stack[B]);
    }

    VM_OP(JOP_PROPAGATE) {
        Janet fv = stack[C];
        vm_assert_type(fv, JANET_FIBER);
        JanetFiber *f = janet_unwrap_fiber(fv);
        JanetFiberStatus sub_status = janet_fiber_status(f);
        if (sub_status > JANET_STATUS_USER9) {
            vm_commit();
            janet_panicf("cannot propagate from fiber with status :%s",
                         janet_status_names[sub_status]);
        }
        fiber->child = f;
        vm_return((int) sub_status, stack[B]);
    }

    VM_OP(JOP_CANCEL) {
        Janet retreg;
        vm_assert_type(stack[B], JANET_FIBER);
        JanetFiber *child = janet_unwrap_fiber(stack[B]);
        if (janet_check_can_resume(child, &retreg, 1)) {
            vm_commit();
            janet_panicv(retreg);
        }
        fiber->child = child;
        JanetSignal sig = janet_continue_signal(child, stack[C], &retreg, JANET_SIGNAL_ERROR);
        if (sig != JANET_SIGNAL_OK && !(child->flags & (1 << sig))) {
            vm_return(sig, retreg);
        }
        fiber->child = NULL;
        stack = fiber->data + fiber->frame;
        stack[A] = retreg;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_PUT)
    vm_commit();
    fiber->flags |= JANET_FIBER_RESUME_NO_USEVAL;
    janet_put(stack[A], stack[B], stack[C]);
    fiber->flags &= ~JANET_FIBER_RESUME_NO_USEVAL;
    vm_checkgc_pcnext();

    VM_OP(JOP_PUT_INDEX)
    vm_commit();
    fiber->flags |= JANET_FIBER_RESUME_NO_USEVAL;
    janet_putindex(stack[A], C, stack[B]);
    fiber->flags &= ~JANET_FIBER_RESUME_NO_USEVAL;
    vm_checkgc_pcnext();

    VM_OP(JOP_IN)
    vm_commit();
    stack[A] = janet_in(stack[B], stack[C]);
    vm_pcnext();

    VM_OP(JOP_GET)
    vm_commit();
    stack[A] = janet_get(stack[B], stack[C]);
    vm_pcnext();

    VM_OP(JOP_GET_INDEX)
    vm_commit();
    stack[A] = janet_getindex(stack[B], C);
    vm_pcnext();

    VM_OP(JOP_LENGTH)
    vm_commit();
    stack[A] = janet_lengthv(stack[E]);
    vm_pcnext();

    VM_OP(JOP_MAKE_ARRAY) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        stack[D] = janet_wrap_array(janet_array_n(mem, count));
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_TUPLE)
    /* fallthrough */
    VM_OP(JOP_MAKE_BRACKET_TUPLE) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        const Janet *tup = janet_tuple_n(mem, count);
        if (opcode == JOP_MAKE_BRACKET_TUPLE)
            janet_tuple_flag(tup) |= JANET_TUPLE_FLAG_BRACKETCTOR;
        stack[D] = janet_wrap_tuple(tup);
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_TABLE) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        if (count & 1) {
            vm_commit();
            janet_panicf("expected even number of arguments to table constructor, got %d", count);
        }
        JanetTable *table = janet_table(count / 2);
        for (int32_t i = 0; i < count; i += 2)
            janet_table_put(table, mem[i], mem[i + 1]);
        stack[D] = janet_wrap_table(table);
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_STRUCT) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        if (count & 1) {
            vm_commit();
            janet_panicf("expected even number of arguments to struct constructor, got %d", count);
        }
        JanetKV *st = janet_struct_begin(count / 2);
        for (int32_t i = 0; i < count; i += 2)
            janet_struct_put(st, mem[i], mem[i + 1]);
        stack[D] = janet_wrap_struct(janet_struct_end(st));
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_STRING) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        JanetBuffer buffer;
        janet_buffer_init(&buffer, 10 * count);
        for (int32_t i = 0; i < count; i++)
            janet_to_string_b(&buffer, mem[i]);
        stack[D] = janet_stringv(buffer.data, buffer.count);
        janet_buffer_deinit(&buffer);
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_BUFFER) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        JanetBuffer *buffer = janet_buffer(10 * count);
        for (int32_t i = 0; i < count; i++)
            janet_to_string_b(buffer, mem[i]);
        stack[D] = janet_wrap_buffer(buffer);
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_END()
}

/*
 * Execute a single instruction in the fiber. Does this by inspecting
 * the fiber, setting a breakpoint at the next instruction, executing, and
 * reseting breakpoints to how they were prior. Yes, it's a bit hacky.
 */
JanetSignal janet_step(JanetFiber *fiber, Janet in, Janet *out) {
    /* No finished or currently alive fibers. */
    JanetFiberStatus status = janet_fiber_status(fiber);
    if (status == JANET_STATUS_ALIVE ||
            status == JANET_STATUS_DEAD ||
            status == JANET_STATUS_ERROR) {
        janet_panicf("cannot step fiber with status :%s", janet_status_names[status]);
    }

    /* Get PC for setting breakpoints */
    uint32_t *pc = janet_stack_frame(fiber->data + fiber->frame)->pc;

    /* Check current opcode (sans debug flag). This tells us where the next or next two candidate
     * instructions will be. Usually it's the next instruction in memory,
     * but for branching instructions it is also the target of the branch. */
    uint32_t *nexta = NULL, *nextb = NULL, olda = 0, oldb = 0;

    /* Set temporary breakpoints */
    switch (*pc & 0x7F) {
        default:
            nexta = pc + 1;
            break;
        /* These we just ignore for now. Supporting them means
         * we could step into and out of functions (including JOP_CALL). */
        case JOP_RETURN_NIL:
        case JOP_RETURN:
        case JOP_ERROR:
        case JOP_TAILCALL:
            break;
        case JOP_JUMP:
            nexta = pc + DS;
            break;
        case JOP_JUMP_IF:
        case JOP_JUMP_IF_NOT:
            nexta = pc + 1;
            nextb = pc + ES;
            break;
    }
    if (nexta) {
        olda = *nexta;
        *nexta |= 0x80;
    }
    if (nextb) {
        oldb = *nextb;
        *nextb |= 0x80;
    }

    /* Go */
    JanetSignal signal = janet_continue(fiber, in, out);

    /* Restore */
    if (nexta) *nexta = olda;
    if (nextb) *nextb = oldb;

    return signal;
}

static Janet void_cfunction(int32_t argc, Janet *argv) {
    (void) argc;
    (void) argv;
    janet_panic("placeholder");
}

Janet janet_call(JanetFunction *fun, int32_t argc, const Janet *argv) {
    /* Check entry conditions */
    if (!janet_vm.fiber)
        janet_panic("janet_call failed because there is no current fiber");
    if (janet_vm.stackn >= JANET_RECURSION_GUARD)
        janet_panic("C stack recursed too deeply");

    /* Dirty stack */
    int32_t dirty_stack = janet_vm.fiber->stacktop - janet_vm.fiber->stackstart;
    if (dirty_stack) {
        janet_fiber_cframe(janet_vm.fiber, void_cfunction);
    }

    /* Tracing */
    if (fun->gc.flags & JANET_FUNCFLAG_TRACE) {
        janet_vm.stackn++;
        vm_do_trace(fun, argc, argv);
        janet_vm.stackn--;
    }

    /* Push frame */
    janet_fiber_pushn(janet_vm.fiber, argv, argc);
    if (janet_fiber_funcframe(janet_vm.fiber, fun)) {
        int32_t min = fun->def->min_arity;
        int32_t max = fun->def->max_arity;
        Janet funv = janet_wrap_function(fun);
        if (min == max && min != argc)
            janet_panicf("arity mismatch in %v, expected %d, got %d", funv, min, argc);
        if (min >= 0 && argc < min)
            janet_panicf("arity mismatch in %v, expected at least %d, got %d", funv, min, argc);
        janet_panicf("arity mismatch in %v, expected at most %d, got %d", funv, max, argc);
    }
    janet_fiber_frame(janet_vm.fiber)->flags |= JANET_STACKFRAME_ENTRANCE;

    /* Set up */
    int32_t oldn = janet_vm.stackn++;
    int handle = janet_gclock();

    /* Run vm */
    janet_vm.fiber->flags |= JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP;
    JanetSignal signal = run_vm(janet_vm.fiber, janet_wrap_nil());

    /* Teardown */
    janet_vm.stackn = oldn;
    janet_gcunlock(handle);
    if (dirty_stack) {
        janet_fiber_popframe(janet_vm.fiber);
        janet_vm.fiber->stacktop += dirty_stack;
    }

    if (signal != JANET_SIGNAL_OK) {
        janet_panicv(*janet_vm.return_reg);
    }

    return *janet_vm.return_reg;
}

static JanetSignal janet_check_can_resume(JanetFiber *fiber, Janet *out, int is_cancel) {
    /* Check conditions */
    JanetFiberStatus old_status = janet_fiber_status(fiber);
    if (janet_vm.stackn >= JANET_RECURSION_GUARD) {
        janet_fiber_set_status(fiber, JANET_STATUS_ERROR);
        *out = janet_cstringv("C stack recursed too deeply");
        return JANET_SIGNAL_ERROR;
    }
    /* If a "task" fiber is trying to be used as a normal fiber, detect that. See bug #920.
     * Fibers must be marked as root fibers manually, or by the ev scheduler. */
    if (janet_vm.fiber != NULL && (fiber->gc.flags & JANET_FIBER_FLAG_ROOT)) {
#ifdef JANET_EV
        *out = janet_cstringv(is_cancel
                              ? "cannot cancel root fiber, use ev/cancel"
                              : "cannot resume root fiber, use ev/go");
#else
        *out = janet_cstringv(is_cancel
                              ? "cannot cancel root fiber"
                              : "cannot resume root fiber");
#endif
        return JANET_SIGNAL_ERROR;
    }
    if (old_status == JANET_STATUS_ALIVE ||
            old_status == JANET_STATUS_DEAD ||
            (old_status >= JANET_STATUS_USER0 && old_status <= JANET_STATUS_USER4) ||
            old_status == JANET_STATUS_ERROR) {
        const uint8_t *str = janet_formatc("cannot resume fiber with status :%s",
                                           janet_status_names[old_status]);
        *out = janet_wrap_string(str);
        return JANET_SIGNAL_ERROR;
    }
    return JANET_SIGNAL_OK;
}

void janet_try_init(JanetTryState *state) {
    state->stackn = janet_vm.stackn++;
    state->gc_handle = janet_vm.gc_suspend;
    state->vm_fiber = janet_vm.fiber;
    state->vm_jmp_buf = janet_vm.signal_buf;
    state->vm_return_reg = janet_vm.return_reg;
    janet_vm.return_reg = &(state->payload);
    janet_vm.signal_buf = &(state->buf);
}

void janet_restore(JanetTryState *state) {
    janet_vm.stackn = state->stackn;
    janet_vm.gc_suspend = state->gc_handle;
    janet_vm.fiber = state->vm_fiber;
    janet_vm.signal_buf = state->vm_jmp_buf;
    janet_vm.return_reg = state->vm_return_reg;
}

static JanetSignal janet_continue_no_check(JanetFiber *fiber, Janet in, Janet *out) {

    JanetFiberStatus old_status = janet_fiber_status(fiber);

#ifdef JANET_EV
    janet_fiber_did_resume(fiber);
#endif

    /* Clear last value */
    fiber->last_value = janet_wrap_nil();

    /* Continue child fiber if it exists */
    if (fiber->child) {
        if (janet_vm.root_fiber == NULL) janet_vm.root_fiber = fiber;
        JanetFiber *child = fiber->child;
        uint32_t instr = (janet_stack_frame(fiber->data + fiber->frame)->pc)[0];
        janet_vm.stackn++;
        JanetSignal sig = janet_continue(child, in, &in);
        janet_vm.stackn--;
        if (janet_vm.root_fiber == fiber) janet_vm.root_fiber = NULL;
        if (sig != JANET_SIGNAL_OK && !(child->flags & (1 << sig))) {
            *out = in;
            janet_fiber_set_status(fiber, sig);
            return sig;
        }
        /* Check if we need any special handling for certain opcodes */
        switch (instr & 0x7F) {
            default:
                break;
            case JOP_NEXT: {
                if (sig == JANET_SIGNAL_OK ||
                        sig == JANET_SIGNAL_ERROR ||
                        sig == JANET_SIGNAL_USER0 ||
                        sig == JANET_SIGNAL_USER1 ||
                        sig == JANET_SIGNAL_USER2 ||
                        sig == JANET_SIGNAL_USER3 ||
                        sig == JANET_SIGNAL_USER4) {
                    in = janet_wrap_nil();
                } else {
                    in = janet_wrap_integer(0);
                }
                break;
            }
        }
        fiber->child = NULL;
    }

    /* Handle new fibers being resumed with a non-nil value */
    if (old_status == JANET_STATUS_NEW && !janet_checktype(in, JANET_NIL)) {
        Janet *stack = fiber->data + fiber->frame;
        JanetFunction *func = janet_stack_frame(stack)->func;
        if (func) {
            if (func->def->arity > 0) {
                stack[0] = in;
            } else if (func->def->flags & JANET_FUNCDEF_FLAG_VARARG) {
                stack[0] = janet_wrap_tuple(janet_tuple_n(&in, 1));
            }
        }
    }

    /* Save global state */
    JanetTryState tstate;
    JanetSignal sig = janet_try(&tstate);
    if (!sig) {
        /* Normal setup */
        if (janet_vm.root_fiber == NULL) janet_vm.root_fiber = fiber;
        janet_vm.fiber = fiber;
        janet_fiber_set_status(fiber, JANET_STATUS_ALIVE);
        sig = run_vm(fiber, in);
    }

    /* Restore */
    if (janet_vm.root_fiber == fiber) janet_vm.root_fiber = NULL;
    janet_fiber_set_status(fiber, sig);
    janet_restore(&tstate);
    fiber->last_value = tstate.payload;
    *out = tstate.payload;

    return sig;
}

/* Enter the main vm loop */
JanetSignal janet_continue(JanetFiber *fiber, Janet in, Janet *out) {
    /* Check conditions */
    JanetSignal tmp_signal = janet_check_can_resume(fiber, out, 0);
    if (tmp_signal) return tmp_signal;
    return janet_continue_no_check(fiber, in, out);
}

/* Enter the main vm loop but immediately raise a signal */
JanetSignal janet_continue_signal(JanetFiber *fiber, Janet in, Janet *out, JanetSignal sig) {
    JanetSignal tmp_signal = janet_check_can_resume(fiber, out, sig != JANET_SIGNAL_OK);
    if (tmp_signal) return tmp_signal;
    if (sig != JANET_SIGNAL_OK) {
        JanetFiber *child = fiber;
        while (child->child) child = child->child;
        child->gc.flags &= ~JANET_FIBER_STATUS_MASK;
        child->gc.flags |= sig << JANET_FIBER_STATUS_OFFSET;
        child->flags |= JANET_FIBER_RESUME_SIGNAL;
    }
    return janet_continue_no_check(fiber, in, out);
}

JanetSignal janet_pcall(
    JanetFunction *fun,
    int32_t argc,
    const Janet *argv,
    Janet *out,
    JanetFiber **f) {
    JanetFiber *fiber;
    if (f && *f) {
        fiber = janet_fiber_reset(*f, fun, argc, argv);
    } else {
        fiber = janet_fiber(fun, 64, argc, argv);
    }
    if (f) *f = fiber;
    if (!fiber) {
        *out = janet_cstringv("arity mismatch");
        return JANET_SIGNAL_ERROR;
    }
    return janet_continue(fiber, janet_wrap_nil(), out);
}

Janet janet_mcall(const char *name, int32_t argc, Janet *argv) {
    /* At least 1 argument */
    if (argc < 1) {
        janet_panicf("method :%s expected at least 1 argument", name);
    }
    /* Find method */
    Janet method = janet_method_lookup(argv[0], name);
    if (janet_checktype(method, JANET_NIL)) {
        janet_panicf("could not find method :%s for %v", name, argv[0]);
    }
    /* Invoke method */
    return janet_method_invoke(method, argc, argv);
}

/* Setup VM */
int janet_init(void) {

    /* Garbage collection */
    janet_vm.blocks = NULL;
    janet_vm.next_collection = 0;
    janet_vm.gc_interval = 0x400000;
    janet_vm.block_count = 0;

    janet_symcache_init();

    /* Initialize gc roots */
    janet_vm.roots = NULL;
    janet_vm.root_count = 0;
    janet_vm.root_capacity = 0;

    /* Scratch memory */
    janet_vm.user = NULL;
    janet_vm.scratch_mem = NULL;
    janet_vm.scratch_len = 0;
    janet_vm.scratch_cap = 0;

    /* Initialize registry */
    janet_vm.registry = NULL;
    janet_vm.registry_cap = 0;
    janet_vm.registry_count = 0;
    janet_vm.registry_dirty = 0;

    /* Intialize abstract registry */
    janet_vm.abstract_registry = janet_table(0);
    janet_gcroot(janet_wrap_table(janet_vm.abstract_registry));

    /* Traversal */
    janet_vm.traversal = NULL;
    janet_vm.traversal_base = NULL;
    janet_vm.traversal_top = NULL;

    /* Core env */
    janet_vm.core_env = NULL;

    /* Auto suspension */
    janet_vm.auto_suspend = 0;

    /* Dynamic bindings */
    janet_vm.top_dyns = NULL;

    /* Seed RNG */
    janet_rng_seed(janet_default_rng(), 0);

    /* Fibers */
    janet_vm.fiber = NULL;
    janet_vm.root_fiber = NULL;
    janet_vm.stackn = 0;

#ifdef JANET_EV
    janet_ev_init();
#endif
#ifdef JANET_NET
    janet_net_init();
#endif
    return 0;
}

/* Clear all memory associated with the VM */
void janet_deinit(void) {
    janet_clear_memory();
    janet_symcache_deinit();
    janet_free(janet_vm.roots);
    janet_vm.roots = NULL;
    janet_vm.root_count = 0;
    janet_vm.root_capacity = 0;
    janet_vm.abstract_registry = NULL;
    janet_vm.core_env = NULL;
    janet_vm.top_dyns = NULL;
    janet_vm.user = NULL;
    janet_free(janet_vm.traversal_base);
    janet_vm.fiber = NULL;
    janet_vm.root_fiber = NULL;
    janet_free(janet_vm.registry);
    janet_vm.registry = NULL;
#ifdef JANET_EV
    janet_ev_deinit();
#endif
#ifdef JANET_NET
    janet_net_deinit();
#endif
}


/* src/core/wrap.c */
#line 0 "src/core/wrap.c"

/*
* Copyright (c) 2023 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include <math.h>
#include "util.h"
#include "state.h"
#endif

/* Macro fills */

JanetType(janet_type)(Janet x) {
    return janet_type(x);
}
int (janet_checktype)(Janet x, JanetType type) {
    return janet_checktype(x, type);
}
int (janet_checktypes)(Janet x, int typeflags) {
    return janet_checktypes(x, typeflags);
}
int (janet_truthy)(Janet x) {
    return janet_truthy(x);
}

const JanetKV *(janet_unwrap_struct)(Janet x) {
    return janet_unwrap_struct(x);
}
const Janet *(janet_unwrap_tuple)(Janet x) {
    return janet_unwrap_tuple(x);
}
JanetFiber *(janet_unwrap_fiber)(Janet x) {
    return janet_unwrap_fiber(x);
}
JanetArray *(janet_unwrap_array)(Janet x) {
    return janet_unwrap_array(x);
}
JanetTable *(janet_unwrap_table)(Janet x) {
    return janet_unwrap_table(x);
}
JanetBuffer *(janet_unwrap_buffer)(Janet x) {
    return janet_unwrap_buffer(x);
}
const uint8_t *(janet_unwrap_string)(Janet x) {
    return janet_unwrap_string(x);
}
const uint8_t *(janet_unwrap_symbol)(Janet x) {
    return janet_unwrap_symbol(x);
}
const uint8_t *(janet_unwrap_keyword)(Janet x) {
    return janet_unwrap_keyword(x);
}
void *(janet_unwrap_abstract)(Janet x) {
    return janet_unwrap_abstract(x);
}
void *(janet_unwrap_pointer)(Janet x) {
    return janet_unwrap_pointer(x);
}
JanetFunction *(janet_unwrap_function)(Janet x) {
    return janet_unwrap_function(x);
}
JanetCFunction(janet_unwrap_cfunction)(Janet x) {
    return janet_unwrap_cfunction(x);
}
int (janet_unwrap_boolean)(Janet x) {
    return janet_unwrap_boolean(x);
}
int32_t (janet_unwrap_integer)(Janet x) {
    return janet_unwrap_integer(x);
}

#if defined(JANET_NANBOX_32) || defined(JANET_NANBOX_64)
Janet(janet_wrap_nil)(void) {
    return janet_wrap_nil();
}
Janet(janet_wrap_true)(void) {
    return janet_wrap_true();
}
Janet(janet_wrap_false)(void) {
    return janet_wrap_false();
}
Janet(janet_wrap_boolean)(int x) {
    return janet_wrap_boolean(x);
}
Janet(janet_wrap_string)(const uint8_t *x) {
    return janet_wrap_string(x);
}
Janet(janet_wrap_symbol)(const uint8_t *x) {
    return janet_wrap_symbol(x);
}
Janet(janet_wrap_keyword)(const uint8_t *x) {
    return janet_wrap_keyword(x);
}
Janet(janet_wrap_array)(JanetArray *x) {
    return janet_wrap_array(x);
}
Janet(janet_wrap_tuple)(const Janet *x) {
    return janet_wrap_tuple(x);
}
Janet(janet_wrap_struct)(const JanetKV *x) {
    return janet_wrap_struct(x);
}
Janet(janet_wrap_fiber)(JanetFiber *x) {
    return janet_wrap_fiber(x);
}
Janet(janet_wrap_buffer)(JanetBuffer *x) {
    return janet_wrap_buffer(x);
}
Janet(janet_wrap_function)(JanetFunction *x) {
    return janet_wrap_function(x);
}
Janet(janet_wrap_cfunction)(JanetCFunction x) {
    return janet_wrap_cfunction(x);
}
Janet(janet_wrap_table)(JanetTable *x) {
    return janet_wrap_table(x);
}
Janet(janet_wrap_abstract)(void *x) {
    return janet_wrap_abstract(x);
}
Janet(janet_wrap_pointer)(void *x) {
    return janet_wrap_pointer(x);
}
Janet(janet_wrap_integer)(int32_t x) {
    return janet_wrap_integer(x);
}
#endif

#ifndef JANET_NANBOX_32
double (janet_unwrap_number)(Janet x) {
    return janet_unwrap_number(x);
}
#endif

#ifdef JANET_NANBOX_64
Janet(janet_wrap_number)(double x) {
    return janet_wrap_number(x);
}
#endif

/*****/

void *janet_memalloc_empty(int32_t count) {
    int32_t i;
    void *mem = janet_malloc((size_t) count * sizeof(JanetKV));
    janet_vm.next_collection += (size_t) count * sizeof(JanetKV);
    if (NULL == mem) {
        JANET_OUT_OF_MEMORY;
    }
    JanetKV *mmem = (JanetKV *)mem;
    for (i = 0; i < count; i++) {
        JanetKV *kv = mmem + i;
        kv->key = janet_wrap_nil();
        kv->value = janet_wrap_nil();
    }
    return mem;
}

void janet_memempty(JanetKV *mem, int32_t count) {
    int32_t i;
    for (i = 0; i < count; i++) {
        mem[i].key = janet_wrap_nil();
        mem[i].value = janet_wrap_nil();
    }
}

#ifdef JANET_NANBOX_64

Janet janet_wrap_number_safe(double d) {
    Janet ret;
    ret.number = isnan(d) ? NAN : d;
    return ret;
}

void *janet_nanbox_to_pointer(Janet x) {
    x.i64 &= JANET_NANBOX_PAYLOADBITS;
    return x.pointer;
}

Janet janet_nanbox_from_pointer(void *p, uint64_t tagmask) {
    Janet ret;
    ret.pointer = p;
    ret.u64 |= tagmask;
    return ret;
}

Janet janet_nanbox_from_cpointer(const void *p, uint64_t tagmask) {
    Janet ret;
    ret.pointer = (void *)p;
    ret.u64 |= tagmask;
    return ret;
}

Janet janet_nanbox_from_double(double d) {
    Janet ret;
    ret.number = d;
    return ret;
}

Janet janet_nanbox_from_bits(uint64_t bits) {
    Janet ret;
    ret.u64 = bits;
    return ret;
}

#elif defined(JANET_NANBOX_32)

Janet janet_wrap_number(double x) {
    Janet ret;
    ret.number = x;
    ret.tagged.type += JANET_DOUBLE_OFFSET;
    return ret;
}

Janet janet_wrap_number_safe(double d) {
    double x = isnan(d) ? NAN : d;
    return janet_wrap_number(x);
}

Janet janet_nanbox32_from_tagi(uint32_t tag, int32_t integer) {
    Janet ret;
    ret.tagged.type = tag;
    ret.tagged.payload.integer = integer;
    return ret;
}

Janet janet_nanbox32_from_tagp(uint32_t tag, void *pointer) {
    Janet ret;
    ret.tagged.type = tag;
    ret.tagged.payload.pointer = pointer;
    return ret;
}

double janet_unwrap_number(Janet x) {
    x.tagged.type -= JANET_DOUBLE_OFFSET;
    return x.number;
}

#else

Janet janet_wrap_number_safe(double d) {
    return janet_wrap_number(d);
}

Janet janet_wrap_nil(void) {
    Janet y;
    y.type = JANET_NIL;
    y.as.u64 = 0;
    return y;
}

Janet janet_wrap_true(void) {
    Janet y;
    y.type = JANET_BOOLEAN;
    y.as.u64 = 1;
    return y;
}

Janet janet_wrap_false(void) {
    Janet y;
    y.type = JANET_BOOLEAN;
    y.as.u64 = 0;
    return y;
}

Janet janet_wrap_boolean(int x) {
    Janet y;
    y.type = JANET_BOOLEAN;
    y.as.u64 = !!x;
    return y;
}

#define JANET_WRAP_DEFINE(NAME, TYPE, DTYPE, UM)\
Janet janet_wrap_##NAME(TYPE x) {\
    Janet y;\
    y.type = DTYPE;\
    y.as.u64 = 0; /* zero other bits in case of 32 bit integer */ \
    y.as.UM = x;\
    return y;\
}

JANET_WRAP_DEFINE(number, double, JANET_NUMBER, number)
JANET_WRAP_DEFINE(string, const uint8_t *, JANET_STRING, cpointer)
JANET_WRAP_DEFINE(symbol, const uint8_t *, JANET_SYMBOL, cpointer)
JANET_WRAP_DEFINE(keyword, const uint8_t *, JANET_KEYWORD, cpointer)
JANET_WRAP_DEFINE(array, JanetArray *, JANET_ARRAY, pointer)
JANET_WRAP_DEFINE(tuple, const Janet *, JANET_TUPLE, cpointer)
JANET_WRAP_DEFINE(struct, const JanetKV *, JANET_STRUCT, cpointer)
JANET_WRAP_DEFINE(fiber, JanetFiber *, JANET_FIBER, pointer)
JANET_WRAP_DEFINE(buffer, JanetBuffer *, JANET_BUFFER, pointer)
JANET_WRAP_DEFINE(function, JanetFunction *, JANET_FUNCTION, pointer)
JANET_WRAP_DEFINE(cfunction, JanetCFunction, JANET_CFUNCTION, pointer)
JANET_WRAP_DEFINE(table, JanetTable *, JANET_TABLE, pointer)
JANET_WRAP_DEFINE(abstract, void *, JANET_ABSTRACT, pointer)
JANET_WRAP_DEFINE(pointer, void *, JANET_POINTER, pointer)

#undef JANET_WRAP_DEFINE

#endif


static const unsigned char janet_core_image_bytes[] = {
  0xD3, 0x82, 0x6C, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x63, 0x6C, 0x6F, 0x63, 0x6B, 0xD3, 0x03, 0xD0, 
  0x0A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2D, 0x6D, 0x61, 0x70, 0xD2, 0x03, 0x00, 0xCE, 0x0D, 
  0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x6F, 0x73, 0x2E, 0x63, 0x84, 0xD6, 0x01, 
  0xD0, 0x05, 0x76, 0x61, 0x6C, 0x75, 0x65, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x63, 0x6C, 0x6F, 0x63, 
  0x6B, 0xD0, 0x03, 0x64, 0x6F, 0x63, 0xCE, 0x80, 0x96, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x6C, 0x6F, 
  0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x77, 0x68, 0x6F, 0x6C, 0x65, 0x20, 
  0x2B, 0x20, 0x66, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x65, 0x63, 
  0x6F, 0x6E, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6E, 0x63, 0x65, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 
  0x66, 0x69, 0x78, 0x65, 0x64, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 
  0x69, 0x6D, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x69, 
  0x73, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6E, 0x74, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 
  0x62, 0x65, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x64, 0x65, 0x63, 0x72, 0x65, 0x61, 0x73, 0x69, 0x6E, 
  0x67, 0x20, 0x69, 0x6E, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0xCF, 
  0x08, 0x66, 0x66, 0x69, 0x2F, 0x72, 0x65, 0x61, 0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xCE, 0x0E, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x66, 0x66, 0x69, 0x2E, 0x63, 
  0x85, 0x6A, 0x01, 0xDA, 0x06, 0xD8, 0x08, 0x66, 0x66, 0x69, 0x2F, 0x72, 0x65, 0x61, 0x64, 0xDA, 
  0x08, 0xCE, 0x80, 0xE5, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x66, 
  0x69, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x29, 0x0A, 0x0A, 0x50, 0x61, 0x72, 0x73, 0x65, 
  0x20, 0x61, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x20, 0x6F, 0x75, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 0x69, 0x74, 0x20, 
  0x74, 0x6F, 0x20, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x20, 0x4A, 0x61, 0x6E, 0x65, 0x74, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x73, 0x2E, 
  0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x60, 0x66, 0x66, 0x69, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0x60, 0x2E, 0x20, 0x60, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 
  0x65, 0x20, 0x61, 0x20, 0x72, 0x61, 0x77, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x2C, 
  0x20, 0x61, 0x6C, 0x74, 0x68, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 
  0x73, 0x20, 0x75, 0x6E, 0x73, 0x61, 0x66, 0x65, 0x2E, 0xCF, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x77, 
  0x72, 0x69, 0x74, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x0E, 0x73, 0x72, 0x63, 
  0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x6E, 0x65, 0x74, 0x2E, 0x63, 0x83, 0x33, 0x01, 0xDA, 0x06, 
  0xD8, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0xDA, 0x08, 0xCE, 0x80, 0xED, 
  0x28, 0x6E, 0x65, 0x74, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 
  0x6D, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x6F, 0x75, 0x74, 0x29, 0x0A, 0x0A, 0x57, 0x72, 0x69, 0x74, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 
  0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2C, 0x20, 0x73, 0x75, 
  0x73, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 
  0x65, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 
  0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x20, 
  0x69, 0x6E, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x2C, 0x20, 0x61, 0x66, 0x74, 0x65, 
  0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x73, 0x20, 
  0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0xCF, 0x06, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x3F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x0A, 0x62, 0x6F, 
  0x6F, 0x74, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x72, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x05, 0x17, 0xCE, 0x06, 0x62, 0x79, 0x74, 0x65, 0x73, 
  0x3F, 0xDA, 0x18, 0xD8, 0x04, 0x74, 0x79, 0x70, 0x65, 0xD0, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0xD0, 0x06, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0xD0, 0x07, 0x6B, 0x65, 0x79, 0x77, 0x6F, 
  0x72, 0x64, 0xD0, 0x06, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x05, 
  0x01, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x03, 0x00, 0x27, 0x05, 0x00, 0x00, 0x03, 0x05, 
  0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 0x05, 0x03, 0x06, 0x1C, 0x05, 0x03, 0x00, 0x27, 0x06, 
  0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x23, 0x06, 0x03, 0x07, 0x1C, 0x06, 
  0x03, 0x00, 0x27, 0x07, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x23, 0x07, 
  0x03, 0x08, 0x03, 0x07, 0x00, 0x00, 0x72, 0x01, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 
  0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1A, 
  0x00, 0x1A, 0x00, 0x1A, 0x00, 0x35, 0x00, 0x35, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x49, 
  0x00, 0x49, 0x00, 0x49, 0xDA, 0x08, 0xCE, 0x3F, 0x28, 0x62, 0x79, 0x74, 0x65, 0x73, 0x3F, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x73, 0x79, 0x6D, 0x62, 
  0x6F, 0x6C, 0x2C, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2C, 0x20, 0x6F, 0x72, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xCF, 0x02, 0x2B, 0x3D, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x80, 0x98, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x06, 0x02, 0x02, 0x02, 0x02, 0x08, 0xCE, 0x02, 0x2B, 0x3D, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 
  0x09, 0x00, 0x09, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x01, 0x2B, 
  0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x00, 0x00, 
  0x3B, 0x04, 0x00, 0x00, 0x06, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 
  0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x06, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 
  0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x03, 0x73, 0x65, 
  0x74, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x04, 0x00, 0x01, 0x43, 0x03, 0x00, 
  0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 
  0x00, 0x80, 0x98, 0x01, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 
  0x00, 0x31, 0xDA, 0x08, 0xCE, 0x24, 0x28, 0x2B, 0x3D, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 
  0x49, 0x6E, 0x63, 0x72, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 
  0x61, 0x72, 0x20, 0x78, 0x20, 0x62, 0x79, 0x20, 0x6E, 0x2E, 0xD0, 0x05, 0x6D, 0x61, 0x63, 0x72, 
  0x6F, 0xCB, 0xCF, 0x0F, 0x65, 0x76, 0x2F, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2D, 0x6C, 
  0x6F, 0x63, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x0D, 0x73, 0x72, 0x63, 0x2F, 
  0x63, 0x6F, 0x72, 0x65, 0x2F, 0x65, 0x76, 0x2E, 0x63, 0x8C, 0x1B, 0x01, 0xDA, 0x06, 0xD8, 0x0F, 
  0x65, 0x76, 0x2F, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2D, 0x6C, 0x6F, 0x63, 0x6B, 0xDA, 
  0x08, 0xCE, 0x80, 0xFD, 0x28, 0x65, 0x76, 0x2F, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2D, 
  0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x41, 0x63, 0x71, 0x75, 
  0x69, 0x72, 0x65, 0x20, 0x61, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 
  0x69, 0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 
  0x64, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x74, 0x68, 
  0x72, 0x65, 0x61, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 
  0x65, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x6C, 0x6F, 
  0x63, 0x6B, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x65, 0x6E, 0x74, 0x69, 0x72, 0x65, 0x20, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x62, 0x65, 0x63, 0x6F, 0x6D, 0x65, 0x73, 0x20, 0x61, 0x76, 0x61, 
  0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x6E, 0x6F, 0x74, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6F, 0x74, 
  0x68, 0x65, 0x72, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 
  0x69, 0x73, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 
  0x2E, 0xCF, 0x0A, 0x6E, 0x65, 0x74, 0x2F, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8E, 0x1A, 0x03, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 
  0x00, 0x00, 0x0A, 0x04, 0x02, 0x04, 0x02, 0x0C, 0x01, 0xCE, 0x0A, 0x6E, 0x65, 0x74, 0x2F, 0x73, 
  0x65, 0x72, 0x76, 0x65, 0x72, 0xDA, 0x18, 0xD8, 0x0A, 0x6E, 0x65, 0x74, 0x2F, 0x6C, 0x69, 0x73, 
  0x74, 0x65, 0x6E, 0xD7, 0x00, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x05, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x01, 0x05, 0x01, 0xCE, 0x07, 0x65, 0x76, 0x2F, 0x63, 0x61, 0x6C, 0x6C, 0xDA, 0x18, 
  0xD8, 0x05, 0x65, 0x76, 0x2F, 0x67, 0x6F, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x2F, 
  0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 
  0x02, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x05, 0x01, 0xCE, 0x05, 0x5F, 0x63, 0x61, 
  0x6C, 0x6C, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x01, 0x32, 0x01, 0x00, 0x00, 
  0x2B, 0x01, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x8D, 0xE7, 0x0C, 0x00, 0x1A, 0x00, 
  0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x8D, 0xE1, 0x03, 0x06, 0x0C, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x03, 0x00, 0x00, 0x00, 0x2C, 0x04, 0x00, 0x00, 0x31, 0x00, 0x01, 0x03, 0x2A, 0x06, 0x00, 0x00, 
  0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1C, 0x02, 0x06, 0x00, 0x2E, 0x07, 0x00, 0x00, 
  0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x33, 0x08, 0x09, 0x00, 0x1A, 0x01, 0x00, 0x00, 
  0x03, 0x06, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x05, 0x01, 
  0xDA, 0x18, 0xD8, 0x0F, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2D, 0x6C, 
  0x6F, 0x6F, 0x70, 0x2B, 0x00, 0x00, 0x06, 0x2B, 0x01, 0x00, 0x02, 0x30, 0x00, 0x01, 0x00, 0x2A, 
  0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8E, 0x1F, 0x17, 0x00, 0x17, 0x00, 0x17, 
  0x00, 0x17, 0x00, 0x17, 0x8E, 0x1A, 0x03, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 
  0x05, 0x01, 0x10, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0xBF, 0xFC, 0x03, 0x44, 
  0x00, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x80, 0x8F, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x73, 0x65, 0x72, 
  0x76, 0x65, 0x72, 0x20, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x20, 0x74, 0x79, 0x70, 0x65, 0x29, 
  0x0A, 0x0A, 0x53, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 
  0x20, 0x61, 0x73, 0x79, 0x6E, 0x63, 0x68, 0x72, 0x6F, 0x6E, 0x6F, 0x75, 0x73, 0x6C, 0x79, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x6E, 0x65, 0x74, 0x2F, 0x6C, 0x69, 0x73, 0x74, 0x65, 0x6E, 
  0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x63, 0x63, 0x65, 0x70, 
  0x74, 0x2D, 0x6C, 0x6F, 0x6F, 0x70, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 
  0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0xCF, 0x06, 0x61, 0x73, 0x73, 0x65, 0x72, 0x74, 0xD3, 
  0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0x9E, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x09, 0x02, 0x01, 0x02, 0x07, 0x1A, 0xCE, 0x06, 0x61, 0x73, 0x73, 0x65, 
  0x72, 0x74, 0xDA, 0x18, 0xD8, 0x06, 0x67, 0x65, 0x6E, 0x73, 0x79, 0x6D, 0xCF, 0x03, 0x64, 0x65, 
  0x66, 0xCE, 0x14, 0x61, 0x73, 0x73, 0x65, 0x72, 0x74, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 
  0x65, 0x20, 0x69, 0x6E, 0x20, 0x25, 0x6A, 0xD8, 0x0D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x02, 0x01, 0x01, 0x01, 
  0x01, 0x00, 0x01, 0xCE, 0x05, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x01, 0x00, 0x00, 0x00, 0xCF, 0x02, 
  0x69, 0x66, 0xCF, 0x02, 0x64, 0x6F, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x31, 0x06, 0x04, 0x00, 0x43, 0x05, 
  0x00, 0x00, 0x1C, 0x01, 0x03, 0x00, 0x19, 0x06, 0x01, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 0x07, 
  0x02, 0x00, 0x30, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x06, 
  0x07, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x30, 0x08, 0x06, 0x00, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x08, 
  0x05, 0x00, 0x31, 0x08, 0x04, 0x04, 0x2F, 0x07, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x08, 
  0x06, 0x00, 0x31, 0x08, 0x05, 0x06, 0x43, 0x07, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x80, 0x9E, 
  0x01, 0x03, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x04, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x11, 0xBF, 0xFC, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x5F, 0x28, 0x61, 0x73, 0x73, 0x65, 0x72, 0x74, 0x20, 
  0x78, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x72, 0x72, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 
  0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x78, 
  0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2E, 0x20, 
  0x57, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 
  0x65, 0x20, 0x60, 0x65, 0x72, 0x72, 0x60, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 
  0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x0C, 0x6D, 0x6F, 0x64, 0x75, 
  0x6C, 0x65, 0x2F, 0x76, 0x61, 0x6C, 0x75, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x8A, 0xB3, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x03, 0x02, 
  0x03, 0x04, 0x1F, 0xCE, 0x0C, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0xDA, 0x18, 0xDA, 0x06, 0xD0, 0x03, 0x72, 0x65, 0x66, 0xD0, 0x07, 0x70, 0x72, 0x69, 0x76, 
  0x61, 0x74, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 
  0xCE, 0x06, 0x61, 0x72, 0x72, 0x61, 0x79, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xD0, 0x05, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x6F, 
  0x01, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x2C, 0x03, 0x00, 
  0x00, 0x39, 0x04, 0x00, 0x01, 0x19, 0x05, 0x04, 0x00, 0x1C, 0x05, 0x1B, 0x00, 0x2A, 0x07, 0x00, 
  0x00, 0x38, 0x06, 0x05, 0x07, 0x19, 0x07, 0x06, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x38, 0x06, 0x05, 
  0x08, 0x19, 0x08, 0x06, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x38, 0x06, 0x05, 0x09, 0x19, 0x09, 0x06, 
  0x00, 0x1C, 0x09, 0x05, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0x1A, 0x01, 0x00, 0x00, 0x1C, 0x08, 0x06, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0B, 0x03, 
  0x00, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x06, 0x0A, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x06, 0x08, 
  0x00, 0x1C, 0x06, 0x04, 0x00, 0x29, 0x0B, 0x00, 0x00, 0x39, 0x0A, 0x08, 0x0B, 0x03, 0x0A, 0x00, 
  0x00, 0x03, 0x07, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8A, 0xB3, 0x01, 0x05, 0x0E, 0x00, 0x03, 
  0x01, 0x03, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x05, 0x01, 0x0D, 0x00, 0x0D, 0xBF, 0xFF, 0x05, 0x02, 
  0x0D, 0x00, 0x0D, 0xBF, 0xFE, 0x05, 0x03, 0x07, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x1D, 0x00, 0x07, 
  0x01, 0x0B, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x07, 
  0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0xBF, 0xFB, 0x03, 0xDA, 0x08, 0xCE, 0x80, 
  0xCF, 0x28, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6D, 
  0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x73, 0x79, 0x6D, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 
  0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 
  0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x67, 
  0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x62, 0x6F, 0x75, 
  0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x60, 
  0x73, 0x79, 0x6D, 0x60, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 
  0x65, 0x60, 0x20, 0x69, 0x73, 0x0A, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x20, 
  0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x73, 
  0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x0A, 0x6E, 0x69, 0x6C, 0x2E, 
  0xCF, 0x0D, 0x66, 0x66, 0x69, 0x2F, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 0x82, 0xFF, 0x01, 0xDA, 0x06, 0xD8, 0x0D, 0x66, 
  0x66, 0x69, 0x2F, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0xDA, 0x08, 0xCE, 0x80, 
  0x96, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 
  0x63, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x2D, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x6E, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x72, 0x65, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x20, 0x26, 0x20, 0x61, 0x72, 
  0x67, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 
  0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x69, 0x67, 0x6E, 
  0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x72, 0x61, 0x77, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x70, 0x6F, 
  0x69, 0x6E, 0x74, 0x65, 0x72, 0x73, 0x2E, 0xCF, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x66, 0x6C, 0x75, 
  0x73, 0x68, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 0x83, 0x5B, 0x01, 0xDA, 0x06, 
  0xD8, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xDA, 0x08, 0xCE, 0x80, 0xB5, 
  0x28, 0x6E, 0x65, 0x74, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 
  0x6D, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x6B, 0x65, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x79, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x74, 0x65, 0x6D, 0x70, 
  0x6F, 0x72, 0x61, 0x72, 0x69, 0x6C, 0x79, 0x20, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x73, 
  0x20, 0x4E, 0x61, 0x67, 0x6C, 0x65, 0x27, 0x73, 0x20, 0x61, 0x6C, 0x67, 0x6F, 0x72, 0x69, 0x74, 
  0x68, 0x6D, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x6D, 0x61, 0x6B, 0x65, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x69, 
  0x73, 0x20, 0x73, 0x65, 0x6E, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x64, 
  0x65, 0x6C, 0x61, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x73, 0x74, 
  0x72, 0x65, 0x61, 0x6D, 0x2E, 0xCF, 0x03, 0x69, 0x6E, 0x63, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x80, 0x94, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 
  0x01, 0x01, 0x01, 0x00, 0x03, 0xCE, 0x03, 0x69, 0x6E, 0x63, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 
  0x05, 0x02, 0x00, 0x01, 0x03, 0x02, 0x00, 0x00, 0x80, 0x94, 0x01, 0x00, 0x20, 0x00, 0x20, 0xDA, 
  0x08, 0xCE, 0x17, 0x28, 0x69, 0x6E, 0x63, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x78, 0x20, 0x2B, 0x20, 0x31, 0x2E, 0xCF, 0x06, 0x69, 0x66, 0x2D, 0x6C, 
  0x65, 0x74, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x92, 0x01, 0xDA, 0x06, 
  0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x09, 0x03, 0x02, 0x03, 0x03, 0x15, 0x01, 0xCE, 0x06, 
  0x69, 0x66, 0x2D, 0x6C, 0x65, 0x74, 0xDA, 0x18, 0xCE, 0x1B, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 
  0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x6C, 0x65, 0x61, 0x73, 0x74, 0x20, 0x31, 0x20, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 
  0x00, 0x06, 0xCE, 0x04, 0x6F, 0x64, 0x64, 0x3F, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 
  0x02, 0x00, 0x0C, 0x02, 0x00, 0x03, 0x29, 0x04, 0x01, 0x00, 0x23, 0x03, 0x04, 0x02, 0x03, 0x03, 
  0x00, 0x00, 0x80, 0x82, 0x01, 0x00, 0x15, 0x00, 0x15, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xCE, 
  0x23, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x76, 0x65, 
  0x6E, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x69, 0x6E, 0x64, 
  0x69, 0x6E, 0x67, 0x73, 0x2C, 0x03, 0x00, 0x00, 0x3D, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 
  0x29, 0x07, 0x00, 0x00, 0x23, 0x06, 0x07, 0x05, 0x1C, 0x06, 0x04, 0x00, 0x2A, 0x07, 0x00, 0x00, 
  0x01, 0x07, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 
  0x33, 0x06, 0x07, 0x00, 0x1C, 0x06, 0x04, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x01, 0x07, 0x00, 0x00, 
  0x1A, 0x01, 0x00, 0x00, 0x2E, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x29, 0x08, 0x00, 0x00, 
  0x2F, 0x08, 0x00, 0x00, 0x34, 0x07, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0C, 0x01, 0x01, 
  0x01, 0x06, 0x46, 0x01, 0xCE, 0x03, 0x61, 0x75, 0x78, 0xDA, 0x18, 0xD7, 0x01, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x09, 0x01, 0xCE, 0x0B, 0x69, 0x64, 0x65, 0x6D, 0x70, 
  0x6F, 0x74, 0x65, 0x6E, 0x74, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xD8, 0x03, 0x6E, 0x6F, 0x74, 0x2C, 
  0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2B, 
  0x04, 0x00, 0x00, 0x38, 0x03, 0x04, 0x02, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 
  0x02, 0x00, 0x00, 0xBF, 0xFF, 0x80, 0x91, 0x05, 0x00, 0x33, 0x00, 0x33, 0x00, 0x33, 0x00, 0x1E, 
  0x00, 0x1E, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x04, 0xD5, 0x05, 0xDA, 0x20, 0xCB, 0xDA, 
  0x55, 0xCB, 0xD0, 0x06, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0xCB, 0xD0, 0x05, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0xCB, 0xD0, 0x05, 0x74, 0x75, 0x70, 0x6C, 0x65, 0xCB, 0xC9, 0xC9, 0xC9, 0xDA, 0x43, 
  0xDA, 0x44, 0xD8, 0x05, 0x74, 0x75, 0x70, 0x6C, 0x65, 0xDA, 0x49, 0xDA, 0x4A, 0x2C, 0x01, 0x00, 
  0x00, 0x2B, 0x03, 0x00, 0x05, 0x45, 0x02, 0x00, 0x03, 0x1C, 0x02, 0x03, 0x00, 0x2B, 0x03, 0x00, 
  0x01, 0x03, 0x03, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x38, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x29, 0x05, 0x01, 0x00, 0x06, 0x03, 0x05, 0x00, 0x2B, 0x06, 0x00, 0x00, 0x38, 0x05, 0x06, 
  0x03, 0x19, 0x03, 0x05, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 
  0x00, 0x19, 0x06, 0x05, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x1A, 0x04, 0x00, 
  0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x05, 0x07, 0x00, 0x19, 0x07, 0x05, 
  0x00, 0x1C, 0x06, 0x13, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 0x05, 0x07, 0x03, 0x2A, 0x08, 0x03, 
  0x00, 0x33, 0x05, 0x08, 0x00, 0x29, 0x09, 0x02, 0x00, 0x06, 0x08, 0x09, 0x00, 0x2F, 0x08, 0x00, 
  0x00, 0x33, 0x09, 0x01, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x08, 0x07, 0x09, 0x2B, 0x08, 0x00, 
  0x02, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x2A, 0x09, 0x05, 
  0x00, 0x31, 0x09, 0x05, 0x08, 0x2A, 0x09, 0x03, 0x00, 0x34, 0x09, 0x00, 0x00, 0x2A, 0x05, 0x02, 
  0x00, 0x31, 0x05, 0x07, 0x03, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x05, 0x08, 0x00, 0x2A, 0x08, 0x02, 
  0x00, 0x31, 0x08, 0x04, 0x07, 0x2A, 0x09, 0x03, 0x00, 0x33, 0x08, 0x09, 0x00, 0x29, 0x0A, 0x02, 
  0x00, 0x06, 0x09, 0x0A, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x33, 0x0A, 0x01, 0x00, 0x2A, 0x09, 0x05, 
  0x00, 0x31, 0x09, 0x08, 0x0A, 0x2A, 0x0B, 0x03, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x2A, 0x08, 0x04, 
  0x00, 0x31, 0x08, 0x07, 0x09, 0x2B, 0x08, 0x00, 0x02, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x03, 
  0x00, 0x33, 0x08, 0x0A, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x31, 0x09, 0x05, 0x08, 0x2A, 0x09, 0x03, 
  0x00, 0x34, 0x09, 0x00, 0x00, 0xBF, 0xFF, 0x82, 0x9A, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x03, 0x11, 0x00, 0x11, 0x00, 0x09, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x11, 
  0x00, 0x11, 0x00, 0x09, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x09, 0x01, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x12, 0x00, 0x09, 0x01, 0x09, 0x03, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x01, 0x26, 0x00, 0x26, 0x00, 0x21, 0x00, 0x21, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFE, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x05, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x03, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 
  0x20, 0x01, 0x25, 0x00, 0x25, 0x00, 0x20, 0x00, 0x20, 0xBF, 0xFE, 0x19, 0x00, 0x19, 0x00, 0x19, 
  0x00, 0x19, 0xBF, 0xFF, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 
  0xFE, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x82, 0x92, 0x01, 0x05, 0x0C, 0x00, 0x03, 0x01, 
  0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x03, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x15, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x27, 0x00, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x80, 0xCB, 0x28, 0x69, 0x66, 0x2D, 
  0x6C, 0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x74, 0x72, 0x75, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x66, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x6B, 0x65, 
  0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x0A, 0x65, 0x76, 0x61, 0x6C, 0x75, 
  0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x74, 0x72, 0x75, 0x60, 0x20, 0x66, 0x6F, 
  0x72, 0x6D, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 
  0x61, 0x6C, 0x73, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x65, 0x76, 0x61, 
  0x6C, 0x75, 0x61, 0x74, 0x65, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x60, 0x66, 0x61, 0x6C, 0x60, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x2E, 0x20, 0x42, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x68, 
  0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x73, 0x79, 0x6E, 
  0x74, 0x61, 0x78, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x6C, 0x65, 0x74, 0x60, 
  0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x06, 0x63, 0x61, 0x6E, 0x63, 
  0x65, 0x6C, 0xD3, 0x02, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x20, 0x02, 0x02, 0x02, 
  0x02, 0x00, 0x02, 0xCE, 0x06, 0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x4A, 0x00, 0x00, 0x01, 0x03, 
  0x00, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x80, 0x9C, 0x28, 0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x65, 0x72, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x73, 0x75, 
  0x6D, 0x65, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x62, 0x75, 0x74, 0x20, 0x68, 
  0x61, 0x76, 0x65, 0x20, 0x69, 0x74, 0x20, 0x69, 0x6D, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 
  0x6C, 0x79, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6C, 0x65, 0x74, 0x73, 0x20, 0x61, 0x20, 0x70, 
  0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x65, 0x72, 0x20, 0x75, 0x6E, 0x77, 0x69, 0x6E, 0x64, 
  0x20, 0x61, 0x20, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 
  0x6D, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x61, 0x73, 0x20, 0x72, 0x65, 0x73, 
  0x75, 0x6D, 0x65, 0x2E, 0xCF, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xCE, 0x12, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x63, 
  0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x2E, 0x63, 0x83, 0xEE, 0x01, 0xDA, 0x06, 0xD8, 0x07, 0x63, 
  0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0xDA, 0x08, 0xCE, 0x81, 0xB9, 0x28, 0x63, 0x6F, 0x6D, 0x70, 
  0x69, 0x6C, 0x65, 0x20, 0x61, 0x73, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x6E, 0x76, 
  0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6C, 0x69, 0x6E, 0x74, 0x73, 0x29, 0x0A, 0x0A, 
  0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x41, 0x62, 0x73, 0x74, 
  0x72, 0x61, 0x63, 0x74, 0x20, 0x53, 0x79, 0x6E, 0x74, 0x61, 0x78, 0x20, 0x54, 0x72, 0x65, 0x65, 
  0x20, 0x28, 0x61, 0x73, 0x74, 0x29, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x50, 0x61, 0x69, 0x72, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20, 0x74, 0x6F, 0x20, 
  0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x79, 0x20, 0x61, 0x73, 0x74, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6B, 0x65, 0x79, 
  0x73, 0x20, 0x3A, 0x6C, 0x69, 0x6E, 0x65, 0x2C, 0x20, 0x3A, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x61, 0x69, 0x6C, 
  0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x60, 0x6C, 0x69, 0x6E, 0x74, 0x73, 0x60, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x2C, 0x20, 
  0x6C, 0x69, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x65, 
  0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 
  0x45, 0x61, 0x63, 0x68, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x60, 0x28, 0x6C, 0x65, 0x76, 0x65, 0x6C, 
  0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 
  0x65, 0x29, 0x60, 0x2E, 0xCF, 0x12, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 
  0x73, 0x2D, 0x75, 0x6E, 0x70, 0x61, 0x63, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x12, 0x82, 0xDC, 0x01, 0xDA, 0x06, 0xD8, 0x12, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x64, 0x64, 0x72, 
  0x65, 0x73, 0x73, 0x2D, 0x75, 0x6E, 0x70, 0x61, 0x63, 0x6B, 0xDA, 0x08, 0xCE, 0x80, 0xA3, 0x28, 
  0x6E, 0x65, 0x74, 0x2F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2D, 0x75, 0x6E, 0x70, 0x61, 
  0x63, 0x6B, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 
  0x65, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x64, 
  0x72, 0x65, 0x73, 0x73, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x68, 
  0x6F, 0x73, 0x74, 0x2C, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x70, 0x61, 0x69, 0x72, 0x2E, 0x20, 
  0x55, 0x6E, 0x69, 0x78, 0x20, 0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E, 0x20, 0x73, 0x6F, 0x63, 0x6B, 
  0x65, 0x74, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6F, 0x6E, 
  0x6C, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 
  0x65, 0x2E, 0xCF, 0x06, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x66, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x80, 0xA8, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 
  0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x07, 0xCE, 0x06, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x66, 0xDA, 0x18, 0xDA, 0x46, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x32, 0x01, 0x00, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x01, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0x80, 0xA8, 0x01, 0x03, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x00, 0x03, 
  0xDA, 0x08, 0xCE, 0x75, 0x28, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x66, 0x20, 0x66, 0x6D, 0x74, 0x20, 
  0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x41, 0x20, 0x63, 0x6F, 0x6D, 0x62, 0x69, 
  0x6E, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 
  0x72, 0x6D, 0x61, 0x74, 0x60, 0x2E, 0x20, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x28, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x28, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x66, 0x6D, 0x74, 0x20, 
  0x3B, 0x61, 0x72, 0x67, 0x73, 0x29, 0x29, 0x60, 0x2E, 0xCF, 0x02, 0x69, 0x6E, 0xD3, 0x02, 0xDA, 
  0x06, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x06, 0x04, 0x03, 0x02, 0x03, 0x00, 0x06, 0xCE, 0x02, 
  0x69, 0x6E, 0x38, 0x00, 0x00, 0x01, 0x26, 0x03, 0x00, 0x00, 0x23, 0x03, 0x00, 0x03, 0x1B, 0x03, 
  0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x81, 0x8A, 0x28, 
  0x69, 0x6E, 0x20, 0x64, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 
  0x66, 0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x69, 0x6E, 0x20, 0x64, 0x73, 0x20, 0x61, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x2C, 0x20, 0x77, 0x6F, 
  0x72, 0x6B, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 
  0x65, 0x73, 0x2E, 0x20, 0x41, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2C, 0x20, 0x74, 0x75, 0x70, 0x6C, 
  0x65, 0x73, 0x2C, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x73, 0x2C, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x2C, 0x20, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 
  0x69, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 
  0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x2E, 0x20, 0x41, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2C, 0x20, 
  0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x2C, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x69, 
  0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x73, 0x20, 0x6F, 
  0x72, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x73, 0x20, 0x72, 0x61, 
  0x69, 0x73, 0x65, 0x64, 0x2E, 0x20, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x74, 0x61, 0x6B, 
  0x65, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 
  0x20, 0x6B, 0x65, 0x79, 0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x20, 0x6E, 0x69, 0x6C, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 
  0x6E, 0x69, 0x6C, 0x20, 0x6F, 0x72, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x20, 0x69, 0x66, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x6C, 0x73, 
  0x74, 0x61, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 0x5A, 0x01, 0xDA, 
  0x06, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x6C, 0x73, 0x74, 0x61, 0x74, 0xDA, 0x08, 0xCE, 0x47, 0x28, 
  0x6F, 0x73, 0x2F, 0x6C, 0x73, 0x74, 0x61, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x74, 0x61, 0x62, 0x7C, 0x6B, 0x65, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 0x69, 0x6B, 
  0x65, 0x20, 0x6F, 0x73, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x64, 
  0x6F, 0x6E, 0x27, 0x74, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x73, 0x79, 0x6D, 0x6C, 
  0x69, 0x6E, 0x6B, 0x73, 0x2E, 0x0A, 0xCF, 0x02, 0x2D, 0x2D, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x80, 0x97, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 
  0x01, 0x01, 0x01, 0x02, 0x09, 0xCE, 0x02, 0x2D, 0x2D, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x09, 
  0x00, 0x0A, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x01, 0x2D, 0x3D, 
  0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 0x03, 
  0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x00, 0x00, 0x3B, 
  0x04, 0x00, 0x00, 0x07, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 
  0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x07, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 
  0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xDA, 0x29, 0x2C, 0x01, 0x00, 
  0x00, 0x2A, 0x03, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 0x31, 0x03, 0x00, 0x04, 0x43, 0x02, 0x00, 
  0x00, 0x2A, 0x04, 0x01, 0x00, 0x31, 0x04, 0x00, 0x02, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x80, 0x97, 0x01, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 
  0x00, 0x2F, 0x00, 0x2F, 0xDA, 0x08, 0xCE, 0x22, 0x28, 0x2D, 0x2D, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x44, 0x65, 0x63, 0x72, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 
  0x61, 0x72, 0x20, 0x78, 0x20, 0x62, 0x79, 0x20, 0x31, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x08, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x0F, 
  0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x6D, 0x61, 0x74, 0x68, 0x2E, 0x63, 0x81, 
  0x17, 0x01, 0xDA, 0x06, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0xDA, 0x08, 
  0xCE, 0x31, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x61, 0x74, 0x75, 
  0x72, 0x61, 0x6C, 0x20, 0x6C, 0x6F, 0x67, 0x61, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x20, 0x6F, 0x66, 
  0x20, 0x78, 0x2E, 0xCF, 0x0A, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x74, 0x79, 0x70, 0x65, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x10, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 
  0x2F, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0x63, 0x56, 0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x2F, 0x74, 0x79, 0x70, 0x65, 0xDA, 0x08, 0xCE, 0x81, 0x1D, 0x28, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x2F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x75, 0x70, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x73, 0x20, 0x68, 0x6F, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x65, 0x64, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x3A, 0x62, 0x72, 
  0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x64, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x2C, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x3A, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x73, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 
  0x69, 0x73, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x74, 0x79, 0x70, 
  0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 
  0x65, 0x20, 0x6D, 0x6F, 0x73, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 
  0x6D, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x70, 0x72, 0x69, 
  0x6E, 0x74, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x64, 0x69, 
  0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x72, 0x2E, 0xCF, 0x09, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x2F, 0x6E, 0x65, 0x77, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x10, 0x73, 0x72, 
  0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x63, 0x81, 0x2D, 
  0x01, 0xDA, 0x06, 0xD8, 0x09, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x6E, 0x65, 0x77, 0xDA, 0x08, 
  0xCE, 0x80, 0xF3, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x6E, 0x65, 0x77, 0x20, 0x63, 0x61, 
  0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 
  0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x20, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70, 0x72, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0x6F, 
  0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x60, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x60, 0x20, 0x65, 0x6E, 0x74, 0x72, 
  0x69, 0x65, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x66, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6B, 0x6E, 0x6F, 0x77, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 
  0x65, 0x6E, 0x74, 0x72, 0x69, 0x65, 0x73, 0x20, 0x67, 0x6F, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 
  0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x6E, 0x20, 0x63, 0x72, 
  0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x20, 0x6D, 0x65, 
  0x6D, 0x6F, 0x72, 0x79, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x61, 0x76, 0x6F, 0x69, 0x64, 0x65, 0x64, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xCF, 0x07, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0xD3, 
  0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x09, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 
  0x00, 0x99, 0x00, 0x00, 0x09, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x09, 0x23, 0xCE, 0x07, 
  0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0xDA, 0x18, 0xDA, 0x43, 0xCF, 0x02, 0x66, 0x6E, 0xD8, 
  0x09, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xD0, 0x02, 0x69, 0x65, 0xD7, 0x00, 
  0xCD, 0x00, 0x08, 0x00, 0x05, 0x02, 0x02, 0x01, 0x02, 0x00, 0x02, 0xCE, 0x06, 0x72, 0x65, 0x73, 
  0x75, 0x6D, 0x65, 0x35, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0xD8, 0x0C, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x19, 
  0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x04, 0x6E, 0x6F, 0x74, 0x3D, 
  0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 
  0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 
  0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 
  0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 
  0xD0, 0x05, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xCF, 0x03, 0x6C, 0x65, 0x74, 0x2C, 0x01, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x33, 0x02, 0x04, 0x00, 0x19, 0x04, 0x02, 0x00, 0x44, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 
  0x30, 0x06, 0x02, 0x00, 0x32, 0x00, 0x00, 0x00, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 
  0x2A, 0x07, 0x03, 0x00, 0x31, 0x06, 0x05, 0x07, 0x43, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 
  0x30, 0x06, 0x03, 0x00, 0x43, 0x05, 0x00, 0x00, 0x31, 0x03, 0x02, 0x04, 0x2F, 0x05, 0x00, 0x00, 
  0x44, 0x06, 0x00, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x30, 0x05, 0x03, 0x00, 0x43, 0x02, 0x00, 0x00, 
  0x2A, 0x07, 0x06, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x31, 0x07, 0x08, 0x02, 0x43, 0x05, 0x00, 0x00, 
  0x30, 0x05, 0x04, 0x00, 0x44, 0x02, 0x00, 0x00, 0x2A, 0x07, 0x08, 0x00, 0x31, 0x07, 0x06, 0x02, 
  0x43, 0x05, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x81, 0x09, 0x01, 0x05, 0x0B, 0x00, 0x0B, 0x00, 
  0x03, 0x00, 0x16, 0x00, 0x16, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xDA, 
  0x08, 0xCE, 0x80, 0xD2, 0x28, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x20, 0x26, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x65, 
  0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x6C, 
  0x65, 0x20, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x79, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x2E, 0x20, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 
  0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x0A, 0x6F, 0x66, 0x20, 
  0x74, 0x77, 0x6F, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x20, 0x54, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 
  0x73, 0x73, 0x66, 0x75, 0x6C, 0x2C, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x69, 0x66, 0x20, 
  0x61, 0x6E, 0x0A, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x72, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x07, 0x65, 0x76, 0x2F, 0x63, 0x68, 
  0x61, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x84, 0x43, 0x01, 0xDA, 0x06, 
  0xD8, 0x07, 0x65, 0x76, 0x2F, 0x63, 0x68, 0x61, 0x6E, 0xDA, 0x08, 0xCE, 0x80, 0xA7, 0x28, 0x65, 
  0x76, 0x2F, 0x63, 0x68, 0x61, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x63, 0x61, 0x70, 0x61, 
  0x63, 0x69, 0x74, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x2E, 0x20, 0x63, 0x61, 0x70, 
  0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x62, 0x6C, 
  0x6F, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x72, 0x73, 0x2C, 0x20, 
  0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x30, 0x20, 0x69, 0x66, 
  0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x63, 0x68, 0x61, 
  0x6E, 0x6E, 0x65, 0x6C, 0x2E, 0xCF, 0x02, 0x2D, 0x3D, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x80, 0x99, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 
  0x02, 0x02, 0x02, 0x08, 0xCE, 0x02, 0x2D, 0x3D, 0xDA, 0x18, 0xDA, 0x80, 0x9F, 0xDA, 0x29, 0x2C, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x04, 0x00, 0x01, 0x43, 0x03, 0x00, 0x00, 0x2A, 
  0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 
  0x99, 0x01, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 
  0xDA, 0x08, 0xCE, 0x24, 0x28, 0x2D, 0x3D, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x44, 0x65, 
  0x63, 0x72, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x72, 
  0x20, 0x78, 0x20, 0x62, 0x79, 0x20, 0x6E, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x06, 0x65, 0x64, 0x65, 
  0x66, 0x65, 0x72, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x4F, 0x01, 0xDA, 
  0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0B, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x0C, 0x2F, 0xCE, 0x06, 0x65, 0x64, 0x65, 0x66, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x80, 
  0xB9, 0xDA, 0x80, 0xBA, 0xD0, 0x02, 0x74, 0x69, 0xDA, 0x44, 0xDA, 0x80, 0xBC, 0xDA, 0x80, 0xBE, 
  0xCF, 0x01, 0x3D, 0xD0, 0x04, 0x64, 0x65, 0x61, 0x64, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x1A, 
  0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 0xCE, 0x09, 0x70, 0x72, 0x6F, 0x70, 0x61, 0x67, 0x61, 0x74, 
  0x65, 0x37, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0xDA, 0x4A, 0xDA, 0x49, 0x2C, 0x02, 0x00, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x00, 
  0x00, 0x33, 0x03, 0x05, 0x00, 0x19, 0x05, 0x03, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x01, 
  0x00, 0x30, 0x07, 0x03, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x02, 
  0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x07, 0x06, 0x08, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x04, 
  0x00, 0x31, 0x07, 0x04, 0x03, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x30, 0x07, 0x04, 
  0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x08, 0x05, 0x03, 0x43, 0x07, 0x00, 
  0x00, 0x2A, 0x08, 0x06, 0x00, 0x30, 0x08, 0x04, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x07, 
  0x00, 0x2A, 0x0A, 0x08, 0x00, 0x31, 0x09, 0x03, 0x0A, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x09, 
  0x00, 0x31, 0x09, 0x05, 0x04, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 0x0A, 0x00, 0x31, 0x0A, 0x00, 
  0x03, 0x43, 0x09, 0x00, 0x00, 0x2A, 0x0A, 0x0B, 0x00, 0x31, 0x0A, 0x08, 0x05, 0x2F, 0x09, 0x00, 
  0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x0A, 0x00, 0x31, 0x09, 0x06, 0x07, 0x2F, 0x03, 0x00, 
  0x00, 0x43, 0x08, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x81, 0x4F, 0x01, 0x04, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xDA, 0x08, 0xCE, 0x80, 0x9F, 0x28, 0x65, 0x64, 
  0x65, 0x66, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 
  0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x60, 0x66, 0x6F, 0x72, 0x6D, 0x60, 0x20, 0x61, 0x66, 
  0x74, 0x65, 0x72, 0x20, 0x60, 0x62, 0x6F, 0x64, 0x79, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x62, 0x6F, 0x64, 0x79, 
  0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x62, 0x6E, 0x6F, 
  0x72, 0x6D, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x28, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x20, 0x6F, 0x72, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 
  0x30, 0x2D, 0x34, 0x29, 0x2E, 0x0A, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 
  0x6D, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x62, 0x6F, 0x64, 0x79, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 
  0x02, 0x2D, 0x3E, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xD5, 0x01, 0xDA, 
  0x06, 0xD7, 0x00, 0xCD, 0x00, 0xB9, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x01, 0x06, 0x01, 0xCE, 0x02, 0x2D, 0x3E, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x08, 0x03, 0x03, 0x03, 0x00, 0x0D, 0xCE, 0x06, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0xDA, 0x18, 
  0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 0x01, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x02, 0x06, 
  0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 0x07, 0x00, 0x38, 0x05, 0x02, 0x06, 0x19, 0x07, 0x05, 0x00, 
  0x30, 0x04, 0x07, 0x00, 0x33, 0x04, 0x00, 0x00, 0x47, 0x06, 0x02, 0x06, 0x1A, 0xFA, 0xFF, 0xFF, 
  0x03, 0x04, 0x00, 0x00, 0x83, 0x63, 0x01, 0x08, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF7, 0x01, 
  0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x31, 0x04, 0x00, 0x01, 
  0x2A, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 0x02, 0x02, 
  0x02, 0x06, 0x25, 0xCE, 0x03, 0x66, 0x6F, 0x70, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x76, 0xD8, 0x0B, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x78, 0xD8, 0x0C, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0xD8, 0x0B, 0x74, 0x75, 0x70, 
  0x6C, 0x65, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 
  0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 0x06, 0x04, 
  0x1C, 0x05, 0x0C, 0x00, 0x29, 0x06, 0x00, 0x00, 0x38, 0x04, 0x01, 0x06, 0x29, 0x06, 0x01, 0x00, 
  0x30, 0x01, 0x06, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x04, 0x06, 0x00, 
  0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x03, 0x07, 0x00, 0x1A, 0x06, 0x00, 0x00, 
  0x3E, 0x04, 0x00, 0x00, 0x30, 0x01, 0x04, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 
  0x19, 0x03, 0x06, 0x00, 0x3B, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3B, 0x04, 0x03, 0x01, 
  0x19, 0x06, 0x04, 0x00, 0x30, 0x05, 0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 0x30, 0x04, 0x06, 0x00, 
  0x2A, 0x08, 0x04, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x04, 0x07, 0x00, 0x29, 0x08, 0x00, 0x00, 
  0x30, 0x04, 0x08, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x34, 0x08, 0x00, 0x00, 0x84, 0xDA, 0x03, 0x01, 
  0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x01, 0x19, 0x00, 0x19, 0x00, 
  0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFF, 0x10, 
  0x00, 0x10, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFE, 0x10, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x84, 0xD5, 0x01, 0x05, 0x03, 0x00, 0x03, 
  0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x80, 0xDD, 0x28, 0x2D, 0x3E, 0x20, 0x78, 
  0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x65, 0x61, 
  0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x49, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0x73, 0x20, 0x78, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 
  0x6F, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x0A, 0x69, 0x6E, 0x20, 0x60, 
  0x66, 0x6F, 0x72, 0x6D, 0x73, 0x60, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x69, 0x6E, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x0A, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x6D, 0x61, 0x6E, 
  0x6E, 0x65, 0x72, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x6F, 0x20, 0x6F, 0x6E, 0x2E, 0x20, 
  0x55, 0x73, 0x65, 0x66, 0x75, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 
  0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x73, 0x20, 
  0x6F, 0x66, 0x20, 0x64, 0x61, 0x74, 0x61, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x0C, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x73, 0x70, 0x6C, 0x69, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xCE, 0x11, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2E, 0x63, 0x81, 0xB8, 0x01, 0xDA, 0x06, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2F, 0x73, 0x70, 0x6C, 0x69, 0x74, 0xDA, 0x08, 0xCE, 0x81, 0x77, 0x28, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2F, 0x73, 0x70, 0x6C, 0x69, 0x74, 0x20, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x20, 0x73, 
  0x74, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x6C, 0x69, 
  0x6D, 0x69, 0x74, 0x29, 0x0A, 0x0A, 0x53, 0x70, 0x6C, 0x69, 0x74, 0x73, 0x20, 0x61, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x73, 0x74, 0x72, 0x60, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x69, 0x74, 0x65, 0x72, 0x20, 0x60, 0x64, 0x65, 0x6C, 0x69, 
  0x6D, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 
  0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x6C, 0x69, 0x6D, 
  0x69, 0x74, 0x65, 0x72, 0x20, 0x60, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x60, 0x2E, 0x20, 0x49, 0x66, 
  0x20, 0x60, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x60, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x68, 
  0x61, 0x76, 0x65, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 
  0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x73, 0x65, 0x61, 0x72, 
  0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x64, 0x65, 0x6C, 0x69, 0x6D, 
  0x60, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 
  0x73, 0x74, 0x61, 0x72, 0x74, 0x60, 0x20, 0x28, 0x69, 0x66, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 
  0x64, 0x65, 0x64, 0x29, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 
  0x20, 0x6F, 0x66, 0x20, 0x60, 0x6C, 0x69, 0x6D, 0x69, 0x74, 0x60, 0x20, 0x72, 0x65, 0x73, 0x75, 
  0x6C, 0x74, 0x73, 0x20, 0x28, 0x69, 0x66, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 
  0x29, 0x2E, 0xCF, 0x04, 0x63, 0x6F, 0x72, 0x6F, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x82, 0x75, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x00, 0x00, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x05, 0x0C, 0xCE, 0x04, 0x63, 0x6F, 0x72, 0x6F, 0xDA, 0x18, 0xDA, 
  0x80, 0xB9, 0xD2, 0x00, 0x01, 0xDA, 0x78, 0xDA, 0x80, 0xBA, 0xD0, 0x02, 0x79, 0x69, 0x2C, 0x01, 
  0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x02, 0x03, 0x00, 0x32, 0x00, 
  0x00, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x03, 0x00, 0x2A, 0x04, 
  0x04, 0x00, 0x31, 0x03, 0x02, 0x04, 0x2A, 0x03, 0x02, 0x00, 0x34, 0x03, 0x00, 0x00, 0x82, 0x75, 
  0x01, 0x03, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x7F, 0x28, 0x63, 0x6F, 0x72, 0x6F, 
  0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x41, 0x20, 0x77, 0x72, 0x61, 0x70, 
  0x70, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6D, 0x61, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x79, 
  0x69, 0x65, 0x6C, 0x64, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x73, 0x20, 0x28, 0x63, 0x6F, 0x72, 0x6F, 0x75, 0x74, 0x69, 0x6E, 0x65, 0x29, 
  0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x6E, 0x65, 0x77, 0x20, 0x28, 0x66, 0x6E, 0x20, 0x5B, 0x5D, 0x20, 0x3B, 0x62, 0x6F, 
  0x64, 0x79, 0x29, 0x20, 0x3A, 0x79, 0x69, 0x29, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x0A, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x67, 0x61, 0x6D, 0x6D, 0x61, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x80, 0xA4, 0x81, 0x21, 0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x67, 
  0x61, 0x6D, 0x6D, 0x61, 0xDA, 0x08, 0xCE, 0x21, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x67, 0x61, 
  0x6D, 0x6D, 0x61, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x67, 0x61, 0x6D, 0x6D, 0x61, 0x28, 0x78, 0x29, 0x2E, 0xCF, 0x04, 0x64, 0x65, 0x66, 0x2D, 0xD3, 
  0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x45, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 
  0x99, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x07, 0xCE, 0x04, 0x64, 
  0x65, 0x66, 0x2D, 0xDA, 0x18, 0xDA, 0x44, 0xDA, 0x52, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x04, 0x00, 0x05, 0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 
  0x00, 0x03, 0x03, 0x00, 0x00, 0x45, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x45, 0x28, 0x64, 0x65, 0x66, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 
  0x65, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 
  0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x62, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 
  0x05, 0x65, 0x70, 0x72, 0x69, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x0D, 0x73, 
  0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x69, 0x6F, 0x2E, 0x63, 0x82, 0x01, 0x01, 0xDA, 
  0x06, 0xD8, 0x05, 0x65, 0x70, 0x72, 0x69, 0x6E, 0xDA, 0x08, 0xCE, 0x5A, 0x28, 0x65, 0x70, 0x72, 
  0x69, 0x6E, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 
  0x73, 0x20, 0x60, 0x70, 0x72, 0x69, 0x6E, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 
  0x65, 0x73, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x20, 0x73, 0x74, 
  0x64, 0x65, 0x72, 0x72, 0x29, 0x60, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 
  0x66, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 
  0x6F, 0x75, 0x74, 0x29, 0x60, 0x2E, 0xCF, 0x06, 0x2A, 0x61, 0x72, 0x67, 0x73, 0x2A, 0xD3, 0x04, 
  0xD0, 0x03, 0x64, 0x79, 0x6E, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8E, 0xCB, 0x01, 
  0xDA, 0x06, 0xD0, 0x04, 0x61, 0x72, 0x67, 0x73, 0xDA, 0x08, 0xCE, 0x4B, 0x44, 0x79, 0x6E, 0x61, 
  0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x20, 0x63, 
  0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 
  0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2E, 0xCF, 0x05, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0xE2, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x00, 0x10, 0xCE, 0x05, 0x63, 0x6F, 0x75, 0x6E, 0x74, 
  0xDA, 0x18, 0x2C, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 
  0x01, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x0A, 0x00, 0x38, 0x04, 0x01, 0x05, 0x19, 0x06, 
  0x04, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x04, 0x00, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x05, 0x03, 
  0x03, 0x01, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x05, 0x01, 0x05, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 0x03, 
  0x00, 0x00, 0x83, 0xE2, 0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x07, 0xBF, 0xFF, 0x05, 0xBF, 0xFF, 
  0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 0xDA, 0x08, 0xCE, 0x55, 0x28, 0x63, 0x6F, 0x75, 0x6E, 0x74, 
  0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x75, 0x6E, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 
  0x69, 0x74, 0x65, 0x6D, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x69, 0x6E, 0x64, 0x60, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x60, 0x28, 0x70, 0x72, 0x65, 0x64, 0x20, 
  0x69, 0x74, 0x65, 0x6D, 0x29, 0x60, 0x0A, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0xCF, 
  0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x62, 0x79, 0x74, 
  0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x11, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 
  0x72, 0x65, 0x2F, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x63, 0x80, 0xE6, 0x01, 0xDA, 0x06, 
  0xD8, 0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x62, 0x79, 
  0x74, 0x65, 0xDA, 0x08, 0xCE, 0x80, 0xA8, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 
  0x75, 0x73, 0x68, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x41, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x62, 0x79, 
  0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x6E, 0x65, 0x63, 0x65, 0x73, 
  0x73, 0x61, 0x72, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x73, 0x2E, 0xCF, 
  0x0A, 0x64, 0x6F, 0x63, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x8B, 0xB4, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 
  0x48, 0x04, 0x01, 0x04, 0x0A, 0x80, 0x8D, 0x18, 0xCE, 0x0A, 0x64, 0x6F, 0x63, 0x2D, 0x66, 0x6F, 
  0x72, 0x6D, 0x61, 0x74, 0xDA, 0x18, 0xD0, 0x09, 0x64, 0x6F, 0x63, 0x2D, 0x77, 0x69, 0x64, 0x74, 
  0x68, 0xD8, 0x03, 0x64, 0x79, 0x6E, 0xD0, 0x09, 0x64, 0x6F, 0x63, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 
  0x72, 0xD5, 0x04, 0xD0, 0x04, 0x63, 0x6F, 0x64, 0x65, 0xD2, 0x02, 0x00, 0xCE, 0x05, 0x1B, 0x5B, 
  0x39, 0x37, 0x6D, 0xCE, 0x05, 0x1B, 0x5B, 0x33, 0x39, 0x6D, 0xD0, 0x04, 0x62, 0x6F, 0x6C, 0x64, 
  0xD2, 0x02, 0x00, 0xCE, 0x04, 0x1B, 0x5B, 0x31, 0x6D, 0xCE, 0x05, 0x1B, 0x5B, 0x32, 0x32, 0x6D, 
  0xD0, 0x09, 0x75, 0x6E, 0x64, 0x65, 0x72, 0x6C, 0x69, 0x6E, 0x65, 0xD2, 0x02, 0x00, 0xCE, 0x04, 
  0x1B, 0x5B, 0x34, 0x6D, 0xCE, 0x05, 0x1B, 0x5B, 0x32, 0x34, 0x6D, 0xD0, 0x07, 0x69, 0x74, 0x61, 
  0x6C, 0x69, 0x63, 0x73, 0xDA, 0x81, 0x2A, 0xD5, 0x04, 0xDA, 0x81, 0x1F, 0xD2, 0x02, 0x00, 0xCE, 
  0x01, 0x60, 0xDA, 0x81, 0x2D, 0xDA, 0x81, 0x23, 0xD2, 0x02, 0x00, 0xCE, 0x02, 0x2A, 0x2A, 0xDA, 
  0x81, 0x2F, 0xDA, 0x81, 0x27, 0xD2, 0x02, 0x00, 0xCE, 0x01, 0x5F, 0xDA, 0x81, 0x31, 0xDA, 0x81, 
  0x2B, 0xD2, 0x02, 0x00, 0xCE, 0x01, 0x2A, 0xDA, 0x81, 0x33, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x81, 0x20, 0xCE, 0x00, 0xDA, 0x81, 0x21, 
  0xD8, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x04, 0x00, 0x00, 0x26, 0x07, 0x00, 0x00, 
  0x23, 0x06, 0x07, 0x02, 0x1C, 0x06, 0x03, 0x00, 0x29, 0x05, 0x04, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x19, 0x05, 0x02, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1C, 0x01, 0x03, 0x00, 0x19, 0x07, 0x01, 0x00, 
  0x1A, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x29, 0x09, 0x50, 0x00, 0x30, 0x08, 0x09, 0x00, 
  0x2A, 0x09, 0x01, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x07, 0x08, 0x00, 0x05, 0x08, 0x07, 0xF8, 
  0x19, 0x07, 0x08, 0x00, 0x26, 0x0B, 0x00, 0x00, 0x48, 0x0A, 0x0B, 0x03, 0x1C, 0x0A, 0x03, 0x00, 
  0x19, 0x09, 0x03, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x2F, 0x0B, 0x00, 0x00, 
  0x2A, 0x0C, 0x01, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x09, 0x0B, 0x00, 0x19, 0x0A, 0x09, 0x00, 
  0x1C, 0x0A, 0x03, 0x00, 0x2A, 0x0B, 0x03, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x0B, 0x04, 0x00, 
  0x19, 0x0C, 0x0B, 0x00, 0x42, 0x0D, 0x00, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x2E, 0x0F, 0x00, 0x00, 
  0x19, 0x10, 0x0F, 0x00, 0x29, 0x11, 0x00, 0x00, 0x3E, 0x12, 0x00, 0x00, 0x19, 0x13, 0x12, 0x00, 
  0x2E, 0x14, 0x01, 0x00, 0x19, 0x15, 0x14, 0x00, 0x2E, 0x16, 0x02, 0x00, 0x19, 0x17, 0x16, 0x00, 
  0x2E, 0x18, 0x03, 0x00, 0x19, 0x19, 0x18, 0x00, 0x2E, 0x1A, 0x04, 0x00, 0x19, 0x1B, 0x1A, 0x00, 
  0x2E, 0x1C, 0x05, 0x00, 0x19, 0x1D, 0x1C, 0x00, 0x2E, 0x1E, 0x06, 0x00, 0x19, 0x1F, 0x1E, 0x00, 
  0x2E, 0x20, 0x07, 0x00, 0x19, 0x21, 0x20, 0x00, 0x2E, 0x22, 0x08, 0x00, 0x19, 0x23, 0x22, 0x00, 
  0x2E, 0x24, 0x09, 0x00, 0x19, 0x25, 0x24, 0x00, 0x2E, 0x26, 0x0A, 0x00, 0x19, 0x27, 0x26, 0x00, 
  0x26, 0x28, 0x00, 0x00, 0x2E, 0x29, 0x0B, 0x00, 0x19, 0x2A, 0x29, 0x00, 0x2E, 0x2B, 0x0C, 0x00, 
  0x19, 0x2C, 0x2B, 0x00, 0x2E, 0x2D, 0x0D, 0x00, 0x19, 0x2E, 0x2D, 0x00, 0x2E, 0x2F, 0x0E, 0x00, 
  0x19, 0x30, 0x2F, 0x00, 0x2E, 0x31, 0x0F, 0x00, 0x19, 0x32, 0x31, 0x00, 0x2E, 0x33, 0x10, 0x00, 
  0x19, 0x34, 0x33, 0x00, 0x2E, 0x35, 0x11, 0x00, 0x19, 0x36, 0x35, 0x00, 0x2E, 0x28, 0x12, 0x00, 
  0x29, 0x38, 0x00, 0x00, 0x38, 0x37, 0x00, 0x38, 0x29, 0x39, 0x28, 0x00, 0x23, 0x38, 0x39, 0x37, 
  0x1C, 0x38, 0x1D, 0x00, 0x33, 0x37, 0x1F, 0x00, 0x05, 0x37, 0x11, 0xFF, 0x29, 0x39, 0x00, 0x00, 
  0x31, 0x00, 0x39, 0x37, 0x2A, 0x3A, 0x05, 0x00, 0x33, 0x39, 0x3A, 0x00, 0x19, 0x37, 0x39, 0x00, 
  0x1C, 0x0A, 0x03, 0x00, 0x2A, 0x39, 0x06, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x39, 0x07, 0x00, 
  0x19, 0x3A, 0x39, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x2A, 0x39, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x2A, 0x39, 0x07, 0x00, 0x19, 0x3B, 0x39, 0x00, 0x31, 0x3A, 0x37, 0x3B, 0x2A, 0x3C, 0x09, 0x00, 
  0x33, 0x39, 0x3C, 0x00, 0x3D, 0x3C, 0x37, 0x00, 0x30, 0x39, 0x3C, 0x00, 0x43, 0x39, 0x00, 0x00, 
  0x2F, 0x39, 0x00, 0x00, 0x43, 0x39, 0x00, 0x00, 0x2F, 0x39, 0x00, 0x00, 0x33, 0x3C, 0x2C, 0x00, 
  0x1A, 0x01, 0x00, 0x00, 0x29, 0x37, 0x00, 0x00, 0x2F, 0x37, 0x00, 0x00, 0x33, 0x37, 0x28, 0x00, 
  0x2A, 0x38, 0x07, 0x00, 0x2F, 0x38, 0x00, 0x00, 0x3F, 0x38, 0x00, 0x00, 0x19, 0x39, 0x38, 0x00, 
  0x29, 0x3A, 0x00, 0x00, 0x2E, 0x3B, 0x13, 0x00, 0x19, 0x3C, 0x3B, 0x00, 0x2E, 0x3D, 0x14, 0x00, 
  0x19, 0x3E, 0x3D, 0x00, 0x2E, 0x3F, 0x15, 0x00, 0x19, 0x40, 0x3F, 0x00, 0x2E, 0x41, 0x16, 0x00, 
  0x19, 0x42, 0x41, 0x00, 0x2E, 0x43, 0x17, 0x00, 0x19, 0x44, 0x43, 0x00, 0x26, 0x46, 0x00, 0x00, 
  0x47, 0x45, 0x13, 0x46, 0x19, 0x46, 0x45, 0x00, 0x1D, 0x46, 0x08, 0x00, 0x38, 0x45, 0x13, 0x46, 
  0x19, 0x47, 0x45, 0x00, 0x33, 0x45, 0x3E, 0x00, 0x30, 0x47, 0x06, 0x00, 0x33, 0x45, 0x44, 0x00, 
  0x47, 0x46, 0x13, 0x46, 0x1A, 0xF9, 0xFF, 0xFF, 0x03, 0x39, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 
  0x00, 0x08, 0x01, 0x01, 0x01, 0x01, 0x12, 0x01, 0xCE, 0x0B, 0x74, 0x6F, 0x67, 0x67, 0x6C, 0x65, 
  0x2D, 0x6D, 0x6F, 0x64, 0x65, 0xDA, 0x18, 0xDA, 0x73, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 
  0x0E, 0x39, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2B, 0x05, 0x00, 0x0C, 0x39, 0x04, 0x05, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 
  0x00, 0x2B, 0x07, 0x00, 0x0E, 0x3A, 0x07, 0x00, 0x06, 0x1C, 0x03, 0x03, 0x00, 0x29, 0x06, 0x01, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x34, 0x05, 0x00, 
  0x00, 0xBF, 0xFF, 0x8B, 0xCC, 0x03, 0x01, 0x11, 0x00, 0x11, 0x00, 0x05, 0x01, 0x11, 0x00, 0x11, 
  0x00, 0x05, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0D, 0x00, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0x00, 0x05, 0x01, 0xCE, 0x01, 0x63, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 
  0x00, 0x2B, 0x03, 0x00, 0x11, 0x39, 0x01, 0x02, 0x03, 0x03, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 
  0xD7, 0x03, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 
  0x01, 0x01, 0x01, 0x00, 0x06, 0x01, 0xCE, 0x02, 0x63, 0x6E, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 
  0x2B, 0x03, 0x00, 0x11, 0x06, 0x02, 0x00, 0x03, 0x2B, 0x04, 0x00, 0x00, 0x39, 0x03, 0x04, 0x02, 
  0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xD8, 0x03, 0x00, 0x19, 0x00, 0x19, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x01, 0xCE, 
  0x03, 0x63, 0x2B, 0x2B, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x2B, 0x03, 
  0x00, 0x11, 0x39, 0x01, 0x02, 0x03, 0x19, 0x02, 0x01, 0x00, 0x2B, 0x03, 0x00, 0x11, 0x05, 0x01, 
  0x03, 0x01, 0x2D, 0x01, 0x00, 0x11, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xD9, 0x03, 0x00, 
  0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x10, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x10, 0xCD, 
  0x00, 0xD8, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x00, 0x09, 0x01, 0xCE, 0x04, 0x63, 0x2B, 0x3D, 
  0x6E, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x11, 0x39, 
  0x02, 0x03, 0x04, 0x19, 0x03, 0x02, 0x00, 0x2B, 0x04, 0x00, 0x11, 0x06, 0x02, 0x04, 0x00, 0x2D, 
  0x02, 0x00, 0x11, 0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xDA, 0x03, 0x00, 0x1C, 0x00, 0x1C, 
  0x00, 0x1C, 0x00, 0x12, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x12, 0xCD, 0x00, 0xD8, 0x00, 
  0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x01, 0xCE, 0x09, 0x73, 0x6B, 0x69, 0x70, 0x77, 0x68, 
  0x69, 0x74, 0x65, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x11, 0x2B, 0x03, 0x00, 
  0x15, 0x33, 0x02, 0x03, 0x00, 0x24, 0x03, 0x02, 0x20, 0x1C, 0x03, 0x05, 0x00, 0x2B, 0x04, 0x00, 
  0x11, 0x05, 0x02, 0x04, 0x01, 0x2D, 0x02, 0x00, 0x11, 0x1A, 0xF9, 0xFF, 0xFF, 0x2B, 0x03, 0x00, 
  0x11, 0x07, 0x02, 0x03, 0x01, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xDC, 0x03, 0x01, 0x05, 
  0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0C, 0x00, 0x05, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x05, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 
  0x14, 0x01, 0xCE, 0x08, 0x73, 0x6B, 0x69, 0x70, 0x6C, 0x69, 0x6E, 0x65, 0xDA, 0x18, 0x2C, 0x00, 
  0x00, 0x00, 0x2B, 0x01, 0x00, 0x11, 0x2B, 0x03, 0x00, 0x15, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x1C, 0x03, 0x04, 0x00, 0x49, 0x04, 0x03, 0x0A, 0x19, 0x02, 0x04, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x05, 0x00, 0x2B, 0x04, 0x00, 0x11, 0x05, 0x03, 
  0x04, 0x01, 0x2D, 0x03, 0x00, 0x11, 0x1A, 0xF4, 0xFF, 0xFF, 0x2B, 0x03, 0x00, 0x19, 0x33, 0x02, 
  0x03, 0x00, 0x2B, 0x04, 0x00, 0x11, 0x07, 0x03, 0x04, 0x01, 0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 
  0x8B, 0xE0, 0x03, 0x01, 0x05, 0x01, 0x14, 0x00, 0x14, 0x00, 0x0C, 0x00, 0x19, 0x00, 0x20, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x05, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x05, 0x01, 
  0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x00, 
  0x00, 0x00, 0x00, 0x19, 0x01, 0xCE, 0x03, 0x75, 0x6C, 0x3F, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 
  0x2B, 0x02, 0x00, 0x15, 0x33, 0x01, 0x02, 0x00, 0x19, 0x02, 0x01, 0x00, 0x29, 0x01, 0x01, 0x00, 
  0x2F, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x17, 0x33, 0x01, 0x03, 0x00, 0x19, 0x03, 0x01, 0x00, 
  0x24, 0x01, 0x03, 0x20, 0x19, 0x04, 0x01, 0x00, 0x1C, 0x01, 0x0D, 0x00, 0x24, 0x05, 0x02, 0x2A, 
  0x19, 0x06, 0x05, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 0x05, 0x06, 0x00, 0x1A, 0x03, 0x00, 0x00, 
  0x24, 0x07, 0x02, 0x2D, 0x19, 0x05, 0x07, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1C, 0x05, 0x03, 0x00, 
  0x29, 0x07, 0x02, 0x00, 0x03, 0x07, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 
  0xBF, 0xFF, 0x8B, 0xE7, 0x03, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x05, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x05, 0x02, 0x09, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x02, 0x0D, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x1D, 0x00, 0x09, 0xBF, 0xFE, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
  0x00, 0x2A, 0x01, 0xCE, 0x03, 0x6F, 0x6C, 0x3F, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x01, 
  0x00, 0x11, 0x2B, 0x04, 0x00, 0x15, 0x33, 0x03, 0x04, 0x00, 0x29, 0x05, 0x30, 0x00, 0x45, 0x04, 
  0x03, 0x05, 0x19, 0x03, 0x04, 0x00, 0x1C, 0x04, 0x07, 0x00, 0x2B, 0x06, 0x00, 0x15, 0x33, 0x05, 
  0x06, 0x00, 0x29, 0x07, 0x39, 0x00, 0x46, 0x06, 0x05, 0x07, 0x19, 0x02, 0x06, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x04, 0x00, 0x2B, 0x04, 0x00, 0x19, 0x33, 0x03, 
  0x04, 0x00, 0x1A, 0xF0, 0xFF, 0xFF, 0x2B, 0x03, 0x00, 0x15, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x29, 0x02, 0x01, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x17, 0x33, 0x02, 
  0x04, 0x00, 0x19, 0x04, 0x02, 0x00, 0x2B, 0x02, 0x00, 0x11, 0x2D, 0x01, 0x00, 0x11, 0x24, 0x06, 
  0x03, 0x2E, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x06, 0x04, 0x00, 0x24, 0x08, 0x04, 0x20, 0x19, 0x05, 
  0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x05, 0x07, 0x00, 0x1C, 0x05, 0x05, 0x00, 0x2B, 0x07, 
  0x00, 0x11, 0x07, 0x06, 0x02, 0x07, 0x05, 0x06, 0x06, 0x02, 0x03, 0x06, 0x00, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xED, 0x03, 0x01, 0x05, 0x01, 0x15, 0x00, 0x15, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x28, 0x00, 0x28, 0x00, 0x24, 0x00, 0x24, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x05, 0x00, 0x38, 0x00, 0x38, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 
  0x05, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 0x01, 
  0x10, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x21, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x01, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x06, 
  0x00, 0x00, 0x00, 0x00, 0x15, 0x01, 0xCE, 0x04, 0x66, 0x63, 0x62, 0x3F, 0xDA, 0x18, 0x2C, 0x00, 
  0x00, 0x00, 0x2B, 0x02, 0x00, 0x15, 0x33, 0x01, 0x02, 0x00, 0x29, 0x02, 0x01, 0x00, 0x2F, 0x02, 
  0x00, 0x00, 0x2B, 0x03, 0x00, 0x17, 0x33, 0x02, 0x03, 0x00, 0x29, 0x03, 0x02, 0x00, 0x2F, 0x03, 
  0x00, 0x00, 0x2B, 0x04, 0x00, 0x17, 0x33, 0x03, 0x04, 0x00, 0x29, 0x05, 0x60, 0x00, 0x23, 0x04, 
  0x05, 0x01, 0x1C, 0x04, 0x04, 0x00, 0x23, 0x04, 0x01, 0x02, 0x1C, 0x04, 0x02, 0x00, 0x23, 0x04, 
  0x02, 0x03, 0x1C, 0x04, 0x03, 0x00, 0x29, 0x01, 0x03, 0x00, 0x03, 0x01, 0x00, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xF4, 0x03, 0x00, 0x22, 0x00, 0x22, 0x00, 0x26, 0x00, 0x26, 0x00, 
  0x26, 0x00, 0x26, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0xCD, 
  0x00, 0xD8, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xCE, 0x03, 0x6E, 0x6C, 0x3F, 
  0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x15, 0x33, 0x01, 0x02, 0x00, 0x29, 0x03, 
  0x0A, 0x00, 0x23, 0x02, 0x03, 0x01, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xF5, 0x03, 0x00, 
  0x1E, 0x00, 0x1E, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x06, 0x02, 
  0x02, 0x02, 0x02, 0x0B, 0x01, 0xCE, 0x08, 0x67, 0x65, 0x74, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 
  0x18, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x02, 0x05, 0xCE, 0x03, 0x6D, 0x69, 0x6E, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x15, 
  0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x01, 0x3C, 0x3D, 0x01, 0x00, 
  0x00, 0x22, 0x02, 0x01, 0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 
  0x00, 0x38, 0x04, 0x00, 0x05, 0x21, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 
  0x01, 0x19, 0x03, 0x04, 0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 
  0x00, 0x03, 0x03, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x00, 0x11, 0xCE, 0x07, 0x65, 0x78, 0x74, 0x72, 
  0x65, 0x6D, 0x65, 0xDA, 0x18, 0x2C, 0x02, 0x00, 0x00, 0x3B, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x03, 0x01, 0x05, 0x19, 0x05, 0x03, 0x00, 0x1D, 0x05, 0x0A, 
  0x00, 0x38, 0x03, 0x01, 0x05, 0x19, 0x06, 0x03, 0x00, 0x30, 0x06, 0x04, 0x00, 0x33, 0x03, 0x00, 
  0x00, 0x1C, 0x03, 0x03, 0x00, 0x19, 0x04, 0x06, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x05, 0x01, 
  0x05, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x82, 0xCE, 0x01, 0x05, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x10, 0x00, 0x22, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0x2C, 0x01, 0x00, 
  0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 
  0x00, 0x82, 0xDB, 0x01, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xDA, 0x81, 0x36, 0x2C, 
  0x02, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x3D, 0x03, 0x04, 0x00, 0x30, 0x01, 0x03, 0x00, 0x2A, 
  0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x03, 0x04, 0x00, 0x2B, 0x05, 0x00, 0x00, 0x31, 
  0x05, 0x00, 0x03, 0x2A, 0x05, 0x01, 0x00, 0x34, 0x05, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xFC, 0x03, 
  0x01, 0x15, 0x00, 0x15, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 
  0xCE, 0x04, 0x70, 0x75, 0x73, 0x68, 0xDA, 0x18, 0xD8, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 
  0x70, 0x75, 0x73, 0x68, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x13, 0x30, 0x02, 0x00, 0x00, 
  0x2A, 0x02, 0x00, 0x00, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0xFF, 0x03, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0D, 0x03, 0x03, 0x03, 0x00, 0x33, 
  0x01, 0xCE, 0x0A, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 0x6C, 0x69, 0x73, 0x74, 0xDA, 0x18, 0x2C, 
  0x03, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2B, 
  0x06, 0x00, 0x13, 0x2D, 0x05, 0x00, 0x13, 0x19, 0x07, 0x02, 0x00, 0x2B, 0x0A, 0x00, 0x15, 0x33, 
  0x09, 0x0A, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x1C, 0x09, 0x04, 0x00, 0x45, 0x0B, 0x07, 0x02, 0x19, 
  0x08, 0x0B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x08, 0x0A, 0x00, 0x1C, 0x08, 0x1F, 0x00, 0x33, 
  0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x1C, 0x0A, 0x0A, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x2B, 
  0x0C, 0x00, 0x1B, 0x33, 0x0B, 0x0C, 0x00, 0x2B, 0x0C, 0x00, 0x1D, 0x33, 0x0B, 0x0C, 0x00, 0x06, 
  0x0C, 0x02, 0x0B, 0x06, 0x0C, 0x0C, 0x0A, 0x19, 0x09, 0x0C, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 
  0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x1C, 0x0A, 0x02, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2B, 
  0x09, 0x00, 0x1D, 0x33, 0x07, 0x09, 0x00, 0x1A, 0x0C, 0x00, 0x00, 0x3E, 0x09, 0x00, 0x00, 0x19, 
  0x0B, 0x09, 0x00, 0x2D, 0x0B, 0x00, 0x13, 0x2F, 0x0A, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x28, 0x33, 
  0x07, 0x09, 0x00, 0x2D, 0x05, 0x00, 0x13, 0x2F, 0x0B, 0x00, 0x00, 0x2B, 0x0C, 0x00, 0x2C, 0x33, 
  0x09, 0x0C, 0x00, 0x1A, 0xDA, 0xFF, 0xFF, 0x2D, 0x06, 0x00, 0x13, 0x2F, 0x05, 0x00, 0x00, 0x2B, 
  0x09, 0x00, 0x2C, 0x33, 0x08, 0x09, 0x00, 0x03, 0x07, 0x00, 0x00, 0xBF, 0xFF, 0x8C, 0x01, 0x03, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x01, 0x05, 0x01, 0x05, 0x01, 0x11, 0x00, 0x11, 
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x15, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x02, 0x16, 
  0x00, 0x09, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 0x15, 0x00, 0x15, 0x00, 0x0B, 
  0x00, 0x0B, 0xBF, 0xFE, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0x04, 0x07, 0x00, 0x07, 
  0x01, 0x1D, 0x00, 0x1D, 0x01, 0x09, 0x01, 0x07, 0x00, 0x07, 0x01, 0x07, 0x01, 0x1B, 0x00, 0x1B, 
  0x00, 0x1B, 0x01, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xF4, 0x05, 0x0D, 0x05, 0x01, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xED, 0x03, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x09, 0x03, 0x03, 
  0x03, 0x06, 0x1B, 0x01, 0xCE, 0x0D, 0x61, 0x64, 0x64, 0x2D, 0x63, 0x6F, 0x64, 0x65, 0x62, 0x6C, 
  0x6F, 0x63, 0x6B, 0xDA, 0x18, 0xCE, 0x01, 0x20, 0xD8, 0x0D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2F, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0xCE, 0x01, 0x0A, 0xDA, 0x81, 0x38, 0xD8, 0x12, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x2D, 0x61, 0x6C, 
  0x6C, 0xD0, 0x02, 0x63, 0x62, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x30, 0x04, 0x00, 
  0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x30, 0x05, 0x04, 
  0x00, 0x2A, 0x06, 0x03, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x04, 0x05, 0x00, 0x30, 0x01, 0x02, 
  0x00, 0x2B, 0x07, 0x00, 0x2A, 0x33, 0x06, 0x07, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x31, 0x04, 0x07, 
  0x06, 0x2A, 0x08, 0x04, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x30, 0x06, 0x07, 
  0x00, 0x3E, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2B, 0x08, 0x00, 0x2C, 0x33, 0x07, 0x08, 
  0x00, 0x2B, 0x08, 0x00, 0x1F, 0x33, 0x06, 0x08, 0x00, 0x2B, 0x08, 0x00, 0x1D, 0x34, 0x08, 0x00, 
  0x00, 0xBF, 0xFF, 0x8C, 0x17, 0x03, 0x01, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x18, 
  0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x05, 0x01, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x11, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 
  0x01, 0x01, 0x01, 0x00, 0x1D, 0x01, 0xCE, 0x09, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 0x66, 0x63, 
  0x62, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 
  0x03, 0x00, 0x1B, 0x33, 0x02, 0x03, 0x00, 0x2B, 0x04, 0x00, 0x1F, 0x33, 0x03, 0x04, 0x00, 0x2F, 
  0x00, 0x00, 0x00, 0x2B, 0x05, 0x00, 0x1B, 0x33, 0x04, 0x05, 0x00, 0x2B, 0x05, 0x00, 0x11, 0x2B, 
  0x06, 0x00, 0x11, 0x2B, 0x08, 0x00, 0x15, 0x33, 0x07, 0x08, 0x00, 0x1C, 0x07, 0x0C, 0x00, 0x2B, 
  0x09, 0x00, 0x25, 0x33, 0x08, 0x09, 0x00, 0x1C, 0x08, 0x03, 0x00, 0x1A, 0x08, 0x00, 0x00, 0x1A, 
  0x01, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x1F, 0x33, 0x08, 0x09, 0x00, 0x2B, 0x06, 0x00, 0x11, 0x2B, 
  0x09, 0x00, 0x1D, 0x33, 0x08, 0x09, 0x00, 0x1A, 0xF3, 0xFF, 0xFF, 0x31, 0x00, 0x05, 0x06, 0x2B, 
  0x07, 0x00, 0x30, 0x34, 0x07, 0x00, 0x00, 0xBF, 0xFF, 0x8C, 0x1D, 0x03, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 
  0x01, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x12, 
  0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x01, 0x07, 0x01, 0x07, 0x00, 0x07, 0xBF, 0xFC, 0x05, 0x05, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x01, 0x01, 0x01, 0x00, 0x14, 
  0x01, 0xCE, 0x09, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 0x69, 0x63, 0x62, 0xDA, 0x18, 0x2C, 0x01, 
  0x00, 0x00, 0x19, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x11, 0x2B, 0x04, 0x00, 0x11, 0x2B, 0x06, 
  0x00, 0x15, 0x33, 0x05, 0x06, 0x00, 0x1C, 0x05, 0x0B, 0x00, 0x2B, 0x07, 0x00, 0x1F, 0x33, 0x06, 
  0x07, 0x00, 0x2B, 0x04, 0x00, 0x11, 0x2B, 0x06, 0x00, 0x1D, 0x33, 0x02, 0x06, 0x00, 0x21, 0x06, 
  0x02, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xF4, 
  0xFF, 0xFF, 0x31, 0x00, 0x03, 0x04, 0x2B, 0x05, 0x00, 0x30, 0x34, 0x05, 0x00, 0x00, 0xBF, 0xFF, 
  0x8C, 0x2A, 0x03, 0x01, 0x05, 0x01, 0x05, 0x01, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 
  0x07, 0x00, 0x07, 0x01, 0x07, 0x01, 0x1B, 0x00, 0x1B, 0x01, 0x0B, 0x00, 0x07, 0x00, 0x25, 0x00, 
  0x07, 0xBF, 0xFC, 0x05, 0x05, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x02, 0xFA, 0x00, 0x00, 0x18, 
  0x01, 0x01, 0x01, 0x08, 0x59, 0x01, 0x02, 0xCE, 0x0D, 0x74, 0x6F, 0x6B, 0x65, 0x6E, 0x69, 0x7A, 
  0x65, 0x2D, 0x6C, 0x69, 0x6E, 0x65, 0xDA, 0x18, 0xDA, 0x81, 0x37, 0xDA, 0x81, 0x1F, 0xDA, 0x73, 
  0xD8, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0xDA, 0x81, 0x27, 
  0xDA, 0x81, 0x23, 0xDA, 0x81, 0x2B, 0xDA, 0x80, 0xE4, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 0x00, 
  0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x3F, 0x04, 0x00, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x29, 0x06, 0x00, 0x00, 0x2E, 0x07, 0x00, 0x00, 0x19, 0x08, 0x07, 
  0x00, 0x2E, 0x09, 0x01, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x29, 0x0B, 0x00, 0x00, 0x3D, 0x0C, 0x00, 
  0x00, 0x19, 0x0D, 0x0C, 0x00, 0x21, 0x0C, 0x0B, 0x0D, 0x1C, 0x0C, 0x45, 0x00, 0x39, 0x0E, 0x00, 
  0x0B, 0x19, 0x0F, 0x0E, 0x00, 0x24, 0x0E, 0x0F, 0x0A, 0x19, 0x10, 0x0E, 0x00, 0x1C, 0x10, 0x03, 
  0x00, 0x19, 0x0E, 0x10, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x24, 0x11, 0x0F, 0x20, 0x19, 0x0E, 0x11, 
  0x00, 0x1C, 0x0E, 0x03, 0x00, 0x33, 0x10, 0x0A, 0x00, 0x1A, 0x37, 0x00, 0x00, 0x24, 0x10, 0x0F, 
  0x60, 0x1C, 0x10, 0x05, 0x00, 0x2A, 0x11, 0x01, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x33, 0x11, 0x08, 
  0x00, 0x1A, 0x31, 0x00, 0x00, 0x2A, 0x11, 0x01, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x2B, 0x12, 0x00, 
  0x0E, 0x33, 0x11, 0x12, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x2A, 0x13, 0x02, 0x00, 0x33, 0x12, 0x13, 
  0x00, 0x1C, 0x12, 0x25, 0x00, 0x24, 0x11, 0x0F, 0x5C, 0x1C, 0x11, 0x08, 0x00, 0x05, 0x06, 0x06, 
  0x01, 0x05, 0x0B, 0x0B, 0x01, 0x39, 0x13, 0x00, 0x0B, 0x30, 0x05, 0x13, 0x00, 0x2A, 0x15, 0x03, 
  0x00, 0x33, 0x14, 0x15, 0x00, 0x1A, 0x1B, 0x00, 0x00, 0x24, 0x13, 0x0F, 0x5F, 0x1C, 0x13, 0x05, 
  0x00, 0x2A, 0x14, 0x04, 0x00, 0x2F, 0x14, 0x00, 0x00, 0x33, 0x14, 0x08, 0x00, 0x1A, 0x15, 0x00, 
  0x00, 0x24, 0x14, 0x0F, 0x2A, 0x1C, 0x14, 0x0F, 0x00, 0x05, 0x15, 0x0B, 0x01, 0x39, 0x16, 0x00, 
  0x15, 0x29, 0x17, 0x2A, 0x00, 0x23, 0x15, 0x17, 0x16, 0x1C, 0x15, 0x06, 0x00, 0x05, 0x0B, 0x0B, 
  0x01, 0x2A, 0x16, 0x05, 0x00, 0x2F, 0x16, 0x00, 0x00, 0x33, 0x16, 0x08, 0x00, 0x1A, 0x04, 0x00, 
  0x00, 0x2A, 0x16, 0x06, 0x00, 0x2F, 0x16, 0x00, 0x00, 0x33, 0x16, 0x08, 0x00, 0x1A, 0x05, 0x00, 
  0x00, 0x05, 0x06, 0x06, 0x01, 0x30, 0x05, 0x0F, 0x00, 0x2A, 0x16, 0x03, 0x00, 0x33, 0x15, 0x16, 
  0x00, 0x1A, 0x05, 0x00, 0x00, 0x05, 0x06, 0x06, 0x01, 0x30, 0x05, 0x0F, 0x00, 0x2A, 0x13, 0x03, 
  0x00, 0x33, 0x11, 0x13, 0x00, 0x05, 0x0B, 0x0B, 0x01, 0x1A, 0xBB, 0xFF, 0xFF, 0x33, 0x0B, 0x0A, 
  0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x0C, 0x07, 0x00, 0x34, 0x0C, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 
  0x00, 0xD8, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x01, 0x10, 0x02, 0xCE, 0x05, 0x64, 0x65, 0x6C, 
  0x69, 0x6D, 0xDA, 0x18, 0xDA, 0x81, 0x57, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2B, 
  0x03, 0x00, 0x10, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2B, 0x04, 0x00, 0x0A, 0x1C, 
  0x04, 0x02, 0x00, 0x1A, 0x05, 0x00, 0x00, 0x3D, 0x04, 0x03, 0x00, 0x2B, 0x06, 0x01, 0x06, 0x06, 
  0x05, 0x06, 0x04, 0x2D, 0x05, 0x01, 0x06, 0x2B, 0x04, 0x01, 0x05, 0x30, 0x04, 0x03, 0x00, 0x2A, 
  0x04, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8C, 0x39, 0x05, 0x01, 0x0E, 0x00, 
  0x0E, 0x00, 0x0E, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x2A, 0x00, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xCD, 0x00, 0xD8, 0x00, 0x00, 
  0x05, 0x00, 0x00, 0x00, 0x04, 0x1A, 0x01, 0xCE, 0x08, 0x65, 0x6E, 0x64, 0x74, 0x6F, 0x6B, 0x65, 
  0x6E, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 
  0xCE, 0x05, 0x66, 0x69, 0x72, 0x73, 0x74, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x00, 
  0x00, 0x39, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x82, 0xE7, 0x01, 0x03, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xDA, 0x81, 0x38, 0xDA, 0x81, 0x4C, 0xD8, 0x0C, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x05, 0x2F, 0x01, 
  0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x33, 0x01, 0x02, 0x00, 0x1C, 0x01, 0x0D, 0x00, 0x2B, 0x02, 
  0x00, 0x05, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2B, 0x03, 
  0x00, 0x06, 0x30, 0x02, 0x03, 0x00, 0x43, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x03, 0x30, 0x03, 
  0x02, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2B, 0x01, 
  0x00, 0x05, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x03, 0x00, 0x33, 0x01, 0x02, 0x00, 0x29, 0x02, 
  0x00, 0x00, 0x2D, 0x02, 0x00, 0x06, 0x2B, 0x02, 0x00, 0x06, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 
  0x8C, 0x3D, 0x05, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x2D, 0x00, 
  0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x19, 0x00, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x8C, 0x35, 0x03, 0x01, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x01, 0x05, 0x00, 0x05, 0x04, 0x05, 0x00, 0x05, 0x04, 0x05, 
  0x00, 0x0F, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x07, 0x02, 0x0D, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x1E, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0x01, 0x2F, 0xBF, 
  0xFF, 0x07, 0x02, 0x09, 0xBF, 0xFE, 0x07, 0x02, 0x19, 0x00, 0x19, 0x00, 0x19, 0xBF, 0xFE, 0x07, 
  0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFD, 
  0x07, 0x04, 0x0B, 0xBF, 0xFF, 0x1D, 0x02, 0x1D, 0x01, 0x3A, 0x00, 0x30, 0x00, 0x1D, 0x00, 0x1D, 
  0x00, 0x1D, 0xBF, 0xFD, 0x1D, 0x04, 0x0B, 0xBF, 0xFC, 0x1D, 0x04, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 
  0xBF, 0xFC, 0x1D, 0x05, 0x0B, 0xBF, 0xFB, 0x1D, 0x06, 0x28, 0x00, 0x1E, 0x00, 0x11, 0x00, 0x11, 
  0x00, 0x0D, 0x01, 0x13, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xFE, 0x0D, 0x03, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0xBF, 0xF7, 0x1D, 0x0A, 0x0F, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0xBF, 0xF3, 
  0x07, 0x0E, 0x0D, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0xBF, 0xF0, 0x05, 0x00, 0x05, 0x11, 0x05, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x68, 0x00, 0x00, 0x00, 0xCD, 0x02, 0xFA, 0x00, 0x00, 0x10, 
  0x01, 0x01, 0x01, 0x02, 0x43, 0x01, 0x02, 0xCE, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 0x62, 
  0x6C, 0x6F, 0x63, 0x6B, 0x73, 0xDA, 0x18, 0xD0, 0x02, 0x75, 0x6C, 0xD0, 0x02, 0x6F, 0x6C, 0x2C, 
  0x01, 0x00, 0x00, 0x19, 0x02, 0x00, 0x00, 0x26, 0x03, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x2E, 
  0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x07, 0x01, 0x00, 0x19, 0x08, 0x07, 0x00, 0x2B, 
  0x0B, 0x00, 0x15, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x1C, 0x0A, 0x04, 0x00, 0x45, 
  0x0C, 0x02, 0x00, 0x19, 0x09, 0x0C, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x09, 0x0B, 0x00, 0x1C, 
  0x09, 0x31, 0x00, 0x2B, 0x0B, 0x00, 0x27, 0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x07, 0x00, 0x33, 
  0x0B, 0x08, 0x00, 0x2B, 0x0C, 0x00, 0x19, 0x33, 0x0B, 0x0C, 0x00, 0x2B, 0x0B, 0x00, 0x1D, 0x33, 
  0x02, 0x0B, 0x00, 0x1A, 0x27, 0x00, 0x00, 0x2B, 0x0C, 0x00, 0x21, 0x33, 0x0B, 0x0C, 0x00, 0x1C, 
  0x0B, 0x08, 0x00, 0x33, 0x0C, 0x08, 0x00, 0x2B, 0x0C, 0x00, 0x21, 0x2A, 0x0D, 0x00, 0x00, 0x31, 
  0x0C, 0x0D, 0x02, 0x2B, 0x0C, 0x00, 0x2E, 0x33, 0x02, 0x0C, 0x00, 0x1A, 0x1D, 0x00, 0x00, 0x2B, 
  0x0D, 0x00, 0x23, 0x33, 0x0C, 0x0D, 0x00, 0x1C, 0x0C, 0x08, 0x00, 0x33, 0x0D, 0x08, 0x00, 0x2B, 
  0x0D, 0x00, 0x23, 0x2A, 0x0E, 0x01, 0x00, 0x31, 0x0D, 0x0E, 0x02, 0x2B, 0x0D, 0x00, 0x2E, 0x33, 
  0x02, 0x0D, 0x00, 0x1A, 0x13, 0x00, 0x00, 0x2B, 0x0E, 0x00, 0x25, 0x33, 0x0D, 0x0E, 0x00, 0x1C, 
  0x0D, 0x06, 0x00, 0x33, 0x0E, 0x08, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 0x0E, 0x00, 0x32, 0x33, 
  0x02, 0x0E, 0x00, 0x1A, 0x0B, 0x00, 0x00, 0x29, 0x0F, 0x04, 0x00, 0x06, 0x0E, 0x0F, 0x00, 0x45, 
  0x0F, 0x02, 0x0E, 0x1C, 0x0F, 0x06, 0x00, 0x33, 0x0E, 0x08, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 
  0x0E, 0x00, 0x34, 0x33, 0x02, 0x0E, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x33, 0x0E, 0x06, 0x00, 0x1A, 
  0xC8, 0xFF, 0xFF, 0x33, 0x09, 0x08, 0x00, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0xCE, 0x06, 0x70, 0x2D, 0x6C, 0x69, 0x6E, 
  0x65, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x03, 0x1C, 0x01, 0x02, 0x00, 0x1A, 
  0x03, 0x00, 0x00, 0x2B, 0x01, 0x01, 0x11, 0x2D, 0x01, 0x00, 0x03, 0x2B, 0x02, 0x01, 0x1F, 0x33, 
  0x01, 0x02, 0x00, 0x2B, 0x02, 0x01, 0x11, 0x2D, 0x02, 0x00, 0x04, 0x2B, 0x03, 0x01, 0x1D, 0x33, 
  0x02, 0x03, 0x00, 0x2D, 0x02, 0x00, 0x02, 0x2B, 0x03, 0x00, 0x02, 0x03, 0x03, 0x00, 0x00, 0xBF, 
  0xFF, 0x00, 0x8C, 0x5B, 0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x01, 
  0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x01, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x09, 0x00, 
  0x09, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x02, 0xCE, 0x08, 0x66, 
  0x69, 0x6E, 0x69, 0x73, 0x68, 0x2D, 0x70, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 
  0x03, 0x1C, 0x02, 0x06, 0x00, 0x2B, 0x03, 0x00, 0x04, 0x2B, 0x04, 0x00, 0x03, 0x1F, 0x02, 0x03, 
  0x04, 0x19, 0x01, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x03, 0x1C, 0x01, 0x10, 
  0x00, 0x2B, 0x02, 0x00, 0x03, 0x2B, 0x03, 0x00, 0x04, 0x30, 0x02, 0x03, 0x00, 0x2B, 0x03, 0x01, 
  0x2A, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 0x04, 0x01, 0x36, 0x33, 0x03, 0x04, 
  0x00, 0x2F, 0x03, 0x00, 0x00, 0x2B, 0x04, 0x01, 0x2C, 0x33, 0x02, 0x04, 0x00, 0x26, 0x02, 0x00, 
  0x00, 0x2D, 0x02, 0x00, 0x03, 0x2B, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0xBF, 0xFF, 0x00, 0x8C, 0x61, 0x07, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x1C, 0x00, 0x1C, 0x00, 
  0x1C, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x09, 0x01, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 
  0x20, 0x00, 0x20, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0x8C, 0x57, 0x05, 0x01, 0x07, 0x01, 
  0x07, 0x01, 0x07, 0x01, 0x07, 0x00, 0x07, 0x06, 0x07, 0x00, 0x07, 0x04, 0x13, 0x00, 0x13, 0x00, 
  0x0E, 0x00, 0x0E, 0x00, 0x17, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x02, 0x0B, 0x00, 
  0x0B, 0xBF, 0xFF, 0x09, 0x01, 0x15, 0x00, 0x20, 0x00, 0x20, 0x00, 0x36, 0x00, 0x36, 0xBF, 0xFF, 
  0x09, 0x02, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0x02, 0x15, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 
  0x00, 0x30, 0x00, 0x30, 0xBF, 0xFE, 0x09, 0x03, 0x0B, 0x00, 0x0B, 0xBF, 0xFD, 0x09, 0x03, 0x15, 
  0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0xBF, 0xFD, 0x09, 0x04, 0x0B, 0x00, 
  0x0B, 0xBF, 0xFC, 0x09, 0x04, 0x16, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0xBF, 0xFC, 0x09, 0x05, 
  0x1A, 0x00, 0x1A, 0x00, 0x0B, 0xBF, 0xFB, 0x09, 0x05, 0x2C, 0x00, 0x47, 0x00, 0x47, 0x00, 0x47, 
  0xBF, 0xFB, 0x09, 0x06, 0x0B, 0xBF, 0xF9, 0x07, 0x08, 0x07, 0xBF, 0xEA, 0x05, 0x1C, 0x00, 0x00, 
  0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x01, 0x01, 0x01, 0x03, 0x13, 0x01, 0xCE, 0x0B, 0x65, 
  0x6D, 0x69, 0x74, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x6E, 0x74, 0xDA, 0x18, 0xDA, 0x81, 0x4F, 0xDA, 
  0x81, 0x50, 0xDA, 0x81, 0x57, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x3A, 0x07, 0x02, 0x00, 
  0x03, 0x19, 0x03, 0x02, 0x00, 0x29, 0x05, 0x00, 0x00, 0x21, 0x04, 0x05, 0x03, 0x1C, 0x04, 0x0C, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x30, 0x05, 0x03, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 
  0x00, 0x2B, 0x06, 0x00, 0x39, 0x30, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 
  0x00, 0x2D, 0x00, 0x00, 0x3A, 0x2B, 0x05, 0x00, 0x3A, 0x03, 0x05, 0x00, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0xBF, 0xFF, 0x8C, 0x7F, 0x03, 0x01, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x0B, 0x00, 0x0B, 
  0x00, 0x05, 0x01, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 
  0x04, 0x01, 0x00, 0x01, 0x02, 0x0A, 0x01, 0xCE, 0x07, 0x65, 0x6D, 0x69, 0x74, 0x2D, 0x6E, 0x6C, 
  0xDA, 0x18, 0xDA, 0x81, 0x51, 0xDA, 0x81, 0x57, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x39, 
  0x2A, 0x03, 0x00, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x29, 0x03, 0x00, 0x00, 0x2D, 0x03, 0x00, 0x3A, 0x2B, 0x03, 0x00, 0x3A, 0x03, 0x03, 0x00, 0x00, 
  0xBF, 0xFF, 0x8C, 0x85, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0C, 0x03, 0x02, 0x03, 
  0x03, 0x3D, 0x01, 0xCE, 0x09, 0x65, 0x6D, 0x69, 0x74, 0x2D, 0x77, 0x6F, 0x72, 0x64, 0xDA, 0x18, 
  0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x05, 0xCE, 0x04, 0x6C, 
  0x61, 0x73, 0x74, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x05, 0x03, 0x02, 
  0xFF, 0x39, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x82, 0xEC, 0x01, 0x03, 0x0E, 0x00, 0x0B, 
  0x00, 0x03, 0x00, 0x03, 0xDA, 0x81, 0x4F, 0xDA, 0x81, 0x57, 0x2C, 0x03, 0x00, 0x00, 0x2B, 0x04, 
  0x00, 0x39, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 
  0x04, 0x00, 0x1C, 0x05, 0x0A, 0x00, 0x49, 0x08, 0x05, 0x0A, 0x19, 0x09, 0x08, 0x00, 0x1C, 0x08, 
  0x04, 0x00, 0x49, 0x0A, 0x05, 0x20, 0x19, 0x07, 0x0A, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x07, 
  0x09, 0x00, 0x19, 0x06, 0x07, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1C, 0x06, 
  0x0A, 0x00, 0x2B, 0x07, 0x00, 0x39, 0x2A, 0x08, 0x01, 0x00, 0x30, 0x07, 0x08, 0x00, 0x2A, 0x08, 
  0x02, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2B, 0x08, 0x00, 0x3A, 0x05, 0x07, 0x08, 0x01, 0x2D, 0x07, 
  0x00, 0x3A, 0x1A, 0x01, 0x00, 0x00, 0x26, 0x08, 0x00, 0x00, 0x23, 0x07, 0x08, 0x02, 0x1C, 0x07, 
  0x04, 0x00, 0x3D, 0x08, 0x00, 0x00, 0x19, 0x06, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x06, 
  0x02, 0x00, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x01, 0x09, 0x00, 0x29, 0x0A, 0x01, 0x00, 0x2B, 0x0B, 
  0x00, 0x3A, 0x06, 0x09, 0x0A, 0x0B, 0x06, 0x09, 0x09, 0x07, 0x2B, 0x0B, 0x00, 0x07, 0x1F, 0x0A, 
  0x09, 0x0B, 0x19, 0x08, 0x0A, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x08, 0x01, 0x00, 0x1C, 0x08, 
  0x07, 0x00, 0x2B, 0x0A, 0x00, 0x3E, 0x33, 0x09, 0x0A, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x0A, 
  0x00, 0x3C, 0x33, 0x09, 0x0A, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2B, 0x08, 0x00, 0x39, 0x30, 0x08, 
  0x00, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 0x2B, 0x0A, 0x00, 0x3A, 0x06, 0x09, 
  0x0A, 0x07, 0x2D, 0x09, 0x00, 0x3A, 0x2B, 0x0A, 0x00, 0x3A, 0x03, 0x0A, 0x00, 0x00, 0xBF, 0xFF, 
  0x8C, 0x89, 0x03, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x05, 0x01, 0x0B, 0x02, 
  0x0D, 0xBF, 0xFE, 0x0B, 0x00, 0x0B, 0x03, 0x0D, 0xBF, 0xFD, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x04, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFB, 0x05, 0x06, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x12, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0B, 0x00, 0x1A, 0x00, 0x1A, 
  0x00, 0x1A, 0x00, 0x1A, 0x00, 0x17, 0x00, 0x17, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 
  0x01, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x05, 0x03, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 
  0x00, 0xD8, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x07, 0x25, 0x01, 0xCE, 0x09, 0x65, 0x6D, 0x69, 
  0x74, 0x2D, 0x63, 0x6F, 0x64, 0x65, 0xDA, 0x18, 0xDA, 0x81, 0x4F, 0xDA, 0x81, 0x50, 0xDA, 0x81, 
  0x51, 0xDA, 0x81, 0x38, 0xDA, 0x81, 0x52, 0xDA, 0x81, 0x57, 0xDA, 0x81, 0x65, 0x2C, 0x02, 0x00, 
  0x00, 0x29, 0x04, 0x04, 0x00, 0x06, 0x03, 0x04, 0x01, 0x2A, 0x04, 0x00, 0x00, 0x30, 0x04, 0x03, 
  0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x30, 0x03, 0x04, 
  0x00, 0x2A, 0x05, 0x03, 0x00, 0x33, 0x03, 0x05, 0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x06, 0x04, 
  0x00, 0x06, 0x05, 0x06, 0x01, 0x2F, 0x05, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x3C, 0x33, 0x06, 0x07, 
  0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 0x05, 0x04, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x33, 0x05, 0x07, 
  0x00, 0x2B, 0x07, 0x00, 0x39, 0x30, 0x07, 0x05, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x33, 0x07, 0x08, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x06, 0x00, 0x33, 0x05, 0x08, 0x00, 0x29, 0x09, 0x0A, 
  0x00, 0x23, 0x08, 0x09, 0x05, 0x1C, 0x08, 0x05, 0x00, 0x29, 0x05, 0x00, 0x00, 0x2D, 0x05, 0x00, 
  0x3A, 0x2B, 0x05, 0x00, 0x3A, 0x03, 0x05, 0x00, 0x00, 0x2B, 0x05, 0x00, 0x3E, 0x34, 0x05, 0x00, 
  0x00, 0xBF, 0xFF, 0x8C, 0x98, 0x03, 0x02, 0x36, 0x00, 0x36, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 
  0x00, 0x23, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0xCD, 0x00, 
  0xD8, 0x00, 0x00, 0x12, 0x02, 0x02, 0x02, 0x0D, 0x80, 0x80, 0x01, 0xCE, 0x09, 0x65, 0x6D, 0x69, 
  0x74, 0x2D, 0x6E, 0x6F, 0x64, 0x65, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 
  0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x06, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x3F, 0xDA, 0x18, 0xDA, 
  0x1C, 0xDA, 0x76, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x70, 
  0x01, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0xDA, 0x81, 0x4F, 
  0xDA, 0x81, 0x50, 0xDA, 0x81, 0x51, 0xDA, 0x81, 0x38, 0xDA, 0x81, 0x52, 0xDA, 0x81, 0x5A, 0xDA, 
  0x81, 0x5E, 0xCE, 0x02, 0x2A, 0x20, 0xDA, 0x81, 0x5F, 0xCE, 0x04, 0x25, 0x64, 0x2E, 0x20, 0xDA, 
  0x46, 0xDA, 0x81, 0x53, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x3C, 
  0x33, 0x03, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 
  0x1C, 0x04, 0x1E, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x30, 0x05, 0x01, 0x00, 0x2A, 0x06, 0x02, 0x00, 
  0x33, 0x05, 0x06, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x30, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x04, 0x00, 
  0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 0x00, 0x26, 0x07, 0x00, 0x00, 0x47, 0x06, 0x00, 0x07, 
  0x19, 0x07, 0x06, 0x00, 0x1D, 0x07, 0x0F, 0x00, 0x38, 0x06, 0x00, 0x07, 0x3B, 0x08, 0x06, 0x00, 
  0x19, 0x09, 0x08, 0x00, 0x3B, 0x08, 0x06, 0x01, 0x19, 0x0A, 0x08, 0x00, 0x2A, 0x06, 0x03, 0x00, 
  0x31, 0x06, 0x05, 0x09, 0x2A, 0x08, 0x05, 0x00, 0x33, 0x06, 0x08, 0x00, 0x31, 0x06, 0x01, 0x0A, 
  0x2B, 0x0B, 0x00, 0x40, 0x33, 0x08, 0x0B, 0x00, 0x47, 0x07, 0x00, 0x07, 0x1A, 0xF2, 0xFF, 0xFF, 
  0x2B, 0x06, 0x00, 0x3E, 0x34, 0x06, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x06, 0x06, 0x00, 
  0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x07, 0x00, 0x23, 0x05, 0x06, 0x07, 
  0x1C, 0x05, 0x23, 0x00, 0x29, 0x07, 0x01, 0x00, 0x3D, 0x08, 0x00, 0x00, 0x19, 0x09, 0x08, 0x00, 
  0x21, 0x08, 0x07, 0x09, 0x1C, 0x08, 0x1D, 0x00, 0x19, 0x0A, 0x07, 0x00, 0x20, 0x0B, 0x0A, 0x01, 
  0x1C, 0x0B, 0x05, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x0D, 0x00, 0x3C, 0x33, 0x0C, 0x0D, 0x00, 
  0x1A, 0x01, 0x00, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x26, 0x0C, 0x00, 0x00, 0x30, 0x0B, 0x0C, 0x00, 
  0x2B, 0x0C, 0x00, 0x40, 0x33, 0x0B, 0x0C, 0x00, 0x39, 0x0B, 0x00, 0x0A, 0x19, 0x0C, 0x0B, 0x00, 
  0x26, 0x0D, 0x00, 0x00, 0x47, 0x0B, 0x0C, 0x0D, 0x19, 0x0D, 0x0B, 0x00, 0x1D, 0x0D, 0x09, 0x00, 
  0x38, 0x0B, 0x0C, 0x0D, 0x19, 0x0E, 0x0B, 0x00, 0x29, 0x0F, 0x02, 0x00, 0x06, 0x0B, 0x0F, 0x01, 
  0x30, 0x0E, 0x0B, 0x00, 0x33, 0x0F, 0x02, 0x00, 0x47, 0x0D, 0x0C, 0x0D, 0x1A, 0xF8, 0xFF, 0xFF, 
  0x05, 0x07, 0x07, 0x01, 0x1A, 0xE3, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x09, 0x00, 
  0x23, 0x07, 0x06, 0x08, 0x1C, 0x07, 0x27, 0x00, 0x29, 0x08, 0x01, 0x00, 0x3D, 0x09, 0x00, 0x00, 
  0x19, 0x0A, 0x09, 0x00, 0x21, 0x09, 0x08, 0x0A, 0x1C, 0x09, 0x21, 0x00, 0x19, 0x0B, 0x08, 0x00, 
  0x20, 0x0C, 0x0B, 0x01, 0x1C, 0x0C, 0x05, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x0E, 0x00, 0x3C, 
  0x33, 0x0D, 0x0E, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x0C, 0x0A, 0x00, 0x30, 0x0C, 0x0B, 0x00, 
  0x2A, 0x0D, 0x0B, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x19, 0x0D, 0x0C, 0x00, 0x26, 0x0C, 0x00, 0x00, 
  0x30, 0x0D, 0x0C, 0x00, 0x2B, 0x0E, 0x00, 0x40, 0x33, 0x0C, 0x0E, 0x00, 0x39, 0x0C, 0x00, 0x0B, 
  0x19, 0x0E, 0x0C, 0x00, 0x26, 0x0F, 0x00, 0x00, 0x47, 0x0C, 0x0E, 0x0F, 0x19, 0x0F, 0x0C, 0x00, 
  0x1D, 0x0F, 0x09, 0x00, 0x38, 0x0C, 0x0E, 0x0F, 0x19, 0x10, 0x0C, 0x00, 0x3D, 0x0C, 0x0D, 0x00, 
  0x06, 0x11, 0x0C, 0x01, 0x30, 0x10, 0x11, 0x00, 0x33, 0x0C, 0x02, 0x00, 0x47, 0x0F, 0x0E, 0x0F, 
  0x1A, 0xF8, 0xFF, 0xFF, 0x05, 0x08, 0x08, 0x01, 0x1A, 0xDF, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 
  0x2A, 0x09, 0x0C, 0x00, 0x23, 0x08, 0x06, 0x09, 0x1C, 0x08, 0x06, 0x00, 0x29, 0x0A, 0x01, 0x00, 
  0x39, 0x09, 0x00, 0x0A, 0x30, 0x09, 0x01, 0x00, 0x2B, 0x0A, 0x00, 0x42, 0x34, 0x0A, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8C, 0xA1, 0x03, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0xBF, 0xFF, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFF, 0x09, 0x00, 0x09, 0x05, 
  0x09, 0x00, 0x09, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x01, 0x0D, 0x00, 0x16, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x13, 0x00, 
  0x0F, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0F, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x01, 0x1B, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x37, 0x00, 0x37, 0x00, 0x26, 0x00, 0x26, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 
  0xFD, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 0x05, 0x0D, 0x00, 
  0x16, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x13, 0x00, 0x0F, 0x00, 0x1B, 0x00, 
  0x1B, 0x00, 0x1B, 0x00, 0x0F, 0x01, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x0F, 0x01, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x1B, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x3A, 0x00, 0x37, 0x00, 0x26, 0x00, 0x26, 0x00, 
  0x0F, 0x00, 0x0F, 0xBF, 0xFC, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFB, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x0A, 0x18, 0x00, 0x18, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xF6, 0x07, 0x8B, 0xB4, 
  0x01, 0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 
  0x15, 0x00, 0x12, 0x00, 0x03, 0x01, 0x16, 0x00, 0x16, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x02, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xBF, 0xFE, 0x12, 0x00, 0x03, 0x06, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x0A, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x07, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x02, 0x03, 0x00, 0x03, 0x04, 0x03, 0x00, 0x03, 0x07, 0x03, 0x00, 
  0x03, 0x06, 0x03, 0x00, 0x03, 0x07, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x06, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 0x02, 0x03, 0x00, 0x03, 0x16, 0x03, 0x00, 0x03, 0x06, 
  0x03, 0x00, 0x03, 0x0D, 0x03, 0x00, 0x03, 0x0B, 0x03, 0x00, 0x03, 0x22, 0x05, 0x1A, 0x16, 0x00, 
  0x16, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x01, 0x05, 0x01, 0x29, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x05, 0x01, 
  0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x05, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 
  0x32, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFB, 0x03, 
  0x07, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 
  0x03, 0x03, 0x00, 0x03, 0x06, 0x03, 0x00, 0x03, 0x04, 0x03, 0x00, 0x03, 0x0F, 0x03, 0x00, 0x03, 
  0x09, 0x03, 0x00, 0x03, 0x17, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x05, 0x01, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0xBE, 0xFC, 0x01, 0x81, 0x54, 
  0xAB, 0xAA, 0xAA, 0x55, 0x55, 0x56, 0x05, 0x00, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x81, 0x1F, 0x28, 
  0x64, 0x6F, 0x63, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x77, 0x69, 0x64, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x6E, 0x74, 
  0x20, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x66, 0x6F, 
  0x72, 0x6D, 0x61, 0x74, 0x20, 0x61, 0x20, 0x64, 0x6F, 0x63, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x61, 0x70, 0x20, 0x61, 0x20, 0x63, 0x65, 0x72, 0x74, 0x61, 
  0x69, 0x6E, 0x20, 0x77, 0x69, 0x64, 0x74, 0x68, 0x2E, 0x20, 0x44, 0x6F, 0x63, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 
  0x62, 0x65, 0x20, 0x70, 0x6C, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x0A, 0x6F, 0x72, 0x20, 
  0x61, 0x20, 0x73, 0x75, 0x62, 0x73, 0x65, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x6D, 0x61, 0x72, 0x6B, 
  0x64, 0x6F, 0x77, 0x6E, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 
  0x73, 0x20, 0x61, 0x20, 0x6C, 0x6F, 0x6E, 0x67, 0x20, 0x73, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 
  0x6C, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x72, 0x6F, 0x73, 0x65, 0x20, 0x6F, 0x72, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x65, 0x64, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 
  0x74, 0x6F, 0x20, 0x62, 0x65, 0x0A, 0x61, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x2D, 0x66, 0x6F, 0x72, 
  0x6D, 0x65, 0x64, 0x20, 0x64, 0x6F, 0x63, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x65, 0x64, 0x20, 0x74, 0x65, 0x78, 0x74, 0x2E, 0xCF, 0x09, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x32, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x80, 0xA4, 0x81, 0x19, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 
  0x6F, 0x67, 0x32, 0xDA, 0x08, 0xCE, 0x2B, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 
  0x32, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6C, 0x6F, 0x67, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x32, 0x20, 0x6F, 0x66, 0x20, 
  0x78, 0x2E, 0xCF, 0x04, 0x77, 0x68, 0x65, 0x6E, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x80, 0xBC, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x01, 0x01, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x09, 0xCE, 0x04, 0x77, 0x68, 0x65, 0x6E, 0xDA, 0x18, 0xDA, 
  0x4A, 0xDA, 0x49, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x32, 
  0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 
  0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0xBC, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x5E, 0x28, 0x77, 
  0x68, 0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x26, 0x20, 
  0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 
  0x74, 0x72, 0x75, 0x65, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 
  0x07, 0x70, 0x72, 0x65, 0x77, 0x61, 0x6C, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x85, 0x30, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x06, 0x02, 0x02, 
  0x02, 0x01, 0x07, 0x01, 0xCE, 0x07, 0x70, 0x72, 0x65, 0x77, 0x61, 0x6C, 0x6B, 0xDA, 0x18, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x02, 0x02, 0x02, 0x0C, 0x2E, 0xCE, 0x04, 0x77, 0x61, 
  0x6C, 0x6B, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x75, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 
  0x02, 0x02, 0x02, 0x00, 0x11, 0xCE, 0x09, 0x77, 0x61, 0x6C, 0x6B, 0x2D, 0x64, 0x69, 0x63, 0x74, 
  0xDA, 0x18, 0x2C, 0x02, 0x00, 0x00, 0x42, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 
  0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 0x0A, 0x00, 0x19, 0x05, 
  0x06, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x33, 0x07, 0x00, 0x00, 0x38, 0x08, 0x01, 0x05, 0x2F, 0x08, 
  0x00, 0x00, 0x33, 0x09, 0x00, 0x00, 0x3A, 0x04, 0x07, 0x09, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xF7, 
  0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x85, 0x14, 0x01, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x17, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFE, 0x01, 0xDA, 0x74, 0xD8, 0x0F, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x2F, 0x74, 0x6F, 0x2D, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0xDA, 0x55, 
  0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x01, 0x11, 0xCE, 0x08, 0x77, 
  0x61, 0x6C, 0x6B, 0x2D, 0x69, 0x6E, 0x64, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 
  0x3E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 
  0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 0x0A, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 
  0x2F, 0x07, 0x00, 0x00, 0x33, 0x05, 0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x09, 0x00, 0x00, 
  0x33, 0x08, 0x09, 0x00, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 
  0x85, 0x0F, 0x01, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x20, 0x00, 0x20, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 
  0x03, 0xBF, 0xFE, 0x01, 0xDA, 0x76, 0xDA, 0x80, 0xAC, 0xD0, 0x06, 0x70, 0x61, 0x72, 0x65, 0x6E, 
  0x73, 0xDA, 0x80, 0xE4, 0xD8, 0x0E, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x62, 0x72, 0x61, 0x63, 
  0x6B, 0x65, 0x74, 0x73, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 0x03, 0x04, 0x05, 
  0x1C, 0x03, 0x04, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x34, 0x05, 0x00, 0x00, 
  0x2A, 0x06, 0x03, 0x00, 0x23, 0x05, 0x04, 0x06, 0x1C, 0x05, 0x07, 0x00, 0x30, 0x00, 0x01, 0x00, 
  0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 
  0x34, 0x07, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x23, 0x06, 0x04, 0x07, 0x1C, 0x06, 0x04, 0x00, 
  0x30, 0x00, 0x01, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x34, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 
  0x23, 0x07, 0x04, 0x08, 0x1C, 0x07, 0x11, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x09, 0x06, 0x00, 
  0x33, 0x08, 0x09, 0x00, 0x19, 0x09, 0x08, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0A, 0x08, 0x00, 
  0x33, 0x08, 0x0A, 0x00, 0x2A, 0x0B, 0x09, 0x00, 0x23, 0x0A, 0x0B, 0x08, 0x1C, 0x0A, 0x04, 0x00, 
  0x2F, 0x09, 0x00, 0x00, 0x2A, 0x08, 0x0A, 0x00, 0x34, 0x08, 0x00, 0x00, 0x32, 0x09, 0x00, 0x00, 
  0x2A, 0x08, 0x0B, 0x00, 0x34, 0x08, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x85, 0x1A, 0x01, 0x06, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 
  0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 0x04, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x0C, 0x01, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0E, 0x01, 0x10, 
  0x00, 0x10, 0x00, 0x10, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xF9, 0x03, 0x2C, 0x02, 0x00, 
  0x00, 0x2E, 0x03, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x33, 0x04, 0x00, 0x00, 0x30, 0x03, 0x04, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x01, 
  0x01, 0x01, 0x00, 0x04, 0x01, 0xDA, 0x18, 0x2B, 0x01, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2B, 
  0x01, 0x00, 0x02, 0x34, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0x33, 0x11, 0x00, 0x11, 0x00, 0x11, 
  0x00, 0x11, 0x85, 0x30, 0x01, 0x03, 0x09, 0x00, 0x20, 0x00, 0x20, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x05, 0x00, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x44, 0x28, 0x70, 0x72, 0x65, 0x77, 0x61, 0x6C, 
  0x6B, 0x20, 0x66, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 
  0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x70, 0x6F, 0x73, 0x74, 0x77, 0x61, 0x6C, 0x6B, 0x60, 
  0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x2D, 0x6F, 0x72, 0x64, 
  0x65, 0x72, 0x20, 0x74, 0x72, 0x61, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x2E, 0xCF, 0x07, 0x2A, 
  0x72, 0x65, 0x64, 0x65, 0x66, 0x2A, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x84, 0xB1, 0x01, 0xDA, 0x06, 0xD0, 0x05, 0x72, 0x65, 0x64, 0x65, 0x66, 0xDA, 
  0x08, 0xCE, 0x7A, 0x57, 0x68, 0x65, 0x6E, 0x20, 0x73, 0x65, 0x74, 0x2C, 0x20, 0x61, 0x6C, 0x6C, 
  0x6F, 0x77, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x72, 
  0x65, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x70, 0x20, 0x6C, 0x65, 0x76, 
  0x65, 0x6C, 0x20, 0x64, 0x65, 0x66, 0x73, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x6C, 
  0x6F, 0x77, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x64, 
  0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x6E, 0x64, 0x65, 
  0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x64, 0x65, 0x76, 0x65, 0x6C, 0x6F, 0x70, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xCF, 0x08, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 
  0xA4, 0x81, 0x11, 0x01, 0xDA, 0x06, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 
  0xDA, 0x08, 0xCE, 0x27, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 
  0x6E, 0x67, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xCF, 0x03, 0x6D, 0x69, 0x6E, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xDB, 0x01, 0xDA, 0x06, 0xDA, 0x81, 
  0x45, 0xDA, 0x08, 0xCE, 0x3B, 0x28, 0x6D, 0x69, 0x6E, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 
  0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 
  0x75, 0x6D, 0x65, 0x72, 0x69, 0x63, 0x20, 0x6D, 0x69, 0x6E, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 
  0xCF, 0x02, 0x2F, 0x3D, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0x9B, 0x01, 
  0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 0x08, 0xCE, 
  0x02, 0x2F, 0x3D, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x0C, 0x06, 0x00, 0x00, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x01, 0x2F, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 
  0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 
  0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x0B, 0x03, 0x03, 
  0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 
  0x05, 0x0B, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 
  0xFF, 0x03, 0x03, 0x00, 0x00, 0xDA, 0x29, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 
  0x04, 0x00, 0x01, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 
  0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0x9B, 0x01, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 
  0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0xDA, 0x08, 0xCE, 0x28, 0x28, 0x2F, 0x3D, 0x20, 
  0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x28, 0x73, 0x65, 0x74, 0x20, 0x78, 0x20, 0x28, 0x2F, 0x20, 0x78, 0x20, 
  0x6E, 0x29, 0x29, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x04, 0x6E, 0x6F, 0x74, 0x3D, 0xD3, 0x02, 0xDA, 
  0x06, 0xDA, 0x80, 0xBF, 0xDA, 0x08, 0xCE, 0x48, 0x28, 0x6E, 0x6F, 0x74, 0x3D, 0x20, 0x26, 0x20, 
  0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 
  0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 
  0xCF, 0x09, 0x66, 0x66, 0x69, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x0C, 0x85, 0x5A, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x66, 0x66, 0x69, 0x2F, 0x77, 
  0x72, 0x69, 0x74, 0x65, 0xDA, 0x08, 0xCE, 0x81, 0x1F, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x77, 0x72, 
  0x69, 0x74, 0x65, 0x20, 0x66, 0x66, 0x69, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x20, 0x64, 0x61, 0x74, 
  0x61, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x29, 0x0A, 0x0A, 
  0x41, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 
  0x74, 0x79, 0x65, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x69, 0x74, 0x20, 0x77, 0x6F, 0x75, 0x6C, 
  0x64, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 
  0x72, 0x79, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 
  0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x6F, 0x69, 
  0x6E, 0x74, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x66, 0x69, 0x2C, 0x20, 0x6F, 0x72, 0x20, 
  0x73, 0x65, 0x6E, 0x64, 0x20, 0x43, 0x2F, 0x43, 0x2B, 0x2B, 0x2F, 0x6E, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x6F, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x20, 0x69, 0x66, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x73, 
  0x75, 0x70, 0x70, 0x6C, 0x69, 0x65, 0x64, 0x2E, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x73, 0x70, 0x61, 
  0x77, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x84, 0x5D, 0x01, 0xDA, 0x06, 
  0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x73, 0x70, 0x61, 0x77, 0x6E, 0xDA, 0x08, 0xCE, 0x82, 0x42, 0x28, 
  0x6F, 0x73, 0x2F, 0x73, 0x70, 0x61, 0x77, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x73, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x65, 0x6E, 0x76, 0x29, 0x0A, 0x0A, 0x45, 
  0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 
  0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x68, 0x61, 0x6E, 0x64, 
  0x6C, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 
  0x73, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x74, 0x61, 
  0x6B, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x72, 0x67, 
  0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x73, 0x20, 0x60, 0x6F, 0x73, 0x2F, 0x65, 0x78, 
  0x65, 0x63, 0x75, 0x74, 0x65, 0x60, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 
  0x20, 0x77, 0x61, 0x69, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 
  0x6F, 0x63, 0x65, 0x73, 0x73, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x69, 0x6E, 0x2C, 0x20, 0x3A, 0x6F, 0x75, 0x74, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x65, 0x6E, 0x76, 0x60, 0x20, 0x61, 0x72, 0x67, 
  0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 
  0x6C, 0x73, 0x6F, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x60, 0x3A, 0x70, 0x69, 0x70, 0x65, 0x60, 0x20, 
  0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x73, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x49, 0x4F, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x61, 
  0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 
  0x65, 0x6E, 0x20, 0x74, 0x6F, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x60, 0x70, 0x72, 0x6F, 0x63, 0x60, 
  0x20, 0x68, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6C, 0x64, 0x73, 0x20, 
  0x3A, 0x69, 0x6E, 0x2C, 0x20, 0x3A, 0x6F, 0x75, 0x74, 0x2C, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x2C, 
  0x20, 0x3A, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x2D, 0x63, 0x6F, 0x64, 0x65, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 
  0x6C, 0x20, 0x66, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x3A, 0x70, 0x69, 0x64, 0x20, 0x6F, 0x6E, 0x20, 
  0x75, 0x6E, 0x69, 0x78, 0x2D, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 
  0x72, 0x6D, 0x73, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x20, 0x60, 0x28, 0x6F, 0x73, 0x2F, 0x70, 0x72, 
  0x6F, 0x63, 0x2D, 0x77, 0x61, 0x69, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x29, 0x60, 0x20, 0x74, 
  0x6F, 0x20, 0x72, 0x65, 0x6A, 0x6F, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 
  0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x60, 0x28, 0x6F, 0x73, 0x2F, 
  0x70, 0x72, 0x6F, 0x63, 0x2D, 0x6B, 0x69, 0x6C, 0x6C, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x29, 0x60, 
  0x2E, 0xCF, 0x09, 0x77, 0x68, 0x65, 0x6E, 0x2D, 0x77, 0x69, 0x74, 0x68, 0xD3, 0x04, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x86, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x17, 0xCE, 0x09, 0x77, 0x68, 0x65, 
  0x6E, 0x2D, 0x77, 0x69, 0x74, 0x68, 0xDA, 0x18, 0xD0, 0x05, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xD7, 
  0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0B, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x0C, 0x2C, 
  0xCE, 0x05, 0x64, 0x65, 0x66, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x80, 0xB9, 0xDA, 0x80, 
  0xBA, 0xDA, 0x80, 0xD4, 0xDA, 0x44, 0xDA, 0x80, 0xBC, 0xDA, 0x80, 0xBE, 0xDA, 0x80, 0xD5, 0xDA, 
  0x80, 0xD6, 0xDA, 0x80, 0xD7, 0xDA, 0x49, 0xDA, 0x4A, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x03, 0x05, 
  0x00, 0x19, 0x05, 0x03, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x30, 0x07, 0x03, 
  0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x2A, 0x08, 0x03, 
  0x00, 0x31, 0x07, 0x06, 0x08, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x31, 0x07, 0x04, 
  0x03, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x30, 0x07, 0x04, 0x00, 0x43, 0x03, 0x00, 
  0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x08, 0x05, 0x03, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x06, 
  0x00, 0x30, 0x08, 0x04, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x07, 0x00, 0x2A, 0x0A, 0x08, 
  0x00, 0x31, 0x09, 0x03, 0x0A, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x09, 0x00, 0x31, 0x09, 0x05, 
  0x04, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 0x0A, 0x00, 0x31, 0x0A, 0x08, 0x05, 0x2F, 0x03, 0x00, 
  0x00, 0x43, 0x09, 0x00, 0x00, 0x2A, 0x08, 0x0B, 0x00, 0x31, 0x08, 0x06, 0x07, 0x30, 0x00, 0x09, 
  0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x81, 0x42, 0x01, 0x04, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xDA, 0x67, 0x3B, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x3B, 0x02, 0x00, 0x01, 
  0x19, 0x04, 0x02, 0x00, 0x3B, 0x02, 0x00, 0x02, 0x19, 0x05, 0x02, 0x00, 0x2C, 0x00, 0x00, 0x00, 
  0x30, 0x03, 0x04, 0x00, 0x44, 0x02, 0x00, 0x00, 0x1C, 0x05, 0x03, 0x00, 0x19, 0x06, 0x05, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x30, 0x06, 0x03, 0x00, 0x43, 0x06, 0x00, 0x00, 
  0x2F, 0x06, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 
  0x2A, 0x08, 0x02, 0x00, 0x31, 0x08, 0x02, 0x07, 0x43, 0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 
  0x81, 0x86, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x04, 
  0x03, 0x00, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xDA, 0x08, 0xCE, 0x80, 0xA0, 0x28, 0x77, 0x68, 0x65, 0x6E, 0x2D, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x5B, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x64, 0x74, 
  0x6F, 0x72, 0x5D, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 
  0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x69, 0x74, 0x68, 0x2C, 0x20, 0x62, 0x75, 
  0x74, 0x20, 0x69, 0x66, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 
  0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x0A, 0x6E, 0x69, 0x6C, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 
  0x74, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 
  0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x77, 
  0x69, 0x74, 0x68, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x04, 0x64, 0x65, 0x66, 0x6E, 0xD3, 0x04, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x0A, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x02, 0xBB, 
  0x00, 0x00, 0x17, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x0D, 0x37, 0x01, 0xCE, 0x04, 0x64, 
  0x65, 0x66, 0x6E, 0xDA, 0x18, 0xDA, 0x81, 0x37, 0xCE, 0x01, 0x28, 0xD8, 0x06, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0xDA, 0x81, 0x4F, 0xD8, 0x12, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 
  0x75, 0x73, 0x68, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xCE, 0x02, 0x25, 0x6A, 0xD8, 0x0D, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xCE, 0x03, 0x29, 
  0x0A, 0x0A, 0xDA, 0x81, 0x38, 0xDA, 0x81, 0x4C, 0xDA, 0x80, 0xE4, 0xDA, 0x80, 0xB9, 0xDA, 0x44, 
  0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 0x00, 0x3E, 0x05, 0x00, 0x00, 
  0x19, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x2E, 0x08, 0x00, 0x00, 0x19, 0x09, 0x08, 0x00, 
  0x29, 0x0A, 0x00, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0A, 0x09, 0x00, 0x19, 0x0B, 0x0A, 0x00, 
  0x38, 0x0C, 0x01, 0x0B, 0x19, 0x0D, 0x0C, 0x00, 0x29, 0x0E, 0x00, 0x00, 0x3D, 0x0F, 0x0D, 0x00, 
  0x19, 0x10, 0x0F, 0x00, 0x2A, 0x11, 0x01, 0x00, 0x30, 0x11, 0x00, 0x00, 0x2A, 0x12, 0x02, 0x00, 
  0x33, 0x11, 0x12, 0x00, 0x19, 0x12, 0x11, 0x00, 0x21, 0x13, 0x0E, 0x10, 0x1C, 0x13, 0x0C, 0x00, 
  0x2A, 0x14, 0x03, 0x00, 0x30, 0x12, 0x14, 0x00, 0x2A, 0x15, 0x04, 0x00, 0x33, 0x14, 0x15, 0x00, 
  0x38, 0x14, 0x0D, 0x0E, 0x2A, 0x15, 0x05, 0x00, 0x31, 0x12, 0x15, 0x14, 0x2A, 0x16, 0x06, 0x00, 
  0x33, 0x15, 0x16, 0x00, 0x05, 0x0E, 0x0E, 0x01, 0x1A, 0xF4, 0xFF, 0xFF, 0x2A, 0x13, 0x07, 0x00, 
  0x31, 0x12, 0x13, 0x07, 0x2A, 0x14, 0x08, 0x00, 0x33, 0x13, 0x14, 0x00, 0x30, 0x06, 0x13, 0x00, 
  0x2A, 0x15, 0x09, 0x00, 0x33, 0x14, 0x15, 0x00, 0x30, 0x01, 0x0B, 0x00, 0x2A, 0x15, 0x0A, 0x00, 
  0x33, 0x13, 0x15, 0x00, 0x2A, 0x16, 0x0B, 0x00, 0x30, 0x16, 0x00, 0x00, 0x32, 0x13, 0x00, 0x00, 
  0x43, 0x15, 0x00, 0x00, 0x2A, 0x16, 0x0C, 0x00, 0x30, 0x16, 0x00, 0x00, 0x32, 0x06, 0x00, 0x00, 
  0x2F, 0x15, 0x00, 0x00, 0x43, 0x13, 0x00, 0x00, 0x03, 0x13, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 
  0x00, 0x09, 0x01, 0x01, 0x01, 0x04, 0x1C, 0x01, 0xCE, 0x05, 0x72, 0x65, 0x63, 0x75, 0x72, 0xDA, 
  0x18, 0xDA, 0x1C, 0xDA, 0x76, 0xDA, 0x1D, 0xDA, 0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 
  0x00, 0x01, 0x38, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x33, 0x02, 0x04, 0x00, 0x19, 0x04, 0x02, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 
  0x04, 0x06, 0x1C, 0x05, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x23, 0x06, 
  0x04, 0x07, 0x1C, 0x06, 0x03, 0x00, 0x2D, 0x03, 0x00, 0x07, 0x1A, 0x05, 0x00, 0x00, 0x2B, 0x07, 
  0x00, 0x06, 0x30, 0x07, 0x03, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2B, 0x07, 
  0x00, 0x04, 0x21, 0x06, 0x00, 0x07, 0x1C, 0x06, 0x04, 0x00, 0x05, 0x07, 0x00, 0x01, 0x2F, 0x07, 
  0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x15, 0x07, 0x01, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x09, 0x01, 0x0D, 0x00, 0x0D, 
  0x00, 0x09, 0x00, 0x09, 0x03, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x01, 0x0F, 0xBF, 0xFF, 0x0D, 0x02, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x00, 0x22, 0x00, 
  0x1B, 0x00, 0x1B, 0x00, 0x0D, 0x10, 0x03, 0x01, 0x0E, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x01, 
  0x05, 0x02, 0x07, 0xBF, 0xFF, 0x05, 0x0B, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x0F, 
  0x00, 0x05, 0x02, 0x05, 0x01, 0x11, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 
  0x00, 0x05, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x1F, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x12, 0xBF, 0xFD, 0x05, 0x04, 0x1B, 0x00, 
  0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x29, 0x00, 0x29, 0x00, 
  0x29, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0xD2, 0x00, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x57, 0x28, 0x64, 0x65, 
  0x66, 0x6E, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 
  0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x2E, 0x20, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x74, 
  0x6F, 0x20, 0x60, 0x28, 0x64, 0x65, 0x66, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x28, 0x66, 0x6E, 
  0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x5B, 0x61, 0x72, 0x67, 0x73, 0x5D, 0x20, 0x2E, 0x2E, 0x2E, 
  0x29, 0x29, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x08, 0x66, 0x66, 0x69, 0x2F, 0x73, 0x69, 0x7A, 
  0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 0x81, 0xCB, 0x01, 0xDA, 0x06, 0xD8, 
  0x08, 0x66, 0x66, 0x69, 0x2F, 0x73, 0x69, 0x7A, 0x65, 0xDA, 0x08, 0xCE, 0x36, 0x28, 0x66, 0x66, 
  0x69, 0x2F, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x29, 0x0A, 0x0A, 0x47, 0x65, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 
  0x20, 0x66, 0x66, 0x69, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x2E, 0xCF, 0x0E, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x76, 0x65, 
  0x72, 0x73, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 0x1D, 0x01, 
  0xDA, 0x06, 0xD8, 0x0E, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x76, 0x65, 0x72, 
  0x73, 0x65, 0xDA, 0x08, 0xCE, 0x4D, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 
  0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 
  0x64, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x73, 0x74, 
  0x72, 0x60, 0x2E, 0xCF, 0x06, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x85, 0xEA, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 
  0x09, 0x03, 0x03, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x09, 0xCE, 0x06, 0x75, 0x70, 0x64, 0x61, 
  0x74, 0x65, 0xDA, 0x18, 0x2C, 0x04, 0x00, 0x00, 0x39, 0x05, 0x00, 0x01, 0x19, 0x06, 0x05, 0x00, 
  0x2F, 0x06, 0x00, 0x00, 0x32, 0x03, 0x00, 0x00, 0x33, 0x07, 0x02, 0x00, 0x19, 0x08, 0x00, 0x00, 
  0x3A, 0x08, 0x01, 0x07, 0x03, 0x08, 0x00, 0x00, 0x85, 0xEA, 0x01, 0x05, 0x0C, 0x00, 0x03, 0x01, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x80, 0xF1, 
  0x28, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x64, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x46, 0x6F, 0x72, 
  0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x6E, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x60, 
  0x64, 0x73, 0x60, 0x2C, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x69, 0x74, 0x73, 
  0x20, 0x63, 0x6F, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x0A, 0x72, 0x65, 
  0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 
  0x60, 0x66, 0x75, 0x6E, 0x63, 0x60, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x61, 0x72, 0x67, 0x73, 0x60, 0x20, 
  0x61, 0x72, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x74, 0x68, 
  0x65, 0x79, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 
  0x64, 0x0A, 0x61, 0x6C, 0x6F, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x66, 0x75, 0x6E, 0x63, 
  0x60, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x60, 0x64, 0x73, 0x60, 0x2C, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 
  0x2E, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0x6D, 0x31, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x16, 0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0x6D, 0x31, 0xDA, 0x08, 0xCE, 0x34, 0x28, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x65, 0x78, 0x70, 0x6D, 0x31, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6F, 0x77, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x20, 0x6D, 0x69, 0x6E, 0x75, 0x73, 0x20, 0x31, 0x2E, 
  0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2D, 0x75, 
  0x70, 0x70, 0x65, 0x72, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 0x0C, 
  0x01, 0xDA, 0x06, 0xD8, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 
  0x69, 0x2D, 0x75, 0x70, 0x70, 0x65, 0x72, 0xDA, 0x08, 0xCE, 0x80, 0xBE, 0x28, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2D, 0x75, 0x70, 0x70, 0x65, 0x72, 0x20, 
  0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 
  0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x75, 0x70, 0x70, 0x65, 0x72, 0x63, 0x61, 0x73, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 
  0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6D, 0x73, 0x65, 0x6C, 0x76, 0x65, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x41, 0x53, 0x43, 0x49, 0x49, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 
  0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20, 0x73, 0x69, 0x6D, 0x70, 
  0x6C, 0x65, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2C, 0x20, 0x6D, 
  0x65, 0x61, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x6F, 0x20, 0x75, 0x6E, 0x69, 0x63, 0x6F, 0x64, 
  0x65, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x2E, 0xCF, 0x0F, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x2F, 0x74, 0x6F, 0x2D, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x80, 0xB0, 0x81, 0x4E, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x82, 0xDA, 0x08, 0xCE, 
  0x80, 0x84, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x74, 0x6F, 0x2D, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x20, 0x74, 0x61, 0x62, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 
  0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x63, 0x63, 
  0x6F, 0x75, 0x6E, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x73, 0x2E, 0xCF, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x80, 0xDD, 
  0x01, 0xDA, 0x06, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0xDA, 0x08, 0xCE, 0x57, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x67, 0x65, 0x72, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0xCF, 0x07, 0x65, 0x76, 
  0x2F, 0x67, 0x69, 0x76, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x83, 0xBB, 
  0x01, 0xDA, 0x06, 0xD8, 0x07, 0x65, 0x76, 0x2F, 0x67, 0x69, 0x76, 0x65, 0xDA, 0x08, 0xCE, 0x80, 
  0xA4, 0x28, 0x65, 0x76, 0x2F, 0x67, 0x69, 0x76, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 
  0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x57, 0x72, 0x69, 0x74, 0x65, 0x20, 
  0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x63, 0x68, 0x61, 
  0x6E, 0x6E, 0x65, 0x6C, 0x2C, 0x20, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 
  0x6C, 0x20, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x69, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x73, 0x75, 0x63, 0x63, 
  0x65, 0x65, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 
  0x77, 0x69, 0x73, 0x65, 0x2E, 0xCF, 0x0C, 0x2A, 0x65, 0x78, 0x69, 0x74, 0x2D, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x2A, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 
  0x84, 0xB4, 0x01, 0xDA, 0x06, 0xD0, 0x0A, 0x65, 0x78, 0x69, 0x74, 0x2D, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0xDA, 0x08, 0xCE, 0x60, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x60, 
  0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x60, 0x20, 0x75, 0x70, 0x6F, 
  0x6E, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x69, 0x74, 0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 
  0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x60, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 
  0x65, 0x78, 0x74, 0x60, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xCF, 0x0C, 0x2A, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0x66, 0x6F, 
  0x72, 0x6D, 0x2A, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 
  0x84, 0xB6, 0x01, 0xDA, 0x06, 0xD0, 0x0A, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0x66, 0x6F, 0x72, 
  0x6D, 0xDA, 0x08, 0xCE, 0x42, 0x49, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x61, 0x20, 0x6D, 0x61, 
  0x63, 0x72, 0x6F, 0x2C, 0x20, 0x69, 0x73, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x76, 0x6F, 0x6B, 0x65, 0x64, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0xCF, 0x04, 0x2D, 0x3F, 0x3E, 0x3E, 0xD3, 0x04, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xFF, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0xB9, 
  0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x06, 0x01, 0xCE, 0x04, 0x2D, 
  0x3F, 0x3E, 0x3E, 0xDA, 0x18, 0xDA, 0x80, 0xDF, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 
  0x19, 0x04, 0x03, 0x00, 0x31, 0x04, 0x00, 0x01, 0x2A, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x09, 0x33, 0xDA, 0x80, 0xE1, 0xDA, 0x18, 
  0xDA, 0x1C, 0xDA, 0x76, 0xDA, 0x80, 0xE2, 0xDA, 0x78, 0xDA, 0x43, 0xDA, 0x80, 0xE3, 0xDA, 0x80, 
  0xE4, 0xDA, 0x49, 0xDA, 0x80, 0xC2, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x05, 
  0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 
  0x0C, 0x00, 0x29, 0x06, 0x00, 0x00, 0x38, 0x04, 0x01, 0x06, 0x29, 0x06, 0x01, 0x00, 0x30, 0x01, 
  0x06, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 
  0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x03, 0x07, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x3E, 0x04, 
  0x00, 0x00, 0x30, 0x01, 0x04, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x03, 
  0x06, 0x00, 0x3B, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3B, 0x04, 0x03, 0x01, 0x19, 0x06, 
  0x04, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x33, 0x04, 0x07, 0x00, 0x19, 0x07, 0x04, 0x00, 0x2F, 0x05, 
  0x00, 0x00, 0x3E, 0x08, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x3E, 0x09, 0x00, 0x00, 0x31, 0x08, 
  0x06, 0x09, 0x2A, 0x0B, 0x05, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x08, 0x0A, 0x00, 0x30, 0x07, 
  0x00, 0x00, 0x44, 0x09, 0x00, 0x00, 0x29, 0x0B, 0x00, 0x00, 0x30, 0x08, 0x0B, 0x00, 0x2A, 0x0C, 
  0x06, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x2A, 0x0D, 0x07, 0x00, 0x31, 0x0D, 0x07, 0x0B, 0x43, 0x0C, 
  0x00, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x31, 0x0D, 0x09, 0x0C, 0x43, 0x0B, 0x00, 0x00, 0x03, 0x0B, 
  0x00, 0x00, 0x85, 0x06, 0x03, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x10, 0x01, 0x19, 0x00, 0x19, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0xBF, 0xFF, 0x10, 0x00, 0x10, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0xBF, 0xFE, 0x10, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x0E, 0x00, 0x0E, 0x00, 
  0x05, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x84, 0xFF, 0x01, 0x07, 0x03, 
  0x00, 0x03, 0x07, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x81, 0x29, 0x28, 0x2D, 0x3F, 
  0x3E, 0x3E, 0x20, 0x78, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x53, 
  0x68, 0x6F, 0x72, 0x74, 0x20, 0x63, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x20, 0x74, 0x68, 0x72, 
  0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x49, 0x6E, 
  0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x78, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 
  0x61, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x0A, 0x69, 0x6E, 0x20, 0x60, 
  0x66, 0x6F, 0x72, 0x6D, 0x73, 0x60, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x69, 0x6E, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x0A, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x6D, 0x61, 0x6E, 
  0x6E, 0x65, 0x72, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x6F, 0x20, 0x6F, 0x6E, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x0A, 0x69, 0x66, 0x20, 
  0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x0A, 0x55, 0x73, 
  0x65, 0x66, 0x75, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x6F, 0x66, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x0A, 0x66, 0x66, 0x69, 0x2F, 0x6E, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 0x85, 0x98, 
  0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x66, 0x66, 0x69, 0x2F, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0xDA, 
  0x08, 0xCE, 0x81, 0x1C, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x61, 0x64, 
  0x20, 0x61, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 
  0x20, 0x6F, 0x72, 0x20, 0x64, 0x6C, 0x6C, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2C, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 
  0x6F, 0x72, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x69, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 
  0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 
  0x60, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x60, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 
  0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x74, 0x6F, 0x20, 
  0x67, 0x65, 0x74, 0x20, 0x61, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x70, 0x61, 0x74, 0x68, 0x60, 0x20, 0x69, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 
  0x62, 0x69, 0x6E, 0x61, 0x72, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x60, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x60, 0x2E, 
  0xCF, 0x07, 0x62, 0x6C, 0x73, 0x68, 0x69, 0x66, 0x74, 0xD3, 0x02, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 
  0x00, 0x09, 0x00, 0x10, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x07, 
  0x62, 0x6C, 0x73, 0x68, 0x69, 0x66, 0x74, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 
  0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 
  0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x12, 0x03, 0x03, 0x04, 0x03, 
  0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x12, 
  0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 
  0x03, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x80, 0x91, 0x28, 0x62, 0x6C, 0x73, 0x68, 0x69, 0x66, 0x74, 
  0x20, 0x78, 0x20, 0x26, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x6F, 0x66, 0x20, 0x78, 0x20, 0x62, 0x69, 0x74, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x65, 0x64, 
  0x20, 0x6C, 0x65, 0x66, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 
  0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x73, 0x2E, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 
  0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 
  0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0xCF, 0x0E, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x2F, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xCE, 0x10, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x2E, 0x63, 0x83, 0x8E, 0x01, 0xDA, 0x06, 0xD8, 0x0E, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 
  0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0xDA, 0x08, 0xCE, 0x80, 0xD3, 0x28, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x2F, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x6D, 
  0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x2E, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x73, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x67, 0x69, 0x76, 0x65, 
  0x6E, 0x20, 0x62, 0x79, 0x20, 0x60, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x60, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2E, 0xCF, 
  0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x66, 0x6C, 0x6F, 0x6F, 0x72, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x1E, 0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x66, 0x6C, 0x6F, 0x6F, 0x72, 0xDA, 0x08, 0xCE, 0x54, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x66, 0x6C, 0x6F, 0x6F, 0x72, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65, 0x73, 0x74, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x67, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x78, 0x2E, 0xCF, 0x0D, 
  0x2A, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0x6C, 0x69, 0x6E, 0x74, 0x73, 0x2A, 0xD3, 0x04, 0xDA, 
  0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x87, 0x9C, 0x01, 0xDA, 0x06, 0xD0, 
  0x0B, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0x6C, 0x69, 0x6E, 0x74, 0x73, 0xDA, 0x08, 0xCE, 0x80, 
  0x9F, 0x42, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x6C, 0x69, 0x6E, 0x74, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 
  0x67, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 
  0x20, 0x72, 0x65, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 
  0x20, 0x61, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x0A, 0x54, 0x6F, 0x20, 0x69, 0x6E, 0x64, 
  0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 
  0x72, 0x20, 0x77, 0x61, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x61, 0x20, 0x6D, 0x61, 0x63, 
  0x72, 0x6F, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 
  0x20, 0x75, 0x73, 0x65, 0x20, 0x60, 0x6D, 0x61, 0x63, 0x6C, 0x69, 0x6E, 0x74, 0x66, 0x60, 0x2E, 
  0xCF, 0x07, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xCE, 0x10, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x6D, 0x61, 0x72, 0x73, 0x68, 
  0x2E, 0x63, 0x85, 0xCF, 0x01, 0xDA, 0x06, 0xD8, 0x07, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 
  0xDA, 0x08, 0xCE, 0x81, 0x7A, 0x28, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x78, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x2D, 0x6C, 0x6F, 0x6F, 
  0x6B, 0x75, 0x70, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6E, 0x6F, 0x2D, 0x63, 0x79, 
  0x63, 0x6C, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x61, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 
  0x6C, 0x61, 0x74, 0x65, 0x72, 0x20, 0x62, 0x65, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 
  0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 
  0x6C, 0x79, 0x2C, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x70, 0x61, 0x73, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6C, 0x6F, 
  0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x65, 
  0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 
  0x65, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 
  0x77, 0x61, 0x72, 0x64, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x72, 0x65, 0x63, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 
  0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x68, 0x65, 0x6E, 
  0x20, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x2E, 0xCF, 
  0x08, 0x70, 0x65, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xCE, 0x0E, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x70, 0x65, 0x67, 0x2E, 0x63, 
  0x86, 0xA9, 0x01, 0xDA, 0x06, 0xD8, 0x08, 0x70, 0x65, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0xDA, 
  0x08, 0xCE, 0x7F, 0x28, 0x70, 0x65, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x70, 0x65, 0x67, 
  0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x46, 0x69, 0x6E, 0x64, 0x20, 0x66, 
  0x69, 0x72, 0x73, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x65, 0x67, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x65, 0x78, 0x74, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2C, 0x20, 0x6F, 0x72, 
  0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 
  0x64, 0x2E, 0xCF, 0x0A, 0x64, 0x72, 0x6F, 0x70, 0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0x7D, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x05, 0x1A, 0xCE, 0x0A, 0x64, 0x72, 0x6F, 0x70, 0x2D, 
  0x75, 0x6E, 0x74, 0x69, 0x6C, 0xDA, 0x18, 0xDA, 0x1A, 0xDA, 0x81, 0x36, 0xDA, 0x80, 0xE4, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x03, 0x02, 0x03, 0x00, 0x13, 0xCE, 0x0A, 0x66, 0x69, 
  0x6E, 0x64, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0xDA, 0x18, 0x2C, 0x03, 0x00, 0x00, 0x26, 0x04, 
  0x00, 0x00, 0x19, 0x05, 0x02, 0x00, 0x47, 0x04, 0x01, 0x04, 0x26, 0x07, 0x00, 0x00, 0x23, 0x06, 
  0x04, 0x07, 0x1C, 0x06, 0x03, 0x00, 0x1A, 0x0B, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x06, 
  0x01, 0x04, 0x19, 0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x06, 0x00, 0x00, 0x1C, 0x06, 
  0x04, 0x00, 0x19, 0x05, 0x04, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xF2, 
  0xFF, 0xFF, 0x03, 0x05, 0x00, 0x00, 0x84, 0x10, 0x01, 0x03, 0x03, 0x01, 0x03, 0x02, 0x0C, 0x01, 
  0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x13, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x05, 0x01, 0x0B, 0x00, 
  0x0B, 0x00, 0x05, 0x01, 0x07, 0x01, 0x07, 0xBF, 0xFE, 0x05, 0xBF, 0xFC, 0x03, 0xBF, 0xFB, 0x01, 
  0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 0x04, 0x6E, 
  0x69, 0x6C, 0x3F, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x26, 0x03, 0x00, 0x00, 0x23, 0x02, 0x00, 
  0x03, 0x03, 0x02, 0x00, 0x00, 0x7E, 0x01, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0x2C, 0x02, 0x00, 
  0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x02, 
  0x00, 0x19, 0x06, 0x05, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 
  0x00, 0x19, 0x08, 0x07, 0x00, 0x3D, 0x09, 0x01, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x2F, 0x08, 0x00, 
  0x00, 0x2A, 0x0D, 0x04, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x1C, 0x0C, 0x03, 0x00, 0x19, 0x0B, 0x0A, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0B, 0x08, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x30, 0x01, 0x0C, 
  0x00, 0x34, 0x06, 0x00, 0x00, 0x84, 0x7D, 0x01, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 
  0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x44, 0x28, 0x64, 
  0x72, 0x6F, 0x70, 0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 
  0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x64, 
  0x72, 0x6F, 0x70, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x70, 0x72, 0x65, 0x64, 0x29, 0x20, 0x69, 0x6E, 0x64, 0x29, 
  0x60, 0x2E, 0xCF, 0x0C, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x10, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 
  0x65, 0x2F, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x63, 0x82, 0x44, 0x01, 0xDA, 0x06, 0xDA, 0x80, 
  0xBE, 0xDA, 0x08, 0xCE, 0x81, 0x98, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 
  0x74, 0x75, 0x73, 0x20, 0x66, 0x69, 0x62, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 
  0x0A, 0x2A, 0x20, 0x3A, 0x64, 0x65, 0x61, 0x64, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x66, 0x69, 0x6E, 0x69, 0x73, 0x68, 0x65, 
  0x64, 0x0A, 0x2A, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x65, 0x64, 0x20, 0x6F, 0x75, 0x74, 0x0A, 0x2A, 0x20, 0x3A, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 
  0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x73, 
  0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x0A, 0x2A, 0x20, 0x3A, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 
  0x73, 0x20, 0x62, 0x65, 0x65, 0x6E, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x65, 0x64, 0x0A, 0x2A, 
  0x20, 0x3A, 0x75, 0x73, 0x65, 0x72, 0x28, 0x30, 0x2D, 0x39, 0x29, 0x20, 0x2D, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x73, 0x75, 0x73, 0x70, 0x65, 
  0x6E, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 
  0x69, 0x67, 0x6E, 0x61, 0x6C, 0x0A, 0x2A, 0x20, 0x3A, 0x61, 0x6C, 0x69, 0x76, 0x65, 0x20, 0x2D, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 
  0x73, 0x75, 0x6D, 0x65, 0x64, 0x0A, 0x2A, 0x20, 0x3A, 0x6E, 0x65, 0x77, 0x20, 0x2D, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6A, 0x75, 0x73, 
  0x74, 0x20, 0x62, 0x65, 0x65, 0x6E, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x79, 0x65, 0x74, 0x20, 0x72, 0x75, 0x6E, 0xCF, 0x0A, 
  0x66, 0x66, 0x69, 0x2F, 0x6D, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x0C, 0x85, 0xC0, 0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x66, 0x66, 0x69, 0x2F, 0x6D, 0x61, 
  0x6C, 0x6C, 0x6F, 0x63, 0xDA, 0x08, 0xCE, 0x80, 0xAF, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x6D, 0x61, 
  0x6C, 0x6C, 0x6F, 0x63, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x29, 0x0A, 0x0A, 0x41, 0x6C, 0x6C, 0x6F, 
  0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x64, 0x69, 0x72, 
  0x65, 0x63, 0x74, 0x6C, 0x79, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x61, 0x6C, 
  0x6C, 0x6F, 0x63, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0x20, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 
  0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x69, 
  0x73, 0x20, 0x77, 0x61, 0x79, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x66, 0x72, 
  0x65, 0x65, 0x64, 0x20, 0x6D, 0x61, 0x6E, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x21, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x61, 0x77, 0x20, 0x70, 0x6F, 0x69, 0x6E, 
  0x74, 0x65, 0x72, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x73, 
  0x69, 0x7A, 0x65, 0x20, 0x3D, 0x20, 0x30, 0x2E, 0xCF, 0x05, 0x70, 0x72, 0x69, 0x6E, 0x66, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x5B, 0x01, 0xDA, 0x06, 0xD8, 0x05, 
  0x70, 0x72, 0x69, 0x6E, 0x66, 0xDA, 0x08, 0xCE, 0x3D, 0x28, 0x70, 0x72, 0x69, 0x6E, 0x66, 0x20, 
  0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x4C, 0x69, 0x6B, 0x65, 0x20, 
  0x60, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x60, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x6E, 0x6F, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 
  0x77, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xCF, 0x06, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x31, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x87, 0xAE, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x02, 
  0xBA, 0x00, 0x00, 0x1F, 0x02, 0x01, 0x02, 0x17, 0x69, 0x08, 0xCE, 0x06, 0x6D, 0x61, 0x63, 0x65, 
  0x78, 0x31, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 
  0x07, 0xCE, 0x07, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x1E, 
  0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x67, 0x01, 0x00, 0x30, 
  0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0xCF, 0x0A, 0x71, 0x75, 0x61, 0x73, 
  0x69, 0x71, 0x75, 0x6F, 0x74, 0x65, 0xDA, 0x4A, 0xDA, 0x29, 0xCF, 0x05, 0x62, 0x72, 0x65, 0x61, 
  0x6B, 0xDA, 0x44, 0xDA, 0x49, 0xDA, 0x80, 0xB9, 0xCF, 0x03, 0x76, 0x61, 0x72, 0xCF, 0x07, 0x75, 
  0x70, 0x73, 0x63, 0x6F, 0x70, 0x65, 0xCF, 0x05, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xCF, 0x05, 0x71, 
  0x75, 0x6F, 0x74, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x02, 0x01, 0x01, 0x01, 0x00, 
  0x02, 0xCE, 0x08, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x74, 0x79, 0xDA, 0x18, 0x2C, 0x01, 0x00, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x82, 0xC4, 0x01, 0x00, 0x01, 0xDA, 0x1C, 0xDA, 0x76, 0xDA, 0x80, 
  0xAC, 0xD0, 0x08, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0xD7, 0x00, 0xCD, 0x00, 0x99, 
  0x00, 0x00, 0x1C, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x80, 0xB2, 0xCE, 0x03, 0x6D, 
  0x61, 0x70, 0xDA, 0x18, 0xCE, 0x26, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 
  0x74, 0x20, 0x6C, 0x65, 0x61, 0x73, 0x74, 0x20, 0x31, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 
  0x64, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0xDA, 0x81, 0x4C, 0xD8, 
  0x10, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 0x65, 
  0x64, 0xD8, 0x0B, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x2C, 0x02, 
  0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x06, 0x00, 0x00, 0x23, 0x05, 
  0x06, 0x04, 0x1C, 0x05, 0x04, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x01, 0x06, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3B, 0x07, 0x01, 0x00, 0x19, 0x08, 
  0x07, 0x00, 0x3B, 0x07, 0x01, 0x01, 0x19, 0x09, 0x07, 0x00, 0x3B, 0x07, 0x01, 0x02, 0x19, 0x0A, 
  0x07, 0x00, 0x3B, 0x07, 0x01, 0x03, 0x19, 0x0B, 0x07, 0x00, 0x24, 0x07, 0x04, 0x01, 0x1C, 0x07, 
  0x0F, 0x00, 0x26, 0x0D, 0x00, 0x00, 0x47, 0x0C, 0x08, 0x0D, 0x19, 0x0D, 0x0C, 0x00, 0x1D, 0x0D, 
  0x0A, 0x00, 0x38, 0x0C, 0x08, 0x0D, 0x19, 0x0E, 0x0C, 0x00, 0x2F, 0x0E, 0x00, 0x00, 0x33, 0x0C, 
  0x00, 0x00, 0x30, 0x06, 0x0C, 0x00, 0x2A, 0x10, 0x01, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x47, 0x0D, 
  0x08, 0x0D, 0x1A, 0xF7, 0xFF, 0xFF, 0x1A, 0x8F, 0x00, 0x00, 0x24, 0x0C, 0x04, 0x02, 0x1C, 0x0C, 
  0x18, 0x00, 0x26, 0x0D, 0x00, 0x00, 0x26, 0x0E, 0x00, 0x00, 0x47, 0x0D, 0x08, 0x0D, 0x26, 0x10, 
  0x00, 0x00, 0x23, 0x0F, 0x10, 0x0D, 0x1C, 0x0F, 0x03, 0x00, 0x1A, 0x10, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x47, 0x0E, 0x09, 0x0E, 0x26, 0x10, 0x00, 0x00, 0x23, 0x0F, 0x10, 0x0E, 0x1C, 0x0F, 
  0x03, 0x00, 0x1A, 0x0A, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x0F, 0x08, 0x0D, 0x38, 0x10, 
  0x09, 0x0E, 0x30, 0x0F, 0x10, 0x00, 0x33, 0x11, 0x00, 0x00, 0x30, 0x06, 0x11, 0x00, 0x2A, 0x10, 
  0x01, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x1A, 0xED, 0xFF, 0xFF, 0x1A, 0x76, 0x00, 0x00, 0x24, 0x0D, 
  0x04, 0x03, 0x1C, 0x0D, 0x20, 0x00, 0x26, 0x0E, 0x00, 0x00, 0x26, 0x0F, 0x00, 0x00, 0x26, 0x10, 
  0x00, 0x00, 0x47, 0x0E, 0x08, 0x0E, 0x26, 0x12, 0x00, 0x00, 0x23, 0x11, 0x12, 0x0E, 0x1C, 0x11, 
  0x03, 0x00, 0x1A, 0x17, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x0F, 0x09, 0x0F, 0x26, 0x12, 
  0x00, 0x00, 0x23, 0x11, 0x12, 0x0F, 0x1C, 0x11, 0x03, 0x00, 0x1A, 0x11, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x47, 0x10, 0x0A, 0x10, 0x26, 0x12, 0x00, 0x00, 0x23, 0x11, 0x12, 0x10, 0x1C, 0x11, 
  0x03, 0x00, 0x1A, 0x0B, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x11, 0x08, 0x0E, 0x38, 0x12, 
  0x09, 0x0F, 0x38, 0x13, 0x0A, 0x10, 0x31, 0x11, 0x12, 0x13, 0x33, 0x14, 0x00, 0x00, 0x30, 0x06, 
  0x14, 0x00, 0x2A, 0x12, 0x01, 0x00, 0x33, 0x11, 0x12, 0x00, 0x1A, 0xE6, 0xFF, 0xFF, 0x1A, 0x55, 
  0x00, 0x00, 0x24, 0x0E, 0x04, 0x04, 0x1C, 0x0E, 0x29, 0x00, 0x26, 0x0F, 0x00, 0x00, 0x26, 0x10, 
  0x00, 0x00, 0x26, 0x11, 0x00, 0x00, 0x26, 0x12, 0x00, 0x00, 0x47, 0x0F, 0x08, 0x0F, 0x26, 0x14, 
  0x00, 0x00, 0x23, 0x13, 0x14, 0x0F, 0x1C, 0x13, 0x03, 0x00, 0x1A, 0x1F, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x47, 0x10, 0x09, 0x10, 0x26, 0x14, 0x00, 0x00, 0x23, 0x13, 0x14, 0x10, 0x1C, 0x13, 
  0x03, 0x00, 0x1A, 0x19, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x11, 0x0A, 0x11, 0x26, 0x14, 
  0x00, 0x00, 0x23, 0x13, 0x14, 0x11, 0x1C, 0x13, 0x03, 0x00, 0x1A, 0x13, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x47, 0x12, 0x0B, 0x12, 0x26, 0x14, 0x00, 0x00, 0x23, 0x13, 0x14, 0x12, 0x1C, 0x13, 
  0x03, 0x00, 0x1A, 0x0D, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x13, 0x08, 0x0F, 0x38, 0x14, 
  0x09, 0x10, 0x38, 0x15, 0x0A, 0x11, 0x38, 0x16, 0x0B, 0x12, 0x31, 0x13, 0x14, 0x15, 0x2F, 0x16, 
  0x00, 0x00, 0x33, 0x17, 0x00, 0x00, 0x30, 0x06, 0x17, 0x00, 0x2A, 0x14, 0x01, 0x00, 0x33, 0x13, 
  0x14, 0x00, 0x1A, 0xDE, 0xFF, 0xFF, 0x1A, 0x2B, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x10, 
  0x02, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x28, 0x0F, 0x00, 0x00, 0x3E, 0x11, 
  0x00, 0x00, 0x19, 0x12, 0x11, 0x00, 0x29, 0x11, 0x00, 0x00, 0x19, 0x13, 0x04, 0x00, 0x21, 0x14, 
  0x11, 0x13, 0x1C, 0x14, 0x14, 0x00, 0x38, 0x15, 0x10, 0x11, 0x19, 0x16, 0x15, 0x00, 0x38, 0x15, 
  0x01, 0x11, 0x19, 0x17, 0x15, 0x00, 0x47, 0x15, 0x17, 0x16, 0x19, 0x18, 0x15, 0x00, 0x26, 0x19, 
  0x00, 0x00, 0x23, 0x15, 0x19, 0x18, 0x1C, 0x15, 0x04, 0x00, 0x27, 0x0F, 0x00, 0x00, 0x1A, 0x09, 
  0x00, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x3A, 0x10, 0x11, 0x18, 0x38, 0x19, 0x17, 0x18, 0x30, 0x12, 
  0x19, 0x00, 0x2A, 0x1B, 0x01, 0x00, 0x33, 0x1A, 0x1B, 0x00, 0x05, 0x11, 0x11, 0x01, 0x1A, 0xEC, 
  0xFF, 0xFF, 0x1C, 0x0F, 0x03, 0x00, 0x1A, 0x0B, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x32, 0x12, 
  0x00, 0x00, 0x33, 0x11, 0x00, 0x00, 0x30, 0x06, 0x11, 0x00, 0x2A, 0x14, 0x01, 0x00, 0x33, 0x13, 
  0x14, 0x00, 0x2F, 0x12, 0x00, 0x00, 0x2A, 0x13, 0x03, 0x00, 0x33, 0x11, 0x13, 0x00, 0x1A, 0xDE, 
  0xFF, 0xFF, 0x03, 0x06, 0x00, 0x00, 0x83, 0x99, 0x01, 0x04, 0x0E, 0x00, 0x03, 0x01, 0x07, 0x00, 
  0x07, 0x00, 0x03, 0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x22, 0x00, 
  0x22, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x03, 0x09, 0x01, 0x09, 0x02, 0x1E, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x00, 0x2D, 
  0x00, 0x0B, 0x01, 0x1E, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x00, 0x2D, 0x00, 0x0B, 0x01, 0x1E, 
  0x00, 0x29, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFD, 0x09, 0xBF, 
  0xFB, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0A, 0x09, 0x01, 0x09, 0x01, 0x09, 0x02, 0x1E, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0B, 0x00, 0x2D, 0x00, 0x0B, 0x01, 0x1E, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 
  0x00, 0x2D, 0x00, 0x0B, 0x01, 0x1E, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x00, 0x2D, 0x00, 0x0B, 
  0x01, 0x1E, 0x00, 0x29, 0x00, 0x34, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0xBF, 0xFC, 0x09, 0xBF, 0xF3, 0x03, 0x00, 0x03, 0x00, 0x03, 0x13, 0x09, 0x01, 0x09, 0x01, 0x09, 
  0x01, 0x09, 0x02, 0x1E, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x00, 0x2D, 0x00, 0x0B, 0x01, 0x1E, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x00, 0x2D, 0x00, 0x0B, 0x01, 0x1E, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0B, 0x00, 0x2D, 0x00, 0x0B, 0x01, 0x1E, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x00, 0x2D, 
  0x00, 0x0B, 0x01, 0x1E, 0x00, 0x29, 0x00, 0x34, 0x00, 0x3F, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFB, 0x09, 0xBF, 0xE9, 0x03, 0x1E, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x07, 0x01, 0x07, 0x01, 0x07, 0x00, 0x07, 0x02, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x01, 0x19, 0x00, 0x0B, 0x01, 0x14, 0xBF, 0xFF, 0x0B, 0x02, 0x19, 0xBF, 0xFE, 0x0B, 
  0x03, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x01, 0x13, 0x00, 0x23, 0xBF, 0xFF, 0x0D, 0x02, 0x13, 0x00, 
  0x46, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0xBF, 0xFA, 0x09, 0x00, 0x09, 0x07, 0x09, 0x00, 0x12, 
  0x00, 0x09, 0x01, 0x19, 0x00, 0x19, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0xBF, 0xF6, 0x07, 0xBF, 0xD7, 0x01, 0xDA, 0x81, 0x86, 0xDA, 0x55, 0xDA, 0x74, 0xDA, 
  0x81, 0x82, 0xDA, 0x75, 0x2C, 0x02, 0x00, 0x00, 0x1C, 0x01, 0x09, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x34, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 
  0x19, 0x04, 0x03, 0x00, 0x2E, 0x05, 0x01, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x07, 0x02, 0x00, 
  0x19, 0x08, 0x07, 0x00, 0x2E, 0x09, 0x03, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x2E, 0x0B, 0x04, 0x00, 
  0x19, 0x0C, 0x0B, 0x00, 0x2E, 0x0D, 0x05, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x2E, 0x0F, 0x06, 0x00, 
  0x19, 0x10, 0x0F, 0x00, 0x2A, 0x11, 0x01, 0x00, 0x2A, 0x12, 0x02, 0x00, 0x31, 0x11, 0x10, 0x12, 
  0x2A, 0x11, 0x03, 0x00, 0x31, 0x0C, 0x11, 0x0A, 0x2A, 0x11, 0x04, 0x00, 0x2A, 0x12, 0x05, 0x00, 
  0x31, 0x11, 0x0C, 0x12, 0x2A, 0x11, 0x06, 0x00, 0x31, 0x0A, 0x11, 0x0C, 0x2A, 0x11, 0x07, 0x00, 
  0x2A, 0x12, 0x08, 0x00, 0x31, 0x11, 0x0E, 0x12, 0x2A, 0x11, 0x09, 0x00, 0x31, 0x0A, 0x11, 0x0C, 
  0x2A, 0x11, 0x0A, 0x00, 0x2A, 0x12, 0x0B, 0x00, 0x31, 0x11, 0x0C, 0x12, 0x2A, 0x11, 0x0C, 0x00, 
  0x2F, 0x11, 0x00, 0x00, 0x41, 0x11, 0x00, 0x00, 0x19, 0x12, 0x11, 0x00, 0x2E, 0x13, 0x07, 0x00, 
  0x19, 0x14, 0x13, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x16, 0x0D, 0x00, 0x33, 0x15, 0x16, 0x00, 
  0x19, 0x16, 0x15, 0x00, 0x2A, 0x18, 0x0E, 0x00, 0x23, 0x17, 0x16, 0x18, 0x1C, 0x17, 0x14, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x1A, 0x0F, 0x00, 0x33, 0x19, 0x1A, 0x00, 0x2A, 0x1B, 0x10, 0x00, 
  0x23, 0x1A, 0x19, 0x1B, 0x1C, 0x1A, 0x09, 0x00, 0x30, 0x04, 0x00, 0x00, 0x2A, 0x1B, 0x11, 0x00, 
  0x33, 0x19, 0x1B, 0x00, 0x32, 0x19, 0x00, 0x00, 0x2A, 0x1C, 0x12, 0x00, 0x33, 0x1B, 0x1C, 0x00, 
  0x19, 0x18, 0x1B, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x33, 0x19, 0x14, 0x00, 
  0x19, 0x18, 0x19, 0x00, 0x19, 0x15, 0x18, 0x00, 0x1A, 0x1E, 0x00, 0x00, 0x2A, 0x1A, 0x13, 0x00, 
  0x23, 0x19, 0x16, 0x1A, 0x1C, 0x19, 0x06, 0x00, 0x30, 0x04, 0x00, 0x00, 0x2A, 0x1B, 0x11, 0x00, 
  0x33, 0x1A, 0x1B, 0x00, 0x19, 0x18, 0x1A, 0x00, 0x1A, 0x15, 0x00, 0x00, 0x2A, 0x1C, 0x14, 0x00, 
  0x23, 0x1B, 0x16, 0x1C, 0x1C, 0x1B, 0x08, 0x00, 0x30, 0x00, 0x04, 0x00, 0x33, 0x1C, 0x06, 0x00, 
  0x2F, 0x1C, 0x00, 0x00, 0x2A, 0x1E, 0x15, 0x00, 0x33, 0x1D, 0x1E, 0x00, 0x19, 0x1A, 0x1D, 0x00, 
  0x1A, 0x0A, 0x00, 0x00, 0x2A, 0x1E, 0x16, 0x00, 0x23, 0x1D, 0x16, 0x1E, 0x1C, 0x1D, 0x05, 0x00, 
  0x30, 0x00, 0x04, 0x00, 0x33, 0x1E, 0x06, 0x00, 0x19, 0x1C, 0x1E, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x19, 0x1C, 0x00, 0x00, 0x19, 0x1A, 0x1C, 0x00, 0x19, 0x18, 0x1A, 0x00, 0x19, 0x15, 0x18, 0x00, 
  0x19, 0x16, 0x15, 0x00, 0x03, 0x16, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x03, 0x01, 0x01, 
  0x01, 0x00, 0x05, 0x01, 0xDA, 0x81, 0xBF, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 
  0x01, 0x30, 0x00, 0x02, 0x00, 0x2B, 0x02, 0x00, 0x02, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x87, 
  0xB7, 0x03, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0B, 
  0x02, 0x02, 0x02, 0x00, 0x13, 0x01, 0xCE, 0x07, 0x64, 0x6F, 0x74, 0x61, 0x62, 0x6C, 0x65, 0xDA, 
  0x18, 0x2C, 0x02, 0x00, 0x00, 0x42, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 
  0x00, 0x47, 0x05, 0x00, 0x06, 0x19, 0x06, 0x05, 0x00, 0x26, 0x08, 0x00, 0x00, 0x48, 0x07, 0x08, 
  0x06, 0x1C, 0x07, 0x0A, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x04, 0x33, 0x08, 0x09, 
  0x00, 0x38, 0x09, 0x00, 0x06, 0x2F, 0x09, 0x00, 0x00, 0x33, 0x0A, 0x01, 0x00, 0x3A, 0x04, 0x08, 
  0x0A, 0x47, 0x06, 0x00, 0x06, 0x1A, 0xF5, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0xBF, 0xFF, 0x87, 
  0xB9, 0x03, 0x01, 0x05, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 
  0x00, 0x05, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x27, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x07, 
  0x01, 0x10, 0xBF, 0xFE, 0x05, 0xBF, 0xFD, 0x03, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x09, 0x01, 0x01, 
  0x01, 0x08, 0x26, 0x01, 0xCE, 0x0F, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x2D, 0x62, 0x69, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x73, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x55, 0xDA, 0x82, 0x48, 0xDA, 0x76, 
  0xDA, 0x80, 0xE4, 0xDA, 0x75, 0xDA, 0x74, 0xDA, 0x81, 0x82, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 
  0x01, 0x00, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x04, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x04, 
  0x02, 0x00, 0x34, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 
  0x07, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2F, 0x05, 
  0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x23, 0x05, 
  0x03, 0x06, 0x1C, 0x05, 0x04, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2B, 0x06, 0x00, 0x06, 0x34, 0x06, 
  0x00, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x23, 0x06, 0x03, 0x07, 0x1C, 0x06, 0x07, 0x00, 0x30, 0x00, 
  0x01, 0x00, 0x2B, 0x08, 0x00, 0x06, 0x33, 0x07, 0x08, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 
  0x07, 0x00, 0x34, 0x08, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x04, 0x34, 0x07, 
  0x00, 0x00, 0xBF, 0xFF, 0x87, 0xC1, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x02, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFE, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFD, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x04, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0B, 0x01, 0x01, 0x01, 0x02, 0x1F, 0x01, 
  0xCE, 0x09, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x64, 0x65, 0x66, 0xDA, 0x18, 0xDA, 0x80, 0xE4, 
  0xDA, 0x80, 0xE3, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x05, 0x03, 0x02, 0xFF, 0x38, 
  0x02, 0x00, 0x03, 0x19, 0x03, 0x02, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x19, 
  0x05, 0x04, 0x00, 0x29, 0x07, 0x00, 0x00, 0x38, 0x06, 0x00, 0x07, 0x2F, 0x05, 0x00, 0x00, 0x2B, 
  0x08, 0x00, 0x08, 0x33, 0x07, 0x08, 0x00, 0x30, 0x06, 0x07, 0x00, 0x3E, 0x06, 0x00, 0x00, 0x29, 
  0x07, 0x02, 0x00, 0x29, 0x08, 0xFE, 0xFF, 0x31, 0x00, 0x07, 0x08, 0x2A, 0x08, 0x00, 0x00, 0x33, 
  0x07, 0x08, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x04, 0x33, 0x08, 0x09, 0x00, 0x2F, 
  0x08, 0x00, 0x00, 0x3E, 0x08, 0x00, 0x00, 0x31, 0x06, 0x07, 0x08, 0x2A, 0x0A, 0x01, 0x00, 0x33, 
  0x09, 0x0A, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x34, 0x06, 0x00, 0x00, 0xBF, 
  0xFF, 0x87, 0xC9, 0x03, 0x01, 0x18, 0x00, 0x15, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x10, 0x00, 0x10, 
  0x00, 0x05, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xBF, 0xFF, 0x07, 0x00, 
  0x07, 0x02, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0xBF, 0xFD, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 0x03, 0x10, 0x01, 0xCE, 
  0x09, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x61, 0x6C, 0x6C, 0xDA, 0x18, 0xDA, 0x80, 0xE4, 0xDA, 
  0x82, 0x48, 0xDA, 0x78, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x01, 0x00, 0x30, 0x00, 0x02, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2B, 0x03, 0x00, 0x04, 0x30, 0x03, 0x02, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 0x00, 0x29, 0x05, 0x00, 0x00, 
  0x38, 0x04, 0x00, 0x05, 0x2F, 0x04, 0x00, 0x00, 0x32, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 
  0x34, 0x05, 0x00, 0x00, 0xBF, 0xFF, 0x87, 0xD2, 0x03, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 
  0x1A, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x01, 0x01, 0x01, 
  0x05, 0x26, 0x01, 0xCE, 0x08, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x66, 0x6E, 0xDA, 0x18, 0xDA, 
  0x82, 0x3D, 0xDA, 0x80, 0xE4, 0xDA, 0x82, 0x48, 0xDA, 0x80, 0xB9, 0xDA, 0x78, 0x2C, 0x01, 0x00, 
  0x00, 0x29, 0x03, 0x01, 0x00, 0x38, 0x02, 0x00, 0x03, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x03, 0x00, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x11, 0x00, 0x29, 0x05, 0x03, 
  0x00, 0x30, 0x00, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2B, 0x06, 0x00, 
  0x04, 0x30, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 
  0x00, 0x29, 0x07, 0x02, 0x00, 0x38, 0x06, 0x00, 0x07, 0x2A, 0x07, 0x03, 0x00, 0x31, 0x07, 0x03, 
  0x06, 0x32, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x34, 0x07, 0x00, 0x00, 0x29, 0x05, 0x02, 
  0x00, 0x30, 0x00, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2B, 0x06, 0x00, 
  0x04, 0x30, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 
  0x00, 0x2A, 0x06, 0x03, 0x00, 0x30, 0x06, 0x03, 0x00, 0x32, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x04, 
  0x00, 0x34, 0x06, 0x00, 0x00, 0xBF, 0xFF, 0x87, 0xD6, 0x03, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x05, 
  0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x02, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x01, 0x17, 0x00, 0x17, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0xCD, 0x00, 0xF8, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x01, 0x0C, 0x01, 
  0x01, 0xCE, 0x08, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x71, 0x71, 0xDA, 0x18, 0xDA, 0x78, 0x2C, 
  0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x29, 0x05, 0x00, 0x00, 0x38, 
  0x04, 0x00, 0x05, 0x29, 0x06, 0x01, 0x00, 0x38, 0x05, 0x00, 0x06, 0x2F, 0x05, 0x00, 0x00, 0x33, 
  0x06, 0x03, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xBF, 
  0xFF, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x0E, 0x47, 0x01, 0xCE, 0x02, 0x71, 
  0x71, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x76, 0xDA, 0x80, 0xAC, 0xDA, 0x82, 0x47, 0xDA, 0x82, 0x48, 
  0xCF, 0x07, 0x75, 0x6E, 0x71, 0x75, 0x6F, 0x74, 0x65, 0xDA, 0x78, 0xDA, 0x80, 0xE4, 0xDA, 0x55, 
  0xDA, 0x75, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x01, 0x0F, 0xCE, 
  0x03, 0x6B, 0x76, 0x73, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 0x00, 
  0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 
  0x00, 0x1D, 0x05, 0x08, 0x00, 0x19, 0x04, 0x05, 0x00, 0x38, 0x06, 0x00, 0x04, 0x31, 0x03, 0x04, 
  0x06, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x07, 0x08, 0x00, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF9, 0xFF, 
  0xFF, 0x03, 0x03, 0x00, 0x00, 0x86, 0x70, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x2A, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x03, 
  0x00, 0x03, 0xBF, 0xFB, 0x01, 0xD8, 0x05, 0x74, 0x61, 0x62, 0x6C, 0x65, 0xDA, 0x74, 0xD8, 0x06, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x02, 
  0x03, 0x04, 0x1C, 0x02, 0x21, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x07, 0x00, 0x30, 0x01, 
  0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x33, 0x04, 0x06, 0x00, 0x32, 0x04, 0x00, 0x00, 0x44, 0x06, 
  0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x29, 0x06, 0x00, 0x00, 0x39, 0x04, 0x00, 0x06, 0x19, 0x06, 
  0x04, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x23, 0x04, 0x07, 0x06, 0x1C, 0x04, 0x09, 0x00, 0x29, 0x08, 
  0x01, 0x00, 0x39, 0x07, 0x00, 0x08, 0x2F, 0x07, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x04, 0x33, 0x08, 
  0x09, 0x00, 0x30, 0x06, 0x08, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x34, 0x07, 0x00, 0x00, 0x30, 0x01, 
  0x00, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 
  0x07, 0x00, 0x34, 0x08, 0x00, 0x00, 0x2A, 0x05, 0x08, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 
  0x04, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x34, 0x05, 0x00, 0x00, 0x2A, 0x06, 
  0x09, 0x00, 0x23, 0x05, 0x03, 0x06, 0x1C, 0x05, 0x0A, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x07, 
  0x0A, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x33, 0x07, 
  0x08, 0x00, 0x32, 0x07, 0x00, 0x00, 0x2A, 0x06, 0x0B, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2A, 0x07, 
  0x0C, 0x00, 0x23, 0x06, 0x03, 0x07, 0x1C, 0x06, 0x0A, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 
  0x0A, 0x00, 0x33, 0x07, 0x08, 0x00, 0x30, 0x01, 0x07, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x33, 0x08, 
  0x09, 0x00, 0x32, 0x08, 0x00, 0x00, 0x2A, 0x07, 0x0D, 0x00, 0x34, 0x07, 0x00, 0x00, 0x03, 0x00, 
  0x00, 0x00, 0x00, 0x87, 0xE1, 0x05, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x01, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 
  0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x02, 0x1C, 0x00, 0x1C, 
  0x00, 0x14, 0x01, 0x18, 0x00, 0x18, 0x00, 0x14, 0x01, 0x27, 0x00, 0x27, 0x00, 0x20, 0x00, 0x20, 
  0x00, 0x20, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x01, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x16, 
  0x00, 0x16, 0x00, 0x16, 0xBF, 0xF9, 0x07, 0x00, 0x07, 0x00, 0x07, 0x08, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0xBF, 0xF8, 0x07, 0x00, 0x07, 0x00, 0x07, 0x09, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x18, 
  0x00, 0x18, 0x00, 0x18, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xF7, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x0A, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0xBF, 0xF6, 0x07, 0x87, 0xE0, 0x03, 0x01, 0x05, 0x00, 0x05, 0x0D, 0x0C, 0x00, 
  0x0C, 0x00, 0x19, 0x00, 0x19, 0x00, 0x15, 0x00, 0x15, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 
  0x00, 0xD8, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x09, 0x34, 0x01, 0xCE, 0x05, 0x64, 0x6F, 0x74, 
  0x75, 0x70, 0xDA, 0x18, 0xDA, 0x81, 0x1D, 0xD5, 0x00, 0xDA, 0x51, 0xDA, 0x06, 0xDA, 0x2B, 0xDA, 
  0x81, 0xF1, 0xD8, 0x06, 0x73, 0x65, 0x74, 0x64, 0x79, 0x6E, 0xDA, 0x80, 0xE4, 0xDA, 0x82, 0x48, 
  0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x38, 0x02, 0x00, 0x03, 0x19, 0x03, 0x02, 0x00, 
  0x2B, 0x05, 0x00, 0x12, 0x38, 0x04, 0x05, 0x03, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 
  0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x03, 0x00, 
  0x19, 0x06, 0x07, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x19, 0x07, 0x06, 0x00, 
  0x2A, 0x09, 0x02, 0x00, 0x39, 0x08, 0x07, 0x09, 0x19, 0x09, 0x08, 0x00, 0x1C, 0x09, 0x05, 0x00, 
  0x29, 0x0B, 0x00, 0x00, 0x38, 0x0A, 0x09, 0x0B, 0x19, 0x08, 0x0A, 0x00, 0x1A, 0x04, 0x00, 0x00, 
  0x2A, 0x0B, 0x03, 0x00, 0x39, 0x0A, 0x07, 0x0B, 0x19, 0x08, 0x0A, 0x00, 0x19, 0x09, 0x08, 0x00, 
  0x2A, 0x0B, 0x04, 0x00, 0x38, 0x0A, 0x07, 0x0B, 0x19, 0x0B, 0x0A, 0x00, 0x1C, 0x05, 0x03, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0x1C, 0x0B, 0x0B, 0x00, 0x2A, 0x0C, 0x05, 0x00, 
  0x30, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x06, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x29, 0x0C, 0x01, 0x00, 
  0x30, 0x00, 0x0C, 0x00, 0x2A, 0x0D, 0x07, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x32, 0x0C, 0x00, 0x00, 
  0x34, 0x09, 0x00, 0x00, 0x2B, 0x0C, 0x00, 0x04, 0x30, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x08, 0x00, 
  0x33, 0x0C, 0x0D, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x07, 0x00, 0x34, 0x0D, 0x00, 0x00, 
  0xBF, 0xFF, 0x87, 0xFD, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 
  0x05, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 0x10, 0x00, 0x29, 0x00, 0x2F, 0x00, 0x2F, 0x00, 
  0x29, 0x00, 0x29, 0x00, 0x38, 0x00, 0x38, 0x00, 0x29, 0x00, 0x05, 0x01, 0x0D, 0x00, 0x0D, 0x00, 
  0x05, 0x01, 0x05, 0x01, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x05, 0x02, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x26, 0x00, 0x26, 0x01, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x87, 0xAE, 0x01, 0x05, 
  0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x05, 
  0xBF, 0xFF, 0x03, 0x04, 0x03, 0x00, 0x03, 0x02, 0x03, 0x00, 0x03, 0x08, 0x03, 0x00, 0x03, 0x08, 
  0x03, 0x00, 0x03, 0x09, 0x03, 0x00, 0x03, 0x04, 0x03, 0x00, 0x03, 0x0A, 0x03, 0x00, 0x03, 0x10, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0D, 0x03, 0x00, 0x03, 0x0C, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0E, 0x01, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFF, 0x0E, 0x00, 0x0E, 0x02, 0x10, 0x00, 0x10, 0xBF, 0xFE, 
  0x0E, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x0E, 0x00, 0x0E, 
  0x00, 0x0E, 0xBF, 0xFC, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x05, 0x20, 0x00, 
  0x20, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFB, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x06, 0x0E, 0x00, 0x0E, 0xBF, 0xFA, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0xBF, 0xA6, 0x01, 0x56, 0x01, 0x04, 0x00, 0xDA, 0x08, 0xCE, 
  0x80, 0x85, 0x28, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x31, 0x20, 0x78, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x29, 0x0A, 0x0A, 0x45, 0x78, 
  0x70, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x20, 0x65, 0x78, 
  0x70, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x2E, 0x0A, 0x53, 0x65, 0x65, 
  0x20, 0x60, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x60, 0x20, 0x64, 0x6F, 0x63, 0x73, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x20, 0x6F, 0x6E, 0x20, 0x60, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0x60, 0x2E, 0xCF, 0x02, 0x6F, 0x72, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x81, 0x25, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 
  0x0F, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x06, 0x28, 0xCE, 0x02, 0x6F, 0x72, 0xDA, 0x18, 
  0xDA, 0x71, 0xDA, 0x49, 0xDA, 0x78, 0xDA, 0x43, 0xDA, 0x44, 0xDA, 0x4A, 0x2C, 0x01, 0x00, 0x00, 
  0x3D, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x05, 0x04, 0x03, 0xFF, 0x19, 0x05, 0x04, 0x00, 
  0x39, 0x06, 0x00, 0x05, 0x19, 0x07, 0x06, 0x00, 0x20, 0x08, 0x05, 0x00, 0x1C, 0x08, 0x1F, 0x00, 
  0x05, 0x05, 0x05, 0xFF, 0x38, 0x09, 0x00, 0x05, 0x19, 0x0A, 0x09, 0x00, 0x2F, 0x0A, 0x00, 0x00, 
  0x2A, 0x0B, 0x00, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x1C, 0x09, 0x07, 0x00, 0x2A, 0x0B, 0x01, 0x00, 
  0x31, 0x0B, 0x0A, 0x0A, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x07, 0x0B, 0x00, 
  0x1A, 0x11, 0x00, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x0C, 0x0B, 0x00, 
  0x2A, 0x0B, 0x04, 0x00, 0x31, 0x0B, 0x0C, 0x0A, 0x2A, 0x0D, 0x02, 0x00, 0x33, 0x0B, 0x0D, 0x00, 
  0x2A, 0x0D, 0x01, 0x00, 0x31, 0x0D, 0x0C, 0x0C, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0E, 0x02, 0x00, 
  0x33, 0x0D, 0x0E, 0x00, 0x2A, 0x0E, 0x05, 0x00, 0x31, 0x0E, 0x0B, 0x0D, 0x2A, 0x0E, 0x02, 0x00, 
  0x33, 0x07, 0x0E, 0x00, 0x1A, 0xE1, 0xFF, 0xFF, 0x03, 0x07, 0x00, 0x00, 0x81, 0x25, 0x01, 0x04, 
  0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 
  0x05, 0x01, 0x0D, 0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0E, 0x01, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFF, 0x0E, 0x03, 0x1B, 0x00, 0x1B, 0x00, 0x12, 
  0x01, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x01, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 
  0x00, 0x19, 0xBF, 0xFF, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xF9, 0x03, 0xBF, 0xF9, 
  0x01, 0xDA, 0x08, 0xCE, 0x80, 0x83, 0x28, 0x6F, 0x72, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x73, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x72, 0x65, 0x63, 0x65, 0x64, 
  0x69, 0x6E, 0x67, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 
  0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 
  0x73, 0x65, 0x0A, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 
  0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x09, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0x68, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 
  0xA4, 0x81, 0x12, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 
  0x68, 0xDA, 0x08, 0xCE, 0x33, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0x68, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x20, 0x74, 0x61, 0x6E, 0x67, 0x65, 
  0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xCF, 0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2F, 0x66, 0x69, 0x6E, 0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 
  0x39, 0x01, 0xDA, 0x06, 0xD8, 0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 0x6E, 
  0x64, 0xDA, 0x08, 0xCE, 0x80, 0xBF, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 
  0x6E, 0x64, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x29, 0x0A, 0x0A, 0x53, 
  0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x60, 0x70, 0x61, 0x74, 0x74, 0x60, 
  0x20, 0x69, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x73, 0x74, 0x72, 0x60, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 
  0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x70, 
  0x61, 0x74, 0x74, 0x60, 0x20, 0x69, 0x66, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x6F, 
  0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xCF, 0x05, 0x70, 0x72, 0x69, 0x6E, 0x74, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x81, 0xEF, 0x01, 0xDA, 0x06, 0xD8, 0x05, 0x70, 0x72, 0x69, 
  0x6E, 0x74, 0xDA, 0x08, 0xCE, 0x81, 0x49, 0x28, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x26, 0x20, 
  0x78, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x6F, 0x6C, 0x65, 
  0x20, 0x28, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x6F, 0x75, 0x74, 0x29, 0x2E, 
  0x20, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 
  0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 
  0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x61, 0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x2E, 0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x20, 0x70, 
  0x72, 0x69, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x73, 0x2C, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x68, 
  0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 
  0x65, 0x64, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x6F, 0x75, 0x74, 0x20, 
  0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x74, 0x65, 
  0x72, 0x6D, 0x69, 0x6E, 0x65, 0x20, 0x77, 0x68, 0x61, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x75, 
  0x73, 0x68, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6F, 
  0x2E, 0x20, 0x45, 0x78, 0x70, 0x65, 0x63, 0x74, 0x73, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 
  0x3A, 0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x60, 0x20, 0x74, 0x6F, 
  0x20, 0x62, 0x65, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x72, 
  0x65, 0x2F, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 
  0xCF, 0x04, 0x64, 0x72, 0x6F, 0x70, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 
  0x71, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x03, 
  0x1B, 0xCE, 0x04, 0x64, 0x72, 0x6F, 0x70, 0xDA, 0x18, 0xDA, 0x1A, 0xDA, 0x81, 0x36, 0xDA, 0x80, 
  0xE4, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x2A, 0x05, 0x02, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3D, 0x07, 0x01, 0x00, 0x19, 0x08, 0x07, 
  0x00, 0x20, 0x0A, 0x00, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x19, 0x09, 0x00, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x29, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x1F, 0x0C, 0x0A, 0x08, 0x1C, 0x0C, 0x03, 
  0x00, 0x19, 0x0B, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x19, 0x0C, 0x0B, 
  0x00, 0x29, 0x0D, 0xFF, 0xFF, 0x31, 0x01, 0x0C, 0x0D, 0x34, 0x06, 0x00, 0x00, 0x84, 0x71, 0x01, 
  0x04, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x02, 0x0E, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x03, 0x01, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x7A, 0x28, 0x64, 0x72, 0x6F, 0x70, 0x20, 0x6E, 0x20, 
  0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x44, 0x72, 0x6F, 0x70, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x72, 0x73, 0x74, 0x20, 0x6E, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x6F, 0x72, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x0A, 0x69, 0x6E, 0x73, 0x74, 0x61, 
  0x6E, 0x63, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6C, 
  0x79, 0x2E, 0xCF, 0x0A, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x6F, 0x66, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x83, 0xA9, 0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x6F, 0x66, 0xDA, 0x08, 0xCE, 0x76, 0x28, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 
  0x0A, 0x0A, 0x49, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x77, 0x61, 
  0x73, 0x20, 0x72, 0x65, 0x61, 0x63, 0x68, 0x65, 0x64, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 
  0x70, 0x75, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x64, 0x65, 0x61, 0x64, 0x20, 0x73, 0x74, 0x61, 
  0x74, 0x65, 0x2E, 0xCF, 0x06, 0x78, 0x70, 0x72, 0x69, 0x6E, 0x66, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x74, 0x01, 0xDA, 0x06, 0xD8, 0x06, 0x78, 0x70, 0x72, 0x69, 
  0x6E, 0x66, 0xDA, 0x08, 0xCE, 0x5D, 0x28, 0x78, 0x70, 0x72, 0x69, 0x6E, 0x66, 0x20, 0x74, 0x6F, 
  0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x4C, 0x69, 0x6B, 0x65, 
  0x20, 0x60, 0x70, 0x72, 0x69, 0x6E, 0x66, 0x60, 0x20, 0x62, 0x75, 0x74, 0x20, 0x70, 0x72, 0x69, 
  0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x70, 0x6C, 0x69, 0x63, 
  0x69, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x60, 0x74, 0x6F, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 
  0x69, 0x6C, 0x2E, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6E, 0x65, 0x78, 0x74, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x32, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x6E, 0x65, 0x78, 0x74, 0xDA, 0x08, 0xCE, 0x62, 0x28, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x72, 0x65, 
  0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x6C, 0x6F, 0x61, 
  0x74, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x75, 0x65, 0x20, 
  0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x78, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 
  0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x79, 0x2E, 0xCF, 0x0C, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x77, 0x68, 0x65, 0x72, 0x65, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x84, 0x38, 0x01, 0xDA, 0x06, 0xD8, 0x0C, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x2F, 0x77, 0x68, 0x65, 0x72, 0x65, 0xDA, 0x08, 0xCE, 0x81, 0x2B, 0x28, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 
  0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 
  0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x27, 0x73, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2E, 0x20, 0x49, 0x66, 
  0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 
  0x64, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 
  0x69, 0x6E, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x66, 0x69, 0x72, 0x73, 
  0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x63, 0x6F, 0x6C, 
  0x75, 0x6D, 0x6E, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xCF, 0x0D, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x2F, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x82, 0x2B, 0x82, 0x4D, 0x01, 0xDA, 0x06, 0xD8, 0x0D, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 
  0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0xDA, 0x08, 0xCE, 0x35, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x2F, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 
  0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xCF, 
  0x05, 0x64, 0x65, 0x65, 0x70, 0x3D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 
  0x33, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
  0x07, 0xCE, 0x05, 0x64, 0x65, 0x65, 0x70, 0x3D, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x0E, 0x02, 0x02, 0x02, 0x0C, 0x4F, 0xCE, 0x09, 0x64, 0x65, 0x65, 0x70, 0x2D, 0x6E, 0x6F, 
  0x74, 0x3D, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x76, 0xDA, 0x82, 0x48, 0xDA, 0x82, 0x45, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x01, 0x17, 0xCE, 0x04, 0x73, 0x6F, 0x6D, 
  0x65, 0xDA, 0x18, 0xDA, 0x73, 0x2C, 0x02, 0x00, 0x00, 0x26, 0x03, 0x00, 0x00, 0x26, 0x05, 0x00, 
  0x00, 0x47, 0x04, 0x01, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x11, 0x00, 0x38, 0x04, 0x01, 
  0x05, 0x19, 0x06, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x04, 0x07, 
  0x00, 0x1C, 0x04, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x1A, 0x09, 0x00, 0x00, 0x2F, 0x06, 0x00, 
  0x00, 0x33, 0x04, 0x00, 0x00, 0x19, 0x07, 0x04, 0x00, 0x1C, 0x07, 0x03, 0x00, 0x19, 0x03, 0x07, 
  0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x05, 0x01, 0x05, 0x1A, 0xF0, 0xFF, 0xFF, 0x03, 0x03, 0x00, 
  0x00, 0x88, 0x1C, 0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x30, 
  0x00, 0x30, 0x00, 0x25, 0x00, 0x25, 0x00, 0x3A, 0x00, 0x25, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFB, 
  0x01, 0xDA, 0x55, 0xDA, 0x74, 0xDA, 0x82, 0x55, 0xDA, 0x75, 0xDA, 0x81, 0x82, 0xDA, 0x20, 0xDA, 
  0x81, 0x38, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 
  0x06, 0x00, 0x48, 0x06, 0x04, 0x05, 0x19, 0x05, 0x06, 0x00, 0x1C, 0x05, 0x02, 0x00, 0x03, 0x05, 
  0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x23, 0x06, 0x04, 0x07, 0x1C, 0x06, 0x0E, 0x00, 0x3D, 0x07, 
  0x00, 0x00, 0x3D, 0x08, 0x01, 0x00, 0x48, 0x09, 0x07, 0x08, 0x19, 0x07, 0x09, 0x00, 0x1C, 0x07, 
  0x02, 0x00, 0x03, 0x07, 0x00, 0x00, 0x31, 0x02, 0x00, 0x01, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 
  0x09, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x30, 0x09, 0x08, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x34, 0x09, 
  0x00, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x23, 0x07, 0x04, 0x08, 0x1C, 0x07, 0x0E, 0x00, 0x3D, 0x08, 
  0x00, 0x00, 0x3D, 0x09, 0x01, 0x00, 0x48, 0x0A, 0x08, 0x09, 0x19, 0x08, 0x0A, 0x00, 0x1C, 0x08, 
  0x02, 0x00, 0x03, 0x08, 0x00, 0x00, 0x31, 0x02, 0x00, 0x01, 0x2A, 0x0A, 0x02, 0x00, 0x33, 0x09, 
  0x0A, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x30, 0x0A, 0x09, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x34, 0x0A, 
  0x00, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x23, 0x08, 0x04, 0x09, 0x1C, 0x08, 0x09, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x0A, 0x07, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0B, 
  0x07, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x30, 0x09, 0x0A, 0x00, 0x34, 0x02, 0x00, 0x00, 0x2A, 0x0A, 
  0x08, 0x00, 0x23, 0x09, 0x04, 0x0A, 0x1C, 0x09, 0x09, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0B, 
  0x09, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0C, 0x09, 0x00, 0x33, 0x0B, 
  0x0C, 0x00, 0x30, 0x0A, 0x0B, 0x00, 0x34, 0x02, 0x00, 0x00, 0x2A, 0x0B, 0x0A, 0x00, 0x23, 0x0A, 
  0x04, 0x0B, 0x1C, 0x0A, 0x09, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0C, 0x0B, 0x00, 0x33, 0x0B, 
  0x0C, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0D, 0x0B, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x48, 0x0D, 
  0x0B, 0x0C, 0x03, 0x0D, 0x00, 0x00, 0x48, 0x0B, 0x00, 0x01, 0x03, 0x0B, 0x00, 0x00, 0x88, 0x24, 
  0x01, 0x04, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x02, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x18, 
  0x00, 0x23, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x3E, 
  0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 
  0x18, 0x00, 0x23, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x3E, 0x00, 0x3E, 0x00, 
  0x3E, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x03, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x0F, 0x00, 0x0F, 
  0xBF, 0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x2D, 0x00, 
  0x2D, 0x00, 0x2D, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFC, 0x05, 0x00, 0x05, 0x00, 0x05, 0x05, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x07, 
  0x00, 0x07, 0xDA, 0x73, 0x2C, 0x02, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x33, 0x03, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 
  0x88, 0x33, 0x01, 0x04, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 
  0x08, 0xCE, 0x80, 0x8F, 0x28, 0x64, 0x65, 0x65, 0x70, 0x3D, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 
  0x0A, 0x4C, 0x69, 0x6B, 0x65, 0x20, 0x60, 0x3D, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6D, 
  0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x28, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x73, 0x2C, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x73, 0x29, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x69, 
  0x64, 0x65, 0x72, 0x65, 0x64, 0x0A, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x79, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x63, 
  0x61, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x4D, 0x75, 
  0x63, 0x68, 0x20, 0x73, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x60, 
  0x3D, 0x60, 0x2E, 0xCF, 0x0E, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x2D, 
  0x6D, 0x61, 0x78, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x9C, 0x01, 
  0xDA, 0x06, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0xDA, 0x08, 0xCE, 0x47, 0x54, 0x68, 0x65, 0x20, 0x6D, 
  0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 
  0x73, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 
  0x74, 0x65, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x33, 0x32, 0x20, 
  0x62, 0x69, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0xCF, 0x09, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x6F, 0x70, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xCE, 0x10, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x2E, 0x63, 0x80, 0xA5, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x2F, 0x70, 0x6F, 0x70, 0xDA, 0x08, 0xCE, 0x80, 0x86, 0x28, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2F, 0x70, 0x6F, 0x70, 0x20, 0x61, 0x72, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6D, 0x6F, 
  0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x69, 0x74, 0x2E, 0x20, 
  0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 
  0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x4D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2E, 0xCF, 0x09, 0x65, 0x76, 0x2F, 0x72, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8C, 0x39, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x65, 0x76, 0x2F, 0x72, 
  0x77, 0x6C, 0x6F, 0x63, 0x6B, 0xDA, 0x08, 0xCE, 0x40, 0x28, 0x65, 0x76, 0x2F, 0x72, 0x77, 0x6C, 
  0x6F, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2D, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6C, 0x6F, 
  0x63, 0x6B, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6F, 0x72, 0x64, 0x69, 0x6E, 0x61, 0x74, 0x65, 
  0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x2E, 0xCF, 0x0A, 0x66, 0x66, 0x69, 0x2F, 0x6C, 
  0x6F, 0x6F, 0x6B, 0x75, 0x70, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 0x85, 0xA7, 
  0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x66, 0x66, 0x69, 0x2F, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0xDA, 
  0x08, 0xCE, 0x80, 0x95, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 
  0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2D, 0x6E, 0x61, 
  0x6D, 0x65, 0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x61, 0x20, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x6E, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2E, 0x20, 0x41, 0x6C, 0x6C, 0x20, 0x73, 
  0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x73, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x61, 0x77, 0x20, 
  0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 
  0x65, 0x6C, 0x73, 0x65, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xCF, 0x02, 0x70, 0x70, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0xB9, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x05, 0x0B, 0xCE, 0x02, 0x70, 0x70, 0xDA, 0x18, 0xD0, 0x0D, 
  0x70, 0x72, 0x65, 0x74, 0x74, 0x79, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xCE, 0x02, 0x25, 
  0x71, 0xDA, 0x81, 0x1D, 0xD8, 0x06, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0xD8, 0x05, 0x66, 0x6C, 
  0x75, 0x73, 0x68, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 
  0x02, 0x03, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x33, 0x02, 0x03, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 
  0x04, 0x03, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2A, 0x02, 0x04, 0x00, 0x34, 0x02, 0x00, 0x00, 0x86, 
  0xB9, 0x01, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x68, 0x28, 0x70, 0x70, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x50, 0x72, 0x65, 0x74, 0x74, 0x79, 0x2D, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 
  0x6F, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x20, 0x6F, 0x72, 0x20, 0x60, 0x28, 0x64, 0x79, 
  0x6E, 0x20, 0x2A, 0x6F, 0x75, 0x74, 0x2A, 0x29, 0x60, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x75, 0x73, 0x65, 
  0x64, 0x20, 0x69, 0x73, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x2A, 0x70, 0x72, 0x65, 0x74, 
  0x74, 0x79, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x2A, 0x20, 0x22, 0x25, 0x71, 0x22, 0x29, 
  0x60, 0x2E, 0xCF, 0x0D, 0x6E, 0x65, 0x74, 0x2F, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x6E, 0x61, 0x6D, 
  0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 0x82, 0xBB, 0x01, 0xDA, 0x06, 0xD8, 
  0x0D, 0x6E, 0x65, 0x74, 0x2F, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x6E, 0x61, 0x6D, 0x65, 0xDA, 0x08, 
  0xCE, 0x51, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x6E, 0x61, 0x6D, 0x65, 
  0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x74, 
  0x75, 0x70, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6F, 0x72, 0x64, 
  0x65, 0x72, 0x2E, 0xCF, 0x06, 0x78, 0x70, 0x72, 0x69, 0x6E, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x09, 0x01, 0xDA, 0x06, 0xD8, 0x06, 0x78, 0x70, 0x72, 0x69, 
  0x6E, 0x74, 0xDA, 0x08, 0xCE, 0x80, 0xD4, 0x28, 0x78, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 
  0x6F, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x74, 0x68, 0x65, 
  0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 
  0x6C, 0x79, 0x20, 0x28, 0x6E, 0x6F, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 
  0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 
  0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 
  0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 
  0x6F, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x61, 
  0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 
  0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 
  0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x60, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xCF, 0x09, 0x77, 0x69, 0x74, 
  0x68, 0x2D, 0x64, 0x79, 0x6E, 0x73, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 
  0x4E, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0C, 0x01, 0x01, 0xCD, 0x7F, 
  0xFF, 0xFF, 0xFF, 0x06, 0x25, 0xCE, 0x09, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x64, 0x79, 0x6E, 0x73, 
  0xDA, 0x18, 0xCF, 0x06, 0x73, 0x65, 0x74, 0x64, 0x79, 0x6E, 0xDA, 0x81, 0x4C, 0xDA, 0x80, 0xB9, 
  0xDA, 0x80, 0xBA, 0xD0, 0x01, 0x70, 0xDA, 0x80, 0xBC, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 0x00, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 0x3D, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 
  0x00, 0x21, 0x05, 0x03, 0x06, 0x1C, 0x05, 0x0F, 0x00, 0x19, 0x07, 0x03, 0x00, 0x2F, 0x07, 0x00, 
  0x00, 0x33, 0x08, 0x00, 0x00, 0x05, 0x09, 0x07, 0x01, 0x2F, 0x09, 0x00, 0x00, 0x33, 0x0A, 0x00, 
  0x00, 0x2A, 0x0B, 0x00, 0x00, 0x31, 0x0B, 0x08, 0x0A, 0x43, 0x09, 0x00, 0x00, 0x30, 0x04, 0x09, 
  0x00, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x05, 0x03, 0x03, 0x02, 0x1A, 0xF1, 0xFF, 
  0xFF, 0x19, 0x03, 0x04, 0x00, 0x44, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x30, 0x07, 0x05, 
  0x00, 0x32, 0x03, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x03, 
  0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x07, 0x06, 0x08, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x05, 
  0x00, 0x30, 0x07, 0x05, 0x00, 0x43, 0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x85, 0x4E, 0x01, 
  0x07, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x17, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x11, 0x00, 0x11, 0x00, 0x29, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x03, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x80, 0xE4, 0x28, 
  0x77, 0x69, 0x74, 0x68, 0x2D, 0x64, 0x79, 0x6E, 0x73, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 
  0x61, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6F, 0x66, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x68, 0x61, 0x73, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x0A, 0x64, 0x79, 0x6E, 
  0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x73, 0x65, 
  0x74, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x61, 0x73, 0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x73, 0x0A, 0x6F, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x2C, 0x20, 0x62, 0x75, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x70, 
  0x72, 0x6F, 0x70, 0x65, 0x72, 0x6C, 0x79, 0x0A, 0x75, 0x6E, 0x73, 0x65, 0x74, 0x2C, 0x20, 0x61, 
  0x73, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2D, 0x6C, 0x6F, 0x63, 
  0x61, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x0D, 0x6F, 0x73, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x2D, 
  0x63, 0x6C, 0x6F, 0x73, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x82, 0x74, 
  0x01, 0xDA, 0x06, 0xD8, 0x0D, 0x6F, 0x73, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x2D, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0xDA, 0x08, 0xCE, 0x80, 0x96, 0x28, 0x6F, 0x73, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x2D, 
  0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x29, 0x0A, 0x0A, 0x57, 0x61, 0x69, 
  0x74, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x69, 
  0x66, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x65, 
  0x6E, 0x20, 0x77, 0x61, 0x69, 0x74, 0x65, 0x64, 0x20, 0x6F, 0x6E, 0x2C, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x70, 0x69, 0x70, 0x65, 0x73, 0x20, 0x63, 0x72, 0x65, 
  0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x60, 0x6F, 0x73, 0x2F, 0x73, 0x70, 0x61, 0x77, 
  0x6E, 0x60, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x65, 0x6E, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x64, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xCF, 0x0B, 0x74, 
  0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x80, 0xAA, 0x4A, 0x01, 0xDA, 0x06, 0xDA, 0x80, 0xE4, 0xDA, 0x08, 0xCE, 0x81, 0xCB, 
  0x28, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x61, 0x72, 0x72, 
  0x74, 0x75, 0x70, 0x20, 0x5B, 0x2C, 0x73, 0x74, 0x61, 0x72, 0x74, 0x3D, 0x30, 0x20, 0x5B, 0x2C, 
  0x65, 0x6E, 0x64, 0x3D, 0x28, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x61, 0x72, 0x72, 0x74, 
  0x75, 0x70, 0x29, 0x5D, 0x5D, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x20, 0x61, 0x20, 0x73, 
  0x75, 0x62, 0x2D, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 
  0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x60, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 0x65, 0x6E, 0x64, 0x60, 0x20, 0x65, 0x78, 0x63, 
  0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x73, 0x74, 0x61, 0x72, 
  0x74, 0x60, 0x20, 0x6F, 0x72, 0x20, 0x60, 0x65, 0x6E, 0x64, 0x60, 0x20, 0x61, 0x72, 0x65, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x74, 0x68, 
  0x65, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x30, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 
  0x66, 0x20, 0x60, 0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x60, 0x2C, 0x20, 0x72, 0x65, 0x73, 0x70, 
  0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x2E, 0x20, 0x60, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x65, 0x6E, 0x64, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x64, 
  0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 
  0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2E, 
  0x20, 0x4E, 0x6F, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 
  0x20, 0x2D, 0x31, 0x20, 0x69, 0x73, 0x20, 0x73, 0x79, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 
  0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 0x28, 0x6C, 
  0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x29, 0x60, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x20, 0x6E, 
  0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x72, 0x61, 
  0x6E, 0x67, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0xCF, 0x0B, 0x65, 0x76, 0x61, 
  0x6C, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x8A, 0x1A, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x01, 
  0x01, 0x02, 0x12, 0xCE, 0x0B, 0x65, 0x76, 0x61, 0x6C, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x01, 0x01, 0x01, 0x09, 0x2E, 0xCE, 
  0x09, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0xDA, 0x18, 0xD8, 0x0A, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xDA, 0x82, 0x07, 0xD8, 0x0D, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xDA, 0x80, 0xC1, 0xD8, 0x0C, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xDA, 0x82, 0x7B, 0xD8, 0x0F, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x6D, 0x6F, 0x72, 0x65, 0xD8, 
  0x0E, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0xDA, 
  0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x3E, 0x02, 0x00, 0x00, 0x19, 0x04, 0x02, 0x00, 0x30, 0x03, 0x00, 0x00, 0x2A, 0x05, 
  0x01, 0x00, 0x33, 0x02, 0x05, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x33, 0x02, 
  0x05, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x23, 0x05, 0x06, 0x02, 0x1C, 0x05, 0x06, 0x00, 0x2F, 0x03, 
  0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x33, 0x02, 0x06, 0x00, 0x01, 0x02, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x33, 0x02, 0x05, 0x00, 0x2F, 0x03, 
  0x00, 0x00, 0x2A, 0x05, 0x06, 0x00, 0x33, 0x02, 0x05, 0x00, 0x1C, 0x02, 0x08, 0x00, 0x2F, 0x03, 
  0x00, 0x00, 0x2A, 0x06, 0x07, 0x00, 0x33, 0x05, 0x06, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x07, 
  0x08, 0x00, 0x33, 0x06, 0x07, 0x00, 0x1A, 0xF6, 0xFF, 0xFF, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 
  0x02, 0x00, 0x33, 0x02, 0x05, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x23, 0x05, 0x06, 0x02, 0x1C, 0x05, 
  0x06, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x33, 0x02, 0x06, 0x00, 0x01, 0x02, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x8A, 0x0A, 0x01, 0x04, 0x0B, 0x00, 
  0x0B, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x07, 0xBF, 0xFF, 0x05, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 
  0x05, 0x02, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x0E, 0x00, 
  0x0E, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x07, 0x01, 0x01, 0x01, 0x05, 0x12, 0xCE, 0x04, 0x65, 0x76, 0x61, 0x6C, 0xDA, 0x18, 0xD0, 
  0x04, 0x65, 0x76, 0x61, 0x6C, 0xDA, 0x80, 0x83, 0xDA, 0x1C, 0xD0, 0x08, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0xDA, 0x80, 0xC1, 0x2C, 0x01, 0x00, 0x00, 0x26, 0x02, 0x00, 0x00, 0x2A, 
  0x03, 0x00, 0x00, 0x31, 0x00, 0x02, 0x03, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 
  0x03, 0x02, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 
  0x06, 0x03, 0x00, 0x23, 0x05, 0x04, 0x06, 0x1C, 0x05, 0x02, 0x00, 0x34, 0x03, 0x00, 0x00, 0x2A, 
  0x06, 0x04, 0x00, 0x39, 0x04, 0x03, 0x06, 0x01, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x89, 
  0xF2, 0x01, 0x04, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0A, 
  0x00, 0x0A, 0x00, 0x0A, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x01, 0x05, 0x01, 0x0C, 0x00, 0x0C, 
  0x00, 0x05, 0x00, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x26, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x05, 0x00, 0x00, 
  0x47, 0x03, 0x04, 0x05, 0x19, 0x05, 0x03, 0x00, 0x1D, 0x05, 0x08, 0x00, 0x38, 0x03, 0x04, 0x05, 
  0x19, 0x06, 0x03, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x47, 0x05, 0x04, 0x05, 0x1A, 0xF9, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x8A, 0x1A, 0x01, 0x04, 
  0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x03, 0x00, 0x03, 0xBF, 
  0xFB, 0x01, 0xDA, 0x08, 0xCE, 0x80, 0x84, 0x28, 0x65, 0x76, 0x61, 0x6C, 0x2D, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 
  0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 
  0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6D, 0x6F, 0x72, 0x65, 
  0x20, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 
  0x65, 0x0A, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x6E, 0x65, 0x65, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x75, 0x73, 0x65, 0x20, 0x60, 0x72, 0x75, 
  0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x60, 0x2E, 0xCF, 0x0B, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0x2F, 0x62, 0x75, 0x69, 0x6C, 0x64, 0xD3, 0x02, 0xDA, 0x06, 0xCE, 0x07, 0x63, 0x32, 
  0x38, 0x64, 0x66, 0x31, 0x34, 0xDA, 0x08, 0xCE, 0x32, 0x54, 0x68, 0x65, 0x20, 0x62, 0x75, 0x69, 
  0x6C, 0x64, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xCF, 0x07, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x70, 0x69, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x92, 
  0x01, 0xDA, 0x06, 0xC8, 0x18, 0x2D, 0x44, 0x54, 0xFB, 0x21, 0x09, 0x40, 0xDA, 0x08, 0xCE, 0x0D, 
  0x54, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 0x69, 0x2E, 0xCF, 0x08, 0x6E, 
  0x65, 0x74, 0x2F, 0x72, 0x65, 0x61, 0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 
  0x83, 0x00, 0x01, 0xDA, 0x06, 0xD8, 0x08, 0x6E, 0x65, 0x74, 0x2F, 0x72, 0x65, 0x61, 0x64, 0xDA, 
  0x08, 0xCE, 0x81, 0xD0, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x20, 0x73, 0x74, 
  0x72, 0x65, 0x61, 0x6D, 0x20, 0x6E, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x62, 0x75, 0x66, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x61, 0x64, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2C, 
  0x20, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x75, 0x6E, 
  0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 
  0x65, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x60, 0x6E, 0x60, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x60, 0x3A, 0x61, 0x6C, 0x6C, 0x60, 0x20, 
  0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x65, 0x6E, 
  0x64, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0x20, 0x49, 0x66, 0x20, 
  0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 
  0x28, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x30, 
  0x29, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x70, 0x75, 0x73, 0x68, 0x20, 0x74, 0x68, 0x6F, 
  0x73, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x65, 0x61, 0x72, 0x6C, 0x79, 0x2E, 0x20, 0x54, 0x61, 0x6B, 0x65, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 
  0x65, 0x6F, 0x75, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x2C, 
  0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x20, 0x6D, 0x6F, 0x72, 0x65, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x69, 0x74, 0x2C, 0x20, 0x6F, 0x72, 
  0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x61, 0x69, 
  0x6C, 0x65, 0x64, 0x2E, 0xCF, 0x04, 0x70, 0x6F, 0x73, 0x3F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x83, 0x23, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 
  0x01, 0x01, 0x01, 0x01, 0x07, 0xCE, 0x04, 0x70, 0x6F, 0x73, 0x3F, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x01, 0x1C, 0xCE, 0x07, 0x63, 0x6F, 0x6D, 0x70, 
  0x61, 0x72, 0x65, 0xDA, 0x18, 0xD0, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x2C, 0x02, 
  0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x39, 0x03, 0x00, 0x04, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 
  0x05, 0x00, 0x30, 0x00, 0x01, 0x00, 0x33, 0x05, 0x04, 0x00, 0x19, 0x03, 0x05, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x26, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x02, 0x00, 0x03, 0x04, 
  0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x39, 0x03, 0x01, 0x05, 0x19, 0x05, 0x03, 0x00, 0x1C, 0x05, 
  0x06, 0x00, 0x30, 0x01, 0x00, 0x00, 0x33, 0x06, 0x05, 0x00, 0x08, 0x07, 0x06, 0xFF, 0x19, 0x03, 
  0x07, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x03, 0x00, 0x00, 0x19, 0x05, 0x03, 0x00, 0x1C, 0x05, 
  0x02, 0x00, 0x03, 0x05, 0x00, 0x00, 0x25, 0x03, 0x00, 0x01, 0x03, 0x03, 0x00, 0x00, 0x82, 0xF3, 
  0x01, 0x08, 0x12, 0x00, 0x12, 0x00, 0x05, 0x00, 0x05, 0x00, 0x24, 0x00, 0x24, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x12, 0x00, 0x12, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x27, 0x00, 0x27, 0x00, 0x24, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFE, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x05, 0x00, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x00, 
  0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x24, 0x03, 0x02, 
  0x01, 0x03, 0x03, 0x00, 0x00, 0x83, 0x23, 0x01, 0x00, 0x33, 0x00, 0x33, 0x00, 0x33, 0x00, 0x33, 
  0x00, 0x30, 0x00, 0x30, 0xDA, 0x08, 0xCE, 0x27, 0x28, 0x70, 0x6F, 0x73, 0x3F, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 
  0x67, 0x72, 0x65, 0x61, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x30, 0x2E, 0xCF, 
  0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x80, 0xB3, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x36, 0xDA, 
  0x08, 0xCE, 0x81, 0x6B, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x73, 0x6C, 0x69, 0x63, 
  0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 
  0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x69, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 
  0x73, 0x74, 0x61, 0x72, 0x74, 0x60, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 
  0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 0x65, 0x6E, 0x64, 0x60, 0x2C, 
  0x20, 0x65, 0x78, 0x63, 0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x2E, 0x20, 0x41, 0x6C, 0x6C, 0x20, 
  0x69, 0x6E, 0x64, 0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x30, 0x2E, 0x20, 0x60, 0x73, 0x74, 0x61, 0x72, 0x74, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x60, 0x65, 0x6E, 0x64, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 
  0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 
  0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x65, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x2D, 0x31, 0x20, 0x69, 
  0x73, 0x20, 0x73, 0x79, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 0x73, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 0x28, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x29, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 
  0x77, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2E, 0x20, 0xCF, 
  0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0x32, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x80, 0xA4, 0x81, 0x15, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x65, 0x78, 0x70, 0x32, 0xDA, 0x08, 0xCE, 0x2B, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 
  0x70, 0x32, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x32, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x78, 0x2E, 0xCF, 0x0A, 0x6F, 0x73, 0x2F, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x85, 0xD9, 0x01, 0xDA, 0x06, 0xD8, 0x0A, 0x6F, 
  0x73, 0x2F, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0xDA, 0x08, 0xCE, 0x80, 0x80, 0x28, 0x6F, 
  0x73, 0x2F, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x6F, 0x6C, 0x64, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x6E, 0x65, 0x77, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x6F, 0x6C, 0x64, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x65, 0x77, 
  0x70, 0x61, 0x74, 0x68, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x20, 
  0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x6F, 
  0x73, 0x2F, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x6F, 0x6C, 0x64, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6E, 
  0x65, 0x77, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x72, 0x75, 0x65, 0x29, 0x60, 0x2E, 0xCF, 0x0A, 
  0x64, 0x72, 0x6F, 0x70, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x84, 0x87, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 
  0x02, 0x02, 0x02, 0x02, 0x07, 0xCE, 0x0A, 0x64, 0x72, 0x6F, 0x70, 0x2D, 0x77, 0x68, 0x69, 0x6C, 
  0x65, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x03, 
  0x01, 0xCE, 0x0A, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0xDA, 0x18, 0x2C, 
  0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 
  0x03, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0xDA, 0x18, 0xDA, 0x73, 0x2F, 0x00, 0x00, 0x00, 0x2B, 
  0x02, 0x00, 0x00, 0x33, 0x01, 0x02, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x34, 
  0x02, 0x00, 0x00, 0xBF, 0xFF, 0x82, 0xCC, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x82, 0xC9, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xDA, 0x82, 0x22, 
  0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 
  0x30, 0x03, 0x01, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x84, 0x87, 0x01, 0x04, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x80, 0xBC, 
  0x28, 0x64, 0x72, 0x6F, 0x70, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x72, 0x65, 0x64, 
  0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x70, 
  0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 
  0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 
  0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x6F, 0x72, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x61, 0x74, 
  0x69, 0x73, 0x66, 0x79, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 
  0x74, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x62, 0x6F, 0x72, 0x74, 0x20, 0x6F, 0x6E, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x72, 
  0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x2E, 0xCF, 0x03, 0x6D, 0x6F, 
  0x64, 0xD3, 0x02, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x1D, 0x02, 0x02, 0x02, 0x02, 
  0x00, 0x02, 0xCE, 0x03, 0x6D, 0x6F, 0x64, 0x0C, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0xDA, 
  0x08, 0xCE, 0x41, 0x28, 0x6D, 0x6F, 0x64, 0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x6E, 0x64, 
  0x20, 0x64, 0x69, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x6F, 0x20, 0x6F, 0x66, 
  0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x6E, 0x64, 0x20, 0x2F, 0x20, 0x64, 0x69, 0x76, 0x69, 
  0x73, 0x6F, 0x72, 0x2E, 0xCF, 0x06, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0xD3, 0x04, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x5B, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x0E, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x0A, 0x38, 0xCE, 0x06, 0x70, 0x72, 0x6F, 
  0x6D, 0x70, 0x74, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x4A, 0xDA, 0x80, 0xB9, 0xDA, 0x80, 0xBA, 0xD0, 
  0x02, 0x69, 0x30, 0xDA, 0x44, 0xDA, 0x80, 0xBC, 0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x18, 0x06, 
  0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x01, 0x3D, 0x3D, 0x01, 0x00, 0x00, 
  0x22, 0x02, 0x01, 0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 
  0x38, 0x04, 0x00, 0x05, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 
  0x19, 0x03, 0x04, 0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xDA, 0x80, 0xD7, 0xDA, 
  0x49, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x03, 0x05, 0x00, 0x19, 0x05, 0x03, 0x00, 0x2A, 0x06, 0x00, 
  0x00, 0x33, 0x03, 0x06, 0x00, 0x19, 0x06, 0x03, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x03, 0x07, 
  0x00, 0x19, 0x07, 0x03, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x2F, 0x09, 0x00, 
  0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x08, 0x00, 0x00, 0x30, 0x00, 0x08, 0x00, 0x44, 0x09, 0x00, 
  0x00, 0x2A, 0x0A, 0x02, 0x00, 0x31, 0x0A, 0x03, 0x09, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x03, 
  0x00, 0x2A, 0x0A, 0x04, 0x00, 0x31, 0x09, 0x08, 0x0A, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x05, 
  0x00, 0x31, 0x09, 0x07, 0x03, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x30, 0x09, 0x07, 
  0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 0x05, 0x00, 0x31, 0x0A, 0x04, 0x03, 0x43, 0x09, 0x00, 
  0x00, 0x30, 0x05, 0x06, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x0B, 0x05, 0x00, 0x31, 0x0B, 0x03, 
  0x04, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x07, 0x00, 0x31, 0x0B, 0x00, 0x05, 0x43, 0x03, 0x00, 
  0x00, 0x2A, 0x0C, 0x08, 0x00, 0x31, 0x0C, 0x04, 0x07, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0D, 0x09, 
  0x00, 0x31, 0x0D, 0x03, 0x06, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0B, 0x01, 
  0x00, 0x31, 0x0B, 0x08, 0x09, 0x30, 0x0A, 0x0C, 0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x81, 0x5B, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xDA, 0x08, 0xCE, 0x80, 0x8F, 0x28, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x20, 0x74, 
  0x61, 0x67, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 
  0x75, 0x70, 0x20, 0x61, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x2E, 0x20, 0x60, 0x74, 0x61, 0x67, 0x60, 0x20, 0x73, 
  0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x0A, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 
  0x20, 0x61, 0x20, 0x60, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x60, 0x20, 0x73, 0x74, 0x61, 0x74, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x61, 0x20, 0x6B, 0x65, 
  0x79, 0x77, 0x6F, 0x72, 0x64, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x73, 0x71, 0x72, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x1A, 
  0x01, 0xDA, 0x06, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x71, 0x72, 0x74, 0xDA, 0x08, 
  0xCE, 0x2C, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x71, 0x72, 0x74, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x71, 0x75, 
  0x61, 0x72, 0x65, 0x20, 0x72, 0x6F, 0x6F, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xCF, 0x0C, 
  0x6E, 0x65, 0x74, 0x2F, 0x70, 0x65, 0x65, 0x72, 0x6E, 0x61, 0x6D, 0x65, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x12, 0x82, 0xCB, 0x01, 0xDA, 0x06, 0xD8, 0x0C, 0x6E, 0x65, 0x74, 0x2F, 
  0x70, 0x65, 0x65, 0x72, 0x6E, 0x61, 0x6D, 0x65, 0xDA, 0x08, 0xCE, 0x58, 0x28, 0x6E, 0x65, 0x74, 
  0x2F, 0x70, 0x65, 0x65, 0x72, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 
  0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6D, 0x6F, 
  0x74, 0x65, 0x20, 0x70, 0x65, 0x65, 0x72, 0x27, 0x73, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 
  0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 
  0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6F, 0x72, 
  0x64, 0x65, 0x72, 0x2E, 0xCF, 0x08, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0xC8, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x02, 
  0xBA, 0x00, 0x00, 0x10, 0x02, 0x01, 0x02, 0x14, 0x3F, 0x01, 0xCE, 0x08, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x67, 0x65, 0x72, 0xDA, 0x18, 0xD8, 0x0C, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x67, 0x65, 
  0x74, 0x65, 0x6E, 0x76, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x00, 0x01, 0x02, 
  0x0C, 0xCE, 0x08, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x65, 0x6E, 0x76, 0xDA, 0x18, 0xDA, 0x00, 0xD8, 
  0x0E, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x2C, 
  0x01, 0x00, 0x00, 0x1C, 0x00, 0x03, 0x00, 0x19, 0x02, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x42, 0x04, 0x00, 0x00, 0x30, 0x04, 0x03, 0x00, 0x2A, 
  0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x04, 0x05, 0x00, 0x03, 0x04, 0x00, 0x00, 0x88, 
  0xD5, 0x01, 0x05, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0xD0, 0x05, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0xD0, 0x0B, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2D, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0xD8, 0x10, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2F, 0x6C, 0x61, 0x73, 0x74, 0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0xD0, 
  0x06, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0xD3, 0x12, 0xCF, 0x09, 0x2E, 0x62, 0x79, 0x74, 0x65, 
  0x63, 0x6F, 0x64, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x4F, 0x03, 
  0xDA, 0x06, 0xD7, 0x01, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01, 0x07, 0x01, 
  0xCE, 0x09, 0x2E, 0x62, 0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0xDA, 0x18, 0xD0, 0x08, 0x62, 
  0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2B, 
  0x03, 0x00, 0x01, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x34, 
  0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8D, 0x4F, 0x03, 0x03, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x07, 0xC9, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 
  0x00, 0x01, 0x03, 0x0C, 0xCE, 0x07, 0x2E, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 0xDA, 0x18, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x01, 0x00, 0x01, 0x02, 0x0D, 0xCE, 0x06, 0x2E, 0x66, 
  0x72, 0x61, 0x6D, 0x65, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x02, 0x00, 0x00, 
  0x00, 0x02, 0x05, 0xCE, 0x06, 0x2E, 0x66, 0x69, 0x62, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x83, 0x33, 
  0xDA, 0x81, 0x1D, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 
  0x01, 0x01, 0x00, 0x34, 0x01, 0x00, 0x00, 0x8D, 0x1F, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xD8, 0x0B, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x2C, 
  0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 
  0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 0x00, 0x1C, 0x00, 0x03, 0x00, 0x19, 
  0x04, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x04, 0x00, 0x00, 0x38, 0x05, 0x02, 0x04, 0x03, 
  0x05, 0x00, 0x00, 0x8D, 0x30, 0x01, 0x03, 0x1B, 0x00, 0x1B, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 
  0x00, 0x03, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x82, 
  0xE3, 0xD8, 0x06, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 
  0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 
  0x00, 0x2F, 0x04, 0x00, 0x00, 0x33, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x05, 0x00, 
  0x00, 0x2A, 0x06, 0x02, 0x00, 0x34, 0x06, 0x00, 0x00, 0x8D, 0x48, 0x03, 0x03, 0x10, 0x00, 0x10, 
  0x00, 0x10, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xDA, 0x83, 0x3B, 0xC9, 0xC9, 0xC9, 0xC9, 0xDA, 0x08, 0xCE, 0x3E, 0x28, 0x2E, 0x62, 
  0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 
  0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xCF, 0x07, 0x2E, 0x73, 0x6F, 
  0x75, 0x72, 0x63, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x85, 0x01, 
  0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x01, 0x00, 0x01, 0x05, 0x12, 0xCE, 
  0x07, 0x2E, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0xDA, 0x18, 0xDA, 0x83, 0x40, 0xD0, 0x06, 0x73, 
  0x6F, 0x75, 0x72, 0x63, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x01, 0x01, 0x01, 
  0x07, 0x16, 0xCE, 0x05, 0x73, 0x6C, 0x75, 0x72, 0x70, 0xDA, 0x18, 0xD0, 0x02, 0x72, 0x62, 0xD8, 
  0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x6F, 0x70, 0x65, 0x6E, 0xCE, 0x14, 0x63, 0x6F, 0x75, 0x6C, 
  0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0xDA, 0x81, 0x38, 0xD0, 0x03, 0x61, 0x6C, 0x6C, 0xD8, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x72, 
  0x65, 0x61, 0x64, 0xD8, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x2C, 
  0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x1C, 0x03, 0x02, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 
  0x04, 0x02, 0x00, 0x30, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x33, 0x04, 0x05, 0x00, 0x01, 
  0x04, 0x00, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x30, 0x03, 0x04, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x33, 
  0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x33, 
  0x06, 0x07, 0x00, 0x03, 0x05, 0x00, 0x00, 0x86, 0xA3, 0x01, 0x03, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x0D, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xBF, 0xFA, 0x01, 0xDA, 0x81, 0x51, 0xD8, 0x06, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 
  0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x33, 0x04, 0x03, 0x00, 
  0x19, 0x05, 0x04, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 
  0x19, 0x07, 0x06, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x31, 0x08, 0x07, 0x09, 
  0x2A, 0x08, 0x04, 0x00, 0x34, 0x08, 0x00, 0x00, 0x8D, 0x85, 0x01, 0x03, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 
  0x47, 0x28, 0x2E, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 
  0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x64, 
  0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x64, 0x2E, 0xCF, 0x05, 0x2E, 0x73, 0x74, 0x65, 0x70, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0xAD, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x08, 0x01, 0x00, 0x01, 0x02, 0x12, 0xCE, 0x05, 0x2E, 0x73, 0x74, 0x65, 
  0x70, 0xDA, 0x18, 0xDA, 0x83, 0x42, 0xD8, 0x0A, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 
  0x65, 0x70, 0x2C, 0x01, 0x00, 0x00, 0x26, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x1C, 0x00, 
  0x03, 0x00, 0x19, 0x04, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 0x19, 0x05, 
  0x04, 0x00, 0x21, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x08, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 
  0x07, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x02, 0x07, 0x00, 0x05, 0x03, 
  0x03, 0x01, 0x1A, 0xF8, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x8D, 0xAD, 0x01, 0x03, 0x03, 0x01, 
  0x03, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x1A, 0x00, 0x1A, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFC, 
  0x01, 0xDA, 0x08, 0xCE, 0x30, 0x28, 0x2E, 0x73, 0x74, 0x65, 0x70, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x6E, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x73, 0x2E, 0xCF, 0x09, 0x2E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x61, 0x6C, 0x6C, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x73, 0x03, 0xDA, 0x06, 0xD7, 0x01, 
  0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0B, 0x01, 0x00, 0x01, 0x05, 0x1A, 0x01, 0xCE, 0x09, 0x2E, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0x61, 0x6C, 0x6C, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x05, 0x01, 0x00, 0x01, 0x02, 0x07, 0xCE, 0x03, 0x2E, 0x66, 0x6E, 0xDA, 0x18, 0xDA, 0x83, 0x40, 
  0xDA, 0x82, 0xE3, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x38, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x8D, 
  0x36, 0x01, 0x03, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xD8, 0x0C, 
  0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x66, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xCE, 0x04, 0x73, 0x65, 
  0x74, 0x20, 0xCE, 0x10, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0xDA, 0x83, 0x55, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 
  0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2B, 
  0x05, 0x00, 0x02, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x29, 0x06, 0x00, 0x00, 0x3D, 
  0x07, 0x05, 0x00, 0x19, 0x08, 0x07, 0x00, 0x21, 0x07, 0x06, 0x08, 0x1C, 0x07, 0x06, 0x00, 0x30, 
  0x03, 0x06, 0x00, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x05, 0x06, 0x06, 0x01, 0x1A, 
  0xFA, 0xFF, 0xFF, 0x3D, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 
  0x07, 0x06, 0x08, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x34, 0x07, 0x00, 0x00, 0xBF, 
  0xFF, 0x8D, 0x73, 0x03, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x13, 0x00, 0x13, 
  0x00, 0x13, 0x00, 0x05, 0x01, 0x05, 0x00, 0x0F, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x02, 0x14, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xDB, 0x01, 0xDA, 0x08, 0xCE, 0x50, 0x28, 0x2E, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0x61, 0x6C, 0x6C, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 
  0x0A, 0x53, 0x65, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 
  0x20, 0x6F, 0x6E, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 
  0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xCF, 0x05, 0x2E, 
  0x6E, 0x65, 0x78, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x9F, 0x01, 
  0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x01, 0x00, 0x01, 0x01, 0x11, 0xCE, 
  0x05, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0xDA, 0x18, 0xDA, 0x83, 0x42, 0x2C, 0x01, 0x00, 0x00, 0x26, 
  0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x1C, 0x00, 0x03, 0x00, 0x19, 0x04, 0x00, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 0x19, 0x05, 0x04, 0x00, 0x21, 0x04, 0x03, 0x05, 0x1C, 
  0x04, 0x07, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x26, 0x07, 0x00, 0x00, 0x35, 
  0x02, 0x06, 0x07, 0x05, 0x03, 0x03, 0x01, 0x1A, 0xF9, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x8D, 
  0x9F, 0x01, 0x03, 0x03, 0x01, 0x03, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x16, 0x00, 0x16, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x03, 0x00, 
  0x03, 0xBF, 0xFC, 0x01, 0xDA, 0x08, 0xCE, 0x2A, 0x28, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x6F, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 
  0x74, 0x2E, 0xCF, 0x09, 0x2E, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x61, 0x6C, 0x6C, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x7C, 0x03, 0xDA, 0x06, 0xD7, 0x01, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x0B, 0x01, 0x00, 0x01, 0x05, 0x1A, 0x01, 0xCE, 0x09, 0x2E, 0x63, 0x6C, 0x65, 0x61, 
  0x72, 0x61, 0x6C, 0x6C, 0xDA, 0x18, 0xDA, 0x83, 0x63, 0xD8, 0x0E, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x2F, 0x75, 0x6E, 0x66, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xCE, 0x08, 0x63, 0x6C, 0x65, 0x61, 0x72, 
  0x65, 0x64, 0x20, 0xDA, 0x83, 0x67, 0xDA, 0x83, 0x55, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 
  0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x00, 0x00, 
  0x00, 0x2B, 0x05, 0x00, 0x02, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x29, 0x06, 0x00, 
  0x00, 0x3D, 0x07, 0x05, 0x00, 0x19, 0x08, 0x07, 0x00, 0x21, 0x07, 0x06, 0x08, 0x1C, 0x07, 0x06, 
  0x00, 0x30, 0x03, 0x06, 0x00, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x05, 0x06, 0x06, 
  0x01, 0x1A, 0xFA, 0xFF, 0xFF, 0x3D, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x2A, 0x08, 0x03, 
  0x00, 0x31, 0x07, 0x06, 0x08, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x34, 0x07, 0x00, 
  0x00, 0xBF, 0xFF, 0x8D, 0x7C, 0x03, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x13, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x05, 0x01, 0x05, 0x00, 0x0F, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x02, 0x18, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xDB, 0x01, 0xDA, 0x08, 0xCE, 0x42, 0x28, 
  0x2E, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x61, 0x6C, 0x6C, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 
  0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x72, 0x65, 
  0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x2E, 0xCF, 0x07, 0x2E, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x8D, 0x48, 0x03, 0xDA, 0x06, 0xDA, 0x83, 0x3E, 0xDA, 0x08, 0xCE, 0x3D, 0x28, 
  0x2E, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 
  0x6C, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 
  0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xCF, 0x05, 0x2E, 0x73, 
  0x6C, 0x6F, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x40, 0x01, 0xDA, 
  0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x00, 0x02, 0x01, 0x0A, 0xCE, 0x05, 
  0x2E, 0x73, 0x6C, 0x6F, 0x74, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 
  0x00, 0x01, 0x02, 0x07, 0xCE, 0x06, 0x2E, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0xDA, 0x18, 0xDA, 0x83, 
  0x40, 0xD0, 0x05, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x38, 0x03, 0x02, 0x04, 
  0x03, 0x03, 0x00, 0x00, 0x8D, 0x3B, 0x01, 0x03, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 
  0x03, 0x04, 0x00, 0x1C, 0x00, 0x03, 0x00, 0x19, 0x04, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 
  0x04, 0x00, 0x00, 0x38, 0x05, 0x03, 0x04, 0x03, 0x05, 0x00, 0x00, 0x8D, 0x40, 0x01, 0x03, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 
  0xDA, 0x08, 0xCE, 0x3A, 0x28, 0x2E, 0x73, 0x6C, 0x6F, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x6E, 0x74, 0x68, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x2D, 0x69, 0x64, 0x78, 0x29, 0x0A, 0x0A, 
  0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x74, 0x68, 0x20, 0x73, 0x6C, 0x6F, 0x74, 0x2E, 0xCF, 0x06, 
  0x2E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 
  0x8D, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x07, 
  0x15, 0xCE, 0x06, 0x2E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xDA, 0x18, 0xDA, 0x83, 0x40, 0xDA, 0x82, 
  0xE3, 0xD0, 0x02, 0x70, 0x63, 0xDA, 0x83, 0x65, 0xCE, 0x12, 0x73, 0x65, 0x74, 0x20, 0x62, 0x72, 
  0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0xCE, 0x07, 0x20, 0x61, 
  0x74, 0x20, 0x70, 0x63, 0x3D, 0xDA, 0x83, 0x55, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 
  0x33, 0x01, 0x02, 0x00, 0x19, 0x02, 0x01, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x2F, 0x03, 0x00, 0x00, 
  0x33, 0x03, 0x02, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x2F, 0x05, 0x00, 0x00, 
  0x33, 0x05, 0x02, 0x00, 0x19, 0x06, 0x05, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 0x03, 0x00, 
  0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x31, 0x08, 0x04, 0x09, 
  0x2F, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x06, 0x00, 0x34, 0x08, 0x00, 0x00, 0x8D, 0x8D, 0x01, 0x03, 
  0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x2B, 0x28, 0x2E, 0x62, 0x72, 0x65, 
  0x61, 0x6B, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 
  0x69, 0x6E, 0x74, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 
  0x6E, 0x74, 0x20, 0x70, 0x63, 0x2E, 0xCF, 0x06, 0x2E, 0x63, 0x6C, 0x65, 0x61, 0x72, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x96, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x15, 0xCE, 0x06, 0x2E, 0x63, 0x6C, 0x65, 0x61, 
  0x72, 0xDA, 0x18, 0xDA, 0x83, 0x40, 0xDA, 0x82, 0xE3, 0xDA, 0x83, 0x89, 0xDA, 0x83, 0x74, 0xCE, 
  0x16, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x65, 0x64, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 
  0x69, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0xDA, 0x83, 0x8B, 0xDA, 0x83, 0x55, 0x2C, 0x00, 0x00, 
  0x00, 0x2A, 0x02, 0x00, 0x00, 0x33, 0x01, 0x02, 0x00, 0x19, 0x02, 0x01, 0x00, 0x2A, 0x03, 0x01, 
  0x00, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x03, 0x02, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x02, 
  0x00, 0x2F, 0x05, 0x00, 0x00, 0x33, 0x05, 0x02, 0x00, 0x19, 0x06, 0x05, 0x00, 0x30, 0x04, 0x06, 
  0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x2A, 0x09, 0x05, 
  0x00, 0x31, 0x08, 0x04, 0x09, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x06, 0x00, 0x34, 0x08, 0x00, 
  0x00, 0x8D, 0x96, 0x01, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x27, 
  0x28, 0x2E, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 
  0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x2E, 0xCF, 0x06, 0x2E, 0x66, 0x72, 0x61, 0x6D, 0x65, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x30, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x40, 
  0xDA, 0x08, 0xCE, 0x24, 0x28, 0x2E, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x63, 
  0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x2E, 0xCF, 0x03, 0x2E, 0x66, 0x6E, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x36, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x63, 0xDA, 0x08, 
  0xCE, 0x27, 0x28, 0x2E, 0x66, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 
  0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xCF, 0x06, 0x2E, 0x73, 0x6C, 0x6F, 0x74, 
  0x73, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x3B, 0x01, 0xDA, 0x06, 0xDA, 
  0x83, 0x80, 0xDA, 0x08, 0xCE, 0x38, 0x28, 0x2E, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x2E, 0xCF, 0x06, 
  0x2E, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 
  0x29, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0xB8, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 
  0x0C, 0x01, 0xCE, 0x06, 0x2E, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xDA, 0x18, 0xDA, 0x82, 0x70, 0xDA, 
  0x82, 0xC9, 0xDA, 0x80, 0xBA, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x33, 0x01, 0x02, 
  0x00, 0x2E, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x02, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x26, 0x04, 0x00, 0x00, 0x35, 0x02, 0x03, 0x04, 0x2A, 0x03, 0x00, 
  0x00, 0x34, 0x03, 0x00, 0x00, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x06, 0x0D, 
  0xDA, 0x18, 0xD0, 0x09, 0x65, 0x72, 0x72, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0xDA, 0x82, 0x5B, 
  0xDA, 0x83, 0x42, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x05, 
  0xCE, 0x07, 0x2E, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0xDA, 0x18, 0xDA, 0x83, 0x36, 0xDA, 0x81, 
  0x1D, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x01, 0x01, 
  0x00, 0x34, 0x01, 0x00, 0x00, 0x8D, 0x24, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xDA, 0x81, 0x37, 0xD8, 0x10, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 
  0x74, 0x72, 0x61, 0x63, 0x65, 0x2A, 0x00, 0x00, 0x00, 0x28, 0x01, 0x00, 0x00, 0x30, 0x00, 0x01, 
  0x00, 0x2A, 0x01, 0x01, 0x00, 0x33, 0x00, 0x01, 0x00, 0x2A, 0x02, 0x02, 0x00, 0x33, 0x01, 0x02, 
  0x00, 0x2A, 0x03, 0x03, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x04, 0x00, 0x31, 0x01, 0x02, 
  0x03, 0x2A, 0x03, 0x05, 0x00, 0x34, 0x03, 0x00, 0x00, 0x8D, 0x2D, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x34, 0x00, 0x34, 0x00, 0x3D, 0x00, 0x3D, 0x00, 0x22, 0x00, 0x22, 
  0x00, 0x22, 0x00, 0x22, 0x8D, 0x29, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 
  0x28, 0x28, 0x2E, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x2E, 0xCF, 0x07, 0x2E, 0x73, 0x69, 0x67, 0x6E, 
  0x61, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x24, 0x01, 0xDA, 0x06, 
  0xDA, 0x83, 0xA6, 0xDA, 0x08, 0xCE, 0x31, 0x28, 0x2E, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x29, 
  0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x64, 
  0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x64, 0x2E, 0xCF, 0x06, 0x2E, 0x70, 0x70, 0x61, 0x73, 0x6D, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x54, 0x03, 0xDA, 0x06, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x20, 0x01, 0x00, 0x01, 0x29, 0x80, 0x95, 0xCE, 0x06, 0x2E, 0x70, 
  0x70, 0x61, 0x73, 0x6D, 0xDA, 0x18, 0xDA, 0x83, 0x40, 0xDA, 0x82, 0xE3, 0xDA, 0x83, 0x45, 0xDA, 
  0x83, 0x3D, 0xDA, 0x83, 0x89, 0xD0, 0x09, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 0x61, 0x70, 
  0xD2, 0x02, 0x00, 0xBF, 0xFE, 0xBF, 0xFE, 0xDA, 0x83, 0xA6, 0xCE, 0x0F, 0x0A, 0x20, 0x20, 0x73, 
  0x69, 0x67, 0x6E, 0x61, 0x6C, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDA, 0x83, 0x55, 0xDA, 0x83, 
  0x42, 0xDA, 0x80, 0xBE, 0xCE, 0x0E, 0x20, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3A, 0x20, 
  0x20, 0x20, 0x20, 0x20, 0xD0, 0x04, 0x6E, 0x61, 0x6D, 0x65, 0xCE, 0x0B, 0x3C, 0x61, 0x6E, 0x6F, 
  0x6E, 0x79, 0x6D, 0x6F, 0x75, 0x73, 0x3E, 0xDA, 0x83, 0x4C, 0xDA, 0x81, 0x37, 0xDA, 0x80, 0x92, 
  0xCE, 0x0E, 0x20, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x20, 0x20, 0x20, 
  0xCE, 0x02, 0x20, 0x5B, 0xCE, 0x01, 0x5D, 0xD0, 0x09, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 
  0x74, 0x73, 0xCE, 0x12, 0x20, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x73, 0x3A, 
  0x20, 0x20, 0x25, 0x2E, 0x34, 0x71, 0xD8, 0x07, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0xDA, 
  0x83, 0x82, 0xCE, 0x13, 0x20, 0x20, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x3A, 0x20, 0x20, 0x20, 0x20, 
  0x20, 0x20, 0x25, 0x2E, 0x34, 0x71, 0x0A, 0xDA, 0x81, 0x4F, 0xDA, 0x81, 0x50, 0xDA, 0x80, 0xAC, 
  0xDA, 0x82, 0x47, 0xDA, 0x81, 0x33, 0xDA, 0x81, 0x03, 0xCE, 0x02, 0x3E, 0x20, 0xCE, 0x02, 0x20, 
  0x20, 0xDA, 0x81, 0x38, 0xDA, 0x82, 0x48, 0xD8, 0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x6A, 0x6F, 0x69, 0x6E, 0xCE, 0x05, 0x25, 0x2E, 0x32, 0x30, 0x73, 0xD8, 0x06, 0x65, 0x70, 0x72, 
  0x69, 0x6E, 0x66, 0xCE, 0x08, 0x20, 0x23, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0xCE, 0x09, 0x2C, 
  0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 0x00, 
  0x2F, 0x04, 0x00, 0x00, 0x33, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x05, 0x00, 0x00, 
  0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x2A, 0x09, 0x03, 0x00, 
  0x38, 0x08, 0x07, 0x09, 0x19, 0x09, 0x08, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x2F, 0x0A, 0x00, 0x00, 
  0x33, 0x0A, 0x03, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x2A, 0x0D, 0x05, 0x00, 0x38, 0x0C, 0x07, 0x0D, 
  0x19, 0x0D, 0x0C, 0x00, 0x2A, 0x0E, 0x06, 0x00, 0x2A, 0x10, 0x07, 0x00, 0x33, 0x0F, 0x10, 0x00, 
  0x2A, 0x10, 0x08, 0x00, 0x30, 0x10, 0x0F, 0x00, 0x2A, 0x11, 0x09, 0x00, 0x33, 0x10, 0x11, 0x00, 
  0x2A, 0x11, 0x0A, 0x00, 0x33, 0x0F, 0x11, 0x00, 0x2F, 0x0F, 0x00, 0x00, 0x2A, 0x12, 0x0B, 0x00, 
  0x33, 0x11, 0x12, 0x00, 0x2A, 0x0F, 0x0C, 0x00, 0x30, 0x0F, 0x11, 0x00, 0x2A, 0x12, 0x09, 0x00, 
  0x33, 0x0F, 0x12, 0x00, 0x2A, 0x12, 0x0D, 0x00, 0x39, 0x11, 0x07, 0x12, 0x1E, 0x11, 0x02, 0x00, 
  0x2A, 0x11, 0x0E, 0x00, 0x2A, 0x12, 0x0F, 0x00, 0x2A, 0x13, 0x10, 0x00, 0x31, 0x07, 0x12, 0x13, 
  0x2A, 0x13, 0x11, 0x00, 0x33, 0x12, 0x13, 0x00, 0x2A, 0x13, 0x12, 0x00, 0x2A, 0x14, 0x13, 0x00, 
  0x31, 0x13, 0x11, 0x14, 0x2A, 0x13, 0x14, 0x00, 0x30, 0x12, 0x13, 0x00, 0x2A, 0x14, 0x09, 0x00, 
  0x33, 0x13, 0x14, 0x00, 0x2A, 0x11, 0x15, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x33, 0x11, 0x07, 0x00, 
  0x19, 0x12, 0x11, 0x00, 0x1C, 0x12, 0x06, 0x00, 0x2A, 0x11, 0x16, 0x00, 0x30, 0x11, 0x12, 0x00, 
  0x2A, 0x14, 0x17, 0x00, 0x33, 0x11, 0x14, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x11, 0x18, 0x00, 
  0x2F, 0x11, 0x00, 0x00, 0x33, 0x11, 0x03, 0x00, 0x2A, 0x12, 0x19, 0x00, 0x30, 0x12, 0x11, 0x00, 
  0x2A, 0x14, 0x17, 0x00, 0x33, 0x12, 0x14, 0x00, 0x2A, 0x11, 0x1A, 0x00, 0x29, 0x14, 0x14, 0x00, 
  0x30, 0x11, 0x14, 0x00, 0x2A, 0x14, 0x1B, 0x00, 0x33, 0x11, 0x14, 0x00, 0x19, 0x14, 0x11, 0x00, 
  0x29, 0x15, 0x00, 0x00, 0x3D, 0x16, 0x09, 0x00, 0x19, 0x17, 0x16, 0x00, 0x21, 0x16, 0x15, 0x17, 
  0x1C, 0x16, 0x41, 0x00, 0x19, 0x18, 0x15, 0x00, 0x2F, 0x18, 0x00, 0x00, 0x33, 0x19, 0x09, 0x00, 
  0x19, 0x1A, 0x19, 0x00, 0x2F, 0x1A, 0x00, 0x00, 0x2A, 0x1C, 0x1C, 0x00, 0x33, 0x1B, 0x1C, 0x00, 
  0x2A, 0x1D, 0x1D, 0x00, 0x23, 0x1C, 0x1B, 0x1D, 0x1C, 0x1C, 0x03, 0x00, 0x2A, 0x19, 0x1E, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x2A, 0x19, 0x1A, 0x00, 0x2F, 0x19, 0x00, 0x00, 0x2A, 0x1C, 0x1F, 0x00, 
  0x33, 0x1B, 0x1C, 0x00, 0x23, 0x1B, 0x18, 0x0B, 0x1C, 0x1B, 0x03, 0x00, 0x2A, 0x19, 0x20, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x2A, 0x19, 0x21, 0x00, 0x2F, 0x19, 0x00, 0x00, 0x2A, 0x1C, 0x1F, 0x00, 
  0x33, 0x1B, 0x1C, 0x00, 0x2A, 0x19, 0x22, 0x00, 0x30, 0x19, 0x1A, 0x00, 0x2A, 0x1B, 0x23, 0x00, 
  0x33, 0x19, 0x1B, 0x00, 0x2A, 0x1B, 0x1A, 0x00, 0x30, 0x19, 0x1B, 0x00, 0x2A, 0x1C, 0x24, 0x00, 
  0x33, 0x1B, 0x1C, 0x00, 0x30, 0x1B, 0x14, 0x00, 0x2A, 0x1C, 0x22, 0x00, 0x33, 0x19, 0x1C, 0x00, 
  0x2A, 0x1B, 0x25, 0x00, 0x30, 0x1B, 0x19, 0x00, 0x2A, 0x1C, 0x26, 0x00, 0x33, 0x1B, 0x1C, 0x00, 
  0x1C, 0x0D, 0x15, 0x00, 0x2F, 0x18, 0x00, 0x00, 0x33, 0x19, 0x0D, 0x00, 0x3B, 0x1B, 0x19, 0x00, 
  0x19, 0x1C, 0x1B, 0x00, 0x3B, 0x1B, 0x19, 0x01, 0x19, 0x1D, 0x1B, 0x00, 0x30, 0x1C, 0x1D, 0x00, 
  0x43, 0x19, 0x00, 0x00, 0x19, 0x1B, 0x19, 0x00, 0x48, 0x19, 0x1B, 0x0E, 0x1C, 0x19, 0x09, 0x00, 
  0x19, 0x0E, 0x1B, 0x00, 0x2A, 0x1E, 0x27, 0x00, 0x2A, 0x1F, 0x28, 0x00, 0x31, 0x1E, 0x1C, 0x1F, 
  0x2F, 0x1D, 0x00, 0x00, 0x2A, 0x1F, 0x1F, 0x00, 0x33, 0x1E, 0x1F, 0x00, 0x1A, 0x01, 0x00, 0x00, 
  0x1A, 0x01, 0x00, 0x00, 0x2A, 0x1B, 0x09, 0x00, 0x33, 0x19, 0x1B, 0x00, 0x05, 0x15, 0x15, 0x01, 
  0x1A, 0xBF, 0xFF, 0xFF, 0x2A, 0x15, 0x09, 0x00, 0x34, 0x15, 0x00, 0x00, 0x8D, 0x54, 0x03, 0x03, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x01, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x13, 0x00, 0x13, 0x00, 0x05, 0x01, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x05, 0x01, 0x14, 0x00, 0x14, 0x00, 0x05, 0x01, 0x05, 0x01, 0x20, 0x00, 
  0x20, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x2C, 0x00, 0x2C, 0x00, 0x1E, 0x00, 
  0x1E, 0x00, 0x1E, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x1E, 0x00, 0x1E, 0x00, 
  0x1E, 0x00, 0x1E, 0x00, 0x42, 0x00, 0x42, 0x00, 0x42, 0x00, 0x42, 0x00, 0x42, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x1A, 0x00, 0x1A, 0x00, 
  0x1A, 0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 
  0x02, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x05, 0x01, 0x05, 0x00, 0x18, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x18, 0x00, 0x18, 0xBF, 0xFF, 0x05, 0x02, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x01, 0x07, 0x01, 0x17, 0x00, 0x17, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x01, 0x13, 0x00, 0x13, 0xBF, 0xFF, 0x09, 0x02, 0x11, 0x00, 0x0B, 0x01, 0x0D, 0x01, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFE, 0x0B, 0xBF, 0xFD, 0x07, 
  0x06, 0x07, 0x00, 0x07, 0xBF, 0xF5, 0x05, 0x00, 0x05, 0x0C, 0x05, 0x00, 0x05, 0xDA, 0x08, 0xCE, 
  0x45, 0x28, 0x2E, 0x70, 0x70, 0x61, 0x73, 0x6D, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 
  0x0A, 0x0A, 0x50, 0x72, 0x65, 0x74, 0x74, 0x79, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xCF, 0x06, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0x63, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0xA7, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x04, 0x01, 0x00, 0x01, 0x02, 0x06, 0xCE, 0x06, 0x2E, 0x6E, 0x65, 0x78, 0x74, 
  0x63, 0xDA, 0x18, 0xDA, 0x83, 0x90, 0xDA, 0x83, 0x6C, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 
  0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 
  0x00, 0x8D, 0xA7, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 
  0xCE, 0x4C, 0x28, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 
  0x29, 0x0A, 0x0A, 0x47, 0x6F, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 
  0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x2C, 0x20, 0x63, 0x6C, 
  0x65, 0x61, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 
  0x6E, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x2E, 0xCF, 0x06, 
  0x2E, 0x66, 0x69, 0x62, 0x65, 0x72, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 
  0x1F, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x42, 0xDA, 0x08, 0xCE, 0x2F, 0x28, 0x2E, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 
  0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x64, 0x2E, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x08, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x0A, 0x6D, 0x65, 0x72, 
  0x67, 0x65, 0x2D, 0x69, 0x6E, 0x74, 0x6F, 0xDA, 0x18, 0x2C, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 
  0x00, 0x47, 0x03, 0x01, 0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 0x0E, 0x00, 0x38, 0x03, 0x01, 
  0x04, 0x19, 0x05, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x03, 0x05, 0x06, 0x19, 0x06, 0x03, 
  0x00, 0x1D, 0x06, 0x06, 0x00, 0x19, 0x03, 0x06, 0x00, 0x38, 0x07, 0x05, 0x03, 0x3A, 0x00, 0x03, 
  0x07, 0x47, 0x06, 0x05, 0x06, 0x1A, 0xFB, 0xFF, 0xFF, 0x47, 0x04, 0x01, 0x04, 0x1A, 0xF3, 0xFF, 
  0xFF, 0x03, 0x00, 0x00, 0x00, 0x85, 0xF2, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x12, 
  0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCE, 0x0F, 
  0x65, 0x6E, 0x74, 0x65, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x5B, 0xCE, 
  0x12, 0x5D, 0x20, 0x2D, 0x20, 0x28, 0x71, 0x75, 0x69, 0x74, 0x29, 0x20, 0x74, 0x6F, 0x20, 0x65, 
  0x78, 0x69, 0x74, 0xDA, 0x83, 0x55, 0xDA, 0x82, 0xB7, 0xD1, 0x01, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 
  0x00, 0x00, 0x07, 0x03, 0x01, 0x03, 0x00, 0x0A, 0x01, 0xCE, 0x12, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x67, 0x65, 0x72, 0x2D, 0x6F, 0x6E, 0x2D, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xDA, 0x18, 0x2C, 
  0x03, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x01, 0x1C, 0x05, 0x03, 0x00, 0x29, 
  0x04, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x04, 0x01, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2E, 
  0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 
  0x0D, 0x29, 0x01, 0xDA, 0x18, 0xDA, 0x80, 0xBE, 0xDA, 0x80, 0xD6, 0xDA, 0x06, 0xCF, 0x01, 0x5F, 
  0xDA, 0x82, 0xB4, 0xDA, 0x82, 0xB5, 0xDA, 0x82, 0xB6, 0xDA, 0x82, 0xB7, 0xDA, 0x81, 0x37, 0xDA, 
  0x83, 0xA8, 0xD8, 0x06, 0x65, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xD0, 0x05, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0xDA, 0x83, 0x2D, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x19, 0x03, 0x02, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 0x04, 0x05, 0x03, 0x1C, 0x04, 0x14, 0x00, 
  0x2B, 0x05, 0x00, 0x02, 0x1C, 0x05, 0x11, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x30, 0x05, 0x01, 0x00, 
  0x42, 0x05, 0x00, 0x00, 0x2B, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x3A, 0x06, 0x07, 0x05, 
  0x2B, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x39, 0x05, 0x06, 0x07, 0x1E, 0x05, 0x02, 0x00, 
  0x2A, 0x05, 0x05, 0x00, 0x30, 0x05, 0x01, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x33, 0x06, 0x07, 0x00, 
  0x2A, 0x05, 0x07, 0x00, 0x34, 0x05, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x08, 0x00, 
  0x31, 0x00, 0x01, 0x05, 0x2A, 0x06, 0x09, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2A, 0x06, 0x0A, 0x00, 
  0x33, 0x05, 0x06, 0x00, 0x2B, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x0B, 0x00, 0x39, 0x05, 0x06, 0x07, 
  0x1C, 0x05, 0x05, 0x00, 0x2B, 0x06, 0x00, 0x05, 0x30, 0x00, 0x06, 0x00, 0x2A, 0x06, 0x0C, 0x00, 
  0x34, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xE9, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x01, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0xBF, 0xFD, 0x07, 
  0x05, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x01, 0x0D, 0x00, 0x0D, 
  0x00, 0x0D, 0x00, 0x09, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x09, 0x8A, 0xE1, 
  0x01, 0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x25, 0x00, 0x00, 0x00, 0xD0, 0x06, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0x73, 0xD0, 
  0x09, 0x6F, 0x6E, 0x2D, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xD0, 0x03, 0x65, 0x6E, 0x76, 0xD7, 
  0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x43, 0x01, 0x01, 0x01, 0x25, 0x81, 0x39, 0x05, 0xCE, 0x0B, 
  0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0xDA, 0x18, 0xD0, 0x04, 0x72, 
  0x65, 0x61, 0x64, 0xD0, 0x0E, 0x6F, 0x6E, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 0x65, 0x72, 
  0x72, 0x6F, 0x72, 0xD0, 0x0B, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2D, 0x66, 0x6C, 0x61, 0x67, 0x73, 
  0xDA, 0x83, 0xDE, 0xD0, 0x10, 0x6F, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x2D, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0xDA, 0x83, 0xDC, 0xD0, 0x06, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0xDA, 0x83, 0xDD, 0xDA, 0x83, 0x4C, 0xD0, 0x09, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 
  0x72, 0xD0, 0x12, 0x6F, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x2D, 0x77, 0x61, 
  0x72, 0x6E, 0x69, 0x6E, 0x67, 0xD0, 0x08, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 0x72, 0xDA, 
  0x82, 0x8F, 0xDA, 0x83, 0x2F, 0xDA, 0x83, 0xA8, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 
  0x05, 0x03, 0x05, 0x0C, 0x26, 0xCE, 0x0B, 0x62, 0x61, 0x64, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 
  0x6C, 0x65, 0xDA, 0x18, 0xDA, 0x83, 0xA5, 0xDA, 0x81, 0x1D, 0xCE, 0x05, 0x1B, 0x5B, 0x33, 0x31, 
  0x6D, 0xDA, 0x81, 0x37, 0xCE, 0x01, 0x3A, 0xCE, 0x11, 0x3A, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 
  0x6C, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20, 0xDA, 0x81, 0x03, 0xDA, 0x83, 0xA8, 
  0xDA, 0x83, 0x55, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x0A, 0x03, 0x03, 0x03, 0x08, 0x26, 
  0x01, 0xCE, 0x0E, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x2D, 0x6C, 0x69, 0x6E, 0x65, 0x2D, 0x63, 0x6F, 
  0x6C, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 
  0xCE, 0x07, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x1D, 0x2C, 
  0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 
  0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x66, 0x01, 0x00, 0x30, 0x00, 
  0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0xD0, 0x01, 0x72, 0xDA, 0x83, 0x50, 0xDA, 
  0x80, 0xD4, 0xDA, 0x80, 0xBA, 0xDA, 0x81, 0xB0, 0xDA, 0x80, 0xBE, 0xDA, 0x80, 0xD6, 0x2C, 0x03, 
  0x00, 0x00, 0x1C, 0x01, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x02, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x30, 0x00, 0x04, 0x00, 0x2A, 0x05, 
  0x02, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x1C, 0x05, 0x16, 0x00, 0x2E, 0x04, 
  0x00, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x33, 0x06, 
  0x07, 0x00, 0x19, 0x04, 0x06, 0x00, 0x26, 0x07, 0x00, 0x00, 0x35, 0x06, 0x04, 0x07, 0x19, 0x07, 
  0x06, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x33, 0x06, 0x08, 0x00, 0x2F, 0x04, 
  0x00, 0x00, 0x2A, 0x08, 0x06, 0x00, 0x33, 0x06, 0x08, 0x00, 0x2A, 0x09, 0x07, 0x00, 0x23, 0x08, 
  0x06, 0x09, 0x1C, 0x08, 0x02, 0x00, 0x03, 0x07, 0x00, 0x00, 0x37, 0x06, 0x07, 0x04, 0x03, 0x06, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0C, 
  0x39, 0x01, 0xDA, 0x18, 0xDA, 0x83, 0x52, 0xDA, 0x83, 0x53, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x03, 0xCE, 0x03, 0x64, 0x65, 0x63, 0xDA, 0x18, 0x2C, 0x01, 
  0x00, 0x00, 0x05, 0x02, 0x00, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x80, 0x95, 0x01, 0x00, 0x20, 0x00, 
  0x20, 0xDA, 0x81, 0x51, 0xDA, 0x82, 0x6B, 0xDA, 0x81, 0x36, 0xDA, 0x83, 0xC1, 0xDA, 0x83, 0x55, 
  0xDA, 0x64, 0xDA, 0x81, 0x4F, 0xDA, 0x81, 0x50, 0xCE, 0x01, 0x5E, 0x2B, 0x00, 0x00, 0x05, 0x2A, 
  0x01, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x01, 0x01, 0x00, 0x33, 0x00, 0x01, 0x00, 0x19, 
  0x01, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x01, 0x2F, 0x03, 0x00, 0x00, 0x2A, 
  0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x20, 0x03, 0x04, 0x00, 0x1C, 
  0x03, 0x0D, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x1A, 0x0A, 0x00, 0x00, 0x2A, 
  0x05, 0x03, 0x00, 0x31, 0x05, 0x01, 0x02, 0x2A, 0x05, 0x04, 0x00, 0x33, 0x02, 0x05, 0x00, 0x1C, 
  0x02, 0x03, 0x00, 0x05, 0x02, 0x02, 0x01, 0x1A, 0x01, 0x00, 0x00, 0x05, 0x04, 0x04, 0xFF, 0x1A, 
  0xF3, 0xFF, 0xFF, 0x1C, 0x02, 0x1E, 0x00, 0x2A, 0x03, 0x03, 0x00, 0x31, 0x03, 0x01, 0x02, 0x2A, 
  0x04, 0x04, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x31, 0x01, 0x02, 0x04, 0x2A, 
  0x05, 0x05, 0x00, 0x33, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x06, 0x00, 0x30, 0x05, 0x03, 0x00, 0x2A, 
  0x06, 0x07, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2B, 0x03, 0x00, 0x02, 0x1C, 0x03, 0x0F, 0x00, 0x2B, 
  0x03, 0x00, 0x02, 0x06, 0x02, 0x02, 0x03, 0x2B, 0x03, 0x00, 0x02, 0x2F, 0x03, 0x00, 0x00, 0x2A, 
  0x05, 0x08, 0x00, 0x33, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x09, 0x00, 0x30, 0x05, 0x03, 0x00, 0x2A, 
  0x06, 0x0A, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2A, 0x03, 0x0B, 0x00, 0x30, 0x05, 0x03, 0x00, 0x2A, 
  0x03, 0x07, 0x00, 0x34, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xBF, 
  0xFF, 0x88, 0xF9, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x05, 0x01, 0x05, 
  0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 
  0x00, 0x07, 0x00, 0x15, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x01, 0x07, 0x00, 0x11, 
  0x00, 0x07, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0x04, 0x05, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x07, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x01, 0x07, 0x00, 0x07, 0x01, 0x09, 0x00, 0x09, 0x01, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 
  0x24, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0xBF, 0xFE, 0x07, 0xBF, 0xFD, 0x05, 0x88, 0xF2, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x10, 
  0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 0x00, 0x1B, 0x01, 0x11, 0x00, 0x11, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x26, 0x00, 0x00, 0x00, 0xCE, 0x04, 0x1B, 0x5B, 0x30, 0x6D, 0xDA, 0x83, 
  0xDA, 0x2C, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x01, 
  0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x03, 0x00, 0x2A, 0x08, 0x02, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x08, 0x02, 
  0x09, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x03, 0x09, 0x04, 0x2A, 0x09, 0x05, 0x00, 0x2F, 0x09, 0x00, 
  0x00, 0x2A, 0x0A, 0x06, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x1C, 0x01, 0x06, 0x00, 0x2A, 0x08, 0x03, 
  0x00, 0x31, 0x01, 0x00, 0x08, 0x2A, 0x0A, 0x07, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x1A, 0x04, 0x00, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0A, 0x08, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x1C, 0x07, 0x09, 
  0x00, 0x31, 0x02, 0x03, 0x04, 0x2A, 0x0A, 0x09, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x2A, 0x08, 0x0A, 
  0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x06, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x1A, 0x01, 0x00, 
  0x00, 0x2A, 0x08, 0x0B, 0x00, 0x34, 0x08, 0x00, 0x00, 0x89, 0x18, 0x01, 0x03, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x08, 
  0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x02, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xBF, 0xFE, 0x03, 0x03, 0x03, 0x00, 0x03, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x0C, 0x05, 0x03, 0x05, 0x0C, 0x21, 0xCE, 0x0C, 0x77, 0x61, 0x72, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 
  0x70, 0x69, 0x6C, 0x65, 0xDA, 0x18, 0xDA, 0x83, 0xA5, 0xDA, 0x81, 0x1D, 0xCE, 0x05, 0x1B, 0x5B, 
  0x33, 0x33, 0x6D, 0xDA, 0x81, 0x37, 0xDA, 0x83, 0xEC, 0xCE, 0x13, 0x3A, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x69, 0x6C, 0x65, 0x20, 0x77, 0x61, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x28, 0xCE, 0x03, 
  0x29, 0x3A, 0x20, 0xDA, 0x81, 0x03, 0xDA, 0x83, 0x55, 0xDA, 0x83, 0xEE, 0xDA, 0x83, 0xF6, 0xDA, 
  0x83, 0xDA, 0x2C, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 
  0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x03, 0x00, 0x2A, 0x08, 
  0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x08, 
  0x02, 0x09, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x03, 0x09, 0x04, 0x2A, 0x09, 0x05, 0x00, 0x2A, 0x0A, 
  0x06, 0x00, 0x31, 0x09, 0x01, 0x0A, 0x2A, 0x0A, 0x07, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x0A, 0x08, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x1C, 0x07, 0x09, 0x00, 0x31, 0x02, 
  0x03, 0x04, 0x2A, 0x0B, 0x09, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2A, 0x0A, 0x0A, 0x00, 0x2F, 0x0A, 
  0x00, 0x00, 0x2A, 0x0B, 0x07, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x0A, 
  0x0B, 0x00, 0x34, 0x0A, 0x00, 0x00, 0x89, 0x06, 0x01, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x03, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x08, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x03, 0x03, 0x00, 0x03, 0xD7, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x0D, 0x02, 0x02, 0x02, 0x0B, 0x22, 0xCE, 0x09, 0x62, 0x61, 0x64, 0x2D, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0xDA, 0x18, 0xDA, 0x83, 0xA5, 0xDA, 0x81, 0x1D, 0xD0, 0x05, 0x77, 0x68, 0x65, 
  0x72, 0x65, 0xDA, 0x83, 0xEB, 0xDA, 0x81, 0x37, 0xDA, 0x80, 0xC1, 0xDA, 0x83, 0xF6, 0xDA, 0x83, 
  0xEC, 0xCE, 0x0F, 0x3A, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x3A, 0x20, 0xDA, 0x83, 0x55, 0xDA, 0x83, 0xDA, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x3B, 0x06, 0x05, 0x00, 
  0x19, 0x07, 0x06, 0x00, 0x3B, 0x06, 0x05, 0x01, 0x19, 0x08, 0x06, 0x00, 0x1C, 0x04, 0x03, 0x00, 
  0x2A, 0x06, 0x03, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x0A, 0x05, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x0A, 0x06, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x2A, 0x0B, 0x07, 0x00, 0x31, 0x06, 0x01, 0x0B, 
  0x2A, 0x0B, 0x07, 0x00, 0x31, 0x07, 0x0B, 0x08, 0x2A, 0x0B, 0x08, 0x00, 0x31, 0x0B, 0x09, 0x0A, 
  0x2A, 0x0C, 0x09, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x2A, 0x06, 0x0A, 0x00, 0x34, 0x06, 0x00, 0x00, 
  0x88, 0xE1, 0x01, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x07, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0xBF, 0xF7, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x0A, 0x03, 0x00, 0x03, 0xD0, 0x0B, 0x3C, 0x61, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 
  0x75, 0x73, 0x3E, 0xD0, 0x03, 0x79, 0x64, 0x74, 0xDA, 0x83, 0xF0, 0xD0, 0x0C, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x2D, 0x66, 0x69, 0x6C, 0x65, 0xD0, 0x04, 0x65, 0x78, 0x69, 0x74, 0xDA, 
  0x81, 0xEC, 0xDA, 0x80, 0x92, 0xDA, 0x82, 0xDB, 0xD0, 0x07, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 
  0x65, 0xD0, 0x07, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0xD0, 0x06, 0x73, 0x74, 0x61, 0x74, 
  0x75, 0x73, 0xD0, 0x08, 0x68, 0x61, 0x73, 0x2D, 0x6D, 0x6F, 0x72, 0x65, 0xDA, 0x81, 0x37, 0xDA, 
  0x81, 0x5C, 0xD0, 0x06, 0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0xD0, 0x05, 0x66, 0x6C, 0x75, 0x73, 
  0x68, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x03, 0x0D, 0xCE, 0x08, 
  0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x55, 0xDA, 0x76, 
  0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x19, 0x03, 0x02, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x03, 0x00, 
  0x27, 0x05, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 0x05, 0x03, 0x06, 
  0x03, 0x05, 0x00, 0x00, 0x78, 0x01, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x07, 
  0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xD0, 0x03, 
  0x65, 0x6F, 0x66, 0xDA, 0x80, 0xC1, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x38, 0x02, 
  0x00, 0x03, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x38, 0x02, 0x00, 0x04, 0x19, 0x04, 
  0x02, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x38, 0x02, 0x00, 0x05, 0x19, 0x05, 0x02, 0x00, 0x2A, 0x06, 
  0x03, 0x00, 0x38, 0x02, 0x00, 0x06, 0x19, 0x06, 0x02, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x38, 0x02, 
  0x00, 0x07, 0x19, 0x07, 0x02, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x38, 0x02, 0x00, 0x08, 0x19, 0x08, 
  0x02, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x38, 0x02, 0x00, 0x09, 0x19, 0x09, 0x02, 0x00, 0x2A, 0x0A, 
  0x07, 0x00, 0x38, 0x02, 0x00, 0x0A, 0x19, 0x0A, 0x02, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x38, 0x02, 
  0x00, 0x0B, 0x19, 0x0B, 0x02, 0x00, 0x2A, 0x0C, 0x09, 0x00, 0x38, 0x02, 0x00, 0x0C, 0x19, 0x0C, 
  0x02, 0x00, 0x2A, 0x0D, 0x0A, 0x00, 0x38, 0x02, 0x00, 0x0D, 0x19, 0x0D, 0x02, 0x00, 0x2A, 0x0E, 
  0x0B, 0x00, 0x38, 0x02, 0x00, 0x0E, 0x19, 0x0E, 0x02, 0x00, 0x26, 0x10, 0x00, 0x00, 0x23, 0x0F, 
  0x10, 0x06, 0x1C, 0x0F, 0x0E, 0x00, 0x2A, 0x11, 0x0C, 0x00, 0x33, 0x10, 0x11, 0x00, 0x2F, 0x10, 
  0x00, 0x00, 0x2A, 0x12, 0x0D, 0x00, 0x33, 0x11, 0x12, 0x00, 0x19, 0x10, 0x11, 0x00, 0x1C, 0x10, 
  0x03, 0x00, 0x19, 0x11, 0x10, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x42, 0x12, 0x00, 0x00, 0x19, 0x11, 
  0x12, 0x00, 0x19, 0x02, 0x11, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x02, 0x06, 0x00, 0x19, 0x0F, 
  0x02, 0x00, 0x26, 0x12, 0x00, 0x00, 0x23, 0x11, 0x12, 0x08, 0x1C, 0x11, 0x04, 0x00, 0x2E, 0x12, 
  0x00, 0x00, 0x19, 0x10, 0x12, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x10, 0x08, 0x00, 0x19, 0x11, 
  0x10, 0x00, 0x26, 0x14, 0x00, 0x00, 0x23, 0x13, 0x14, 0x0A, 0x1C, 0x13, 0x03, 0x00, 0x2A, 0x12, 
  0x0E, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x12, 0x0A, 0x00, 0x19, 0x13, 0x12, 0x00, 0x26, 0x16, 
  0x00, 0x00, 0x23, 0x15, 0x16, 0x07, 0x1C, 0x15, 0x03, 0x00, 0x2A, 0x14, 0x0F, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x14, 0x07, 0x00, 0x19, 0x15, 0x14, 0x00, 0x26, 0x18, 0x00, 0x00, 0x23, 0x17, 
  0x18, 0x0D, 0x1C, 0x17, 0x03, 0x00, 0x2A, 0x16, 0x10, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x16, 
  0x0D, 0x00, 0x19, 0x17, 0x16, 0x00, 0x26, 0x1A, 0x00, 0x00, 0x23, 0x19, 0x1A, 0x04, 0x1C, 0x19, 
  0x03, 0x00, 0x2A, 0x18, 0x11, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x18, 0x04, 0x00, 0x19, 0x19, 
  0x18, 0x00, 0x26, 0x1C, 0x00, 0x00, 0x23, 0x1B, 0x1C, 0x0C, 0x1C, 0x1B, 0x04, 0x00, 0x2E, 0x1C, 
  0x01, 0x00, 0x19, 0x1A, 0x1C, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x1A, 0x0C, 0x00, 0x19, 0x1B, 
  0x1A, 0x00, 0x26, 0x1E, 0x00, 0x00, 0x23, 0x1D, 0x1E, 0x0B, 0x1C, 0x1D, 0x03, 0x00, 0x2A, 0x1C, 
  0x12, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x1C, 0x0B, 0x00, 0x19, 0x1D, 0x1C, 0x00, 0x26, 0x20, 
  0x00, 0x00, 0x23, 0x1F, 0x20, 0x05, 0x1C, 0x1F, 0x03, 0x00, 0x2A, 0x1E, 0x13, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x1E, 0x05, 0x00, 0x19, 0x1F, 0x1E, 0x00, 0x19, 0x20, 0x1D, 0x00, 0x2F, 0x20, 
  0x00, 0x00, 0x2A, 0x22, 0x14, 0x00, 0x33, 0x21, 0x22, 0x00, 0x1C, 0x21, 0x04, 0x00, 0x2A, 0x22, 
  0x15, 0x00, 0x3A, 0x0F, 0x22, 0x20, 0x1A, 0x01, 0x00, 0x00, 0x3E, 0x21, 0x00, 0x00, 0x19, 0x22, 
  0x21, 0x00, 0x2E, 0x23, 0x02, 0x00, 0x19, 0x24, 0x23, 0x00, 0x1C, 0x03, 0x10, 0x00, 0x2A, 0x26, 
  0x16, 0x00, 0x38, 0x25, 0x0F, 0x26, 0x1C, 0x25, 0x03, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x30, 0x0F, 0x20, 0x00, 0x33, 0x25, 0x03, 0x00, 0x2F, 0x25, 0x00, 0x00, 0x33, 0x26, 
  0x24, 0x00, 0x1A, 0xF7, 0xFF, 0xFF, 0x2A, 0x25, 0x17, 0x00, 0x31, 0x0F, 0x25, 0x0F, 0x2A, 0x25, 
  0x18, 0x00, 0x34, 0x25, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1C, 0x09, 0x03, 0x00, 0x19, 0x25, 
  0x09, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x27, 0x19, 0x00, 0x33, 0x26, 0x27, 0x00, 0x19, 0x25, 
  0x26, 0x00, 0x19, 0x26, 0x25, 0x00, 0x2A, 0x27, 0x1A, 0x00, 0x2F, 0x27, 0x00, 0x00, 0x33, 0x27, 
  0x26, 0x00, 0x19, 0x28, 0x27, 0x00, 0x2A, 0x29, 0x1B, 0x00, 0x2F, 0x29, 0x00, 0x00, 0x33, 0x29, 
  0x26, 0x00, 0x19, 0x2A, 0x29, 0x00, 0x2A, 0x2B, 0x1C, 0x00, 0x2F, 0x2B, 0x00, 0x00, 0x33, 0x2B, 
  0x26, 0x00, 0x19, 0x2C, 0x2B, 0x00, 0x2A, 0x2D, 0x1D, 0x00, 0x2F, 0x2D, 0x00, 0x00, 0x33, 0x2D, 
  0x26, 0x00, 0x19, 0x2E, 0x2D, 0x00, 0x2E, 0x2F, 0x03, 0x00, 0x19, 0x30, 0x2F, 0x00, 0x2E, 0x31, 
  0x04, 0x00, 0x19, 0x32, 0x31, 0x00, 0x2A, 0x33, 0x1E, 0x00, 0x2F, 0x33, 0x00, 0x00, 0x3F, 0x33, 
  0x00, 0x00, 0x19, 0x34, 0x33, 0x00, 0x27, 0x35, 0x00, 0x00, 0x1C, 0x35, 0x6B, 0x00, 0x2A, 0x36, 
  0x16, 0x00, 0x2F, 0x36, 0x00, 0x00, 0x33, 0x36, 0x0F, 0x00, 0x1C, 0x36, 0x03, 0x00, 0x1A, 0x66, 
  0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2F, 0x34, 0x00, 0x00, 0x2A, 0x37, 0x1F, 0x00, 0x33, 0x36, 
  0x37, 0x00, 0x30, 0x34, 0x26, 0x00, 0x33, 0x36, 0x11, 0x00, 0x19, 0x37, 0x36, 0x00, 0x2A, 0x38, 
  0x20, 0x00, 0x23, 0x36, 0x37, 0x38, 0x1C, 0x36, 0x08, 0x00, 0x2F, 0x26, 0x00, 0x00, 0x2A, 0x39, 
  0x21, 0x00, 0x33, 0x38, 0x39, 0x00, 0x2F, 0x34, 0x00, 0x00, 0x2A, 0x39, 0x1F, 0x00, 0x33, 0x38, 
  0x39, 0x00, 0x1A, 0x54, 0x00, 0x00, 0x2F, 0x37, 0x00, 0x00, 0x2A, 0x3A, 0x22, 0x00, 0x33, 0x39, 
  0x3A, 0x00, 0x1C, 0x39, 0x04, 0x00, 0x3D, 0x3A, 0x37, 0x00, 0x19, 0x38, 0x3A, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x26, 0x38, 0x00, 0x00, 0x19, 0x39, 0x38, 0x00, 0x29, 0x3A, 0x00, 0x00, 0x39, 0x38, 
  0x37, 0x3A, 0x19, 0x3A, 0x38, 0x00, 0x29, 0x3B, 0x01, 0x00, 0x39, 0x38, 0x37, 0x3B, 0x19, 0x3B, 
  0x38, 0x00, 0x1C, 0x39, 0x0C, 0x00, 0x29, 0x3E, 0x02, 0x00, 0x46, 0x3D, 0x3E, 0x39, 0x19, 0x3E, 
  0x3D, 0x00, 0x1C, 0x3D, 0x05, 0x00, 0x2A, 0x40, 0x08, 0x00, 0x23, 0x3F, 0x3A, 0x40, 0x19, 0x3C, 
  0x3F, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x3C, 0x3E, 0x00, 0x19, 0x38, 0x3C, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x38, 0x39, 0x00, 0x1C, 0x38, 0x0B, 0x00, 0x19, 0x3C, 0x3B, 0x00, 0x19, 0x20, 
  0x3C, 0x00, 0x2F, 0x3C, 0x00, 0x00, 0x2A, 0x3E, 0x14, 0x00, 0x33, 0x3D, 0x3E, 0x00, 0x1C, 0x3D, 
  0x04, 0x00, 0x2A, 0x3E, 0x15, 0x00, 0x3A, 0x0F, 0x3E, 0x3C, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x2D, 
  0x00, 0x00, 0x29, 0x3C, 0x00, 0x00, 0x26, 0x3D, 0x00, 0x00, 0x3D, 0x3E, 0x34, 0x00, 0x19, 0x3F, 
  0x3E, 0x00, 0x24, 0x3E, 0x3F, 0x00, 0x1C, 0x3E, 0x06, 0x00, 0x2F, 0x26, 0x00, 0x00, 0x2A, 0x41, 
  0x23, 0x00, 0x33, 0x40, 0x41, 0x00, 0x28, 0x35, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1F, 0x3E, 
  0x3F, 0x3C, 0x1C, 0x3E, 0x20, 0x00, 0x31, 0x26, 0x34, 0x3C, 0x33, 0x40, 0x28, 0x00, 0x06, 0x3C, 
  0x3C, 0x40, 0x2F, 0x26, 0x00, 0x00, 0x33, 0x40, 0x2E, 0x00, 0x1C, 0x40, 0x0B, 0x00, 0x33, 0x41, 
  0x32, 0x00, 0x32, 0x41, 0x00, 0x00, 0x33, 0x42, 0x24, 0x00, 0x2A, 0x41, 0x16, 0x00, 0x2F, 0x41, 
  0x00, 0x00, 0x33, 0x41, 0x0F, 0x00, 0x1C, 0x41, 0x03, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x1A, 0xF4, 0xFF, 0xFF, 0x2F, 0x26, 0x00, 0x00, 0x33, 0x40, 0x2C, 0x00, 0x2A, 0x42, 
  0x24, 0x00, 0x23, 0x41, 0x40, 0x42, 0x1C, 0x41, 0x0A, 0x00, 0x30, 0x26, 0x20, 0x00, 0x33, 0x40, 
  0x30, 0x00, 0x2A, 0x40, 0x16, 0x00, 0x2F, 0x40, 0x00, 0x00, 0x33, 0x40, 0x0F, 0x00, 0x1C, 0x40, 
  0x03, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xE0, 
  0xFF, 0xFF, 0x1A, 0x96, 0xFF, 0xFF, 0x2A, 0x36, 0x16, 0x00, 0x2F, 0x36, 0x00, 0x00, 0x33, 0x36, 
  0x0F, 0x00, 0x1C, 0x36, 0x02, 0x00, 0x1A, 0x16, 0x00, 0x00, 0x2F, 0x26, 0x00, 0x00, 0x33, 0x37, 
  0x2E, 0x00, 0x1C, 0x37, 0x0B, 0x00, 0x33, 0x38, 0x32, 0x00, 0x32, 0x38, 0x00, 0x00, 0x33, 0x39, 
  0x24, 0x00, 0x2A, 0x38, 0x16, 0x00, 0x2F, 0x38, 0x00, 0x00, 0x33, 0x38, 0x0F, 0x00, 0x1C, 0x38, 
  0x03, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xF4, 0xFF, 0xFF, 0x2F, 0x26, 
  0x00, 0x00, 0x33, 0x37, 0x2C, 0x00, 0x2A, 0x39, 0x24, 0x00, 0x23, 0x38, 0x37, 0x39, 0x1C, 0x38, 
  0x04, 0x00, 0x30, 0x26, 0x20, 0x00, 0x33, 0x37, 0x30, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x36, 
  0x16, 0x00, 0x26, 0x37, 0x00, 0x00, 0x3A, 0x0F, 0x36, 0x37, 0x2A, 0x36, 0x17, 0x00, 0x31, 0x0F, 
  0x36, 0x0F, 0x2A, 0x36, 0x18, 0x00, 0x34, 0x36, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x04, 
  0x02, 0x02, 0x02, 0x02, 0x05, 0x01, 0xDA, 0x18, 0xDA, 0x81, 0x37, 0xD8, 0x07, 0x67, 0x65, 0x74, 
  0x6C, 0x69, 0x6E, 0x65, 0x2A, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x0F, 0x31, 0x02, 0x00, 0x03, 
  0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x89, 0x6E, 0x1F, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x1F, 0x00, 0x1F, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x02, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x00, 0x02, 0xCE, 0x08, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0xDA, 0x18, 
  0x2C, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x89, 0x73, 0x16, 0x00, 0x29, 0xCD, 0x02, 0xFA, 
  0x00, 0x00, 0x0E, 0x03, 0x01, 0x03, 0x03, 0x23, 0x01, 0x01, 0xCE, 0x05, 0x65, 0x76, 0x61, 0x6C, 
  0x31, 0xDA, 0x18, 0xDA, 0x80, 0xBA, 0xD8, 0x0C, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 
  0x74, 0x65, 0x6E, 0x76, 0xD8, 0x11, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 0x61, 0x6E, 0x2D, 
  0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x3F, 0x2C, 0x03, 0x00, 0x00, 0x2B, 0x05, 0x00, 0x0E, 0x1C, 
  0x05, 0x06, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x06, 0x00, 0x0E, 0x33, 0x05, 0x06, 0x00, 0x19, 
  0x04, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x27, 
  0x06, 0x00, 0x00, 0x26, 0x07, 0x00, 0x00, 0x2E, 0x08, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x1F, 0x30, 
  0x08, 0x09, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 0x08, 0x09, 0x00, 0x2B, 
  0x0A, 0x00, 0x0F, 0x30, 0x08, 0x0A, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2F, 
  0x08, 0x00, 0x00, 0x2A, 0x0C, 0x02, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x1C, 0x0B, 0x09, 0x00, 0x35, 
  0x0C, 0x08, 0x07, 0x19, 0x0D, 0x0C, 0x00, 0x1C, 0x06, 0x05, 0x00, 0x30, 0x08, 0x0D, 0x00, 0x2B, 
  0x0C, 0x00, 0x13, 0x33, 0x07, 0x0C, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xF5, 0xFF, 0xFF, 0x04, 
  0x00, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x0D, 0x80, 
  0x98, 0x02, 0xDA, 0x18, 0xDA, 0x82, 0x4C, 0xDA, 0x80, 0x83, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x05, 0x01, 0x01, 0x01, 0x00, 0x06, 0xCE, 0x06, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x3F, 0xDA, 
  0x18, 0x2C, 0x01, 0x00, 0x00, 0x26, 0x03, 0x00, 0x00, 0x47, 0x02, 0x00, 0x03, 0x26, 0x04, 0x00, 
  0x00, 0x23, 0x03, 0x04, 0x02, 0x03, 0x03, 0x00, 0x00, 0x7F, 0x01, 0x00, 0x32, 0x00, 0x32, 0x00, 
  0x2B, 0x00, 0x2B, 0x00, 0x2B, 0xD0, 0x0B, 0x6C, 0x69, 0x6E, 0x74, 0x2D, 0x6C, 0x65, 0x76, 0x65, 
  0x6C, 0x73, 0xD5, 0x05, 0xDA, 0x83, 0x52, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x7F, 
  0xD0, 0x04, 0x6E, 0x6F, 0x6E, 0x65, 0x00, 0xD0, 0x07, 0x72, 0x65, 0x6C, 0x61, 0x78, 0x65, 0x64, 
  0x01, 0xD0, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x03, 0xD0, 0x06, 0x6E, 0x6F, 0x72, 0x6D, 
  0x61, 0x6C, 0x02, 0xD0, 0x0A, 0x6C, 0x69, 0x6E, 0x74, 0x2D, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xD0, 
  0x09, 0x6C, 0x69, 0x6E, 0x74, 0x2D, 0x77, 0x61, 0x72, 0x6E, 0xDA, 0x1C, 0xDA, 0x82, 0xE3, 0xD0, 
  0x06, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0xD0, 0x04, 0x6C, 0x69, 0x6E, 0x65, 0xDA, 0x83, 0x33, 
  0xDA, 0x80, 0xC1, 0x2B, 0x00, 0x00, 0x22, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x33, 
  0x00, 0x01, 0x00, 0x2B, 0x01, 0x01, 0x05, 0x2B, 0x02, 0x00, 0x0F, 0x2B, 0x03, 0x00, 0x20, 0x31, 
  0x01, 0x02, 0x03, 0x2B, 0x01, 0x00, 0x22, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x33, 
  0x01, 0x02, 0x00, 0x19, 0x02, 0x01, 0x00, 0x2B, 0x03, 0x00, 0x22, 0x2F, 0x03, 0x00, 0x00, 0x2A, 
  0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x02, 0x00, 0x1A, 0x5B, 0x00, 0x00, 0x2B, 
  0x05, 0x00, 0x0F, 0x2A, 0x06, 0x03, 0x00, 0x39, 0x04, 0x05, 0x06, 0x1E, 0x04, 0x02, 0x00, 0x2A, 
  0x04, 0x04, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2B, 0x06, 0x00, 0x0F, 0x2A, 0x07, 0x05, 0x00, 0x39, 
  0x04, 0x06, 0x07, 0x19, 0x06, 0x04, 0x00, 0x2B, 0x07, 0x00, 0x0F, 0x2A, 0x08, 0x06, 0x00, 0x39, 
  0x04, 0x07, 0x08, 0x19, 0x07, 0x04, 0x00, 0x39, 0x04, 0x05, 0x06, 0x1E, 0x04, 0x02, 0x00, 0x19, 
  0x04, 0x06, 0x00, 0x19, 0x08, 0x04, 0x00, 0x1C, 0x08, 0x03, 0x00, 0x19, 0x04, 0x08, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x29, 0x04, 0x00, 0x00, 0x19, 0x08, 0x04, 0x00, 0x39, 0x04, 0x05, 0x07, 0x1E, 
  0x04, 0x02, 0x00, 0x19, 0x04, 0x07, 0x00, 0x19, 0x09, 0x04, 0x00, 0x1C, 0x09, 0x03, 0x00, 0x19, 
  0x04, 0x09, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x04, 0x02, 0x00, 0x19, 0x09, 0x04, 0x00, 0x2B, 
  0x0A, 0x00, 0x22, 0x26, 0x0B, 0x00, 0x00, 0x47, 0x04, 0x0A, 0x0B, 0x19, 0x0A, 0x04, 0x00, 0x1D, 
  0x0A, 0x36, 0x00, 0x2B, 0x0B, 0x00, 0x22, 0x38, 0x04, 0x0B, 0x0A, 0x3B, 0x0B, 0x04, 0x00, 0x19, 
  0x0C, 0x0B, 0x00, 0x3B, 0x0B, 0x04, 0x01, 0x19, 0x0D, 0x0B, 0x00, 0x3B, 0x0B, 0x04, 0x02, 0x19, 
  0x0E, 0x0B, 0x00, 0x3B, 0x0B, 0x04, 0x03, 0x19, 0x0F, 0x0B, 0x00, 0x2A, 0x0B, 0x04, 0x00, 0x39, 
  0x04, 0x0B, 0x0C, 0x1E, 0x04, 0x02, 0x00, 0x29, 0x04, 0x00, 0x00, 0x19, 0x0B, 0x04, 0x00, 0x46, 
  0x04, 0x0B, 0x08, 0x1C, 0x04, 0x12, 0x00, 0x28, 0x10, 0x00, 0x00, 0x2D, 0x10, 0x01, 0x06, 0x1C, 
  0x0D, 0x03, 0x00, 0x19, 0x10, 0x0D, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2B, 0x10, 0x01, 0x01, 0x1C, 
  0x0E, 0x03, 0x00, 0x19, 0x11, 0x0E, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2B, 0x11, 0x01, 0x02, 0x26, 
  0x12, 0x00, 0x00, 0x2B, 0x13, 0x00, 0x20, 0x31, 0x0F, 0x12, 0x13, 0x30, 0x10, 0x11, 0x00, 0x2B, 
  0x13, 0x00, 0x15, 0x33, 0x12, 0x13, 0x00, 0x1A, 0x11, 0x00, 0x00, 0x46, 0x10, 0x0B, 0x09, 0x1C, 
  0x10, 0x0F, 0x00, 0x1C, 0x0D, 0x03, 0x00, 0x19, 0x11, 0x0D, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2B, 
  0x11, 0x01, 0x01, 0x1C, 0x0E, 0x03, 0x00, 0x19, 0x12, 0x0E, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2B, 
  0x12, 0x01, 0x02, 0x2B, 0x13, 0x00, 0x20, 0x31, 0x0F, 0x0C, 0x13, 0x30, 0x11, 0x12, 0x00, 0x2B, 
  0x14, 0x00, 0x17, 0x33, 0x13, 0x14, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x22, 0x47, 
  0x0A, 0x04, 0x0A, 0x1A, 0xCB, 0xFF, 0xFF, 0x2B, 0x03, 0x01, 0x06, 0x1C, 0x03, 0x29, 0x00, 0x2F, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x07, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2A, 0x05, 0x08, 0x00, 0x23, 
  0x04, 0x03, 0x05, 0x1C, 0x04, 0x08, 0x00, 0x2B, 0x03, 0x01, 0x05, 0x2B, 0x05, 0x00, 0x0F, 0x31, 
  0x02, 0x03, 0x05, 0x2B, 0x03, 0x00, 0x20, 0x2F, 0x03, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x1B, 0x34, 
  0x03, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00, 0x2D, 0x03, 0x01, 0x06, 0x2A, 0x05, 0x09, 0x00, 0x38, 
  0x03, 0x02, 0x05, 0x19, 0x05, 0x03, 0x00, 0x2A, 0x06, 0x0A, 0x00, 0x38, 0x03, 0x02, 0x06, 0x19, 
  0x06, 0x03, 0x00, 0x2A, 0x07, 0x0B, 0x00, 0x38, 0x03, 0x02, 0x07, 0x19, 0x07, 0x03, 0x00, 0x2A, 
  0x08, 0x0C, 0x00, 0x38, 0x03, 0x02, 0x08, 0x19, 0x08, 0x03, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 
  0x03, 0x06, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x01, 0x01, 0x1C, 0x05, 0x03, 0x00, 0x19, 
  0x09, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2B, 0x09, 0x01, 0x02, 0x2B, 0x0A, 0x00, 0x20, 0x31, 
  0x08, 0x07, 0x0A, 0x30, 0x03, 0x09, 0x00, 0x2B, 0x0A, 0x00, 0x15, 0x34, 0x0A, 0x00, 0x00, 0x04, 
  0x00, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x89, 0x85, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x0B, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0B, 0x00, 0x0B, 0x02, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x0D, 0x01, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 
  0x0D, 0x01, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x0D, 0x01, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 
  0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x0D, 0x01, 0x23, 0x00, 0x23, 0x00, 
  0x23, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x0D, 0x01, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x18, 0x00, 0x18, 0x00, 
  0x18, 0x00, 0x18, 0x00, 0x0F, 0x02, 0x11, 0xBF, 0xFF, 0x0F, 0x02, 0x27, 0x00, 0x27, 0x01, 0x47, 
  0x00, 0x47, 0x00, 0x47, 0x00, 0x47, 0x00, 0x53, 0x00, 0x53, 0x00, 0x53, 0x00, 0x53, 0x00, 0x27, 
  0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0xBF, 0xFD, 0x0F, 0x04, 0x11, 0xBF, 
  0xFC, 0x0F, 0x04, 0x4B, 0x00, 0x4B, 0x00, 0x4B, 0x00, 0x4B, 0x00, 0x57, 0x00, 0x57, 0x00, 0x57, 
  0x00, 0x57, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0xBF, 0xFC, 0x0F, 0xBF, 
  0xFE, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x07, 0x0B, 0x00, 0x0B, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x02, 0x11, 0x00, 0x11, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 
  0x01, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x3E, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xFA, 0x0B, 0x89, 0x7E, 0x03, 
  0x01, 0x11, 0x00, 0x11, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 
  0x00, 0x05, 0x01, 0x05, 0x01, 0x05, 0x03, 0x09, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0xBF, 0xFF, 0x05, 0x1B, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x05, 0x01, 0x10, 0x00, 0x07, 0x01, 0x07, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 
  0x00, 0x07, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0x66, 0x00, 0x00, 0x00, 0xCD, 0x02, 0xFA, 0x00, 0x00, 
  0x08, 0x02, 0x02, 0x02, 0x03, 0x0E, 0x01, 0x01, 0xCE, 0x09, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 
  0x65, 0x72, 0x72, 0xDA, 0x18, 0xDA, 0x80, 0xF2, 0xDA, 0x80, 0xBA, 0xDA, 0x84, 0x10, 0x2C, 0x02, 
  0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x30, 0x03, 0x04, 0x00, 0x2A, 0x05, 
  0x01, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x03, 0x04, 0x00, 0x2B, 0x05, 0x00, 0x0F, 0x30, 0x03, 
  0x05, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x26, 0x07, 0x00, 0x00, 0x35, 0x06, 
  0x03, 0x07, 0x03, 0x06, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x00, 0x00, 
  0x00, 0x00, 0x05, 0x02, 0xDA, 0x18, 0x2B, 0x00, 0x01, 0x00, 0x2B, 0x01, 0x01, 0x01, 0x30, 0x00, 
  0x01, 0x00, 0x2B, 0x00, 0x00, 0x19, 0x34, 0x00, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x89, 0xB3, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x89, 0xB0, 0x03, 0x03, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x06, 0x00, 
  0x00, 0x00, 0x01, 0x10, 0x01, 0xCE, 0x07, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0xDA, 0x18, 
  0xD8, 0x0F, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 0x61, 
  0x70, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x26, 0x27, 0x02, 0x00, 0x00, 0x30, 0x01, 0x02, 
  0x00, 0x2B, 0x02, 0x00, 0x2A, 0x33, 0x01, 0x02, 0x00, 0x19, 0x02, 0x01, 0x00, 0x29, 0x04, 0x00, 
  0x00, 0x38, 0x03, 0x02, 0x04, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 
  0x00, 0x2F, 0x03, 0x00, 0x00, 0x32, 0x04, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0xBF, 0xFF, 0x89, 0xB7, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 
  0x00, 0x05, 0x01, 0x06, 0x00, 0x06, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x89, 0x3B, 0x01, 0x26, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0C, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x22, 0x00, 0x22, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x13, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x16, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x03, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x03, 0x01, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x04, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x25, 0x03, 0x02, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x1A, 0x00, 0x07, 0x01, 0x0E, 0x00, 0x0E, 
  0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x05, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 
  0xFC, 0x03, 0x07, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x15, 0x00, 0x15, 0x00, 0x0A, 0x00, 0x03, 
  0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 
  0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 
  0x02, 0x03, 0x00, 0x03, 0x07, 0x03, 0x00, 0x03, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x01, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x15, 0x00, 0x05, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x04, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFB, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x09, 0x09, 0x01, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0xBF, 0xFF, 0x09, 0xBF, 0xF6, 
  0x05, 0x0E, 0x09, 0x01, 0x09, 0x01, 0x12, 0x00, 0x09, 0x01, 0x0F, 0x00, 0x09, 0x01, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x01, 0x0B, 0xBF, 0xFE, 0x09, 0x03, 0x10, 0x00, 0x09, 0x01, 0x16, 0x00, 0x16, 
  0x00, 0x0B, 0x01, 0x12, 0x00, 0x12, 0x00, 0x0B, 0x01, 0x15, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x11, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x00, 0x1D, 0x00, 0x0D, 0xBF, 0xFE, 0x0B, 0x03, 0x14, 0x00, 
  0x14, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0B, 0x01, 0x0D, 0x00, 0x0D, 0x01, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x0D, 0x00, 0x1D, 0x00, 0x0D, 0xBF, 0xFE, 0x0B, 0xBF, 0xFB, 0x09, 0xBF, 0xE9, 0x03, 
  0x21, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 
  0x01, 0x0F, 0x00, 0x07, 0x00, 0x07, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x17, 
  0x00, 0x07, 0xBF, 0xFE, 0x05, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x01, 
  0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0xC0, 0xA8, 0x8A, 0x45, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xCE, 0x0E, 0x65, 0x78, 0x69, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x5B, 
  0xDA, 0x83, 0xBB, 0xD0, 0x0C, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x2D, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x2C, 0x02, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x23, 0x04, 0x05, 0x01, 0x1C, 0x04, 0x03, 
  0x00, 0x29, 0x03, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2F, 0x05, 0x00, 
  0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 0x00, 0x2A, 0x07, 0x02, 
  0x00, 0x3A, 0x05, 0x07, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x3A, 0x05, 0x07, 0x04, 0x2F, 0x00, 0x00, 
  0x00, 0x2A, 0x08, 0x04, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x3A, 0x05, 0x08, 
  0x07, 0x2A, 0x07, 0x06, 0x00, 0x30, 0x05, 0x07, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x33, 0x07, 0x08, 
  0x00, 0x2E, 0x08, 0x00, 0x00, 0x19, 0x09, 0x08, 0x00, 0x2A, 0x0A, 0x08, 0x00, 0x2A, 0x0B, 0x09, 
  0x00, 0x31, 0x0A, 0x04, 0x0B, 0x2A, 0x0B, 0x0A, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2A, 0x0C, 0x0B, 
  0x00, 0x33, 0x0B, 0x0C, 0x00, 0x29, 0x0D, 0x01, 0x00, 0x06, 0x0C, 0x0D, 0x04, 0x27, 0x0D, 0x00, 
  0x00, 0x31, 0x05, 0x0C, 0x0D, 0x2A, 0x0E, 0x0C, 0x00, 0x3B, 0x0E, 0x0E, 0x00, 0x33, 0x0D, 0x0E, 
  0x00, 0x2A, 0x0C, 0x0D, 0x00, 0x2A, 0x0E, 0x0E, 0x00, 0x31, 0x0C, 0x09, 0x0E, 0x2A, 0x0C, 0x0F, 
  0x00, 0x31, 0x0D, 0x0C, 0x05, 0x41, 0x0C, 0x00, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x2A, 0x0E, 0x10, 
  0x00, 0x33, 0x0D, 0x0E, 0x00, 0x2A, 0x0C, 0x11, 0x00, 0x2A, 0x0E, 0x12, 0x00, 0x31, 0x0C, 0x04, 
  0x0E, 0x2A, 0x0E, 0x0A, 0x00, 0x33, 0x0C, 0x0E, 0x00, 0x2A, 0x0F, 0x0B, 0x00, 0x33, 0x0E, 0x0F, 
  0x00, 0x2A, 0x0F, 0x13, 0x00, 0x2F, 0x0F, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x09, 0x1C, 0x01, 0xCE, 0x0F, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x67, 0x65, 0x72, 0x2D, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0x73, 0xDA, 0x18, 0xD0, 0x0A, 0x64, 0x65, 
  0x6C, 0x69, 0x6D, 0x69, 0x74, 0x65, 0x72, 0x73, 0xD0, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0xDA, 
  0x83, 0xFE, 0xCE, 0x06, 0x64, 0x65, 0x62, 0x75, 0x67, 0x5B, 0xCE, 0x02, 0x5D, 0x3A, 0xDA, 0x83, 
  0xEC, 0xDA, 0x83, 0xC0, 0xDA, 0x81, 0x38, 0xDA, 0x84, 0x0D, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x30, 0x01, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 
  0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x29, 0x06, 
  0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x06, 0x05, 0x00, 0x19, 0x05, 0x06, 0x00, 0x2A, 0x07, 
  0x03, 0x00, 0x2B, 0x08, 0x00, 0x04, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x07, 0x08, 0x09, 0x2A, 0x07, 
  0x05, 0x00, 0x31, 0x05, 0x07, 0x04, 0x2A, 0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 
  0x07, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x08, 0x07, 0x00, 0x2B, 0x09, 0x00, 0x05, 0x31, 0x08, 
  0x00, 0x09, 0x2A, 0x09, 0x08, 0x00, 0x34, 0x09, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xD2, 0x03, 0x01, 
  0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x05, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x8A, 0xC8, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x10, 0x00, 0x10, 
  0x00, 0x10, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x18, 0x00, 0x18, 
  0x00, 0x18, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x03, 0x31, 0x00, 0x31, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xFE, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x30, 0x00, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x80, 0x81, 0x28, 0x64, 
  0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 
  0x20, 0x72, 0x65, 0x70, 0x6C, 0x2D, 0x62, 0x61, 0x73, 0x65, 0x64, 0x20, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x67, 0x65, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 
  0x20, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x20, 0x74, 0x6F, 0x20, 
  0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x69, 0x61, 0x74, 0x65, 0x20, 0x6E, 0x65, 
  0x73, 0x74, 0x65, 0x64, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x73, 0x2E, 0xCF, 
  0x0B, 0x2A, 0x65, 0x72, 0x72, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x2A, 0xD3, 0x04, 0xDA, 0x81, 
  0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 0xDE, 0x01, 0xDA, 0x06, 0xDA, 0x83, 
  0xA5, 0xDA, 0x08, 0xCE, 0x51, 0x57, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x6F, 0x72, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6F, 0x6E, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 
  0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x74, 0x72, 0x61, 0x63, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6D, 0x65, 0x73, 
  0x73, 0x61, 0x67, 0x65, 0x73, 0x2E, 0xCF, 0x04, 0x6A, 0x75, 0x78, 0x74, 0xD3, 0x04, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0x97, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x0B, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x08, 0x23, 0xCE, 0x04, 0x6A, 0x75, 0x78, 
  0x74, 0xDA, 0x18, 0xCF, 0x05, 0x74, 0x75, 0x70, 0x6C, 0x65, 0xDA, 0x43, 0xD7, 0x00, 0xCD, 0x00, 
  0x09, 0x00, 0x03, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x0C, 0xCE, 0x05, 0x61, 
  0x70, 0x70, 0x6C, 0x79, 0x3D, 0x02, 0x01, 0x00, 0x24, 0x03, 0x02, 0x00, 0x1B, 0x03, 0x09, 0x00, 
  0x29, 0x04, 0x00, 0x00, 0x38, 0x05, 0x01, 0x04, 0x05, 0x04, 0x04, 0x01, 0x23, 0x03, 0x04, 0x02, 
  0x1B, 0x03, 0x03, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x1A, 0xFB, 0xFF, 0xFF, 0x32, 0x05, 0x00, 0x00, 
  0x34, 0x00, 0x00, 0x00, 0xDA, 0x78, 0xDA, 0x81, 0x4C, 0xCF, 0x01, 0x26, 0xDA, 0x80, 0xE4, 0xDA, 
  0x80, 0xB9, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x3E, 0x02, 
  0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 
  0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x47, 0x06, 0x00, 0x07, 0x19, 0x07, 0x06, 0x00, 0x1D, 0x07, 
  0x0C, 0x00, 0x38, 0x06, 0x00, 0x07, 0x19, 0x08, 0x06, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x31, 0x06, 
  0x08, 0x05, 0x2A, 0x09, 0x03, 0x00, 0x33, 0x06, 0x09, 0x00, 0x30, 0x03, 0x06, 0x00, 0x2A, 0x0A, 
  0x04, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x47, 0x07, 0x00, 0x07, 0x1A, 0xF5, 0xFF, 0xFF, 0x2A, 0x06, 
  0x05, 0x00, 0x30, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x29, 0x07, 
  0x00, 0x00, 0x30, 0x03, 0x07, 0x00, 0x2A, 0x08, 0x06, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 
  0x07, 0x00, 0x31, 0x08, 0x06, 0x07, 0x2A, 0x08, 0x03, 0x00, 0x34, 0x08, 0x00, 0x00, 0x84, 0x97, 
  0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x17, 0x00, 0x17, 0x00, 
  0x17, 0x00, 0x17, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x02, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x47, 0x28, 0x6A, 0x75, 0x78, 0x74, 0x20, 
  0x26, 0x20, 0x66, 0x75, 0x6E, 0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x6A, 0x75, 0x78, 0x74, 0x2A, 0x60, 0x2E, 0x20, 
  0x53, 0x61, 0x6D, 0x65, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6F, 0x72, 0x20, 0x62, 0x75, 
  0x74, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6E, 0x74, 
  0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x70, 0x6F, 0x77, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x30, 0x01, 0xDA, 0x06, 0xD8, 0x08, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x70, 0x6F, 0x77, 0xDA, 0x08, 0xCE, 0x2C, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x70, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6F, 0x77, 0x65, 
  0x72, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xCF, 0x09, 0x70, 0x65, 0x67, 0x2F, 0x6D, 0x61, 0x74, 
  0x63, 0x68, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x1B, 0x86, 0xA1, 0x01, 0xDA, 
  0x06, 0xD8, 0x09, 0x70, 0x65, 0x67, 0x2F, 0x6D, 0x61, 0x74, 0x63, 0x68, 0xDA, 0x08, 0xCE, 0x80, 
  0xFA, 0x28, 0x70, 0x65, 0x67, 0x2F, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x70, 0x65, 0x67, 0x20, 
  0x74, 0x65, 0x78, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 
  0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 
  0x20, 0x50, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 
  0x69, 0x6F, 0x6E, 0x20, 0x47, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x61, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x6F, 0x66, 0x20, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 
  0x20, 0x69, 0x66, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x6E, 0x67, 
  0x75, 0x61, 0x67, 0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 
  0x70, 0x65, 0x67, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x79, 0x6E, 0x74, 0x61, 0x78, 0x20, 
  0x6F, 0x66, 0x20, 0x50, 0x45, 0x47, 0x73, 0x20, 0x69, 0x73, 0x20, 0x64, 0x6F, 0x63, 0x75, 0x6D, 
  0x65, 0x6E, 0x74, 0x65, 0x64, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4A, 0x61, 0x6E, 
  0x65, 0x74, 0x20, 0x77, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 0x2E, 0xCF, 0x08, 0x62, 0x6F, 0x6F, 
  0x6C, 0x65, 0x61, 0x6E, 0x3F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x71, 0x01, 
  0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 
  0x08, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xD0, 0x07, 0x62, 
  0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 
  0x00, 0x00, 0x71, 0x01, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 
  0xDA, 0x08, 0xCE, 0x26, 0x28, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x3F, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x67, 0x63, 0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x4F, 
  0x01, 0xDA, 0x06, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x67, 0x63, 0x64, 0xDA, 0x08, 0xCE, 
  0x44, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x67, 0x63, 0x64, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x72, 0x65, 
  0x61, 0x74, 0x65, 0x73, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E, 0x20, 0x64, 0x69, 0x76, 
  0x69, 0x73, 0x6F, 0x72, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x78, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x79, 0x2E, 0xCF, 0x0D, 0x6E, 0x65, 0x74, 0x2F, 0x72, 0x65, 0x63, 0x76, 0x2D, 
  0x66, 0x72, 0x6F, 0x6D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 0x83, 0x23, 0x01, 
  0xDA, 0x06, 0xD8, 0x0D, 0x6E, 0x65, 0x74, 0x2F, 0x72, 0x65, 0x63, 0x76, 0x2D, 0x66, 0x72, 0x6F, 
  0x6D, 0xDA, 0x08, 0xCE, 0x80, 0xE1, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x72, 0x65, 0x63, 0x76, 0x2D, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x6E, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x62, 0x75, 0x66, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x6F, 
  0x65, 0x75, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x73, 0x20, 0x64, 
  0x61, 0x74, 0x61, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 
  0x72, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x75, 0x74, 
  0x73, 0x20, 0x69, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x2D, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x70, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x20, 0x63, 0x61, 0x6D, 0x65, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x2E, 0x20, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 
  0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x20, 0x69, 
  0x6E, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x2C, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 
  0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xCF, 0x0C, 0x6F, 0x73, 0x2F, 0x63, 0x70, 0x75, 0x2D, 
  0x63, 0x6F, 0x75, 0x6E, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x80, 0xD9, 
  0x01, 0xDA, 0x06, 0xD8, 0x0C, 0x6F, 0x73, 0x2F, 0x63, 0x70, 0x75, 0x2D, 0x63, 0x6F, 0x75, 0x6E, 
  0x74, 0xDA, 0x08, 0xCE, 0x80, 0xA6, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x70, 0x75, 0x2D, 0x63, 0x6F, 
  0x75, 0x6E, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x29, 0x0A, 0x0A, 
  0x47, 0x65, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x70, 0x70, 0x72, 0x6F, 0x78, 0x69, 0x6D, 0x61, 
  0x74, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x43, 0x50, 0x55, 
  0x73, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x6E, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x75, 0x6E, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x70, 0x70, 0x72, 
  0x6F, 0x78, 0x69, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x2E, 0xCF, 0x0C, 0x70, 0x65, 
  0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x61, 0x6C, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x82, 0x1B, 0x86, 0xB5, 0x01, 0xDA, 0x06, 0xD8, 0x0C, 0x70, 0x65, 0x67, 0x2F, 0x66, 
  0x69, 0x6E, 0x64, 0x2D, 0x61, 0x6C, 0x6C, 0xDA, 0x08, 0xCE, 0x78, 0x28, 0x70, 0x65, 0x67, 0x2F, 
  0x66, 0x69, 0x6E, 0x64, 0x2D, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x65, 0x67, 0x20, 0x74, 0x65, 0x78, 
  0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x26, 0x20, 0x61, 
  0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x46, 0x69, 0x6E, 0x64, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x69, 
  0x6E, 0x64, 0x65, 0x78, 0x65, 0x73, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x65, 0x67, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x74, 0x65, 0x78, 0x74, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 
  0x72, 0x73, 0x2E, 0xCF, 0x10, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 
  0x69, 0x6C, 0x6C, 0x65, 0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0xA1, 0x80, 
  0x89, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x4B, 0xDA, 0x08, 0xCE, 0x80, 0x8F, 0x28, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x63, 0x6F, 
  0x75, 0x6E, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 
  0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x60, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x73, 0x65, 
  0x74, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x60, 0x2C, 0x20, 0x77, 0x68, 
  0x69, 0x63, 0x68, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xCF, 0x0F, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x6D, 0x6F, 0x72, 0x65, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x83, 0xDD, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0xDE, 0xDA, 0x08, 
  0xCE, 0x51, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x6D, 0x6F, 
  0x72, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 
  0x6B, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 
  0x68, 0x61, 0x73, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x71, 0x75, 0x65, 
  0x75, 0x65, 0x2E, 0xCF, 0x10, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 
  0x74, 0x72, 0x61, 0x63, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x10, 0x73, 0x72, 
  0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2E, 0x63, 0x81, 0x72, 
  0x01, 0xDA, 0x06, 0xDA, 0x83, 0xA8, 0xDA, 0x08, 0xCE, 0x81, 0x02, 0x28, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x72, 0x72, 0x20, 0x70, 0x72, 0x65, 0x66, 
  0x69, 0x78, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x69, 
  0x63, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 
  0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 
  0x79, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x69, 0x6E, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x74, 0x72, 0x61, 0x63, 
  0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x65, 0x72, 0x72, 0x60, 
  0x20, 0x69, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 
  0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6E, 0x6F, 0x20, 
  0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x2C, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x6B, 0x69, 0x70, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xCF, 0x09, 0x70, 
  0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x86, 0x8E, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0F, 0x02, 0x02, 
  0x02, 0x06, 0x28, 0xCE, 0x09, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0xDA, 0x18, 
  0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x65, 0x69, 0x6C, 0xD8, 0x09, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0xDA, 0x1A, 0xDA, 0x81, 0x36, 0xDA, 0x80, 0xE4, 0xDA, 0x81, 
  0x4C, 0x2C, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x19, 0x04, 0x00, 0x00, 0x3D, 0x05, 0x01, 
  0x00, 0x19, 0x06, 0x05, 0x00, 0x0B, 0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x00, 
  0x00, 0x33, 0x08, 0x09, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x33, 0x07, 0x09, 
  0x00, 0x19, 0x08, 0x07, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 
  0x00, 0x1C, 0x0A, 0x03, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x09, 0x04, 
  0x00, 0x19, 0x0A, 0x09, 0x00, 0x46, 0x0B, 0x04, 0x06, 0x1C, 0x0B, 0x09, 0x00, 0x31, 0x01, 0x03, 
  0x04, 0x33, 0x0C, 0x0A, 0x00, 0x30, 0x08, 0x0C, 0x00, 0x2A, 0x0E, 0x05, 0x00, 0x33, 0x0D, 0x0E, 
  0x00, 0x19, 0x03, 0x04, 0x00, 0x06, 0x04, 0x04, 0x00, 0x1A, 0xF7, 0xFF, 0xFF, 0x48, 0x0B, 0x03, 
  0x06, 0x1C, 0x0B, 0x07, 0x00, 0x30, 0x01, 0x03, 0x00, 0x33, 0x0C, 0x0A, 0x00, 0x30, 0x08, 0x0C, 
  0x00, 0x2A, 0x0E, 0x05, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x03, 0x08, 0x00, 
  0x00, 0x86, 0x8E, 0x01, 0x04, 0x03, 0x00, 0x0D, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x22, 0x00, 0x17, 
  0x00, 0x17, 0x00, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 
  0x00, 0x13, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 
  0x01, 0x15, 0x00, 0x15, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x01, 0x05, 0xBF, 0xFD, 
  0x03, 0x04, 0x07, 0x00, 0x03, 0x00, 0x24, 0x00, 0x24, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x03, 0xBF, 0xF4, 0x01, 0xDA, 0x08, 0xCE, 0x6A, 0x28, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x50, 0x61, 0x72, 0x74, 0x69, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x60, 
  0x69, 0x6E, 0x64, 0x60, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 
  0x0A, 0x6F, 0x66, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x60, 0x6E, 0x60, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2E, 0xCF, 0x04, 0x73, 0x70, 0x69, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x86, 0xAC, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x03, 0x02, 
  0x03, 0x07, 0x1C, 0xCE, 0x04, 0x73, 0x70, 0x69, 0x74, 0xDA, 0x18, 0xD0, 0x02, 0x77, 0x62, 0xDA, 
  0x83, 0x50, 0xDA, 0x83, 0x51, 0xCE, 0x0B, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6D, 0x6F, 0x64, 
  0x65, 0x20, 0xDA, 0x81, 0x38, 0xD8, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x77, 0x72, 0x69, 0x74, 
  0x65, 0xDA, 0x83, 0x54, 0x2C, 0x03, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x02, 
  0x1C, 0x05, 0x03, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x04, 0x02, 0x00, 
  0x19, 0x05, 0x04, 0x00, 0x30, 0x00, 0x05, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 
  0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x02, 0x00, 0x1A, 0x08, 0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 
  0x2A, 0x09, 0x03, 0x00, 0x31, 0x08, 0x00, 0x09, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 
  0x33, 0x08, 0x09, 0x00, 0x01, 0x08, 0x00, 0x00, 0x30, 0x07, 0x01, 0x00, 0x2A, 0x09, 0x05, 0x00, 
  0x33, 0x08, 0x09, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0A, 0x06, 0x00, 0x33, 0x09, 0x0A, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0x86, 0xAC, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x0D, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF9, 0x01, 0xDA, 0x08, 
  0xCE, 0x68, 0x28, 0x73, 0x70, 0x69, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x63, 0x6F, 0x6E, 
  0x74, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 
  0x0A, 0x0A, 0x57, 0x72, 0x69, 0x74, 0x65, 0x20, 0x60, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 
  0x73, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x61, 0x74, 0x20, 
  0x60, 0x70, 0x61, 0x74, 0x68, 0x60, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 
  0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xCF, 0x0A, 0x6E, 0x65, 0x74, 0x2F, 
  0x6C, 0x69, 0x73, 0x74, 0x65, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 0x82, 
  0x3E, 0x01, 0xDA, 0x06, 0xDA, 0x37, 0xDA, 0x08, 0xCE, 0x81, 0xA0, 0x28, 0x6E, 0x65, 0x74, 0x2F, 
  0x6C, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x20, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x70, 0x6F, 0x72, 0x74, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 
  0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 
  0x65, 0x61, 0x6D, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x65, 0x69, 0x74, 
  0x68, 0x65, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6E, 0x6F, 0x72, 
  0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x20, 
  0x6E, 0x65, 0x74, 0x2F, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x65, 
  0x74, 0x2F, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2D, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x62, 0x65, 
  0x20, 0x74, 0x6F, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x20, 
  0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x79, 
  0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x6E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x20, 0x63, 0x6F, 
  0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 
  0x20, 0x61, 0x20, 0x3A, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x28, 0x75, 0x73, 0x75, 0x61, 
  0x6C, 0x6C, 0x79, 0x20, 0x74, 0x63, 0x70, 0x29, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x3A, 0x64, 0x61, 
  0x74, 0x61, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x28, 0x75, 0x73, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x20, 
  0x75, 0x64, 0x70, 0x29, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x73, 0x70, 0x65, 
  0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 
  0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x3A, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x6F, 0x72, 
  0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6E, 
  0x65, 0x74, 0x2F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2E, 0xCF, 0x06, 0x65, 0x66, 0x6C, 
  0x75, 0x73, 0x68, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x96, 0x01, 
  0xDA, 0x06, 0xDA, 0x83, 0xDA, 0xDA, 0x08, 0xCE, 0x4A, 0x28, 0x65, 0x66, 0x6C, 0x75, 0x73, 0x68, 
  0x29, 0x0A, 0x0A, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 
  0x65, 0x72, 0x72, 0x20, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0x29, 0x60, 0x20, 0x69, 0x66, 0x20, 
  0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x6F, 0x74, 
  0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x68, 0x69, 
  0x6E, 0x67, 0x2E, 0xCF, 0x0D, 0x65, 0x76, 0x2F, 0x63, 0x68, 0x61, 0x6E, 0x2D, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x84, 0x59, 0x01, 0xDA, 0x06, 
  0xD8, 0x0D, 0x65, 0x76, 0x2F, 0x63, 0x68, 0x61, 0x6E, 0x2D, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xDA, 
  0x08, 0xCE, 0x80, 0x83, 0x28, 0x65, 0x76, 0x2F, 0x63, 0x68, 0x61, 0x6E, 0x2D, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x20, 
  0x61, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x2E, 0x20, 0x41, 0x20, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0x64, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x65, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x72, 0x65, 0x61, 0x64, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x77, 0x72, 0x69, 
  0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 
  0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 
  0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x2E, 0xCF, 0x03, 0x73, 0x65, 0x71, 0xD3, 0x04, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x61, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x05, 0x17, 0xCE, 0x03, 0x73, 0x65, 0x71, 
  0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x44, 0xDA, 0x4A, 0xDA, 0x81, 0x4C, 0xCF, 0x04, 0x6C, 0x6F, 0x6F, 
  0x70, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x3E, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x31, 0x07, 0x04, 0x05, 0x43, 0x06, 0x00, 
  0x00, 0x2A, 0x07, 0x02, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x05, 0x00, 
  0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x08, 0x04, 0x05, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x04, 
  0x00, 0x31, 0x08, 0x00, 0x07, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x31, 0x08, 0x06, 
  0x05, 0x2F, 0x04, 0x00, 0x00, 0x43, 0x07, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x82, 0x61, 0x01, 
  0x04, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x7B, 
  0x28, 0x73, 0x65, 0x71, 0x20, 0x68, 0x65, 0x61, 0x64, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 
  0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x6C, 
  0x6F, 0x6F, 0x70, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 
  0x6C, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x2E, 0x0A, 0x53, 0x65, 0x65, 0x20, 0x60, 0x6C, 0x6F, 0x6F, 0x70, 0x60, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x09, 
  0x66, 0x66, 0x69, 0x2F, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x0C, 0x81, 0xD3, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x66, 0x66, 0x69, 0x2F, 0x61, 0x6C, 0x69, 
  0x67, 0x6E, 0xDA, 0x08, 0xCE, 0x38, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x61, 0x6C, 0x69, 0x67, 0x6E, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x61, 0x6C, 0x69, 0x67, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x66, 0x66, 0x69, 0x20, 
  0x74, 0x79, 0x70, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2E, 0xCF, 0x0C, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0x33, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x5C, 0xDA, 0x08, 
  0xCE, 0x80, 0xA3, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6D, 0x70, 
  0x74, 0x69, 0x65, 0x73, 0x20, 0x69, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x20, 0x72, 0x65, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x73, 0x20, 
  0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x73, 0x6F, 0x20, 0x69, 0x74, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x62, 0x65, 0x20, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 
  0x72, 0x65, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xCF, 0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 
  0x75, 0x73, 0x68, 0x2D, 0x77, 0x6F, 0x72, 0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x81, 0x13, 0x80, 0xF4, 0x01, 0xDA, 0x06, 0xD8, 0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 
  0x70, 0x75, 0x73, 0x68, 0x2D, 0x77, 0x6F, 0x72, 0x64, 0xDA, 0x08, 0xCE, 0x80, 0xF0, 0x28, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x77, 0x6F, 0x72, 0x64, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x41, 0x70, 
  0x70, 0x65, 0x6E, 0x64, 0x20, 0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x20, 0x77, 0x6F, 0x72, 
  0x64, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x34, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 
  0x70, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x77, 0x6F, 0x73, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x6C, 0x69, 0x74, 0x74, 
  0x6C, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x69, 0x61, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2C, 
  0x20, 0x75, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 
  0x6C, 0x20, 0x78, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x73, 0x2E, 0xCF, 0x0C, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x69, 0x6E, 0x74, 0x2D, 0x6D, 0x61, 0x78, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0xA0, 0x01, 0xDA, 0x06, 0xC8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x40, 0x43, 0xDA, 0x08, 0xCE, 0x42, 0x54, 0x68, 0x65, 0x20, 0x6D, 0x61, 0x78, 0x69, 
  0x6D, 0x75, 0x6D, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x20, 0x69, 
  0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x74, 0x65, 0x6E, 
  0x61, 0x62, 0x6C, 0x65, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x64, 0x6F, 0x75, 0x62, 0x6C, 0x65, 
  0x20, 0x28, 0x2D, 0x28, 0x32, 0x5E, 0x35, 0x33, 0x29, 0x29, 0xCF, 0x10, 0x65, 0x76, 0x2F, 0x72, 
  0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x2D, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8C, 0x5E, 0x01, 0xDA, 0x06, 0xD8, 0x10, 0x65, 0x76, 0x2F, 0x72, 
  0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x2D, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0xDA, 0x08, 0xCE, 0x44, 
  0x28, 0x65, 0x76, 0x2F, 0x72, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x2D, 0x77, 0x6C, 0x6F, 0x63, 
  0x6B, 0x20, 0x72, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6C, 0x65, 0x61, 
  0x73, 0x65, 0x20, 0x61, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 
  0x6F, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2D, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 
  0x6C, 0x6F, 0x63, 0x6B, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x7D, 0x01, 0xDA, 0x06, 0xD8, 0x08, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0xDA, 0x08, 0xCE, 0x80, 0xD5, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x72, 0x6E, 0x67, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x65, 0x65, 0x64, 0x29, 0x0A, 
  0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x50, 0x73, 0x75, 0x65, 0x64, 
  0x6F, 0x2D, 0x52, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 
  0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2C, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x65, 0x65, 0x64, 
  0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x65, 0x64, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 
  0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x75, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 
  0x20, 0x33, 0x32, 0x20, 0x62, 0x69, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 
  0x6F, 0x72, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x44, 0x6F, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 0x61, 0x70, 0x68, 0x79, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x72, 0x6E, 
  0x67, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 
  0xCF, 0x0D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x83, 0xF3, 0x01, 0xDA, 0x06, 0xDA, 0x82, 
  0xDC, 0xDA, 0x08, 0xCE, 0x81, 0x02, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 
  0x61, 0x74, 0x75, 0x73, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x47, 0x65, 
  0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 
  0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 
  0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 0x2A, 
  0x20, 0x3A, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x2D, 0x20, 0x61, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x64, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x2D, 
  0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x20, 0x77, 0x61, 0x73, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 
  0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x72, 0x6F, 0x6F, 0x74, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x65, 0x69, 0x74, 0x68, 
  0x65, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x61, 0x66, 0x65, 0x6C, 0x79, 0x20, 0x74, 0x65, 
  0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x2E, 0xCF, 0x0C, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 
  0x69, 0x6F, 0x6E, 0x2D, 0x62, 0x79, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 
  0x3B, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x01, 
  0x27, 0xCE, 0x0C, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x2D, 0x62, 0x79, 0xDA, 
  0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 
  0x26, 0x05, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x27, 0x07, 0x00, 0x00, 0x26, 0x09, 0x00, 0x00, 
  0x47, 0x08, 0x01, 0x09, 0x19, 0x09, 0x08, 0x00, 0x1D, 0x09, 0x1D, 0x00, 0x38, 0x08, 0x01, 0x09, 
  0x19, 0x0A, 0x08, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x08, 0x00, 0x00, 0x19, 0x0B, 0x08, 0x00, 
  0x1C, 0x07, 0x09, 0x00, 0x28, 0x07, 0x00, 0x00, 0x19, 0x06, 0x0B, 0x00, 0x2F, 0x0A, 0x00, 0x00, 
  0x3E, 0x05, 0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x0C, 0x00, 0x00, 0x33, 0x08, 0x0C, 0x00, 
  0x1A, 0x0D, 0x00, 0x00, 0x23, 0x08, 0x0B, 0x06, 0x1C, 0x08, 0x05, 0x00, 0x30, 0x05, 0x0A, 0x00, 
  0x2A, 0x0D, 0x00, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x19, 0x06, 0x0B, 0x00, 
  0x2F, 0x0A, 0x00, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x0D, 0x00, 0x00, 
  0x33, 0x0C, 0x0D, 0x00, 0x47, 0x09, 0x01, 0x09, 0x1A, 0xE4, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 
  0x86, 0x3B, 0x01, 0x05, 0x03, 0x00, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 
  0x05, 0x01, 0x12, 0x00, 0x25, 0x00, 0x36, 0x00, 0x36, 0x00, 0x46, 0x00, 0x46, 0x00, 0x46, 0xBF, 
  0xFF, 0x05, 0x02, 0x07, 0xBF, 0xFE, 0x05, 0x02, 0x16, 0x00, 0x16, 0x00, 0x16, 0xBF, 0xFE, 0x05, 
  0x03, 0x0B, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0xBF, 0xFB, 0x03, 0x00, 
  0x03, 0xBF, 0xF7, 0x01, 0xDA, 0x08, 0xCE, 0x80, 0xE6, 0x28, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 
  0x69, 0x6F, 0x6E, 0x2D, 0x62, 0x79, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x50, 
  0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x74, 0x69, 0x61, 
  0x6C, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 
  0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x61, 
  0x74, 0x69, 0x76, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x60, 0x66, 
  0x60, 0x2E, 0x20, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x0A, 0x73, 0x70, 
  0x6C, 0x69, 0x74, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x60, 0x28, 0x66, 0x20, 0x78, 0x29, 0x60, 
  0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x73, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 
  0x77, 0x68, 0x65, 0x6E, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 
  0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x60, 0x78, 0x60, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x69, 0x6E, 0x64, 0x60, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x0A, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2E, 0xCF, 
  0x09, 0x2A, 0x73, 0x79, 0x73, 0x70, 0x61, 0x74, 0x68, 0x2A, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 0xCD, 0x01, 0xDA, 0x06, 0xD0, 0x07, 0x73, 0x79, 
  0x73, 0x70, 0x61, 0x74, 0x68, 0xDA, 0x08, 0xCE, 0x2E, 0x50, 0x61, 0x74, 0x68, 0x20, 0x6F, 0x66, 
  0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x6C, 0x6F, 
  0x61, 0x64, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x2E, 0xCF, 0x0E, 0x2A, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x2D, 0x66, 0x69, 0x6C, 0x65, 0x2A, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x84, 0xC2, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x02, 0xDA, 0x08, 0xCE, 0x32, 
  0x42, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x61, 0x6D, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 
  0x6C, 0x79, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x6C, 
  0x65, 0x2E, 0xCF, 0x06, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xCE, 0x12, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x63, 0x6F, 0x72, 0x65, 
  0x6C, 0x69, 0x62, 0x2E, 0x63, 0x81, 0xD4, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x58, 0xDA, 0x08, 0xCE, 
  0x80, 0xCC, 0x28, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x26, 0x20, 0x6B, 0x76, 0x73, 0x29, 
  0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 
  0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 
  0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x2E, 0x20, 0x6B, 0x76, 0x73, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6B, 0x31, 0x2C, 0x20, 
  0x76, 0x31, 0x2C, 0x20, 0x6B, 0x32, 0x2C, 0x20, 0x76, 0x32, 0x2C, 0x20, 0x6B, 0x33, 0x2C, 0x20, 
  0x76, 0x33, 0x2C, 0x20, 0x2E, 0x2E, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6B, 0x76, 0x73, 0x20, 0x68, 
  0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x64, 0x64, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x20, 0x6F, 0x66, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x61, 0x6E, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x74, 
  0x68, 0x72, 0x6F, 0x77, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 0xCF, 0x0A, 
  0x66, 0x69, 0x6E, 0x64, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x84, 0x10, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x24, 0xDA, 0x08, 0xCE, 0x76, 0x28, 
  0x66, 0x69, 0x6E, 0x64, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 
  0x69, 0x6E, 0x64, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x29, 0x0A, 0x0A, 
  0x46, 0x69, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x6F, 
  0x66, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x60, 0x70, 0x72, 0x65, 0x64, 0x60, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x60, 0x64, 0x66, 0x6C, 0x74, 0x60, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 
  0x6F, 0x75, 0x6E, 0x64, 0x2E, 0xCF, 0x03, 0x64, 0x65, 0x63, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x80, 0x95, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0xF3, 0xDA, 0x08, 0xCE, 0x17, 0x28, 
  0x64, 0x65, 0x63, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x78, 0x20, 0x2D, 0x20, 0x31, 0x2E, 0xCF, 0x0F, 0x70, 0x65, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 
  0x61, 0x63, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 
  0x1B, 0x86, 0xDE, 0x01, 0xDA, 0x06, 0xD8, 0x0F, 0x70, 0x65, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 
  0x61, 0x63, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0xDA, 0x08, 0xCE, 0x80, 0xB2, 0x28, 0x70, 0x65, 0x67, 
  0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x65, 0x67, 
  0x20, 0x72, 0x65, 0x70, 0x6C, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 
  0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x65, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x65, 0x78, 
  0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x2C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x65, 0x67, 0x20, 0x64, 0x6F, 0x65, 
  0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 
  0x6B, 0x65, 0x20, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x64, 
  0x6F, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xCF, 0x06, 
  0x6F, 0x73, 0x2F, 0x64, 0x69, 0x72, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 
  0x81, 0x01, 0xDA, 0x06, 0xD8, 0x06, 0x6F, 0x73, 0x2F, 0x64, 0x69, 0x72, 0xDA, 0x08, 0xCE, 0x80, 
  0xA8, 0x28, 0x6F, 0x73, 0x2F, 0x64, 0x69, 0x72, 0x20, 0x64, 0x69, 0x72, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x29, 0x0A, 0x0A, 0x49, 0x74, 0x65, 0x72, 0x61, 0x74, 
  0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x69, 0x65, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x70, 0x61, 0x72, 0x74, 0x73, 0x2C, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x64, 0x69, 0x72, 0x65, 
  0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6E, 
  0x6F, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x2E, 0xCF, 0x08, 0x73, 0x68, 0x6F, 0x72, 0x74, 
  0x2D, 0x66, 0x6E, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 0x77, 0x01, 0xDA, 
  0x06, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x15, 0x02, 0x01, 0x02, 0x07, 0x32, 0x02, 0xCE, 
  0x08, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x2D, 0x66, 0x6E, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x0A, 0x02, 0x01, 0x02, 0x03, 0x18, 0xCE, 0x05, 0x6D, 0x61, 0x63, 0x65, 0x78, 0xDA, 
  0x18, 0xDA, 0x82, 0x3B, 0xDA, 0x82, 0x96, 0xCE, 0x1A, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x65, 
  0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x6F, 0x20, 0x6E, 0x65, 0x73, 
  0x74, 0x65, 0x64, 0x2C, 0x02, 0x00, 0x00, 0x19, 0x03, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 
  0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x29, 0x06, 0x00, 0x00, 0x30, 
  0x05, 0x03, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x1C, 0x07, 0x0D, 0x00, 0x05, 
  0x06, 0x06, 0x01, 0x29, 0x09, 0xC8, 0x00, 0x1F, 0x08, 0x06, 0x09, 0x1C, 0x08, 0x04, 0x00, 0x2A, 
  0x09, 0x02, 0x00, 0x01, 0x09, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x19, 0x03, 0x05, 0x00, 0x30, 
  0x05, 0x01, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x05, 0x08, 0x00, 0x1A, 0xF1, 0xFF, 0xFF, 0x03, 
  0x05, 0x00, 0x00, 0x88, 0x48, 0x01, 0x07, 0x03, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 
  0x01, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x02, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0xBF, 0xFC, 0x03, 0xBF, 0xF6, 0x01, 0xDA, 0x80, 0xF1, 0xCF, 0x01, 0x24, 0xD8, 0x06, 0x73, 
  0x79, 0x6D, 0x62, 0x6F, 0x6C, 0xDA, 0x81, 0x4C, 0xD2, 0x02, 0x00, 0xDA, 0x84, 0x36, 0xCF, 0x02, 
  0x24, 0x26, 0xDA, 0x80, 0xB9, 0x2C, 0x02, 0x00, 0x00, 0x29, 0x03, 0xFF, 0xFF, 0x28, 0x04, 0x00, 
  0x00, 0x2E, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x07, 0x01, 0x00, 0x19, 0x08, 0x07, 
  0x00, 0x30, 0x00, 0x08, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 0x0A, 0x09, 
  0x00, 0x1C, 0x01, 0x05, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x43, 0x0C, 0x00, 0x00, 0x19, 0x0B, 0x0C, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x3E, 0x0D, 0x00, 
  0x00, 0x19, 0x0E, 0x0D, 0x00, 0x29, 0x0D, 0x00, 0x00, 0x29, 0x10, 0x01, 0x00, 0x06, 0x0F, 0x10, 
  0x03, 0x19, 0x10, 0x0F, 0x00, 0x21, 0x0F, 0x0D, 0x10, 0x1C, 0x0F, 0x0B, 0x00, 0x19, 0x11, 0x0D, 
  0x00, 0x2A, 0x12, 0x02, 0x00, 0x30, 0x12, 0x11, 0x00, 0x2A, 0x13, 0x03, 0x00, 0x33, 0x12, 0x13, 
  0x00, 0x30, 0x0E, 0x12, 0x00, 0x2A, 0x14, 0x04, 0x00, 0x33, 0x13, 0x14, 0x00, 0x05, 0x0D, 0x0D, 
  0x01, 0x1A, 0xF5, 0xFF, 0xFF, 0x19, 0x0D, 0x0E, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x0F, 0x05, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x0F, 0x01, 0x00, 0x32, 0x0D, 0x00, 0x00, 0x32, 0x0F, 0x00, 
  0x00, 0x44, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x06, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x32, 0x0C, 0x00, 
  0x00, 0x30, 0x10, 0x0A, 0x00, 0x43, 0x0F, 0x00, 0x00, 0x03, 0x0F, 0x00, 0x00, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0xCE, 0x0F, 0x73, 0x61, 0x77, 0x2D, 0x73, 
  0x70, 0x65, 0x63, 0x69, 0x61, 0x6C, 0x2D, 0x61, 0x72, 0x67, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 
  0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xCE, 0x03, 0x6D, 
  0x61, 0x78, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x14, 0x06, 0x00, 0x00, 0xCD, 0x7F, 
  0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x01, 0x3E, 0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 0x02, 
  0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 
  0x1F, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 0x00, 
  0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 
  0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xDA, 0x81, 0x49, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x82, 
  0xD7, 0x01, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x02, 
  0x00, 0x03, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2D, 0x02, 
  0x00, 0x03, 0x2B, 0x03, 0x00, 0x03, 0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 0x88, 0x88, 0x03, 0x02, 
  0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x07, 0x28, 0x01, 0xCE, 0x0A, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0xDA, 0x18, 0xDA, 0x84, 0xDE, 0xD8, 0x12, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x3F, 0xCF, 0x02, 
  0x24, 0x30, 0xDA, 0x84, 0xE0, 0xDA, 0x81, 0x36, 0xD8, 0x0B, 0x73, 0x63, 0x61, 0x6E, 0x2D, 0x6E, 
  0x75, 0x6D, 0x62, 0x65, 0x72, 0xD8, 0x04, 0x6E, 0x61, 0x74, 0x3F, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 
  0x02, 0x22, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x23, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x07, 0x00, 0x29, 
  0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2B, 0x05, 0x00, 0x06, 0x33, 0x04, 0x05, 0x00, 0x2A, 
  0x04, 0x02, 0x00, 0x03, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x23, 0x04, 0x05, 0x00, 0x1C, 
  0x04, 0x04, 0x00, 0x27, 0x05, 0x00, 0x00, 0x2D, 0x05, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x29, 
  0x05, 0x01, 0x00, 0x30, 0x00, 0x05, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2F, 
  0x05, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 0x00, 0x2F, 
  0x05, 0x00, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x33, 0x06, 0x07, 0x00, 0x1C, 0x06, 0x05, 0x00, 0x2F, 
  0x05, 0x00, 0x00, 0x2B, 0x08, 0x00, 0x06, 0x33, 0x07, 0x08, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x03, 
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x88, 0x8B, 0x03, 
  0x02, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x02, 0x09, 0x00, 0x09, 0xBF, 0xFF, 
  0x07, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 0x0B, 0x00, 0x0B, 0x01, 0x09, 0x00, 
  0x09, 0xBF, 0xFB, 0x07, 0x07, 0x0B, 0x00, 0x0B, 0xBF, 0xFF, 0x09, 0x05, 0x21, 0x00, 0x21, 0x00, 
  0x21, 0x00, 0x21, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x0B, 0x01, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0B, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFF, 0x0B, 0xBF, 0xFE, 0x09, 0xBF, 
  0xF6, 0x07, 0xBF, 0xFF, 0x05, 0x88, 0x77, 0x01, 0x0F, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x03, 0x03, 0x00, 0x03, 0x13, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x14, 0x00, 0x1D, 
  0x00, 0x1D, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x03, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 
  0x00, 0x22, 0x00, 0x22, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x39, 0x00, 0x39, 
  0x00, 0x39, 0x00, 0x39, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 
  0x01, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x58, 0x00, 0x00, 0x00, 0xDA, 0x08, 
  0xCE, 0x82, 0x38, 0x28, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x2D, 0x66, 0x6E, 0x20, 0x61, 0x72, 0x67, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 
  0x72, 0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x66, 0x6E, 0x60, 0x2E, 
  0x20, 0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x67, 
  0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x73, 0x20, 0x60, 0x24, 0x6E, 0x60, 0x2C, 0x20, 0x77, 0x68, 
  0x65, 0x72, 0x65, 0x20, 0x60, 0x6E, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x30, 
  0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x0A, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x2E, 0x20, 0x60, 0x24, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x61, 
  0x6E, 0x20, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x28, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x30, 0x29, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x60, 0x24, 
  0x26, 0x60, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 
  0x61, 0x6B, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 
  0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 
  0x64, 0x69, 0x63, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x0A, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x62, 0x69, 0x6E, 
  0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 
  0x61, 0x6C, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x0A, 0x0A, 0x45, 
  0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x3A, 0x0A, 0x0A, 0x20, 
  0x20, 0x20, 0x20, 0x28, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x2D, 0x66, 0x6E, 0x20, 0x28, 0x2B, 0x20, 
  0x24, 0x20, 0x24, 0x29, 0x29, 0x20, 0x23, 0x20, 0x41, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6F, 0x75, 0x62, 0x6C, 0x65, 0x73, 0x20, 
  0x69, 0x74, 0x73, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x0A, 0x20, 
  0x20, 0x20, 0x20, 0x28, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x2D, 0x66, 0x6E, 0x20, 0x28, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x20, 0x24, 0x30, 0x20, 0x24, 0x31, 0x29, 0x29, 0x20, 0x23, 0x20, 0x61, 
  0x63, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 
  0x65, 0x20, 0x61, 0x72, 0x67, 0x73, 0x2E, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x28, 0x2B, 0x20, 
  0x24, 0x20, 0x24, 0x29, 0x20, 0x23, 0x20, 0x75, 0x73, 0x65, 0x20, 0x70, 0x69, 0x70, 0x65, 0x20, 
  0x72, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x74, 0x65, 0x72, 0x73, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x6C, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6C, 0x73, 0x2E, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x28, 
  0x2B, 0x20, 0x24, 0x26, 0x29, 0x20, 0x20, 0x23, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x64, 0x69, 
  0x63, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0xDA, 0x2B, 0xCB, 0xCF, 0x03, 
  0x6B, 0x76, 0x73, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x70, 0x01, 0xDA, 
  0x06, 0xDA, 0x82, 0x55, 0xDA, 0x08, 0xCE, 0x78, 0x28, 0x6B, 0x76, 0x73, 0x20, 0x64, 0x69, 0x63, 
  0x74, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 
  0x61, 0x69, 0x72, 0x73, 0x0A, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x60, 0x40, 0x5B, 0x6B, 0x20, 0x76, 
  0x20, 0x6B, 0x20, 0x76, 0x20, 0x2E, 0x2E, 0x2E, 0x5D, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 
  0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x70, 0x72, 0x65, 
  0x66, 0x69, 0x78, 0x3F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 0x46, 
  0x01, 0xDA, 0x06, 0xDA, 0x84, 0xE8, 0xDA, 0x08, 0xCE, 0x44, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x3F, 0x20, 0x70, 0x66, 
  0x78, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x54, 0x65, 0x73, 0x74, 0x73, 0x20, 0x77, 0x68, 
  0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x60, 0x73, 0x74, 0x72, 0x60, 0x20, 0x73, 0x74, 0x61, 0x72, 
  0x74, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x70, 0x66, 0x78, 0x60, 0x2E, 0xCF, 0x04, 
  0x6B, 0x65, 0x79, 0x73, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x06, 0x01, 
  0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x01, 0x0F, 0xCE, 
  0x04, 0x6B, 0x65, 0x79, 0x73, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 
  0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 
  0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x48, 0x06, 0x07, 0x05, 0x1C, 0x06, 0x06, 0x00, 0x30, 0x03, 
  0x05, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x07, 0x08, 0x00, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF9, 
  0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x86, 0x06, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x00, 
  0x0A, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x0C, 0xBF, 0xFE, 0x03, 0xBF, 0xFB, 0x01, 0xDA, 0x08, 0xCE, 0x38, 0x28, 0x6B, 0x65, 0x79, 0x73, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 
  0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 
  0x69, 0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 
  0x72, 0x65, 0x2E, 0xCF, 0x0E, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 
  0x73, 0x65, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0x68, 0x01, 
  0xDA, 0x06, 0xD8, 0x0E, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x73, 
  0x65, 0x74, 0xDA, 0x08, 0xCE, 0x57, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 
  0x74, 0x2D, 0x73, 0x65, 0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 
  0x65, 0x78, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 
  0x74, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 
  0x69, 0x74, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xCF, 0x09, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x61, 0x73, 0x69, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x80, 0xA4, 0x81, 0x09, 0x01, 0xDA, 0x06, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x73, 
  0x69, 0x6E, 0xDA, 0x08, 0xCE, 0x27, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x73, 0x69, 0x6E, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x61, 0x72, 0x63, 0x73, 0x69, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xCF, 0x06, 0x67, 
  0x65, 0x74, 0x2D, 0x69, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0xB7, 
  0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x03, 0x02, 0x03, 0x02, 0x19, 
  0xCE, 0x06, 0x67, 0x65, 0x74, 0x2D, 0x69, 0x6E, 0xDA, 0x18, 0xDA, 0x82, 0x26, 0xDA, 0x73, 0x2C, 
  0x03, 0x00, 0x00, 0x19, 0x04, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 
  0x06, 0x05, 0x00, 0x1D, 0x06, 0x0F, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 0x2F, 
  0x04, 0x00, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x05, 0x08, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 
  0x09, 0x01, 0x00, 0x33, 0x08, 0x09, 0x00, 0x1C, 0x08, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x1A, 
  0x04, 0x00, 0x00, 0x39, 0x04, 0x04, 0x07, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xF2, 0xFF, 0xFF, 0x26, 
  0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x02, 0x00, 0x03, 0x02, 0x00, 0x00, 0x03, 
  0x04, 0x00, 0x00, 0x85, 0xB7, 0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x31, 0x00, 0x03, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x08, 0xCE, 0x80, 0xB9, 0x28, 0x67, 0x65, 0x74, 0x2D, 
  0x69, 0x6E, 0x20, 0x64, 0x73, 0x20, 0x6B, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 
  0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x61, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 
  0x4C, 0x6F, 0x6F, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 
  0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x76, 0x69, 
  0x61, 0x0A, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x6B, 0x65, 0x79, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 
  0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x60, 0x64, 0x66, 0x6C, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 
  0x64, 0x65, 0x64, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x60, 0x64, 0x66, 
  0x6C, 0x74, 0x60, 0x2E, 0xCF, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 
  0x68, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0x1C, 0x01, 0xDA, 0x06, 
  0xDA, 0x81, 0x57, 0xDA, 0x08, 0xCE, 0x81, 0x55, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 
  0x70, 0x75, 0x73, 0x68, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x26, 0x20, 0x78, 0x73, 
  0x29, 0x0A, 0x0A, 0x50, 0x75, 0x73, 0x68, 0x20, 0x62, 0x6F, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x64, 
  0x69, 0x76, 0x69, 0x64, 0x75, 0x61, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x73, 
  0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x46, 0x6F, 
  0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x78, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x2C, 0x20, 
  0x70, 0x75, 0x73, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x69, 0x66, 
  0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 
  0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x70, 0x75, 0x73, 0x68, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 
  0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0x20, 0x54, 0x68, 0x75, 0x73, 0x2C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x65, 0x73, 0x20, 0x6C, 0x69, 0x6B, 
  0x65, 0x20, 0x62, 0x6F, 0x74, 0x68, 0x20, 0x60, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 
  0x75, 0x73, 0x68, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x60, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x62, 0x79, 0x74, 
  0x65, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x73, 0x2E, 0xCF, 0x0D, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0xBD, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0xBD, 0xDA, 0x08, 
  0xCE, 0x80, 0x82, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 
  0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 
  0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x6E, 0x70, 0x72, 0x69, 0x6E, 0x74, 
  0x66, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 
  0x6C, 0x69, 0x74, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2E, 0xCF, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x65, 0x65, 
  0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0xA1, 0x80, 0xAD, 0x01, 0xDA, 0x06, 
  0xD8, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x65, 0x65, 0x6B, 0xDA, 0x08, 0xCE, 0x53, 
  0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x65, 0x65, 0x6B, 0x20, 0x61, 0x72, 0x72, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 
  0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x2E, 0xCF, 0x0D, 0x6F, 0x73, 0x2F, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x72, 0x61, 
  0x6E, 0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x85, 0x06, 0x01, 0xDA, 0x06, 
  0xD8, 0x0D, 0x6F, 0x73, 0x2F, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x72, 0x61, 0x6E, 0x64, 0xDA, 
  0x08, 0xCE, 0x80, 0x82, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x72, 0x61, 
  0x6E, 0x64, 0x20, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x29, 0x0A, 0x0A, 
  0x47, 0x65, 0x74, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x60, 0x6E, 
  0x60, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x67, 0x6F, 0x6F, 0x64, 0x20, 
  0x71, 0x75, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x64, 
  0x61, 0x74, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x4F, 0x53, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x72, 0x20, 
  0x60, 0x62, 0x75, 0x66, 0x60, 0x2E, 0xCF, 0x04, 0x62, 0x78, 0x6F, 0x72, 0xD3, 0x02, 0xDA, 0x06, 
  0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x0F, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 
  0x13, 0xCE, 0x04, 0x62, 0x78, 0x6F, 0x72, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 
  0x02, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 
  0x02, 0x05, 0x00, 0x29, 0x03, 0x00, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x10, 0x03, 0x03, 0x04, 0x03, 
  0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x10, 
  0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 
  0x03, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x59, 0x28, 0x62, 0x78, 0x6F, 0x72, 0x20, 0x26, 0x20, 0x78, 
  0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x62, 0x69, 0x74, 0x2D, 0x77, 0x69, 0x73, 0x65, 0x20, 0x78, 0x6F, 0x72, 0x20, 0x6F, 0x66, 0x20, 
  0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 
  0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x20, 0x6D, 0x75, 0x73, 
  0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 
  0xCF, 0x07, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x8B, 0x58, 0x01, 0xDA, 0x06, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x01, 
  0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x07, 0xCE, 0x07, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 
  0x65, 0xDA, 0x18, 0xDA, 0x82, 0x58, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0D, 0x03, 0x03, 
  0x03, 0x0B, 0x3B, 0xCE, 0x09, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2D, 0x31, 0xDA, 0x18, 
  0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x0C, 0x01, 0x01, 0x01, 0x0D, 0x4F, 0x01, 0xCE, 0x0B, 
  0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0xDA, 0x18, 0xD1, 0x11, 0xD2, 
  0x03, 0x00, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x06, 0xCE, 
  0x09, 0x69, 0x73, 0x2D, 0x63, 0x61, 0x63, 0x68, 0x65, 0x64, 0xDA, 0x18, 0xD3, 0x00, 0x2C, 0x01, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x38, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x03, 0x00, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8A, 0x7C, 0x1F, 0x00, 0x38, 0x00, 0x38, 0x00, 0x34, 0x00, 
  0x34, 0x00, 0x34, 0xD0, 0x07, 0x70, 0x72, 0x65, 0x6C, 0x6F, 0x61, 0x64, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x02, 0x08, 0xCE, 0x12, 0x63, 0x68, 0x65, 0x63, 0x6B, 
  0x2D, 0x6E, 0x6F, 0x74, 0x2D, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0xDA, 0x18, 0xCE, 
  0x01, 0x2E, 0xDA, 0x84, 0xE8, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 
  0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x8A, 0x4B, 0x01, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 
  0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0xD2, 0x03, 0x00, 0xCE, 0x12, 0x3A, 0x63, 0x75, 0x72, 0x3A, 
  0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xD0, 0x05, 0x69, 
  0x6D, 0x61, 0x67, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x02, 
  0x08, 0xCE, 0x0E, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0xDA, 0x18, 0xDA, 0x85, 0x32, 0xDA, 0x84, 0xE8, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 
  0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8A, 0x4A, 0x01, 0x00, 0x1F, 0x00, 0x1F, 
  0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0xD2, 0x03, 0x00, 0xCE, 0x11, 0x3A, 
  0x63, 0x75, 0x72, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 
  0xDA, 0x83, 0x4C, 0xDA, 0x85, 0x36, 0xD2, 0x03, 0x00, 0xCE, 0x16, 0x3A, 0x63, 0x75, 0x72, 0x3A, 
  0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2F, 0x69, 0x6E, 0x69, 0x74, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 
  0x74, 0xDA, 0x83, 0x4C, 0xDA, 0x85, 0x36, 0xD2, 0x03, 0x00, 0xCE, 0x13, 0x3A, 0x63, 0x75, 0x72, 
  0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0xD0, 
  0x06, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0xDA, 0x85, 0x36, 0xD2, 0x03, 0x00, 0xCE, 0x12, 0x3A, 
  0x73, 0x79, 0x73, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x69, 0x6D, 0x61, 0x67, 
  0x65, 0xDA, 0x85, 0x35, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x01, 0x01, 0x01, 0x04, 
  0x1A, 0xCE, 0x0C, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x69, 0x73, 0x2D, 0x64, 0x65, 0x70, 0xDA, 
  0x18, 0xDA, 0x81, 0x9C, 0xDA, 0x84, 0xE8, 0xCE, 0x01, 0x40, 0xDA, 0x85, 0x32, 0x2C, 0x01, 0x00, 
  0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 
  0x00, 0x19, 0x03, 0x02, 0x00, 0x1C, 0x03, 0x03, 0x00, 0x19, 0x02, 0x03, 0x00, 0x1A, 0x0F, 0x00, 
  0x00, 0x2A, 0x04, 0x02, 0x00, 0x30, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x1C, 0x05, 0x03, 0x00, 0x19, 0x04, 0x05, 0x00, 0x1A, 0x06, 0x00, 
  0x00, 0x2A, 0x06, 0x03, 0x00, 0x30, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 
  0x00, 0x19, 0x04, 0x06, 0x00, 0x19, 0x02, 0x04, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x8A, 0x4C, 0x01, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 
  0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
  0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x5B, 0x00, 0x5B, 0x00, 0x5B, 0x00, 0x5B, 
  0x00, 0x21, 0x00, 0x21, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xD2, 0x03, 0x00, 0xCE, 0x11, 0x3A, 
  0x73, 0x79, 0x73, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 
  0xDA, 0x83, 0x4C, 0xDA, 0x85, 0x41, 0xD2, 0x03, 0x00, 0xCE, 0x16, 0x3A, 0x73, 0x79, 0x73, 0x3A, 
  0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2F, 0x69, 0x6E, 0x69, 0x74, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 
  0x74, 0xDA, 0x83, 0x4C, 0xDA, 0x85, 0x41, 0xD2, 0x03, 0x00, 0xCE, 0x13, 0x3A, 0x73, 0x79, 0x73, 
  0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0xDA, 
  0x85, 0x3E, 0xDA, 0x85, 0x41, 0xD2, 0x03, 0x00, 0xCE, 0x0D, 0x2E, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 
  0x2E, 0x6A, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xDA, 0x85, 0x35, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x04, 0x01, 0x01, 0x01, 0x02, 0x08, 0xCE, 0x16, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x70, 
  0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x2D, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0xDA, 
  0x18, 0xDA, 0x81, 0x9C, 0xDA, 0x84, 0xE8, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 
  0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x03, 
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8A, 0x4D, 0x01, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 
  0x00, 0x27, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0xD2, 0x03, 0x00, 0xCE, 0x0C, 0x2E, 0x3A, 0x61, 
  0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0xDA, 0x83, 0x4C, 0xDA, 0x85, 0x4C, 0xD2, 
  0x03, 0x00, 0xCE, 0x11, 0x2E, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2F, 0x69, 0x6E, 0x69, 0x74, 0x2E, 
  0x6A, 0x61, 0x6E, 0x65, 0x74, 0xDA, 0x83, 0x4C, 0xDA, 0x85, 0x4C, 0xD2, 0x03, 0x00, 0xCE, 0x0E, 
  0x2E, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0xDA, 0x85, 
  0x3E, 0xDA, 0x85, 0x4C, 0xD2, 0x03, 0x00, 0xCE, 0x0D, 0x3A, 0x40, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 
  0x6A, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xDA, 0x85, 0x35, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x04, 0x01, 0x01, 0x01, 0x02, 0x08, 0xCE, 0x12, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x64, 0x79, 
  0x6E, 0x2D, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0xDA, 0x18, 0xDA, 0x85, 0x43, 0xDA, 
  0x84, 0xE8, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 
  0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0x8A, 0x49, 0x01, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x1F, 0xD2, 0x03, 0x00, 0xCE, 0x0C, 0x3A, 0x40, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 
  0x61, 0x6E, 0x65, 0x74, 0xDA, 0x83, 0x4C, 0xDA, 0x85, 0x56, 0xD2, 0x03, 0x00, 0xCE, 0x11, 0x3A, 
  0x40, 0x61, 0x6C, 0x6C, 0x3A, 0x2F, 0x69, 0x6E, 0x69, 0x74, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 
  0xDA, 0x83, 0x4C, 0xDA, 0x85, 0x56, 0xD2, 0x03, 0x00, 0xCE, 0x0E, 0x3A, 0x40, 0x61, 0x6C, 0x6C, 
  0x3A, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0xDA, 0x85, 0x3E, 0xDA, 0x85, 0x56, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x04, 0x11, 0xCE, 0x0A, 0x6D, 0x6F, 
  0x64, 0x2D, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x1C, 0xD0, 0x03, 0x6E, 0x69, 
  0x6C, 0xDA, 0x1D, 0xD8, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 
  0x73, 0x75, 0x66, 0x66, 0x69, 0x78, 0x3F, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 
  0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 
  0x03, 0x04, 0x05, 0x1C, 0x03, 0x02, 0x00, 0x03, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 
  0x05, 0x04, 0x06, 0x1C, 0x05, 0x04, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x34, 
  0x06, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x8A, 0x8A, 0x01, 0x02, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x02, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x05, 0x00, 0x05, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x09, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x82, 0xE3, 0x2C, 0x01, 0x00, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 
  0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x6A, 0x01, 0x01, 0x06, 0x00, 0x06, 0x00, 
  0x06, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xD8, 0x12, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 
  0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0xDA, 0x81, 0x38, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x03, 0x08, 0xCE, 0x07, 0x66, 0x65, 0x78, 
  0x69, 0x73, 0x74, 0x73, 0xDA, 0x18, 0xD0, 0x04, 0x6D, 0x6F, 0x64, 0x65, 0xD8, 0x07, 0x6F, 0x73, 
  0x2F, 0x73, 0x74, 0x61, 0x74, 0xD0, 0x04, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 
  0x04, 0x02, 0x00, 0x23, 0x03, 0x04, 0x02, 0x03, 0x03, 0x00, 0x00, 0x8A, 0x7F, 0x01, 0x03, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xDA, 0x82, 0x48, 0xDA, 
  0x82, 0x45, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x01, 0x13, 0xCE, 
  0x06, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 
  0x3E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 
  0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 0x0C, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 
  0x2F, 0x07, 0x00, 0x00, 0x33, 0x05, 0x00, 0x00, 0x1C, 0x05, 0x05, 0x00, 0x30, 0x04, 0x07, 0x00, 
  0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x06, 0x01, 0x06, 
  0x1A, 0xF5, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x83, 0xD8, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 
  0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 
  0xFB, 0x01, 0xCE, 0x05, 0x0A, 0x20, 0x20, 0x20, 0x20, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x0C, 0x02, 0x02, 0x02, 0x02, 0x1B, 0xCE, 0x09, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x70, 0x6F, 0x73, 
  0x65, 0xDA, 0x18, 0xDA, 0x84, 0x70, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x06, 0x02, 0x00, 0x09, 0x05, 0x06, 0x04, 0x05, 0x06, 0x05, 
  0xFF, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x05, 0x07, 0x00, 0x19, 0x06, 0x05, 
  0x00, 0x20, 0x07, 0x04, 0x00, 0x1C, 0x07, 0x06, 0x00, 0x29, 0x09, 0x00, 0x00, 0x38, 0x08, 0x01, 
  0x09, 0x29, 0x09, 0x00, 0x00, 0x3A, 0x06, 0x09, 0x08, 0x1A, 0x01, 0x00, 0x00, 0x29, 0x07, 0x01, 
  0x00, 0x21, 0x08, 0x07, 0x04, 0x1C, 0x08, 0x07, 0x00, 0x38, 0x09, 0x01, 0x07, 0x31, 0x06, 0x00, 
  0x09, 0x2A, 0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x05, 0x07, 0x07, 0x01, 0x1A, 0xF9, 0xFF, 
  0xFF, 0x03, 0x06, 0x00, 0x00, 0x86, 0x81, 0x01, 0x04, 0x0C, 0x00, 0x03, 0x01, 0x1A, 0x00, 0x1A, 
  0x00, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x07, 0x00, 0x03, 0x00, 0x1C, 
  0x00, 0x1C, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x19, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0xBF, 0xFE, 0x03, 0xBF, 0xF8, 0x01, 0xCE, 0x16, 
  0x63, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x6D, 
  0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0xCE, 0x06, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x01, 
  0x00, 0x00, 0x26, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x03, 
  0x04, 0x05, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 0x2D, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x38, 0x03, 
  0x05, 0x04, 0x3B, 0x05, 0x03, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3B, 0x05, 0x03, 0x01, 0x19, 0x07, 
  0x05, 0x00, 0x3B, 0x05, 0x03, 0x02, 0x19, 0x08, 0x05, 0x00, 0x30, 0x08, 0x00, 0x00, 0x2A, 0x05, 
  0x01, 0x00, 0x33, 0x03, 0x05, 0x00, 0x1C, 0x03, 0x1E, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x09, 
  0x02, 0x00, 0x33, 0x05, 0x09, 0x00, 0x1C, 0x05, 0x0A, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x33, 0x09, 
  0x06, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x1C, 0x0A, 0x05, 0x00, 0x30, 0x0A, 0x07, 0x00, 0x43, 0x02, 
  0x00, 0x00, 0x1A, 0x16, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x10, 0x00, 0x00, 0x30, 0x00, 
  0x06, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 
  0x04, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x09, 0x0A, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 
  0x05, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x05, 0x00, 0x30, 0x09, 0x07, 0x00, 0x43, 0x02, 
  0x00, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x47, 0x04, 0x03, 0x04, 0x1A, 0xD4, 0xFF, 0xFF, 0x1C, 0x02, 0x02, 0x00, 0x03, 0x02, 
  0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x30, 0x04, 
  0x03, 0x00, 0x2A, 0x05, 0x06, 0x00, 0x33, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x07, 0x00, 0x30, 0x05, 
  0x03, 0x00, 0x2A, 0x06, 0x08, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x03, 0x05, 0x00, 0x2A, 0x05, 
  0x09, 0x00, 0x30, 0x05, 0x03, 0x00, 0x2A, 0x06, 0x0A, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 
  0x05, 0x00, 0x2A, 0x05, 0x0B, 0x00, 0x2A, 0x07, 0x0C, 0x00, 0x31, 0x05, 0x00, 0x07, 0x32, 0x06, 
  0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x33, 0x05, 0x07, 0x00, 0x26, 0x07, 0x00, 0x00, 0x30, 0x07, 
  0x05, 0x00, 0x43, 0x05, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x06, 
  0x01, 0x01, 0x01, 0x03, 0x15, 0x01, 0xDA, 0x18, 0xDA, 0x83, 0xF0, 0xDA, 0x85, 0x5F, 0xDA, 0x85, 
  0x65, 0x3B, 0x01, 0x00, 0x00, 0x19, 0x02, 0x01, 0x00, 0x3B, 0x01, 0x00, 0x01, 0x19, 0x03, 0x01, 
  0x00, 0x3B, 0x01, 0x00, 0x02, 0x19, 0x04, 0x01, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x01, 0x00, 
  0x00, 0x33, 0x00, 0x01, 0x00, 0x1C, 0x00, 0x0B, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x30, 0x04, 0x01, 
  0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x01, 0x05, 0x00, 0x1C, 0x01, 0x05, 0x00, 0x2B, 0x05, 0x00, 
  0x00, 0x30, 0x05, 0x02, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x34, 0x05, 0x00, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xA6, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x01, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x16, 0x01, 0x1E, 0x00, 0x1E, 
  0x00, 0x1E, 0x00, 0x1E, 0x00, 0x18, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0xBF, 0xFF, 
  0x18, 0xBF, 0xFF, 0x16, 0x8A, 0x91, 0x01, 0x08, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x01, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x07, 0x01, 0x18, 0x00, 0x18, 0x00, 0x09, 0x00, 0x09, 0x01, 0x14, 0x00, 0x14, 0x01, 
  0x0B, 0xBF, 0xFE, 0x09, 0xBF, 0xFF, 0x07, 0x05, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x0B, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0B, 0x01, 0x16, 0x00, 
  0x16, 0x01, 0x0D, 0xBF, 0xFE, 0x0B, 0xBF, 0xF9, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x0B, 0x03, 0x00, 0x03, 0x01, 0x14, 0x00, 0x05, 0x04, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xFC, 0x05, 0x05, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0xBF, 0xFB, 0x05, 0x06, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0xD0, 0x05, 
  0x66, 0x72, 0x65, 0x73, 0x68, 0xDA, 0x85, 0x2E, 0xD3, 0x00, 0xCE, 0x14, 0x63, 0x69, 0x72, 0x63, 
  0x75, 0x6C, 0x61, 0x72, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x6E, 0x63, 0x79, 0x20, 
  0xCE, 0x09, 0x20, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0xDA, 0x81, 0x38, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x08, 0x6B, 0x65, 0x79, 
  0x77, 0x6F, 0x72, 0x64, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x1F, 0x2C, 0x01, 0x00, 0x00, 0x2F, 
  0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 
  0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x68, 0x01, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 
  0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xD3, 0x04, 0xDA, 0x85, 0x35, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x07, 0xCE, 0x0C, 0x69, 0x6D, 0x61, 
  0x67, 0x65, 0x2D, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x83, 0x4D, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x02, 0x05, 0xCE, 0x0A, 0x6C, 0x6F, 0x61, 
  0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xDA, 0x18, 0xD3, 0x82, 0x60, 0xDA, 0x01, 0xDA, 0x07, 
  0xDA, 0x0A, 0xDA, 0x0E, 0xDA, 0x10, 0xDA, 0x14, 0xDA, 0x16, 0xDA, 0x1A, 0xDA, 0x22, 0xDA, 0x25, 
  0xDA, 0x2C, 0xDA, 0x30, 0xDA, 0x32, 0xDA, 0x35, 0xDA, 0x3E, 0xDA, 0x41, 0xDA, 0x4C, 0xDA, 0x4F, 
  0xDA, 0x57, 0xDA, 0x5A, 0xDA, 0x5C, 0xDA, 0x5F, 0xDA, 0x61, 0xDA, 0x64, 0xDA, 0x67, 0xDA, 0x6A, 
  0xDA, 0x7A, 0xDA, 0x7C, 0xDA, 0x7F, 0xDA, 0x80, 0x83, 0xDA, 0x80, 0x85, 0xDA, 0x80, 0x88, 0xDA, 
  0x80, 0x8A, 0xDA, 0x80, 0x8D, 0xDA, 0x80, 0x90, 0xDA, 0x80, 0x92, 0xDA, 0x80, 0x95, 0xDA, 0x80, 
  0x98, 0xDA, 0x80, 0x9A, 0xDA, 0x80, 0x9D, 0xDA, 0x80, 0xA2, 0xDA, 0x80, 0xA6, 0xDA, 0x80, 0xA8, 
  0xDA, 0x80, 0xAC, 0xDA, 0x80, 0xAE, 0xDA, 0x80, 0xB2, 0xDA, 0x80, 0xB4, 0xDA, 0x80, 0xB7, 0xDA, 
  0x80, 0xC4, 0xDA, 0x80, 0xC7, 0xDA, 0x80, 0xC9, 0xDA, 0x80, 0xCC, 0xDA, 0x80, 0xCF, 0xDA, 0x80, 
  0xD2, 0xDA, 0x80, 0xDA, 0xDA, 0x80, 0xDD, 0xDA, 0x80, 0xE6, 0xDA, 0x80, 0xEA, 0xDA, 0x80, 0xEC, 
  0xDA, 0x80, 0xEF, 0xDA, 0x80, 0xF4, 0xDA, 0x80, 0xF7, 0xDA, 0x80, 0xF9, 0xDA, 0x80, 0xFC, 0xDA, 
  0x80, 0xFF, 0xDA, 0x81, 0x03, 0xDA, 0x81, 0x05, 0xDA, 0x81, 0x09, 0xDA, 0x81, 0x0B, 0xDA, 0x81, 
  0x0E, 0xDA, 0x81, 0x11, 0xDA, 0x81, 0x15, 0xDA, 0x81, 0x17, 0xDA, 0x81, 0x1A, 0xDA, 0x81, 0x6E, 
  0xDA, 0x81, 0x71, 0xDA, 0x81, 0x73, 0xDA, 0x81, 0x76, 0xDA, 0x81, 0x79, 0xDA, 0x81, 0x7C, 0xDA, 
  0x81, 0x88, 0xDA, 0x81, 0x8B, 0xDA, 0x81, 0x8D, 0xDA, 0x81, 0x90, 0xDA, 0x81, 0x92, 0xDA, 0x81, 
  0x45, 0xDA, 0x81, 0x96, 0xDA, 0x81, 0x99, 0xDA, 0x81, 0x9E, 0xDA, 0x80, 0xBF, 0xDA, 0x81, 0xA1, 
  0xDA, 0x81, 0xA4, 0xDA, 0x81, 0xA6, 0xDA, 0x81, 0xA9, 0xDA, 0x81, 0xAB, 0xDA, 0x81, 0xAE, 0xDA, 
  0x81, 0xB4, 0xDA, 0x81, 0xB7, 0xDA, 0x81, 0xC1, 0xDA, 0x81, 0xC4, 0xDA, 0x81, 0xC6, 0xDA, 0x81, 
  0xC9, 0xDA, 0x81, 0xCB, 0xDA, 0x81, 0xCE, 0xDA, 0x81, 0xD1, 0xDA, 0x81, 0xD4, 0xDA, 0x81, 0xD6, 
  0xDA, 0x81, 0xD9, 0xDA, 0x81, 0xDB, 0xDA, 0x81, 0x82, 0xDA, 0x81, 0xDF, 0xDA, 0x81, 0xE2, 0xDA, 
  0x81, 0xE4, 0xDA, 0x81, 0xE7, 0xDA, 0x81, 0xE9, 0xDA, 0x81, 0xEC, 0xDA, 0x81, 0xEE, 0xDA, 0x81, 
  0xF1, 0xDA, 0x81, 0xF3, 0xDA, 0x81, 0xF6, 0xDA, 0x81, 0xF9, 0xDA, 0x81, 0xFC, 0xDA, 0x81, 0xFE, 
  0xDA, 0x82, 0x00, 0xDA, 0x82, 0x03, 0xDA, 0x82, 0x07, 0xDA, 0x82, 0x09, 0xDA, 0x82, 0x0C, 0xDA, 
  0x82, 0x0E, 0xDA, 0x82, 0x11, 0xDA, 0x82, 0x13, 0xDA, 0x82, 0x17, 0xDA, 0x82, 0x19, 0xDA, 0x82, 
  0x1D, 0xDA, 0x82, 0x1F, 0xDA, 0x82, 0x22, 0xDA, 0x82, 0x29, 0xDA, 0x80, 0xBE, 0xDA, 0x82, 0x2E, 
  0xDA, 0x82, 0x31, 0xDA, 0x82, 0x33, 0xDA, 0x82, 0x36, 0xDA, 0x82, 0x38, 0xDA, 0x82, 0x3B, 0xDA, 
  0x82, 0x5D, 0xDA, 0x82, 0x60, 0xDA, 0x82, 0x63, 0xDA, 0x82, 0x66, 0xDA, 0x82, 0x68, 0xDA, 0x82, 
  0x6B, 0xDA, 0x82, 0x6D, 0xDA, 0x82, 0x70, 0xDA, 0x82, 0x72, 0xDA, 0x82, 0x75, 0xDA, 0x82, 0x78, 
  0xDA, 0x82, 0x7B, 0xDA, 0x82, 0x7D, 0xDA, 0x82, 0x80, 0xDA, 0x82, 0x82, 0xDA, 0x82, 0x85, 0xDA, 
  0x82, 0x87, 0xDA, 0x82, 0x8A, 0xDA, 0x82, 0x8C, 0xDA, 0x82, 0x8F, 0xDA, 0x82, 0x91, 0xDA, 0x82, 
  0x94, 0xDA, 0x82, 0xA5, 0xDA, 0x82, 0xA8, 0xDA, 0x82, 0x9F, 0xDA, 0x82, 0xA3, 0xDA, 0x82, 0xAA, 
  0xDA, 0x82, 0xAD, 0xDA, 0x82, 0xAF, 0xDA, 0x82, 0xB2, 0xDA, 0x82, 0xB9, 0xDA, 0x82, 0xBC, 0xDA, 
  0x82, 0xBE, 0xDA, 0x82, 0xC1, 0xDA, 0x82, 0xC3, 0xDA, 0x82, 0xC6, 0xDA, 0x82, 0xCB, 0xDA, 0x82, 
  0xCE, 0xDA, 0x82, 0xD0, 0xDA, 0x80, 0xE4, 0xDA, 0x82, 0xD4, 0xDA, 0x82, 0xD7, 0xDA, 0x82, 0xE5, 
  0xDA, 0x82, 0xE7, 0xDA, 0x82, 0xEE, 0xDA, 0x82, 0xF1, 0xDA, 0x82, 0xF3, 0xDA, 0x82, 0xF6, 0xDA, 
  0x82, 0xFC, 0xDA, 0x81, 0x36, 0xDA, 0x83, 0x00, 0xDA, 0x83, 0x03, 0xDA, 0x83, 0x05, 0xDA, 0x83, 
  0x08, 0xDA, 0x83, 0x0A, 0xDA, 0x83, 0x0D, 0xDA, 0x83, 0x12, 0xDA, 0x83, 0x14, 0xDA, 0x83, 0x17, 
  0xDA, 0x83, 0x1A, 0xDA, 0x83, 0x20, 0xDA, 0x83, 0x23, 0xDA, 0x83, 0x25, 0xDA, 0x83, 0x28, 0xDA, 
  0x83, 0x2A, 0xDA, 0x83, 0x2D, 0xDA, 0x84, 0x2A, 0xDA, 0x83, 0xA5, 0xDA, 0x84, 0x2E, 0xDA, 0x84, 
  0x31, 0xDA, 0x84, 0x38, 0xDA, 0x84, 0x3B, 0xDA, 0x84, 0x3D, 0xDA, 0x84, 0x40, 0xDA, 0x84, 0x42, 
  0xDA, 0x84, 0x45, 0xDA, 0x84, 0x49, 0xDA, 0x84, 0x4C, 0xDA, 0x84, 0x4E, 0xDA, 0x84, 0x51, 0xDA, 
  0x84, 0x53, 0xDA, 0x84, 0x56, 0xDA, 0x84, 0x58, 0xDA, 0x84, 0x5B, 0xDA, 0x84, 0x5D, 0xDA, 0x82, 
  0x4B, 0xDA, 0x84, 0x61, 0xDA, 0x82, 0xDE, 0xDA, 0x84, 0x6A, 0xDA, 0x84, 0x6D, 0xDA, 0x84, 0x65, 
  0xDA, 0x83, 0xA8, 0xDA, 0x84, 0x72, 0xDA, 0x84, 0x75, 0xDA, 0x84, 0x7B, 0xDA, 0x37, 0xDA, 0x84, 
  0x7F, 0xDA, 0x83, 0xDA, 0xDA, 0x84, 0x83, 0xDA, 0x84, 0x86, 0xDA, 0x84, 0x88, 0xDA, 0x84, 0x8B, 
  0xDA, 0x84, 0x8F, 0xDA, 0x84, 0x92, 0xDA, 0x84, 0x94, 0xDA, 0x81, 0x5C, 0xDA, 0x84, 0x98, 0xDA, 
  0x84, 0x9B, 0xDA, 0x84, 0xA2, 0xDA, 0x84, 0xA5, 0xDA, 0x84, 0xA7, 0xDA, 0x84, 0xAA, 0xDA, 0x84, 
  0xAC, 0xDA, 0x82, 0xDC, 0xDA, 0x84, 0xB0, 0xDA, 0x84, 0xB3, 0xDA, 0x84, 0xB6, 0xDA, 0x84, 0xB9, 
  0xDA, 0x84, 0xBB, 0xDA, 0x84, 0x02, 0xDA, 0x84, 0xBF, 0xDA, 0x82, 0x58, 0xDA, 0x84, 0xC4, 0xDA, 
  0x82, 0x24, 0xDA, 0x84, 0xC8, 0xDA, 0x83, 0xF3, 0xDA, 0x84, 0xCC, 0xDA, 0x84, 0xCF, 0xDA, 0x84, 
  0xD1, 0xDA, 0x84, 0xD4, 0xDA, 0x84, 0xD6, 0xDA, 0x84, 0xD9, 0xDA, 0x84, 0xED, 0xDA, 0x82, 0x55, 
  0xDA, 0x84, 0xF1, 0xDA, 0x84, 0xE8, 0xDA, 0x84, 0xF5, 0xDA, 0x84, 0xF8, 0xDA, 0x84, 0xFB, 0xDA, 
  0x84, 0xFE, 0xDA, 0x85, 0x00, 0xDA, 0x85, 0x03, 0xDA, 0x85, 0x05, 0xDA, 0x85, 0x08, 0xDA, 0x85, 
  0x0B, 0xDA, 0x81, 0x57, 0xDA, 0x85, 0x0F, 0xDA, 0x81, 0xBD, 0xDA, 0x85, 0x13, 0xDA, 0x85, 0x16, 
  0xDA, 0x85, 0x18, 0xDA, 0x85, 0x1B, 0xDA, 0x85, 0x1D, 0xDA, 0x85, 0x1F, 0xDA, 0x85, 0x22, 0xDA, 
  0x85, 0x25, 0xCF, 0x09, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3C, 0x3D, 0xD7, 0x00, 0xCD, 
  0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xCE, 0x09, 
  0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3C, 0x3D, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x09, 
  0x00, 0x17, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x02, 0x3C, 0x3D, 
  0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 
  0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x46, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 
  0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 
  0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 
  0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x20, 0xCE, 0x0E, 0x63, 
  0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x2D, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0xDA, 0x18, 0xDA, 
  0x82, 0xF8, 0xDA, 0x73, 0x2C, 0x02, 0x00, 0x00, 0x27, 0x03, 0x00, 0x00, 0x29, 0x04, 0x00, 0x00, 
  0x3D, 0x05, 0x01, 0x00, 0x05, 0x06, 0x05, 0xFF, 0x19, 0x05, 0x06, 0x00, 0x21, 0x06, 0x04, 0x05, 
  0x1C, 0x06, 0x18, 0x00, 0x19, 0x07, 0x04, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x08, 0x01, 0x00, 
  0x05, 0x09, 0x07, 0x01, 0x2F, 0x09, 0x00, 0x00, 0x33, 0x0A, 0x01, 0x00, 0x30, 0x08, 0x0A, 0x00, 
  0x2A, 0x0B, 0x00, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x19, 0x08, 0x09, 0x00, 0x29, 0x09, 0x00, 0x00, 
  0x30, 0x08, 0x09, 0x00, 0x33, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x2F, 0x0A, 0x00, 0x00, 
  0x2A, 0x0B, 0x01, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x1C, 0x09, 0x04, 0x00, 0x28, 0x03, 0x00, 0x00, 
  0x1A, 0x04, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x05, 0x04, 0x04, 0x01, 0x1A, 0xE8, 0xFF, 0xFF, 
  0x03, 0x03, 0x00, 0x00, 0x82, 0xFF, 0x01, 0x01, 0x03, 0x01, 0x03, 0x00, 0x19, 0x00, 0x16, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x1B, 0x00, 0x1B, 0x00, 0x26, 0x00, 0x22, 0x00, 
  0x22, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFF, 0x03, 0x02, 0x13, 0x00, 0x13, 0x00, 0x13, 
  0xBF, 0xFE, 0x03, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFD, 0x03, 0x04, 0x05, 0x01, 0x05, 
  0xBF, 0xFB, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFE, 0x01, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 
  0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x83, 0x13, 
  0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 
  0x6F, 0x70, 0x65, 0x6E, 0xDA, 0x83, 0x50, 0xCF, 0x0E, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0xD8, 0x0E, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0xCF, 0x0C, 0x2A, 0x6C, 0x69, 0x6E, 0x74, 0x2D, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x2A, 0xDA, 0x84, 0x1B, 0xCF, 0x08, 0x77, 0x68, 0x65, 0x6E, 0x2D, 0x6C, 
  0x65, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x02, 0x09, 0xCE, 0x08, 0x77, 0x68, 0x65, 0x6E, 0x2D, 0x6C, 0x65, 0x74, 0xDA, 0x18, 0xDA, 
  0x4A, 0xDA, 0x67, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x32, 
  0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 
  0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x82, 0xB1, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x3F, 0xDA, 0x85, 0x63, 0xCF, 0x09, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x6E, 
  0x61, 0x6D, 0x65, 0xD8, 0x09, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x6E, 0x61, 0x6D, 0x65, 0xCF, 0x05, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0xDA, 0x47, 0xCF, 0x06, 0x69, 0x66, 0x2D, 0x6E, 0x6F, 0x74, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x03, 0x02, 0x03, 0x01, 0x06, 0xCE, 0x06, 0x69, 0x66, 
  0x2D, 0x6E, 0x6F, 0x74, 0xDA, 0x18, 0xDA, 0x49, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 
  0x31, 0x05, 0x00, 0x02, 0x2F, 0x01, 0x00, 0x00, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 
  0x80, 0xB7, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x05, 0x78, 
  0x70, 0x72, 0x69, 0x6E, 0xD8, 0x05, 0x78, 0x70, 0x72, 0x69, 0x6E, 0xCF, 0x0B, 0x6F, 0x73, 0x2F, 
  0x72, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0xD8, 0x0B, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x61, 
  0x64, 0x6C, 0x69, 0x6E, 0x6B, 0xCF, 0x0A, 0x65, 0x76, 0x2F, 0x72, 0x73, 0x65, 0x6C, 0x65, 0x63, 
  0x74, 0xD8, 0x0A, 0x65, 0x76, 0x2F, 0x72, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0xCF, 0x08, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 0x73, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 
  0x73, 0xCF, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x74, 0x65, 0x6D, 0x70, 0xD8, 0x09, 0x66, 0x69, 
  0x6C, 0x65, 0x2F, 0x74, 0x65, 0x6D, 0x70, 0xCF, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 
  0x66, 0x69, 0x6C, 0x6C, 0xD8, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x69, 0x6C, 
  0x6C, 0xCF, 0x0A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xD8, 0x0A, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xCF, 0x09, 0x64, 0x65, 0x65, 0x70, 0x2D, 
  0x6E, 0x6F, 0x74, 0x3D, 0xDA, 0x82, 0x96, 0xCF, 0x0F, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x65, 
  0x65, 0x64, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0xD8, 0x0F, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 
  0x65, 0x65, 0x64, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0xCF, 0x0A, 0x74, 0x61, 0x6B, 0x65, 0x2D, 
  0x75, 0x6E, 0x74, 0x69, 0x6C, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 
  0x06, 0x14, 0xCE, 0x0A, 0x74, 0x61, 0x6B, 0x65, 0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0xDA, 0x18, 
  0xDA, 0x1A, 0xDA, 0x81, 0x36, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x03, 0x03, 0x03, 
  0x02, 0x12, 0xCE, 0x0B, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0xDA, 
  0x18, 0xDA, 0x82, 0x24, 0xDA, 0x82, 0x26, 0x2C, 0x03, 0x00, 0x00, 0x3D, 0x04, 0x02, 0x00, 0x19, 
  0x05, 0x04, 0x00, 0x30, 0x01, 0x02, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 
  0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x1C, 
  0x09, 0x03, 0x00, 0x19, 0x08, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x08, 0x07, 0x00, 0x19, 
  0x09, 0x08, 0x00, 0x29, 0x0A, 0x00, 0x00, 0x31, 0x02, 0x0A, 0x09, 0x34, 0x00, 0x00, 0x00, 0x84, 
  0x5C, 0x01, 0x02, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x10, 
  0x00, 0x10, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xDA, 0x84, 0x0A, 0xDA, 0x80, 0xE4, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x09, 0x02, 0x02, 0x02, 0x01, 0x14, 0xCE, 0x13, 0x74, 0x61, 0x6B, 0x65, 0x2D, 0x75, 0x6E, 
  0x74, 0x69, 0x6C, 0x2D, 0x66, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0xDA, 0x18, 0xDA, 0x81, 
  0x4C, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 
  0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 0x0D, 0x00, 0x38, 0x05, 0x01, 
  0x06, 0x19, 0x07, 0x05, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x05, 0x00, 0x00, 0x1C, 0x05, 0x03, 
  0x00, 0x1A, 0x07, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x30, 0x04, 0x07, 0x00, 0x2A, 0x08, 0x00, 
  0x00, 0x33, 0x05, 0x08, 0x00, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xF4, 0xFF, 0xFF, 0x03, 0x04, 0x00, 
  0x00, 0x84, 0x44, 0x01, 0x02, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x12, 0x00, 0x05, 0x01, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0xBF, 0xFD, 0x01, 0x2C, 0x02, 0x00, 0x00, 
  0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x05, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x31, 0x04, 0x00, 0x01, 0x2A, 0x04, 0x02, 0x00, 0x34, 0x04, 0x00, 0x00, 
  0x2F, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x05, 0x00, 
  0x2A, 0x05, 0x04, 0x00, 0x31, 0x05, 0x00, 0x01, 0x2A, 0x05, 0x02, 0x00, 0x34, 0x05, 0x00, 0x00, 
  0x30, 0x00, 0x01, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x34, 0x05, 0x00, 0x00, 0x84, 0x63, 0x01, 0x04, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x02, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x09, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 
  0x3E, 0x3D, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x02, 0x05, 0xCE, 0x09, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3E, 0x3D, 0xDA, 0x18, 
  0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x16, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 
  0x10, 0xCE, 0x02, 0x3E, 0x3D, 0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 0x02, 0x1B, 0x02, 0x0A, 
  0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x45, 0x02, 0x03, 
  0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 0x00, 0x23, 0x02, 0x05, 
  0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x28, 0x03, 0x00, 
  0x00, 0x03, 0x03, 0x00, 0x00, 0xDA, 0x85, 0x83, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 
  0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x83, 0x1D, 0x01, 0x03, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0xD8, 
  0x06, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0xCF, 0x02, 0x3C, 0x3D, 0xDA, 0x85, 0x81, 0xCF, 0x10, 
  0x65, 0x76, 0x2F, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2D, 0x72, 0x6C, 0x6F, 0x63, 0x6B, 
  0xD8, 0x10, 0x65, 0x76, 0x2F, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2D, 0x72, 0x6C, 0x6F, 
  0x63, 0x6B, 0xCF, 0x0E, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x6C, 0x6F, 0x61, 0x64, 0x65, 
  0x72, 0x73, 0xDA, 0x85, 0x78, 0xCF, 0x09, 0x65, 0x76, 0x2F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 
  0xD8, 0x09, 0x65, 0x76, 0x2F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0xCF, 0x11, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2F, 0x63, 0x61, 0x6E, 0x2D, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x3F, 0xDA, 0x84, 
  0x11, 0xCF, 0x0B, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0xDA, 0x83, 
  0xDF, 0xCF, 0x0B, 0x66, 0x66, 0x69, 0x2F, 0x64, 0x65, 0x66, 0x62, 0x69, 0x6E, 0x64, 0xD7, 0x01, 
  0xCD, 0x02, 0xFB, 0x00, 0x00, 0x20, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x0D, 0x64, 0x01, 
  0x04, 0xCE, 0x0B, 0x66, 0x66, 0x69, 0x2F, 0x64, 0x65, 0x66, 0x62, 0x69, 0x6E, 0x64, 0xDA, 0x18, 
  0xDA, 0x82, 0xE0, 0xD8, 0x05, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x81, 0x65, 0xDA, 0x84, 0x6D, 
  0xDA, 0x82, 0x48, 0xDA, 0x81, 0x1D, 0xCE, 0x14, 0x6E, 0x6F, 0x20, 0x66, 0x66, 0x69, 0x20, 0x63, 
  0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0xD0, 0x04, 0x6C, 0x61, 
  0x7A, 0x79, 0xD0, 0x0B, 0x6D, 0x61, 0x70, 0x2D, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0xD0, 
  0x0B, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x6C, 0x61, 0x7A, 0x79, 0xDA, 0x85, 0x3E, 0xD8, 
  0x08, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x61, 0x6C, 0x6C, 0xDA, 0x81, 0xB4, 0x2C, 0x03, 0x00, 0x00, 
  0x2F, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 
  0x29, 0x06, 0x00, 0x00, 0x29, 0x07, 0xFE, 0xFF, 0x31, 0x02, 0x06, 0x07, 0x2A, 0x07, 0x01, 0x00, 
  0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x09, 0x02, 0x00, 
  0x33, 0x08, 0x09, 0x00, 0x29, 0x09, 0x02, 0x00, 0x30, 0x09, 0x08, 0x00, 0x2A, 0x0A, 0x03, 0x00, 
  0x33, 0x09, 0x0A, 0x00, 0x19, 0x08, 0x09, 0x00, 0x29, 0x0A, 0x00, 0x00, 0x30, 0x0A, 0x08, 0x00, 
  0x2A, 0x0B, 0x04, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x29, 0x0C, 0x01, 0x00, 
  0x30, 0x0C, 0x08, 0x00, 0x2A, 0x0D, 0x04, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x19, 0x0D, 0x0C, 0x00, 
  0x32, 0x0D, 0x00, 0x00, 0x44, 0x0E, 0x00, 0x00, 0x2F, 0x0E, 0x00, 0x00, 0x2A, 0x10, 0x00, 0x00, 
  0x33, 0x0F, 0x10, 0x00, 0x19, 0x0E, 0x0F, 0x00, 0x2B, 0x10, 0x00, 0x00, 0x2F, 0x10, 0x00, 0x00, 
  0x2A, 0x11, 0x05, 0x00, 0x33, 0x10, 0x11, 0x00, 0x19, 0x11, 0x10, 0x00, 0x1C, 0x11, 0x03, 0x00, 
  0x19, 0x10, 0x11, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x12, 0x06, 0x00, 0x01, 0x12, 0x00, 0x00, 
  0x26, 0x10, 0x00, 0x00, 0x2A, 0x12, 0x07, 0x00, 0x38, 0x11, 0x10, 0x12, 0x19, 0x12, 0x11, 0x00, 
  0x2A, 0x13, 0x08, 0x00, 0x38, 0x11, 0x10, 0x13, 0x19, 0x13, 0x11, 0x00, 0x2A, 0x14, 0x09, 0x00, 
  0x38, 0x11, 0x10, 0x14, 0x19, 0x14, 0x11, 0x00, 0x2A, 0x15, 0x0A, 0x00, 0x38, 0x11, 0x10, 0x15, 
  0x19, 0x15, 0x11, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x33, 0x11, 0x13, 0x00, 0x19, 0x16, 0x11, 0x00, 
  0x2E, 0x17, 0x00, 0x00, 0x19, 0x18, 0x17, 0x00, 0x2E, 0x19, 0x01, 0x00, 0x19, 0x1A, 0x19, 0x00, 
  0x1C, 0x12, 0x15, 0x00, 0x32, 0x0B, 0x00, 0x00, 0x44, 0x1B, 0x00, 0x00, 0x2E, 0x1C, 0x02, 0x00, 
  0x33, 0x1D, 0x1C, 0x00, 0x2F, 0x1D, 0x00, 0x00, 0x43, 0x1C, 0x00, 0x00, 0x2E, 0x1D, 0x03, 0x00, 
  0x33, 0x1E, 0x1D, 0x00, 0x2F, 0x1E, 0x00, 0x00, 0x43, 0x1D, 0x00, 0x00, 0x2A, 0x1F, 0x0B, 0x00, 
  0x31, 0x1F, 0x1C, 0x1D, 0x32, 0x0B, 0x00, 0x00, 0x43, 0x1E, 0x00, 0x00, 0x2A, 0x1D, 0x0C, 0x00, 
  0x30, 0x1D, 0x00, 0x00, 0x32, 0x07, 0x00, 0x00, 0x30, 0x1B, 0x1E, 0x00, 0x43, 0x1C, 0x00, 0x00, 
  0x03, 0x1C, 0x00, 0x00, 0x32, 0x0B, 0x00, 0x00, 0x44, 0x1B, 0x00, 0x00, 0x33, 0x1C, 0x1A, 0x00, 
  0x33, 0x1D, 0x18, 0x00, 0x2A, 0x1F, 0x0B, 0x00, 0x31, 0x1F, 0x1C, 0x1D, 0x32, 0x0B, 0x00, 0x00, 
  0x43, 0x1E, 0x00, 0x00, 0x2A, 0x1D, 0x0C, 0x00, 0x30, 0x1D, 0x00, 0x00, 0x32, 0x07, 0x00, 0x00, 
  0x30, 0x1B, 0x1E, 0x00, 0x43, 0x1C, 0x00, 0x00, 0x03, 0x1C, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 
  0xD8, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x08, 0x01, 0xCE, 0x08, 0x6D, 0x61, 0x6B, 0x65, 
  0x2D, 0x73, 0x69, 0x67, 0xDA, 0x18, 0xD0, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0xDA, 
  0x5A, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x05, 0x30, 0x01, 0x02, 
  0x00, 0x2B, 0x01, 0x00, 0x0E, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x01, 0x01, 0x00, 0x34, 0x01, 0x00, 
  0x00, 0xBF, 0xFF, 0x8E, 0x5D, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x16, 0x01, 
  0xCE, 0x08, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x70, 0x74, 0x72, 0xDA, 0x18, 0xDA, 0x82, 0xAD, 0xCE, 
  0x1A, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 
  0x66, 0x66, 0x69, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0xDA, 0x81, 0x38, 0x2C, 0x00, 
  0x00, 0x00, 0x2B, 0x02, 0x00, 0x12, 0x1C, 0x02, 0x05, 0x00, 0x2B, 0x03, 0x00, 0x14, 0x33, 0x02, 
  0x03, 0x00, 0x19, 0x01, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x15, 0x2B, 0x02, 
  0x00, 0x16, 0x30, 0x01, 0x02, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x01, 
  0x02, 0x00, 0x1C, 0x01, 0x02, 0x00, 0x03, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x2B, 0x03, 
  0x00, 0x16, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x33, 0x02, 0x03, 0x00, 0x01, 0x02, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8E, 0x5F, 0x05, 0x01, 0x1B, 0x00, 0x1B, 0x00, 
  0x24, 0x00, 0x24, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 
  0x3C, 0x00, 0x07, 0x00, 0x07, 0xCD, 0x02, 0xF2, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x04, 
  0x01, 0x01, 0xDA, 0x18, 0x26, 0x00, 0x00, 0x00, 0x26, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 
  0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
  0x0B, 0x02, 0xDA, 0x18, 0x2B, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x03, 0x00, 0x2B, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x01, 0x2B, 0x01, 0x01, 0x1A, 
  0x33, 0x00, 0x01, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
  0xBF, 0xFF, 0x00, 0x8E, 0x63, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 
  0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x19, 0x00, 0x19, 0x8E, 0x63, 0x19, 0x00, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x03, 0x00, 0x00, 0x00, 0xCD, 0x02, 0xF2, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
  0x00, 0x04, 0x01, 0x01, 0xDA, 0x18, 0x26, 0x00, 0x00, 0x00, 0x26, 0x01, 0x00, 0x00, 0x2E, 0x02, 
  0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x00, 0x00, 
  0x00, 0x00, 0x0B, 0x02, 0xDA, 0x18, 0x2B, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x03, 0x00, 0x2B, 0x00, 
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x01, 0x2B, 0x01, 
  0x01, 0x18, 0x33, 0x00, 0x01, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x03, 0x00, 
  0x00, 0x00, 0xBF, 0xFF, 0x00, 0x8E, 0x63, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 
  0x00, 0x2F, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x2F, 0x00, 0x2F, 0x8E, 0x63, 0x2F, 0x00, 
  0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x00, 0x8E, 0x4F, 0x03, 0x03, 0x18, 0x00, 0x18, 
  0x00, 0x18, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 
  0x01, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x05, 
  0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x05, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x05, 0x01, 0x23, 0x00, 0x23, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x05, 
  0x04, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 
  0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 
  0x15, 0x00, 0x15, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x02, 0x05, 0x00, 0x05, 0x02, 0x05, 0x01, 
  0x09, 0x00, 0x09, 0x01, 0x19, 0x00, 0x19, 0xBF, 0xFF, 0x09, 0x00, 0x09, 0x01, 0x2F, 0x00, 0x2F, 
  0xBF, 0xFF, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x09, 0x00, 0x09, 0x01, 0x18, 0x00, 
  0x24, 0xBF, 0xFF, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x20, 0x40, 0x74, 0x05, 0x00, 0x06, 0xD0, 0x0B, 0x66, 0x66, 
  0x69, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0xC9, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x06, 0xCE, 0x0E, 0x64, 0x65, 0x66, 
  0x61, 0x75, 0x6C, 0x74, 0x2D, 0x6D, 0x61, 0x6E, 0x67, 0x6C, 0x65, 0xDA, 0x18, 0xDA, 0x80, 0xA0, 
  0xDA, 0x81, 0x31, 0xDA, 0x81, 0x52, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x2A, 0x03, 
  0x01, 0x00, 0x31, 0x02, 0x03, 0x00, 0x2A, 0x02, 0x02, 0x00, 0x34, 0x02, 0x00, 0x00, 0x8E, 0x3D, 
  0x03, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xC9, 0xC9, 0xC9, 0xCF, 0x0C, 
  0x6E, 0x65, 0x74, 0x2F, 0x73, 0x68, 0x75, 0x74, 0x64, 0x6F, 0x77, 0x6E, 0xD8, 0x0C, 0x6E, 0x65, 
  0x74, 0x2F, 0x73, 0x68, 0x75, 0x74, 0x64, 0x6F, 0x77, 0x6E, 0xCF, 0x07, 0x63, 0x6F, 0x6D, 0x6D, 
  0x65, 0x6E, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x00, 0x02, 0xCE, 0x07, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0xDA, 0x18, 0x2C, 
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0xB3, 0x01, 0x00, 0x01, 0xCF, 0x06, 0x74, 0x61, 
  0x62, 0x73, 0x65, 0x71, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0A, 0x02, 0x02, 0xCD, 0x7F, 
  0xFF, 0xFF, 0xFF, 0x05, 0x18, 0xCE, 0x06, 0x74, 0x61, 0x62, 0x73, 0x65, 0x71, 0xDA, 0x18, 0xDA, 
  0x43, 0xDA, 0x44, 0xDA, 0x4A, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x07, 0x03, 0x03, 0x03, 0x03, 
  0x00, 0x02, 0xCE, 0x03, 0x70, 0x75, 0x74, 0x3A, 0x00, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0xDA, 
  0x84, 0x8D, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 
  0x04, 0x00, 0x42, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x31, 0x08, 0x05, 0x06, 0x43, 0x07, 
  0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x32, 0x02, 0x00, 0x00, 0x43, 0x06, 
  0x00, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x31, 0x09, 0x05, 0x01, 0x2F, 0x06, 0x00, 0x00, 0x43, 0x08, 
  0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x09, 0x00, 0x08, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x09, 
  0x02, 0x00, 0x31, 0x09, 0x07, 0x06, 0x2F, 0x05, 0x00, 0x00, 0x43, 0x08, 0x00, 0x00, 0x03, 0x08, 
  0x00, 0x00, 0x82, 0x68, 0x01, 0x04, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0xCF, 0x0C, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x66, 0x62, 0x72, 0x65, 0x61, 
  0x6B, 0xDA, 0x83, 0x65, 0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 
  0x2D, 0x73, 0x75, 0x66, 0x66, 0x69, 0x78, 0x3F, 0xDA, 0x85, 0x62, 0xCF, 0x09, 0x77, 0x69, 0x74, 
  0x68, 0x2D, 0x76, 0x61, 0x72, 0x73, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x16, 0x01, 0x01, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x10, 0x80, 0x8A, 0xCE, 0x09, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x76, 
  0x61, 0x72, 0x73, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 
  0x01, 0x0A, 0xCE, 0x05, 0x65, 0x76, 0x65, 0x6E, 0x3F, 0xDA, 0x18, 0xDA, 0x82, 0xF8, 0x2C, 0x01, 
  0x00, 0x00, 0x29, 0x03, 0x02, 0x00, 0x0C, 0x02, 0x00, 0x03, 0x29, 0x03, 0x00, 0x00, 0x30, 0x03, 
  0x02, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x29, 0x04, 0x00, 0x00, 0x23, 0x02, 
  0x04, 0x03, 0x03, 0x02, 0x00, 0x00, 0x83, 0x26, 0x01, 0x00, 0x37, 0x00, 0x37, 0x00, 0x2C, 0x00, 
  0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0xCE, 0x28, 0x65, 0x78, 0x70, 
  0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 
  0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 
  0x20, 0x76, 0x61, 0x72, 0x73, 0xDA, 0x43, 0xDA, 0x81, 0x4C, 0xDA, 0x44, 0xDA, 0x29, 0xDA, 0x80, 
  0xB9, 0xDA, 0x80, 0xBA, 0xDA, 0x80, 0xD4, 0xDA, 0x80, 0xBC, 0xDA, 0x80, 0xBE, 0xDA, 0x80, 0xD5, 
  0xDA, 0x80, 0xD6, 0xDA, 0x80, 0xD7, 0xDA, 0x49, 0xDA, 0x4A, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 
  0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 
  0x06, 0x00, 0x1C, 0x05, 0x02, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x01, 0x06, 
  0x00, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x29, 0x05, 0x00, 0x00, 0x19, 0x07, 
  0x04, 0x00, 0x21, 0x08, 0x05, 0x07, 0x1C, 0x08, 0x09, 0x00, 0x19, 0x09, 0x05, 0x00, 0x2A, 0x0B, 
  0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x30, 0x06, 0x0A, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x33, 0x0B, 
  0x0C, 0x00, 0x05, 0x05, 0x05, 0x02, 0x1A, 0xF7, 0xFF, 0xFF, 0x19, 0x05, 0x06, 0x00, 0x3E, 0x07, 
  0x00, 0x00, 0x19, 0x08, 0x07, 0x00, 0x29, 0x07, 0x00, 0x00, 0x19, 0x09, 0x04, 0x00, 0x21, 0x0A, 
  0x07, 0x09, 0x1C, 0x0A, 0x0F, 0x00, 0x19, 0x0B, 0x07, 0x00, 0x0A, 0x0C, 0x0B, 0x02, 0x2F, 0x0C, 
  0x00, 0x00, 0x33, 0x0D, 0x05, 0x00, 0x2F, 0x0B, 0x00, 0x00, 0x33, 0x0C, 0x00, 0x00, 0x2A, 0x0E, 
  0x04, 0x00, 0x31, 0x0E, 0x0D, 0x0C, 0x43, 0x0C, 0x00, 0x00, 0x30, 0x08, 0x0C, 0x00, 0x2A, 0x0E, 
  0x03, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x05, 0x07, 0x07, 0x02, 0x1A, 0xF1, 0xFF, 0xFF, 0x19, 0x07, 
  0x08, 0x00, 0x3E, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x29, 0x09, 0x00, 0x00, 0x19, 0x0B, 
  0x04, 0x00, 0x21, 0x0C, 0x09, 0x0B, 0x1C, 0x0C, 0x0F, 0x00, 0x19, 0x0D, 0x09, 0x00, 0x2F, 0x0D, 
  0x00, 0x00, 0x33, 0x0E, 0x00, 0x00, 0x05, 0x0F, 0x0D, 0x01, 0x2F, 0x0F, 0x00, 0x00, 0x33, 0x10, 
  0x00, 0x00, 0x2A, 0x0F, 0x05, 0x00, 0x31, 0x0F, 0x0E, 0x10, 0x43, 0x0E, 0x00, 0x00, 0x30, 0x0A, 
  0x0E, 0x00, 0x2A, 0x10, 0x03, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x05, 0x09, 0x09, 0x02, 0x1A, 0xF1, 
  0xFF, 0xFF, 0x19, 0x09, 0x0A, 0x00, 0x3E, 0x0B, 0x00, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x29, 0x0B, 
  0x00, 0x00, 0x19, 0x0D, 0x04, 0x00, 0x21, 0x0E, 0x0B, 0x0D, 0x1C, 0x0E, 0x0F, 0x00, 0x19, 0x0F, 
  0x0B, 0x00, 0x2F, 0x0F, 0x00, 0x00, 0x33, 0x10, 0x00, 0x00, 0x0A, 0x11, 0x0F, 0x02, 0x2F, 0x11, 
  0x00, 0x00, 0x33, 0x12, 0x05, 0x00, 0x2A, 0x11, 0x05, 0x00, 0x31, 0x11, 0x10, 0x12, 0x43, 0x10, 
  0x00, 0x00, 0x30, 0x0C, 0x10, 0x00, 0x2A, 0x12, 0x03, 0x00, 0x33, 0x11, 0x12, 0x00, 0x05, 0x0B, 
  0x0B, 0x02, 0x1A, 0xF1, 0xFF, 0xFF, 0x19, 0x0B, 0x0C, 0x00, 0x2A, 0x0E, 0x02, 0x00, 0x33, 0x0D, 
  0x0E, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x2A, 0x0F, 0x02, 0x00, 0x33, 0x0D, 0x0F, 0x00, 0x19, 0x0F, 
  0x0D, 0x00, 0x2A, 0x10, 0x02, 0x00, 0x33, 0x0D, 0x10, 0x00, 0x19, 0x10, 0x0D, 0x00, 0x44, 0x0D, 
  0x00, 0x00, 0x2A, 0x12, 0x06, 0x00, 0x30, 0x12, 0x0D, 0x00, 0x32, 0x09, 0x00, 0x00, 0x32, 0x01, 
  0x00, 0x00, 0x43, 0x11, 0x00, 0x00, 0x2A, 0x12, 0x07, 0x00, 0x2A, 0x13, 0x08, 0x00, 0x31, 0x12, 
  0x11, 0x13, 0x43, 0x0D, 0x00, 0x00, 0x2A, 0x12, 0x04, 0x00, 0x31, 0x12, 0x0F, 0x0D, 0x43, 0x11, 
  0x00, 0x00, 0x2A, 0x12, 0x09, 0x00, 0x30, 0x12, 0x0F, 0x00, 0x43, 0x0D, 0x00, 0x00, 0x2A, 0x13, 
  0x04, 0x00, 0x31, 0x13, 0x0E, 0x0D, 0x43, 0x12, 0x00, 0x00, 0x2A, 0x13, 0x0A, 0x00, 0x30, 0x13, 
  0x0F, 0x00, 0x43, 0x0D, 0x00, 0x00, 0x2A, 0x14, 0x0B, 0x00, 0x2A, 0x15, 0x0C, 0x00, 0x31, 0x14, 
  0x0D, 0x15, 0x43, 0x13, 0x00, 0x00, 0x2A, 0x14, 0x0D, 0x00, 0x31, 0x14, 0x0E, 0x0F, 0x43, 0x0D, 
  0x00, 0x00, 0x2A, 0x15, 0x0E, 0x00, 0x31, 0x15, 0x13, 0x0E, 0x2F, 0x0D, 0x00, 0x00, 0x43, 0x14, 
  0x00, 0x00, 0x2A, 0x13, 0x0F, 0x00, 0x2F, 0x13, 0x00, 0x00, 0x32, 0x07, 0x00, 0x00, 0x30, 0x11, 
  0x12, 0x00, 0x32, 0x0B, 0x00, 0x00, 0x2F, 0x14, 0x00, 0x00, 0x43, 0x0D, 0x00, 0x00, 0x03, 0x0D, 
  0x00, 0x00, 0x85, 0x59, 0x01, 0x04, 0x0C, 0x00, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x17, 0x00, 0x17, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x27, 0x00, 0x27, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x03, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x36, 0x00, 0x30, 0x00, 0x30, 0x00, 0x3F, 0x00, 0x3F, 0x00, 0x2A, 0x00, 
  0x2A, 0x00, 0x2A, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x2F, 0x00, 
  0x2F, 0x00, 0x3E, 0x00, 0x38, 0x00, 0x38, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x33, 0x00, 0x33, 0x00, 0x42, 0x00, 0x3C, 0x00, 
  0x3C, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x0A, 0x74, 0x61, 0x6B, 0x65, 0x2D, 0x77, 0x68, 
  0x69, 0x6C, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 0x07, 
  0xCE, 0x0A, 0x74, 0x61, 0x6B, 0x65, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xDA, 0x18, 0xDA, 0x83, 
  0x0F, 0xDA, 0x85, 0xA5, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x33, 0x03, 0x04, 0x00, 0x30, 0x03, 0x01, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 
  0x84, 0x6B, 0x01, 0x04, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 
  0x05, 0x6D, 0x61, 0x74, 0x63, 0x68, 0xD7, 0x00, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x2D, 0x01, 0x01, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x18, 0x81, 0x16, 0x06, 0xCE, 0x05, 0x6D, 0x61, 0x74, 0x63, 0x68, 
  0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x01, 0x0A, 0xDA, 
  0x6E, 0xDA, 0x18, 0xDA, 0x82, 0xF8, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x02, 0x00, 0x0C, 0x02, 
  0x00, 0x03, 0x29, 0x03, 0x01, 0x00, 0x30, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x29, 0x04, 0x00, 0x00, 0x23, 0x02, 0x04, 0x03, 0x03, 0x02, 0x00, 0x00, 0x83, 0x27, 
  0x01, 0x00, 0x35, 0x00, 0x35, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x25, 0x00, 
  0x25, 0x00, 0x25, 0xDA, 0x81, 0x65, 0xDA, 0x85, 0xBD, 0xDA, 0x84, 0x6D, 0xDA, 0x71, 0xDA, 0x43, 
  0xDA, 0x44, 0xDA, 0x81, 0x4C, 0xD2, 0x02, 0x00, 0xC9, 0xC9, 0xCF, 0x03, 0x61, 0x6E, 0x64, 0xDA, 
  0x83, 0x1D, 0xDA, 0x78, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x01, 0x02, 0x02, 
  0x0C, 0xCE, 0x04, 0x73, 0x6F, 0x72, 0x74, 0xDA, 0x18, 0xDA, 0x81, 0x47, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x02, 0x34, 0xCE, 0x09, 0x73, 0x6F, 0x72, 0x74, 0x2D, 
  0x68, 0x65, 0x6C, 0x70, 0xDA, 0x18, 0xDA, 0x82, 0x0C, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x08, 0x03, 0x03, 0x03, 0x00, 0x0C, 0xCE, 0x0F, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x6E, 0x2D, 0x6F, 
  0x66, 0x2D, 0x74, 0x68, 0x72, 0x65, 0x65, 0xDA, 0x18, 0x2C, 0x03, 0x00, 0x00, 0x1F, 0x04, 0x00, 
  0x01, 0x1F, 0x05, 0x00, 0x02, 0x48, 0x06, 0x04, 0x05, 0x1C, 0x06, 0x02, 0x00, 0x03, 0x00, 0x00, 
  0x00, 0x1F, 0x04, 0x01, 0x00, 0x1F, 0x05, 0x01, 0x02, 0x48, 0x07, 0x04, 0x05, 0x1C, 0x07, 0x02, 
  0x00, 0x03, 0x01, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x83, 0x2F, 0x01, 0x01, 0x0D, 0x00, 0x15, 
  0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x02, 0x0F, 0x00, 0x17, 0x00, 0x09, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x2C, 0x04, 0x00, 0x00, 0x21, 0x05, 0x01, 0x02, 0x1C, 0x05, 0x31, 0x00, 0x38, 0x06, 
  0x00, 0x02, 0x38, 0x07, 0x00, 0x01, 0x06, 0x08, 0x01, 0x02, 0x0A, 0x09, 0x08, 0x02, 0x2F, 0x09, 
  0x00, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x38, 0x09, 0x00, 0x08, 0x31, 0x06, 
  0x07, 0x09, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x19, 0x06, 0x08, 0x00, 0x19, 0x07, 
  0x01, 0x00, 0x19, 0x08, 0x02, 0x00, 0x38, 0x09, 0x00, 0x07, 0x30, 0x09, 0x06, 0x00, 0x33, 0x0A, 
  0x03, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x05, 0x07, 0x07, 0x01, 0x1A, 0xFB, 0xFF, 0xFF, 0x38, 0x09, 
  0x00, 0x08, 0x30, 0x06, 0x09, 0x00, 0x33, 0x0A, 0x03, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x05, 0x08, 
  0x08, 0xFF, 0x1A, 0xFB, 0xFF, 0xFF, 0x46, 0x09, 0x07, 0x08, 0x1C, 0x09, 0x09, 0x00, 0x38, 0x0A, 
  0x00, 0x07, 0x19, 0x0B, 0x0A, 0x00, 0x38, 0x0A, 0x00, 0x08, 0x3A, 0x00, 0x07, 0x0A, 0x3A, 0x00, 
  0x08, 0x0B, 0x05, 0x07, 0x07, 0x01, 0x05, 0x08, 0x08, 0xFF, 0x1A, 0x01, 0x00, 0x00, 0x45, 0x09, 
  0x07, 0x08, 0x1C, 0x09, 0x03, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xE6, 
  0xFF, 0xFF, 0x31, 0x00, 0x01, 0x08, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x09, 0x04, 0x00, 0x31, 0x00, 
  0x07, 0x02, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x09, 0x04, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x03, 0x00, 
  0x00, 0x00, 0x83, 0x34, 0x01, 0x01, 0x09, 0x00, 0x03, 0x02, 0x18, 0x00, 0x22, 0x01, 0x2D, 0x00, 
  0x2A, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x18, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0xBF, 0xFF, 0x05, 0x03, 0x05, 0x01, 0x05, 0x02, 0x17, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x00, 
  0x2A, 0x00, 0x07, 0x01, 0x1D, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x2B, 0x00, 0x07, 0x01, 
  0x0D, 0x00, 0x07, 0x01, 0x12, 0x00, 0x09, 0x01, 0x17, 0x00, 0x09, 0x01, 0x09, 0x01, 0x09, 0x01, 
  0x09, 0xBF, 0xFB, 0x07, 0x06, 0x0B, 0x00, 0x07, 0x00, 0x1B, 0x00, 0x07, 0xBF, 0xF7, 0x05, 0x0A, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xEF, 0x03, 0xBF, 0xFF, 
  0x01, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x05, 0x04, 0x03, 0xFF, 0x1C, 0x01, 0x03, 
  0x00, 0x19, 0x03, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x29, 0x05, 0x00, 
  0x00, 0x31, 0x00, 0x05, 0x04, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x34, 0x05, 0x00, 
  0x00, 0x83, 0x49, 0x01, 0x05, 0x17, 0x00, 0x14, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x80, 0xE3, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x02, 0x13, 0xCE, 0x05, 0x70, 0x61, 0x69, 0x72, 
  0x73, 0xDA, 0x18, 0xDA, 0x78, 0xDA, 0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 0x00, 0x00, 
  0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 
  0x26, 0x07, 0x00, 0x00, 0x48, 0x06, 0x07, 0x05, 0x1C, 0x06, 0x0A, 0x00, 0x38, 0x07, 0x00, 0x05, 
  0x30, 0x05, 0x07, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x30, 0x03, 0x08, 0x00, 
  0x2A, 0x09, 0x01, 0x00, 0x33, 0x07, 0x09, 0x00, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF5, 0xFF, 0xFF, 
  0x03, 0x03, 0x00, 0x00, 0x86, 0x1A, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 
  0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x1E, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 0xBF, 0xFE, 0x03, 0xBF, 0xFB, 0x01, 0xDA, 0x81, 0x5A, 
  0xDA, 0x84, 0x12, 0xDA, 0x4A, 0xDA, 0x80, 0xE4, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 
  0x01, 0x01, 0x01, 0x02, 0x13, 0xCE, 0x07, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0xDA, 0x18, 
  0xDA, 0x84, 0x70, 0xDA, 0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x05, 0x04, 0x03, 0xFF, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 
  0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x29, 0x09, 0x00, 0x00, 0x45, 0x08, 
  0x05, 0x09, 0x1C, 0x08, 0x07, 0x00, 0x38, 0x09, 0x00, 0x05, 0x30, 0x07, 0x09, 0x00, 0x2A, 0x0B, 
  0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x05, 0x05, 0x05, 0xFF, 0x1A, 0xF8, 0xFF, 0xFF, 0x03, 0x07, 
  0x00, 0x00, 0x85, 0x90, 0x01, 0x05, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x15, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x05, 0xBF, 0xFE, 0x03, 0xBF, 0xF8, 0x01, 0xD0, 0x06, 0x62, 0x72, 0x61, 
  0x6E, 0x63, 0x68, 0xDA, 0x82, 0xA3, 0xDA, 0x49, 0xD8, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 
  0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x2F, 0x03, 
  0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x03, 0x04, 0x00, 0x1C, 0x03, 
  0x06, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 
  0x06, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1C, 0x03, 
  0x08, 0x00, 0x29, 0x08, 0x00, 0x00, 0x29, 0x09, 0xFE, 0xFF, 0x31, 0x01, 0x08, 0x09, 0x2A, 0x09, 
  0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x07, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x07, 
  0x01, 0x00, 0x29, 0x08, 0x02, 0x00, 0x30, 0x08, 0x07, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x33, 0x08, 
  0x09, 0x00, 0x19, 0x07, 0x08, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0B, 0x04, 0x00, 0x33, 0x0A, 
  0x0B, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x19, 0x09, 0x00, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x0C, 
  0x05, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x09, 0x0B, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x3E, 0x0B, 
  0x00, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x48, 0x0D, 0x00, 0x0A, 0x1C, 0x0D, 0x08, 0x00, 0x2A, 0x0E, 
  0x06, 0x00, 0x31, 0x0E, 0x0A, 0x00, 0x43, 0x0E, 0x00, 0x00, 0x30, 0x0C, 0x0E, 0x00, 0x2A, 0x10, 
  0x07, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x30, 0x0D, 
  0x0A, 0x00, 0x42, 0x0D, 0x00, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x42, 0x0F, 0x00, 0x00, 0x19, 0x10, 
  0x0F, 0x00, 0x2E, 0x11, 0x00, 0x00, 0x19, 0x12, 0x11, 0x00, 0x2E, 0x13, 0x01, 0x00, 0x19, 0x14, 
  0x13, 0x00, 0x2E, 0x15, 0x02, 0x00, 0x19, 0x16, 0x15, 0x00, 0x2E, 0x17, 0x03, 0x00, 0x19, 0x18, 
  0x17, 0x00, 0x2E, 0x19, 0x04, 0x00, 0x19, 0x1A, 0x19, 0x00, 0x2E, 0x1B, 0x05, 0x00, 0x19, 0x1C, 
  0x1B, 0x00, 0x26, 0x1E, 0x00, 0x00, 0x47, 0x1D, 0x07, 0x1E, 0x19, 0x1E, 0x1D, 0x00, 0x1D, 0x1E, 
  0x87, 0x00, 0x38, 0x1D, 0x07, 0x1E, 0x3B, 0x1F, 0x1D, 0x00, 0x19, 0x20, 0x1F, 0x00, 0x3B, 0x1F, 
  0x1D, 0x01, 0x19, 0x21, 0x1F, 0x00, 0x42, 0x1D, 0x00, 0x00, 0x19, 0x1F, 0x1D, 0x00, 0x42, 0x1D, 
  0x00, 0x00, 0x19, 0x22, 0x1D, 0x00, 0x3E, 0x1D, 0x00, 0x00, 0x19, 0x23, 0x1D, 0x00, 0x26, 0x1D, 
  0x00, 0x00, 0x26, 0x24, 0x00, 0x00, 0x31, 0x1F, 0x1D, 0x24, 0x2F, 0x20, 0x00, 0x00, 0x33, 0x1D, 
  0x1A, 0x00, 0x2A, 0x1D, 0x09, 0x00, 0x2F, 0x1D, 0x00, 0x00, 0x3E, 0x1D, 0x00, 0x00, 0x19, 0x24, 
  0x1D, 0x00, 0x31, 0x24, 0x22, 0x23, 0x26, 0x1D, 0x00, 0x00, 0x26, 0x25, 0x00, 0x00, 0x31, 0x1D, 
  0x25, 0x20, 0x33, 0x1D, 0x1C, 0x00, 0x3E, 0x1D, 0x00, 0x00, 0x19, 0x25, 0x1D, 0x00, 0x26, 0x26, 
  0x00, 0x00, 0x47, 0x1D, 0x1F, 0x26, 0x19, 0x26, 0x1D, 0x00, 0x1D, 0x26, 0x11, 0x00, 0x38, 0x1D, 
  0x1F, 0x26, 0x19, 0x27, 0x1D, 0x00, 0x3D, 0x1D, 0x27, 0x00, 0x29, 0x29, 0x01, 0x00, 0x21, 0x28, 
  0x29, 0x1D, 0x1C, 0x28, 0x09, 0x00, 0x2A, 0x1D, 0x0A, 0x00, 0x2F, 0x1D, 0x00, 0x00, 0x32, 0x27, 
  0x00, 0x00, 0x43, 0x1D, 0x00, 0x00, 0x30, 0x25, 0x1D, 0x00, 0x2A, 0x2A, 0x07, 0x00, 0x33, 0x29, 
  0x2A, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x26, 0x1F, 0x26, 0x1A, 0xF0, 0xFF, 0xFF, 0x26, 0x26, 
  0x00, 0x00, 0x47, 0x1D, 0x22, 0x26, 0x19, 0x26, 0x1D, 0x00, 0x1D, 0x26, 0x12, 0x00, 0x38, 0x1D, 
  0x22, 0x26, 0x30, 0x26, 0x1D, 0x00, 0x2A, 0x28, 0x0B, 0x00, 0x33, 0x27, 0x28, 0x00, 0x3B, 0x1D, 
  0x27, 0x00, 0x19, 0x28, 0x1D, 0x00, 0x3B, 0x1D, 0x27, 0x01, 0x19, 0x29, 0x1D, 0x00, 0x2A, 0x1D, 
  0x0A, 0x00, 0x30, 0x1D, 0x28, 0x00, 0x32, 0x29, 0x00, 0x00, 0x43, 0x1D, 0x00, 0x00, 0x30, 0x25, 
  0x1D, 0x00, 0x2A, 0x2A, 0x07, 0x00, 0x33, 0x27, 0x2A, 0x00, 0x47, 0x26, 0x22, 0x26, 0x1A, 0xEF, 
  0xFF, 0xFF, 0x2F, 0x25, 0x00, 0x00, 0x2A, 0x26, 0x0C, 0x00, 0x33, 0x1D, 0x26, 0x00, 0x30, 0x24, 
  0x25, 0x00, 0x2A, 0x26, 0x0D, 0x00, 0x33, 0x1D, 0x26, 0x00, 0x3E, 0x1D, 0x00, 0x00, 0x19, 0x26, 
  0x1D, 0x00, 0x2F, 0x1F, 0x00, 0x00, 0x2A, 0x27, 0x0E, 0x00, 0x33, 0x1D, 0x27, 0x00, 0x2F, 0x1D, 
  0x00, 0x00, 0x2A, 0x28, 0x0C, 0x00, 0x33, 0x27, 0x28, 0x00, 0x19, 0x1D, 0x27, 0x00, 0x26, 0x28, 
  0x00, 0x00, 0x47, 0x27, 0x1D, 0x28, 0x19, 0x28, 0x27, 0x00, 0x1D, 0x28, 0x11, 0x00, 0x38, 0x27, 
  0x1D, 0x28, 0x3B, 0x29, 0x27, 0x00, 0x19, 0x2A, 0x29, 0x00, 0x3B, 0x29, 0x27, 0x01, 0x19, 0x2B, 
  0x29, 0x00, 0x2F, 0x2B, 0x00, 0x00, 0x2A, 0x29, 0x0F, 0x00, 0x33, 0x27, 0x29, 0x00, 0x2A, 0x29, 
  0x06, 0x00, 0x31, 0x29, 0x2A, 0x27, 0x43, 0x27, 0x00, 0x00, 0x30, 0x26, 0x27, 0x00, 0x2A, 0x2C, 
  0x07, 0x00, 0x33, 0x29, 0x2C, 0x00, 0x47, 0x28, 0x1D, 0x28, 0x1A, 0xF0, 0xFF, 0xFF, 0x19, 0x1D, 
  0x26, 0x00, 0x2F, 0x23, 0x00, 0x00, 0x2A, 0x28, 0x10, 0x00, 0x33, 0x27, 0x28, 0x00, 0x1C, 0x27, 
  0x02, 0x00, 0x1A, 0x0E, 0x00, 0x00, 0x2A, 0x29, 0x09, 0x00, 0x2F, 0x29, 0x00, 0x00, 0x32, 0x23, 
  0x00, 0x00, 0x43, 0x28, 0x00, 0x00, 0x2A, 0x2A, 0x11, 0x00, 0x2F, 0x2A, 0x00, 0x00, 0x32, 0x1D, 
  0x00, 0x00, 0x2F, 0x28, 0x00, 0x00, 0x43, 0x29, 0x00, 0x00, 0x19, 0x28, 0x29, 0x00, 0x30, 0x24, 
  0x28, 0x00, 0x2A, 0x2A, 0x07, 0x00, 0x33, 0x29, 0x2A, 0x00, 0x2F, 0x24, 0x00, 0x00, 0x2A, 0x28, 
  0x12, 0x00, 0x33, 0x27, 0x28, 0x00, 0x2A, 0x28, 0x11, 0x00, 0x2F, 0x28, 0x00, 0x00, 0x32, 0x1D, 
  0x00, 0x00, 0x2F, 0x21, 0x00, 0x00, 0x43, 0x28, 0x00, 0x00, 0x30, 0x27, 0x28, 0x00, 0x33, 0x29, 
  0x14, 0x00, 0x47, 0x1E, 0x07, 0x1E, 0x1A, 0x7A, 0xFF, 0xFF, 0x2F, 0x06, 0x00, 0x00, 0x3E, 0x1D, 
  0x00, 0x00, 0x19, 0x1E, 0x1D, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x2A, 0x20, 0x13, 0x00, 0x33, 0x1F, 
  0x20, 0x00, 0x19, 0x20, 0x1F, 0x00, 0x26, 0x21, 0x00, 0x00, 0x47, 0x1F, 0x20, 0x21, 0x19, 0x21, 
  0x1F, 0x00, 0x1D, 0x21, 0x37, 0x00, 0x38, 0x1F, 0x20, 0x21, 0x19, 0x22, 0x1F, 0x00, 0x2A, 0x23, 
  0x14, 0x00, 0x23, 0x1F, 0x23, 0x22, 0x1C, 0x1F, 0x2D, 0x00, 0x2F, 0x1E, 0x00, 0x00, 0x2A, 0x24, 
  0x15, 0x00, 0x33, 0x23, 0x24, 0x00, 0x19, 0x24, 0x23, 0x00, 0x2F, 0x1E, 0x00, 0x00, 0x2A, 0x25, 
  0x15, 0x00, 0x33, 0x23, 0x25, 0x00, 0x19, 0x25, 0x23, 0x00, 0x3D, 0x23, 0x1E, 0x00, 0x19, 0x26, 
  0x23, 0x00, 0x24, 0x27, 0x26, 0x00, 0x1C, 0x27, 0x03, 0x00, 0x26, 0x23, 0x00, 0x00, 0x1A, 0x11, 
  0x00, 0x00, 0x24, 0x29, 0x26, 0x01, 0x1C, 0x29, 0x06, 0x00, 0x29, 0x2A, 0x00, 0x00, 0x2F, 0x2A, 
  0x00, 0x00, 0x33, 0x2A, 0x1E, 0x00, 0x19, 0x28, 0x2A, 0x00, 0x1A, 0x09, 0x00, 0x00, 0x2F, 0x1E, 
  0x00, 0x00, 0x2A, 0x2B, 0x13, 0x00, 0x33, 0x2A, 0x2B, 0x00, 0x2A, 0x2C, 0x11, 0x00, 0x2F, 0x2C, 
  0x00, 0x00, 0x32, 0x2A, 0x00, 0x00, 0x43, 0x2B, 0x00, 0x00, 0x19, 0x28, 0x2B, 0x00, 0x19, 0x23, 
  0x28, 0x00, 0x2A, 0x27, 0x16, 0x00, 0x31, 0x27, 0x24, 0x25, 0x2F, 0x23, 0x00, 0x00, 0x43, 0x26, 
  0x00, 0x00, 0x19, 0x23, 0x26, 0x00, 0x3D, 0x26, 0x1E, 0x00, 0x29, 0x27, 0x00, 0x00, 0x31, 0x1E, 
  0x27, 0x26, 0x2A, 0x28, 0x17, 0x00, 0x33, 0x27, 0x28, 0x00, 0x30, 0x1E, 0x23, 0x00, 0x2A, 0x27, 
  0x07, 0x00, 0x33, 0x26, 0x27, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x30, 0x1E, 0x22, 0x00, 0x2A, 0x24, 
  0x07, 0x00, 0x33, 0x23, 0x24, 0x00, 0x47, 0x21, 0x20, 0x21, 0x1A, 0xCA, 0xFF, 0xFF, 0x2F, 0x1E, 
  0x00, 0x00, 0x2A, 0x20, 0x13, 0x00, 0x33, 0x1F, 0x20, 0x00, 0x2A, 0x21, 0x11, 0x00, 0x2F, 0x21, 
  0x00, 0x00, 0x32, 0x1F, 0x00, 0x00, 0x43, 0x20, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0xCD, 0x00, 
  0xD8, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0xCE, 0x04, 0x65, 0x6D, 0x69, 0x74, 
  0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x0C, 0x30, 0x02, 0x00, 
  0x00, 0x2A, 0x02, 0x00, 0x00, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x86, 0xF3, 0x03, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
  0x07, 0x01, 0xCE, 0x0B, 0x65, 0x6D, 0x69, 0x74, 0x2D, 0x62, 0x72, 0x61, 0x6E, 0x63, 0x68, 0xDA, 
  0x18, 0xDA, 0x85, 0xEF, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x0C, 0x2A, 
  0x04, 0x00, 0x00, 0x31, 0x03, 0x04, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 
  0x03, 0x00, 0x00, 0xBF, 0xFF, 0x86, 0xF4, 0x03, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 
  0x00, 0x28, 0x00, 0x28, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x03, 0x18, 0x01, 
  0xCE, 0x07, 0x67, 0x65, 0x74, 0x2D, 0x73, 0x79, 0x6D, 0xDA, 0x18, 0xDA, 0x43, 0xD7, 0x00, 0xCD, 
  0x00, 0x08, 0x00, 0x1B, 0x04, 0x03, 0x02, 0x03, 0x00, 0x06, 0xCE, 0x03, 0x67, 0x65, 0x74, 0x39, 
  0x00, 0x00, 0x01, 0x26, 0x03, 0x00, 0x00, 0x23, 0x03, 0x00, 0x03, 0x1B, 0x03, 0x02, 0x00, 0x03, 
  0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0xDA, 0x44, 0x2C, 0x02, 0x00, 0x00, 0x30, 0x00, 0x01, 
  0x00, 0x43, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2B, 0x06, 0x00, 0x0E, 0x39, 0x05, 0x06, 
  0x04, 0x19, 0x06, 0x05, 0x00, 0x1C, 0x06, 0x02, 0x00, 0x03, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x00, 
  0x00, 0x33, 0x05, 0x07, 0x00, 0x19, 0x07, 0x05, 0x00, 0x2B, 0x05, 0x00, 0x0E, 0x3A, 0x05, 0x04, 
  0x07, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x01, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x08, 0x02, 
  0x00, 0x31, 0x08, 0x07, 0x05, 0x43, 0x05, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2B, 0x09, 0x00, 
  0x12, 0x33, 0x08, 0x09, 0x00, 0x03, 0x07, 0x00, 0x00, 0xBF, 0xFF, 0x86, 0xF6, 0x03, 0x02, 0x15, 
  0x00, 0x15, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x11, 
  0x00, 0x11, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x01, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x11, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x05, 0x1B, 0x01, 0xCE, 0x0E, 0x67, 0x65, 0x74, 0x2D, 0x6C, 
  0x65, 0x6E, 0x67, 0x74, 0x68, 0x2D, 0x73, 0x79, 0x6D, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x84, 0x0A, 
  0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x08, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02, 0xCE, 0x06, 0x6C, 
  0x65, 0x6E, 0x67, 0x74, 0x68, 0x3D, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xDA, 0x49, 0xDA, 
  0x44, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x10, 0x39, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 
  0x00, 0x1C, 0x03, 0x02, 0x00, 0x03, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x02, 0x04, 
  0x00, 0x19, 0x04, 0x02, 0x00, 0x2B, 0x02, 0x00, 0x10, 0x3A, 0x02, 0x00, 0x04, 0x2A, 0x02, 0x01, 
  0x00, 0x30, 0x02, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x30, 0x05, 0x00, 
  0x00, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x31, 0x06, 0x02, 0x05, 0x43, 0x02, 0x00, 
  0x00, 0x2A, 0x05, 0x04, 0x00, 0x31, 0x05, 0x04, 0x02, 0x43, 0x02, 0x00, 0x00, 0x2F, 0x02, 0x00, 
  0x00, 0x2B, 0x06, 0x00, 0x12, 0x33, 0x05, 0x06, 0x00, 0x03, 0x04, 0x00, 0x00, 0xBF, 0xFF, 0x86, 
  0xFF, 0x03, 0x02, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x11, 0x00, 0x11, 
  0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x34, 0x00, 0x34, 
  0x00, 0x34, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x17, 0x04, 0x04, 0x04, 
  0x14, 0x80, 0xDF, 0x01, 0xCE, 0x0F, 0x76, 0x69, 0x73, 0x69, 0x74, 0x2D, 0x70, 0x61, 0x74, 0x74, 
  0x65, 0x72, 0x6E, 0x2D, 0x31, 0xDA, 0x18, 0xDA, 0x83, 0xD9, 0xDA, 0x1C, 0xDA, 0x55, 0xDA, 0x76, 
  0xDA, 0x80, 0xAC, 0xDA, 0x82, 0x47, 0xDA, 0x1E, 0xDA, 0x81, 0x4C, 0xDA, 0x82, 0x44, 0xDA, 0x74, 
  0xDA, 0x75, 0xDA, 0x78, 0xDA, 0x84, 0x36, 0xDA, 0x64, 0xCE, 0x26, 0x65, 0x78, 0x70, 0x65, 0x63, 
  0x74, 0x65, 0x64, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 
  0x77, 0x69, 0x6E, 0x67, 0x20, 0x26, 0x20, 0x69, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 
  0x6E, 0xDA, 0x80, 0x8D, 0xDA, 0x85, 0xBD, 0xCE, 0x37, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 
  0x64, 0x20, 0x61, 0x20, 0x73, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x27, 0x26, 0x20, 0x69, 0x6E, 0x20, 0x70, 
  0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x2C, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x25, 0x71, 
  0xCE, 0x30, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x20, 0x26, 0x20, 0x69, 0x6E, 
  0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x2C, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 
  0x25, 0x71, 0xCF, 0x01, 0x40, 0x2C, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x23, 0x05, 0x03, 
  0x06, 0x1C, 0x05, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x30, 0x01, 0x02, 
  0x00, 0x2B, 0x06, 0x00, 0x16, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2F, 0x03, 0x00, 
  0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x08, 0x07, 0x00, 0x2A, 0x0A, 0x02, 
  0x00, 0x23, 0x09, 0x08, 0x0A, 0x19, 0x0A, 0x09, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x19, 0x09, 0x0A, 
  0x00, 0x1A, 0x0E, 0x00, 0x00, 0x2A, 0x0D, 0x03, 0x00, 0x23, 0x0C, 0x08, 0x0D, 0x19, 0x0D, 0x0C, 
  0x00, 0x1C, 0x0C, 0x08, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x0F, 0x04, 0x00, 0x33, 0x0E, 0x0F, 
  0x00, 0x2A, 0x10, 0x05, 0x00, 0x23, 0x0F, 0x0E, 0x10, 0x19, 0x0B, 0x0F, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x19, 0x0B, 0x0D, 0x00, 0x19, 0x09, 0x0B, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x2A, 0x0C, 0x06, 
  0x00, 0x23, 0x0B, 0x08, 0x0C, 0x1C, 0x0B, 0x0C, 0x00, 0x38, 0x0C, 0x00, 0x03, 0x19, 0x0D, 0x0C, 
  0x00, 0x1C, 0x0D, 0x04, 0x00, 0x30, 0x0D, 0x06, 0x00, 0x2A, 0x0C, 0x07, 0x00, 0x34, 0x0C, 0x00, 
  0x00, 0x2F, 0x06, 0x00, 0x00, 0x3E, 0x0C, 0x00, 0x00, 0x19, 0x0E, 0x00, 0x00, 0x3A, 0x0E, 0x03, 
  0x0C, 0x03, 0x0E, 0x00, 0x00, 0x2A, 0x0E, 0x03, 0x00, 0x23, 0x0D, 0x08, 0x0E, 0x19, 0x0E, 0x0D, 
  0x00, 0x1C, 0x0D, 0x10, 0x00, 0x3D, 0x10, 0x03, 0x00, 0x29, 0x12, 0x02, 0x00, 0x23, 0x11, 0x12, 
  0x10, 0x19, 0x10, 0x11, 0x00, 0x1C, 0x11, 0x08, 0x00, 0x29, 0x12, 0x00, 0x00, 0x2F, 0x12, 0x00, 
  0x00, 0x33, 0x12, 0x03, 0x00, 0x2A, 0x14, 0x08, 0x00, 0x23, 0x13, 0x14, 0x12, 0x19, 0x0F, 0x13, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0F, 0x10, 0x00, 0x19, 0x0C, 0x0F, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x19, 0x0C, 0x0E, 0x00, 0x1C, 0x0C, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2A, 0x0E, 0x09, 
  0x00, 0x23, 0x0D, 0x08, 0x0E, 0x19, 0x0E, 0x0D, 0x00, 0x1C, 0x0E, 0x03, 0x00, 0x19, 0x0D, 0x0E, 
  0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x10, 0x0A, 0x00, 0x23, 0x0F, 0x08, 0x10, 0x19, 0x0D, 0x0F, 
  0x00, 0x1C, 0x0D, 0x13, 0x00, 0x26, 0x0F, 0x00, 0x00, 0x47, 0x0E, 0x03, 0x0F, 0x19, 0x0F, 0x0E, 
  0x00, 0x1D, 0x0F, 0x0E, 0x00, 0x38, 0x0E, 0x03, 0x0F, 0x30, 0x0F, 0x0E, 0x00, 0x2A, 0x11, 0x0B, 
  0x00, 0x33, 0x10, 0x11, 0x00, 0x3B, 0x0E, 0x10, 0x00, 0x19, 0x11, 0x0E, 0x00, 0x3B, 0x0E, 0x10, 
  0x01, 0x19, 0x12, 0x0E, 0x00, 0x31, 0x00, 0x06, 0x11, 0x2F, 0x12, 0x00, 0x00, 0x33, 0x0E, 0x04, 
  0x00, 0x47, 0x0F, 0x03, 0x0F, 0x1A, 0xF3, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x1C, 0x0A, 0x55, 
  0x00, 0x2F, 0x06, 0x00, 0x00, 0x2B, 0x0F, 0x00, 0x18, 0x33, 0x0E, 0x0F, 0x00, 0x26, 0x0F, 0x00, 
  0x00, 0x47, 0x0E, 0x03, 0x0F, 0x19, 0x0F, 0x0E, 0x00, 0x1D, 0x0F, 0x4D, 0x00, 0x38, 0x0E, 0x03, 
  0x0F, 0x30, 0x0F, 0x0E, 0x00, 0x2A, 0x11, 0x0B, 0x00, 0x33, 0x10, 0x11, 0x00, 0x3B, 0x0E, 0x10, 
  0x00, 0x19, 0x11, 0x0E, 0x00, 0x3B, 0x0E, 0x10, 0x01, 0x19, 0x12, 0x0E, 0x00, 0x2A, 0x10, 0x0C, 
  0x00, 0x23, 0x0E, 0x12, 0x10, 0x1C, 0x0E, 0x3D, 0x00, 0x3D, 0x10, 0x03, 0x00, 0x2F, 0x11, 0x00, 
  0x00, 0x2A, 0x14, 0x0D, 0x00, 0x33, 0x13, 0x14, 0x00, 0x46, 0x14, 0x10, 0x13, 0x1C, 0x14, 0x06, 
  0x00, 0x2A, 0x10, 0x0E, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x2A, 0x13, 0x0F, 0x00, 0x33, 0x10, 0x13, 
  0x00, 0x1A, 0x01, 0x00, 0x00, 0x05, 0x10, 0x11, 0x02, 0x3D, 0x13, 0x03, 0x00, 0x21, 0x14, 0x10, 
  0x13, 0x1C, 0x14, 0x0C, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x2A, 0x13, 0x0D, 0x00, 0x33, 0x10, 0x13, 
  0x00, 0x30, 0x03, 0x10, 0x00, 0x2A, 0x15, 0x10, 0x00, 0x33, 0x13, 0x15, 0x00, 0x2A, 0x10, 0x11, 
  0x00, 0x30, 0x10, 0x13, 0x00, 0x2A, 0x15, 0x0F, 0x00, 0x33, 0x10, 0x15, 0x00, 0x1A, 0x01, 0x00, 
  0x00, 0x2F, 0x11, 0x00, 0x00, 0x2A, 0x13, 0x0D, 0x00, 0x33, 0x10, 0x13, 0x00, 0x2F, 0x10, 0x00, 
  0x00, 0x33, 0x13, 0x03, 0x00, 0x2F, 0x13, 0x00, 0x00, 0x2A, 0x14, 0x01, 0x00, 0x33, 0x10, 0x14, 
  0x00, 0x2A, 0x14, 0x06, 0x00, 0x48, 0x13, 0x10, 0x14, 0x1C, 0x13, 0x0B, 0x00, 0x2F, 0x11, 0x00, 
  0x00, 0x2A, 0x14, 0x0D, 0x00, 0x33, 0x10, 0x14, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x33, 0x14, 0x03, 
  0x00, 0x2A, 0x10, 0x12, 0x00, 0x30, 0x10, 0x14, 0x00, 0x2A, 0x15, 0x0F, 0x00, 0x33, 0x10, 0x15, 
  0x00, 0x1A, 0x01, 0x00, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x2A, 0x13, 0x0D, 0x00, 0x33, 0x10, 0x13, 
  0x00, 0x2F, 0x10, 0x00, 0x00, 0x33, 0x13, 0x03, 0x00, 0x2A, 0x10, 0x10, 0x00, 0x31, 0x10, 0x06, 
  0x11, 0x43, 0x10, 0x00, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x3E, 0x10, 0x00, 0x00, 0x3A, 0x00, 0x13, 
  0x10, 0x1A, 0x07, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x31, 0x00, 0x06, 0x11, 0x2F, 0x12, 0x00, 
  0x00, 0x33, 0x0E, 0x04, 0x00, 0x47, 0x0F, 0x03, 0x0F, 0x1A, 0xB4, 0xFF, 0xFF, 0x04, 0x00, 0x00, 
  0x00, 0x2A, 0x10, 0x03, 0x00, 0x23, 0x0F, 0x08, 0x10, 0x19, 0x10, 0x0F, 0x00, 0x1C, 0x0F, 0x10, 
  0x00, 0x3D, 0x12, 0x03, 0x00, 0x29, 0x14, 0x02, 0x00, 0x23, 0x13, 0x14, 0x12, 0x19, 0x12, 0x13, 
  0x00, 0x1C, 0x13, 0x08, 0x00, 0x29, 0x14, 0x00, 0x00, 0x2F, 0x14, 0x00, 0x00, 0x33, 0x14, 0x03, 
  0x00, 0x2A, 0x16, 0x13, 0x00, 0x23, 0x15, 0x16, 0x14, 0x19, 0x11, 0x15, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x19, 0x11, 0x12, 0x00, 0x19, 0x0E, 0x11, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0E, 0x10, 
  0x00, 0x1C, 0x0E, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2A, 0x11, 0x03, 0x00, 0x23, 0x10, 0x08, 
  0x11, 0x19, 0x11, 0x10, 0x00, 0x1C, 0x10, 0x06, 0x00, 0x3D, 0x12, 0x03, 0x00, 0x29, 0x14, 0x02, 
  0x00, 0x45, 0x13, 0x12, 0x14, 0x19, 0x0F, 0x13, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0F, 0x11, 
  0x00, 0x1C, 0x0F, 0x07, 0x00, 0x29, 0x10, 0x00, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x33, 0x10, 0x03, 
  0x00, 0x31, 0x00, 0x01, 0x02, 0x2F, 0x10, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0xBF, 0xFF, 0x87, 0x07, 0x03, 0x02, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x18, 0x00, 0x05, 
  0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 
  0x01, 0x14, 0x00, 0x14, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x26, 0x00, 0x26, 
  0x00, 0x21, 0x00, 0x21, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x33, 0x00, 0x33, 0x00, 0x21, 
  0x00, 0x21, 0x00, 0x21, 0x00, 0x10, 0x00, 0x05, 0x04, 0x07, 0x00, 0x07, 0xBF, 0xFD, 0x05, 0x04, 
  0x12, 0x00, 0x07, 0x00, 0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x07, 0x00, 0x07, 0x00, 0x1E, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x07, 0x00, 0x07, 0x00, 0x3A, 0x00, 0x3A, 0x00, 0x3A, 0x00, 0x30, 0x00, 
  0x30, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xF7, 0x05, 
  0x0A, 0x07, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x19, 
  0x00, 0x19, 0x00, 0x07, 0xBF, 0xF3, 0x05, 0x0E, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xF2, 0x05, 0x13, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x11, 0x00, 
  0x11, 0x00, 0x0B, 0x01, 0x17, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 0x13, 0x00, 0x0D, 0x01, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFF, 0x0D, 0x03, 0x16, 0x00, 0x1E, 0x00, 0x13, 
  0x00, 0x0D, 0x01, 0x60, 0x00, 0x60, 0x00, 0x60, 0x00, 0x51, 0x00, 0x51, 0x00, 0x51, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFF, 0x0D, 0x03, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 
  0x1F, 0x00, 0x1F, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0D, 0x01, 
  0x53, 0x00, 0x53, 0x00, 0x53, 0x00, 0x4A, 0x00, 0x4A, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0xBF, 0xFF, 0x0D, 0x03, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x16, 0x00, 0x16, 0x00, 0x2A, 
  0x00, 0x2A, 0x00, 0x2A, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x0D, 0xBF, 0xF5, 0x0B, 0x0C, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xF3, 0x09, 0x00, 0x09, 0x00, 0x09, 0x10, 0x0C, 0x00, 0x0C, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x1E, 0x00, 0x19, 0x00, 0x19, 0x00, 0x07, 0x00, 0x07, 0x00, 0x36, 
  0x00, 0x36, 0x00, 0x36, 0x00, 0x30, 0x00, 0x30, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0xBF, 0xDC, 0x05, 0x25, 0x07, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x1D, 0x00, 0x19, 0x00, 0x19, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xD8, 0x05, 
  0x2A, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xD6, 0x05, 0xCD, 
  0x00, 0xF8, 0x00, 0x00, 0x19, 0x06, 0x06, 0x06, 0x13, 0x80, 0xE0, 0x01, 0x01, 0xCE, 0x0F, 0x76, 
  0x69, 0x73, 0x69, 0x74, 0x2D, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x2D, 0x32, 0xDA, 0x18, 
  0xDA, 0x83, 0xD9, 0xDA, 0x1C, 0xDA, 0x55, 0xDA, 0x76, 0xDA, 0x80, 0xAC, 0xDA, 0x82, 0x47, 0xDA, 
  0x81, 0x4C, 0xDA, 0x82, 0x24, 0xDA, 0x85, 0x81, 0xDA, 0x74, 0xDA, 0x75, 0xDA, 0x78, 0xDA, 0x80, 
  0xBF, 0xDA, 0x84, 0x36, 0xDA, 0x1E, 0xDA, 0x82, 0x44, 0xDA, 0x80, 0xD5, 0xDA, 0x85, 0xFD, 0xDA, 
  0x85, 0xBD, 0x2C, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x23, 0x07, 0x05, 0x08, 0x1C, 0x07, 
  0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x30, 0x03, 0x04, 0x00, 0x2B, 0x08, 
  0x00, 0x16, 0x33, 0x07, 0x08, 0x00, 0x19, 0x08, 0x07, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x0A, 
  0x01, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x2A, 0x0C, 0x02, 0x00, 0x23, 0x0B, 
  0x0A, 0x0C, 0x19, 0x0C, 0x0B, 0x00, 0x1C, 0x0C, 0x03, 0x00, 0x19, 0x0B, 0x0C, 0x00, 0x1A, 0x0E, 
  0x00, 0x00, 0x2A, 0x0F, 0x03, 0x00, 0x23, 0x0E, 0x0A, 0x0F, 0x19, 0x0F, 0x0E, 0x00, 0x1C, 0x0E, 
  0x08, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x11, 0x04, 0x00, 0x33, 0x10, 0x11, 0x00, 0x2A, 0x12, 
  0x05, 0x00, 0x23, 0x11, 0x10, 0x12, 0x19, 0x0D, 0x11, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0D, 
  0x0F, 0x00, 0x19, 0x0B, 0x0D, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x1C, 0x0C, 0x1C, 0x00, 0x2F, 0x08, 
  0x00, 0x00, 0x2B, 0x0E, 0x00, 0x18, 0x33, 0x0D, 0x0E, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x2A, 0x0F, 
  0x06, 0x00, 0x33, 0x0E, 0x0F, 0x00, 0x2E, 0x0D, 0x00, 0x00, 0x30, 0x0D, 0x05, 0x00, 0x2A, 0x0F, 
  0x07, 0x00, 0x33, 0x0E, 0x0F, 0x00, 0x19, 0x0D, 0x0E, 0x00, 0x1C, 0x0D, 0x03, 0x00, 0x19, 0x0E, 
  0x0D, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x3D, 0x0F, 0x05, 0x00, 0x19, 0x0E, 0x0F, 0x00, 0x19, 0x0D, 
  0x0E, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2B, 0x0F, 0x00, 0x18, 0x33, 0x0E, 0x0F, 0x00, 0x2A, 0x0F, 
  0x08, 0x00, 0x31, 0x0F, 0x0D, 0x0E, 0x43, 0x0E, 0x00, 0x00, 0x30, 0x00, 0x0E, 0x00, 0x2A, 0x10, 
  0x06, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x0E, 0x09, 0x00, 0x23, 0x0D, 
  0x0A, 0x0E, 0x19, 0x0E, 0x0D, 0x00, 0x1C, 0x0E, 0x03, 0x00, 0x19, 0x0D, 0x0E, 0x00, 0x1A, 0x04, 
  0x00, 0x00, 0x2A, 0x10, 0x0A, 0x00, 0x23, 0x0F, 0x0A, 0x10, 0x19, 0x0D, 0x0F, 0x00, 0x1C, 0x0D, 
  0x1D, 0x00, 0x26, 0x0F, 0x00, 0x00, 0x47, 0x0E, 0x05, 0x0F, 0x19, 0x0F, 0x0E, 0x00, 0x1D, 0x0F, 
  0x18, 0x00, 0x38, 0x0E, 0x05, 0x0F, 0x30, 0x0F, 0x0E, 0x00, 0x2A, 0x11, 0x0B, 0x00, 0x33, 0x10, 
  0x11, 0x00, 0x3B, 0x0E, 0x10, 0x00, 0x19, 0x11, 0x0E, 0x00, 0x3B, 0x0E, 0x10, 0x01, 0x19, 0x12, 
  0x0E, 0x00, 0x30, 0x08, 0x11, 0x00, 0x2B, 0x10, 0x00, 0x16, 0x33, 0x0E, 0x10, 0x00, 0x2A, 0x10, 
  0x0C, 0x00, 0x26, 0x13, 0x00, 0x00, 0x31, 0x10, 0x13, 0x0E, 0x43, 0x0E, 0x00, 0x00, 0x30, 0x00, 
  0x0E, 0x00, 0x2A, 0x13, 0x06, 0x00, 0x33, 0x10, 0x13, 0x00, 0x31, 0x00, 0x01, 0x02, 0x31, 0x08, 
  0x11, 0x12, 0x33, 0x0E, 0x06, 0x00, 0x47, 0x0F, 0x05, 0x0F, 0x1A, 0xE9, 0xFF, 0xFF, 0x04, 0x00, 
  0x00, 0x00, 0x1C, 0x0C, 0x18, 0x00, 0x26, 0x0F, 0x00, 0x00, 0x47, 0x0E, 0x05, 0x0F, 0x19, 0x0F, 
  0x0E, 0x00, 0x1D, 0x0F, 0x13, 0x00, 0x38, 0x0E, 0x05, 0x0F, 0x30, 0x0F, 0x0E, 0x00, 0x2A, 0x11, 
  0x0B, 0x00, 0x33, 0x10, 0x11, 0x00, 0x3B, 0x0E, 0x10, 0x00, 0x19, 0x11, 0x0E, 0x00, 0x3B, 0x0E, 
  0x10, 0x01, 0x19, 0x12, 0x0E, 0x00, 0x2A, 0x10, 0x0D, 0x00, 0x23, 0x0E, 0x12, 0x10, 0x1C, 0x0E, 
  0x03, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x31, 0x00, 0x01, 0x02, 0x31, 0x08, 
  0x11, 0x12, 0x33, 0x0E, 0x06, 0x00, 0x47, 0x0F, 0x05, 0x0F, 0x1A, 0xEE, 0xFF, 0xFF, 0x04, 0x00, 
  0x00, 0x00, 0x2A, 0x0F, 0x0E, 0x00, 0x23, 0x0E, 0x0A, 0x0F, 0x1C, 0x0E, 0x02, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0x2A, 0x11, 0x03, 0x00, 0x23, 0x10, 0x0A, 0x11, 0x19, 0x11, 0x10, 0x00, 0x1C, 0x10, 
  0x10, 0x00, 0x3D, 0x13, 0x05, 0x00, 0x29, 0x15, 0x02, 0x00, 0x23, 0x14, 0x15, 0x13, 0x19, 0x13, 
  0x14, 0x00, 0x1C, 0x14, 0x08, 0x00, 0x29, 0x15, 0x00, 0x00, 0x2F, 0x15, 0x00, 0x00, 0x33, 0x15, 
  0x05, 0x00, 0x2A, 0x17, 0x0F, 0x00, 0x23, 0x16, 0x17, 0x15, 0x19, 0x12, 0x16, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x12, 0x13, 0x00, 0x19, 0x0F, 0x12, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0F, 
  0x11, 0x00, 0x1C, 0x0F, 0x07, 0x00, 0x2A, 0x10, 0x10, 0x00, 0x31, 0x10, 0x08, 0x05, 0x43, 0x10, 
  0x00, 0x00, 0x30, 0x00, 0x10, 0x00, 0x2A, 0x11, 0x06, 0x00, 0x34, 0x11, 0x00, 0x00, 0x2A, 0x12, 
  0x03, 0x00, 0x23, 0x11, 0x0A, 0x12, 0x19, 0x12, 0x11, 0x00, 0x1C, 0x11, 0x10, 0x00, 0x3D, 0x14, 
  0x05, 0x00, 0x29, 0x16, 0x02, 0x00, 0x23, 0x15, 0x16, 0x14, 0x19, 0x14, 0x15, 0x00, 0x1C, 0x15, 
  0x08, 0x00, 0x29, 0x16, 0x00, 0x00, 0x2F, 0x16, 0x00, 0x00, 0x33, 0x16, 0x05, 0x00, 0x2A, 0x18, 
  0x11, 0x00, 0x23, 0x17, 0x18, 0x16, 0x19, 0x13, 0x17, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x13, 
  0x14, 0x00, 0x19, 0x10, 0x13, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x10, 0x12, 0x00, 0x1C, 0x10, 
  0x12, 0x00, 0x29, 0x11, 0x01, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x33, 0x11, 0x05, 0x00, 0x38, 0x12, 
  0x01, 0x11, 0x19, 0x11, 0x12, 0x00, 0x1C, 0x11, 0x04, 0x00, 0x30, 0x11, 0x08, 0x00, 0x2A, 0x12, 
  0x06, 0x00, 0x34, 0x12, 0x00, 0x00, 0x29, 0x12, 0x01, 0x00, 0x2F, 0x12, 0x00, 0x00, 0x33, 0x12, 
  0x05, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x3E, 0x13, 0x00, 0x00, 0x19, 0x14, 0x01, 0x00, 0x3A, 0x14, 
  0x12, 0x13, 0x03, 0x14, 0x00, 0x00, 0x2A, 0x13, 0x03, 0x00, 0x23, 0x12, 0x0A, 0x13, 0x19, 0x13, 
  0x12, 0x00, 0x1C, 0x12, 0x06, 0x00, 0x3D, 0x14, 0x05, 0x00, 0x29, 0x16, 0x02, 0x00, 0x45, 0x15, 
  0x14, 0x16, 0x19, 0x11, 0x15, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x11, 0x13, 0x00, 0x1C, 0x11, 
  0x0F, 0x00, 0x29, 0x12, 0x01, 0x00, 0x30, 0x05, 0x12, 0x00, 0x2A, 0x13, 0x12, 0x00, 0x33, 0x12, 
  0x13, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x32, 0x12, 0x00, 0x00, 0x2A, 0x14, 0x06, 0x00, 0x33, 0x13, 
  0x14, 0x00, 0x29, 0x12, 0x00, 0x00, 0x2F, 0x12, 0x00, 0x00, 0x33, 0x12, 0x05, 0x00, 0x31, 0x00, 
  0x01, 0x02, 0x31, 0x03, 0x04, 0x12, 0x34, 0x06, 0x00, 0x00, 0x2A, 0x12, 0x10, 0x00, 0x31, 0x12, 
  0x08, 0x05, 0x43, 0x12, 0x00, 0x00, 0x30, 0x00, 0x12, 0x00, 0x2A, 0x13, 0x06, 0x00, 0x34, 0x13, 
  0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0xDA, 
  0x18, 0xDA, 0x84, 0x36, 0x2A, 0x02, 0x00, 0x00, 0x23, 0x01, 0x00, 0x02, 0x03, 0x01, 0x00, 0x00, 
  0x87, 0x42, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x87, 0x39, 0x03, 0x02, 0x09, 0x00, 0x09, 0x00, 0x05, 
  0x00, 0x18, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x05, 0x01, 0x14, 0x00, 0x14, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 
  0x00, 0x26, 0x00, 0x26, 0x00, 0x21, 0x00, 0x21, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x33, 
  0x00, 0x33, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x10, 0x00, 0x05, 0x01, 0x05, 0x01, 0x18, 
  0x00, 0x18, 0x00, 0x18, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x02, 0x27, 0x00, 0x1B, 0x00, 0x1B, 
  0x00, 0x1B, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x0B, 0xBF, 0xFE, 0x09, 0xBF, 
  0xFF, 0x07, 0x04, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0xBF, 0xFA, 0x05, 0x0A, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x19, 0x00, 0x19, 0x00, 0x07, 0xBF, 0xFD, 0x05, 0x04, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x01, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 
  0x00, 0x1A, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFE, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFC, 0x05, 0x09, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x02, 0x0F, 0x00, 0x0F, 0x00, 0x09, 0x01, 0x0B, 0xBF, 0xFF, 0x09, 0x02, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0xBF, 0xFC, 0x07, 0x00, 0x07, 0x00, 0x07, 0x07, 0x07, 0x00, 0x07, 0xBF, 0xF0, 0x05, 0x10, 
  0x15, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x07, 0x00, 0x07, 0x00, 0x1E, 0x00, 0x19, 0x00, 0x19, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x3A, 0x00, 0x3A, 0x00, 0x3A, 0x00, 0x30, 0x00, 0x30, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xED, 0x05, 0x14, 0x18, 0x00, 0x18, 
  0x00, 0x18, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x1E, 0x00, 0x19, 0x00, 0x19, 0x00, 0x07, 0x00, 0x07, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 
  0x00, 0x30, 0x00, 0x30, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0xBF, 0xE9, 0x05, 0x18, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x12, 0x00, 0x07, 0x00, 0x07, 0x01, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x07, 0x00, 0x07, 0x00, 0x1D, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xE3, 0x05, 0x1F, 0x1C, 0x00, 0x1C, 
  0x00, 0x1C, 0x00, 0x1C, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x38, 0x00, 0x38, 
  0x00, 0x38, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x03, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x86, 0xC5, 0x01, 0x21, 0x15, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x03, 0x01, 0x0D, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 
  0x03, 0x01, 0x1E, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x1E, 0x00, 
  0x1E, 0x00, 0x1E, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x03, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x24, 0x00, 0x24, 0x00, 0x0E, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x07, 0x00, 0x03, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 
  0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x02, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x02, 0x03, 0x00, 0x03, 0x09, 
  0x03, 0x00, 0x03, 0x08, 0x03, 0x00, 0x03, 0x32, 0x03, 0x00, 0x03, 0x33, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 
  0x05, 0x01, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x12, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x07, 0x01, 0x1B, 0x00, 
  0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0xBF, 0xFF, 
  0x05, 0x00, 0x05, 0x04, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x19, 0x00, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x02, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x0F, 0x00, 0x0F, 0x00, 0x25, 
  0x00, 0x25, 0x00, 0x25, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x3B, 
  0x00, 0x3B, 0x00, 0x3B, 0x00, 0x33, 0x00, 0x33, 0x00, 0x33, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x02, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 
  0x00, 0x16, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xE9, 
  0x03, 0x00, 0x03, 0x1A, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x09, 0x00, 
  0x09, 0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x07, 0x01, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0xBF, 0xFF, 0x07, 0x03, 0x1F, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 
  0x00, 0x19, 0x00, 0x19, 0x02, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0xBF, 0xFE, 0x19, 0x00, 0x19, 0x03, 
  0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0xBF, 0xFD, 0x19, 
  0x00, 0x19, 0xBF, 0xFF, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0xBF, 0xFE, 0x07, 0x07, 0x1F, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xF7, 
  0x05, 0x0A, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xF5, 0x03, 0x00, 0x03, 0x0D, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x50, 0x45, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0xCF, 0x05, 0x6D, 0x61, 0x63, 0x65, 0x78, 0xDA, 0x84, 0xDB, 0xCF, 0x08, 
  0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x65, 0x6E, 0x76, 0xDA, 0x83, 0x30, 0xCF, 0x08, 0x65, 0x76, 0x2F, 
  0x77, 0x72, 0x69, 0x74, 0x65, 0xD8, 0x08, 0x65, 0x76, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0xCF, 
  0x02, 0x3E, 0x3D, 0xDA, 0x85, 0xAE, 0xCF, 0x04, 0x64, 0x6F, 0x63, 0x2A, 0xD7, 0x00, 0xCD, 0x02, 
  0xBA, 0x00, 0x00, 0x0D, 0x01, 0x00, 0x01, 0x13, 0x46, 0x01, 0xCE, 0x04, 0x64, 0x6F, 0x63, 0x2A, 
  0xDA, 0x18, 0xDA, 0x83, 0xF0, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x01, 0x01, 0x01, 
  0x0D, 0x3D, 0xCE, 0x0B, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0xDA, 
  0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x02, 0x00, 0x02, 0x02, 0x05, 0xCE, 0x0C, 
  0x61, 0x6C, 0x6C, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0xDA, 0x18, 0xDA, 0x82, 
  0x3D, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x10, 0x03, 0x01, 0x03, 0x06, 0x38, 0xCE, 0x08, 
  0x65, 0x6E, 0x76, 0x2D, 0x77, 0x61, 0x6C, 0x6B, 0xDA, 0x18, 0xDA, 0x82, 0x8F, 0xDA, 0x83, 0x2F, 
  0xDA, 0x81, 0x4C, 0xD8, 0x0E, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 
  0x6F, 0x74, 0x6F, 0xDA, 0x84, 0xF8, 0xDA, 0x85, 0xE5, 0x2C, 0x03, 0x00, 0x00, 0x26, 0x06, 0x00, 
  0x00, 0x23, 0x05, 0x06, 0x01, 0x1C, 0x05, 0x08, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 
  0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x04, 0x07, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x04, 0x01, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3E, 0x06, 0x00, 
  0x00, 0x19, 0x07, 0x06, 0x00, 0x19, 0x08, 0x05, 0x00, 0x1C, 0x08, 0x0B, 0x00, 0x30, 0x07, 0x08, 
  0x00, 0x2A, 0x0A, 0x02, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x03, 
  0x00, 0x33, 0x08, 0x09, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x1A, 0x01, 0x00, 
  0x00, 0x1A, 0xF6, 0xFF, 0xFF, 0x42, 0x08, 0x00, 0x00, 0x19, 0x09, 0x08, 0x00, 0x26, 0x0B, 0x00, 
  0x00, 0x47, 0x0A, 0x07, 0x0B, 0x19, 0x0B, 0x0A, 0x00, 0x1D, 0x0B, 0x12, 0x00, 0x38, 0x0A, 0x07, 
  0x0B, 0x19, 0x0C, 0x0A, 0x00, 0x26, 0x0D, 0x00, 0x00, 0x47, 0x0A, 0x0C, 0x0D, 0x19, 0x0D, 0x0A, 
  0x00, 0x1D, 0x0D, 0x0A, 0x00, 0x19, 0x0A, 0x0D, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0E, 0x00, 
  0x00, 0x1C, 0x0E, 0x04, 0x00, 0x27, 0x0F, 0x00, 0x00, 0x3A, 0x09, 0x0A, 0x0F, 0x1A, 0x01, 0x00, 
  0x00, 0x47, 0x0D, 0x0C, 0x0D, 0x1A, 0xF7, 0xFF, 0xFF, 0x47, 0x0B, 0x07, 0x0B, 0x1A, 0xEF, 0xFF, 
  0xFF, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x04, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2F, 0x0A, 0x00, 
  0x00, 0x2A, 0x0B, 0x05, 0x00, 0x34, 0x0B, 0x00, 0x00, 0x8B, 0x94, 0x01, 0x02, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x07, 0x00, 0x13, 0x00, 0x1C, 0x00, 0x1C, 
  0x00, 0x1C, 0x00, 0x37, 0x00, 0x37, 0x00, 0x37, 0x00, 0x4B, 0x00, 0x55, 0x00, 0x4B, 0x00, 0x13, 
  0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x10, 0x00, 0x10, 0xBF, 0xFE, 
  0x03, 0x03, 0x05, 0x00, 0x05, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x04, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x2C, 0x02, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x31, 0x03, 0x00, 0x01, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 
  0x8B, 0xA0, 0x01, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x85, 0x6B, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x02, 0x00, 0x02, 0x02, 0x05, 0xCE, 0x0C, 0x61, 0x6C, 0x6C, 
  0x2D, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x73, 0xDA, 0x18, 0xDA, 0x85, 0x76, 0xDA, 0x86, 
  0x0B, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x31, 0x03, 0x00, 0x01, 0x2A, 0x03, 0x01, 
  0x00, 0x34, 0x03, 0x00, 0x00, 0x8B, 0xA7, 0x01, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xD8, 0x08, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0xDA, 0x82, 0x48, 0xDA, 0x82, 0x70, 
  0xDA, 0x81, 0x4F, 0xDA, 0x83, 0xC2, 0xCE, 0x0B, 0x42, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 
  0x3A, 0x0A, 0x0A, 0xDA, 0x81, 0x38, 0xDA, 0x81, 0x1A, 0xCE, 0x0B, 0x44, 0x79, 0x6E, 0x61, 0x6D, 
  0x69, 0x63, 0x73, 0x3A, 0x0A, 0x0A, 0xCE, 0x36, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x55, 0x73, 0x65, 
  0x20, 0x28, 0x64, 0x6F, 0x63, 0x20, 0x73, 0x79, 0x6D, 0x29, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6D, 
  0x6F, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x6F, 0x6E, 0x20, 0x61, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x0A, 0x2C, 0x01, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x04, 
  0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x30, 0x00, 0x04, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2A, 0x04, 
  0x03, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x33, 0x04, 0x06, 0x00, 0x19, 0x05, 
  0x04, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x30, 0x02, 
  0x07, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x08, 0x00, 0x30, 0x08, 
  0x07, 0x00, 0x2A, 0x09, 0x09, 0x00, 0x33, 0x08, 0x09, 0x00, 0x26, 0x07, 0x00, 0x00, 0x26, 0x09, 
  0x00, 0x00, 0x31, 0x08, 0x07, 0x09, 0x28, 0x07, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 
  0x0A, 0x00, 0x33, 0x07, 0x09, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x33, 0x08, 
  0x09, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x33, 0x07, 0x09, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x30, 0x05, 
  0x09, 0x00, 0x2A, 0x0A, 0x07, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2A, 0x0A, 0x0B, 0x00, 0x30, 0x0A, 
  0x09, 0x00, 0x2A, 0x0B, 0x09, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x26, 0x09, 0x00, 0x00, 0x26, 0x0B, 
  0x00, 0x00, 0x31, 0x0A, 0x09, 0x0B, 0x28, 0x09, 0x00, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 
  0x0A, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x05, 0x00, 0x33, 0x0A, 
  0x0B, 0x00, 0x2A, 0x09, 0x0C, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x34, 0x09, 
  0x00, 0x00, 0x8C, 0xBE, 0x01, 0x03, 0x1E, 0x00, 0x1E, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x03, 0x01, 0x2C, 0x00, 0x2C, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 
  0x2E, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x01, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 
  0x16, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x81, 0x1D, 
  0xDA, 0x73, 0xD2, 0x0D, 0x01, 0xDA, 0x82, 0x40, 0xDA, 0x44, 0xDA, 0x4A, 0xDA, 0x80, 0xB9, 0xDA, 
  0x49, 0xDA, 0x82, 0x3F, 0xDA, 0x82, 0x44, 0xDA, 0x29, 0xCF, 0x06, 0x73, 0x70, 0x6C, 0x69, 0x63, 
  0x65, 0xDA, 0x82, 0x54, 0xDA, 0x82, 0x42, 0xDA, 0x82, 0x41, 0xDA, 0x82, 0x43, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0A, 0x03, 0x02, 0x03, 0x00, 0x11, 0xCE, 0x08, 0x69, 0x6E, 0x64, 0x65, 
  0x78, 0x2D, 0x6F, 0x66, 0xDA, 0x18, 0x2C, 0x03, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 
  0x01, 0x05, 0x19, 0x05, 0x04, 0x00, 0x19, 0x06, 0x02, 0x00, 0x26, 0x08, 0x00, 0x00, 0x48, 0x07, 
  0x08, 0x05, 0x1C, 0x07, 0x09, 0x00, 0x38, 0x08, 0x01, 0x05, 0x23, 0x09, 0x08, 0x00, 0x1C, 0x09, 
  0x04, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x05, 
  0x01, 0x05, 0x1A, 0xF6, 0xFF, 0xFF, 0x03, 0x06, 0x00, 0x00, 0x84, 0x2D, 0x01, 0x05, 0x0A, 0x00, 
  0x0A, 0x00, 0x03, 0x01, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0B, 0x00, 
  0x05, 0x00, 0x1C, 0x00, 0x28, 0x00, 0x05, 0x01, 0x0C, 0xBF, 0xFE, 0x03, 0xBF, 0xF9, 0x01, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 0x07, 0x13, 0xCE, 0x18, 0x70, 0x72, 
  0x69, 0x6E, 0x74, 0x2D, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6C, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 
  0x2D, 0x65, 0x6E, 0x74, 0x72, 0x79, 0xDA, 0x18, 0xCE, 0x12, 0x20, 0x20, 0x20, 0x20, 0x73, 0x70, 
  0x65, 0x63, 0x69, 0x61, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x0A, 0x0A, 0xDA, 0x81, 0x38, 0xCE, 
  0x05, 0x20, 0x20, 0x20, 0x20, 0x28, 0xCE, 0x07, 0x20, 0x2E, 0x2E, 0x2E, 0x29, 0x0A, 0x0A, 0xCE, 
  0x33, 0x20, 0x20, 0x20, 0x20, 0x53, 0x65, 0x65, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 
  0x2F, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x2D, 0x6C, 0x61, 0x6E, 0x67, 0x2E, 0x6F, 0x72, 0x67, 0x2F, 
  0x64, 0x6F, 0x63, 0x73, 0x2F, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6C, 0x73, 0x2E, 0x68, 0x74, 
  0x6D, 0x6C, 0x0A, 0x0A, 0xCE, 0x02, 0x0A, 0x0A, 0xDA, 0x82, 0x70, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 
  0x03, 0x02, 0x00, 0x2A, 0x04, 0x03, 0x00, 0x31, 0x03, 0x00, 0x04, 0x2A, 0x04, 0x01, 0x00, 0x33, 
  0x03, 0x04, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 
  0x04, 0x05, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x31, 0x05, 0x02, 0x03, 0x2F, 0x04, 0x00, 0x00, 0x2A, 
  0x05, 0x06, 0x00, 0x34, 0x05, 0x00, 0x00, 0x8C, 0xDE, 0x01, 0x03, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x01, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x0A, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 
  0x81, 0x38, 0xDA, 0x85, 0x29, 0xDA, 0x85, 0x2E, 0xDA, 0x08, 0xDA, 0x03, 0xD0, 0x04, 0x6B, 0x69, 
  0x6E, 0x64, 0xD0, 0x06, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x11, 0x01, 0x01, 0x01, 0x15, 0x80, 0x80, 0xCE, 0x12, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x2D, 
  0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2D, 0x65, 0x6E, 0x74, 0x72, 0x79, 0xDA, 0x18, 0xDA, 0x81, 
  0x8B, 0xDA, 0x51, 0xDA, 0x1C, 0xD0, 0x03, 0x76, 0x61, 0x72, 0xCE, 0x02, 0x20, 0x28, 0xCE, 0x01, 
  0x29, 0xDA, 0x81, 0x38, 0xDA, 0x2B, 0xDA, 0x86, 0x20, 0xDA, 0x86, 0x1F, 0xDA, 0x06, 0xCE, 0x04, 
  0x20, 0x20, 0x20, 0x20, 0xDA, 0x81, 0x51, 0xDA, 0x03, 0xDA, 0x08, 0xCE, 0x09, 0x20, 0x6F, 0x6E, 
  0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0xDA, 0x83, 0xC6, 0xDA, 0x81, 0x1A, 0xCE, 0x1D, 0x0A, 0x20, 
  0x20, 0x20, 0x20, 0x6E, 0x6F, 0x20, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0x0A, 0xDA, 0x86, 0x1E, 0xDA, 0x82, 
  0x70, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x03, 0x00, 
  0x00, 0x1C, 0x03, 0x0B, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x33, 0x04, 0x00, 
  0x00, 0x29, 0x06, 0x00, 0x00, 0x38, 0x05, 0x04, 0x06, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 
  0x00, 0x33, 0x04, 0x06, 0x00, 0x19, 0x02, 0x04, 0x00, 0x1A, 0x36, 0x00, 0x00, 0x2A, 0x05, 0x01, 
  0x00, 0x2F, 0x05, 0x00, 0x00, 0x33, 0x05, 0x00, 0x00, 0x1C, 0x05, 0x12, 0x00, 0x2A, 0x06, 0x01, 
  0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x06, 0x00, 0x00, 0x29, 0x08, 0x00, 0x00, 0x38, 0x07, 0x06, 
  0x08, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x33, 0x06, 0x08, 0x00, 0x2A, 0x07, 0x03, 
  0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x07, 0x08, 0x06, 0x2A, 0x07, 0x05, 0x00, 0x2F, 0x07, 0x00, 
  0x00, 0x2A, 0x08, 0x06, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x04, 0x07, 0x00, 0x1A, 0x20, 0x00, 
  0x00, 0x2A, 0x07, 0x07, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x07, 0x00, 0x00, 0x1C, 0x07, 0x03, 
  0x00, 0x2A, 0x06, 0x07, 0x00, 0x1A, 0x19, 0x00, 0x00, 0x2A, 0x09, 0x08, 0x00, 0x2F, 0x09, 0x00, 
  0x00, 0x33, 0x09, 0x00, 0x00, 0x1C, 0x09, 0x0D, 0x00, 0x2A, 0x0A, 0x09, 0x00, 0x2F, 0x0A, 0x00, 
  0x00, 0x33, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x2A, 0x0C, 0x04, 0x00, 0x31, 0x0B, 0x0C, 
  0x0A, 0x2A, 0x0B, 0x05, 0x00, 0x2F, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x06, 0x00, 0x33, 0x0B, 0x0C, 
  0x00, 0x19, 0x08, 0x0B, 0x00, 0x1A, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x0A, 0x00, 0x2F, 0x0A, 0x00, 
  0x00, 0x33, 0x0A, 0x00, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0C, 0x02, 0x00, 0x33, 0x0B, 0x0C, 
  0x00, 0x19, 0x08, 0x0B, 0x00, 0x19, 0x06, 0x08, 0x00, 0x19, 0x04, 0x06, 0x00, 0x19, 0x02, 0x04, 
  0x00, 0x2A, 0x03, 0x0B, 0x00, 0x2A, 0x04, 0x0C, 0x00, 0x31, 0x03, 0x02, 0x04, 0x2A, 0x04, 0x06, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x0D, 0x00, 0x2F, 0x04, 0x00, 
  0x00, 0x33, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2A, 0x06, 0x0E, 0x00, 0x2F, 0x06, 0x00, 
  0x00, 0x33, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x19, 0x08, 0x05, 0x00, 0x1C, 0x08, 0x1B, 
  0x00, 0x3B, 0x0A, 0x08, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x3B, 0x0A, 0x08, 0x01, 0x19, 0x0C, 0x0A, 
  0x00, 0x3B, 0x0A, 0x08, 0x02, 0x19, 0x0D, 0x0A, 0x00, 0x1C, 0x0C, 0x03, 0x00, 0x19, 0x0E, 0x0D, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0E, 0x0C, 0x00, 0x1C, 0x0E, 0x09, 0x00, 0x2A, 0x0F, 0x0F, 
  0x00, 0x2A, 0x10, 0x10, 0x00, 0x31, 0x0F, 0x0C, 0x10, 0x2F, 0x0D, 0x00, 0x00, 0x2A, 0x10, 0x06, 
  0x00, 0x33, 0x0F, 0x10, 0x00, 0x19, 0x0A, 0x0F, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x0A, 0x00, 
  0x00, 0x2A, 0x0E, 0x0B, 0x00, 0x31, 0x0E, 0x0B, 0x0A, 0x2A, 0x0F, 0x06, 0x00, 0x33, 0x0E, 0x0F, 
  0x00, 0x19, 0x09, 0x0E, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x09, 0x00, 0x00, 0x1C, 0x05, 0x03, 
  0x00, 0x2A, 0x08, 0x0C, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x08, 0x00, 0x00, 0x1C, 0x07, 0x06, 
  0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0C, 0x11, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x0A, 0x0B, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x0A, 0x12, 0x00, 0x2A, 0x0B, 0x13, 0x00, 0x31, 0x0B, 0x02, 
  0x09, 0x2A, 0x0B, 0x0C, 0x00, 0x31, 0x08, 0x0A, 0x0B, 0x2A, 0x0B, 0x14, 0x00, 0x34, 0x0B, 0x00, 
  0x00, 0x8C, 0xC9, 0x01, 0x05, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFF, 0x0D, 0x01, 0x24, 0x00, 
  0x24, 0x00, 0x24, 0x00, 0x20, 0x00, 0x20, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0xBF, 0xFF, 0x0D, 
  0x00, 0x0D, 0x02, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFE, 0x0D, 0x02, 0x34, 0x00, 0x34, 0x00, 
  0x34, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x18, 0x00, 0x18, 0x00, 
  0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0xBF, 0xFE, 0x0D, 0x00, 0x0D, 0x03, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFD, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x04, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0xBF, 0xFC, 0x0D, 0x04, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 
  0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0xBF, 0xFC, 0x0D, 0x00, 0x0D, 0x05, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFB, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 
  0x00, 0x0D, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 
  0x09, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 
  0x03, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x01, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x20, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 
  0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFF, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x02, 0x0A, 0x00, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0x01, 0x0A, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x0A, 0x00, 0x0A, 0x00, 
  0x0A, 0xBF, 0xFB, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCE, 0x07, 
  0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0xCE, 0x0B, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 
  0x75, 0x6E, 0x64, 0x2E, 0xDA, 0x82, 0x70, 0xDA, 0x82, 0x45, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x05, 0x00, 0x2E, 0x03, 
  0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x1C, 0x00, 
  0x39, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 
  0x03, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x33, 0x03, 0x05, 0x00, 0x1C, 0x03, 
  0x2E, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x30, 0x00, 0x05, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x33, 0x05, 
  0x06, 0x00, 0x1C, 0x05, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x06, 0x06, 0x00, 0x34, 0x06, 
  0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x07, 0x07, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2F, 0x06, 
  0x00, 0x00, 0x2A, 0x08, 0x08, 0x00, 0x33, 0x07, 0x08, 0x00, 0x3B, 0x06, 0x07, 0x00, 0x19, 0x08, 
  0x06, 0x00, 0x3B, 0x06, 0x07, 0x01, 0x19, 0x09, 0x06, 0x00, 0x2A, 0x07, 0x09, 0x00, 0x38, 0x06, 
  0x07, 0x08, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x13, 0x00, 0x26, 0x06, 0x00, 0x00, 0x26, 0x0A, 
  0x00, 0x00, 0x31, 0x08, 0x06, 0x0A, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x0B, 0x0A, 0x00, 0x38, 0x0A, 
  0x07, 0x0B, 0x2A, 0x0B, 0x0B, 0x00, 0x2A, 0x0C, 0x0C, 0x00, 0x31, 0x0B, 0x06, 0x0C, 0x2A, 0x0B, 
  0x0D, 0x00, 0x27, 0x0C, 0x00, 0x00, 0x31, 0x09, 0x0B, 0x0C, 0x2A, 0x0B, 0x0A, 0x00, 0x30, 0x0B, 
  0x0A, 0x00, 0x41, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x0A, 0x0E, 0x00, 0x34, 0x0A, 
  0x00, 0x00, 0x2A, 0x06, 0x0F, 0x00, 0x2A, 0x0A, 0x10, 0x00, 0x31, 0x06, 0x00, 0x0A, 0x2A, 0x06, 
  0x11, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x0E, 0x00, 0x34, 0x05, 
  0x00, 0x00, 0x2A, 0x03, 0x12, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 
  0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0xDA, 0x18, 
  0xDA, 0x82, 0x6B, 0x2B, 0x01, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x34, 
  0x01, 0x00, 0x00, 0xBF, 0xFF, 0x8C, 0xEB, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x8C, 0xE5, 
  0x01, 0x05, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x02, 0x12, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xBF, 0xFE, 0x03, 0x06, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x01, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x07, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x09, 0x02, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x02, 0x33, 0x00, 0x33, 0x00, 0x33, 0x00, 0x26, 0x00, 0x26, 0x00, 
  0x26, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x0D, 0x00, 
  0x0D, 0x03, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x01, 0x29, 0x00, 0x29, 0xBF, 0xFD, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x04, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x03, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x00, 
  0x00, 0x00, 0xCF, 0x03, 0x62, 0x6F, 0x72, 0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x0E, 0x06, 0x00, 
  0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x03, 0x62, 0x6F, 0x72, 0x3D, 0x01, 0x00, 
  0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x00, 0x00, 0x3B, 0x04, 0x00, 
  0x00, 0x0F, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 
  0x00, 0x38, 0x04, 0x00, 0x05, 0x0F, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 
  0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x06, 0x74, 0x72, 0x61, 0x63, 0x65, 
  0x76, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x15, 0x01, 0x01, 0x01, 0x15, 0x4D, 0xCE, 0x06, 
  0x74, 0x72, 0x61, 0x63, 0x65, 0x76, 0xDA, 0x18, 0xDA, 0x81, 0xF1, 0xDA, 0x80, 0xF1, 0xDA, 0x81, 
  0x1D, 0xDA, 0x84, 0x21, 0xDA, 0x84, 0x02, 0xCE, 0x0A, 0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x5B, 
  0x25, 0x73, 0x5D, 0xDA, 0x46, 0xCE, 0x05, 0x74, 0x72, 0x61, 0x63, 0x65, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x07, 0xCE, 0x04, 0x6E, 0x65, 0x67, 0x3F, 0xDA, 
  0x18, 0xDA, 0x82, 0xF8, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x30, 0x00, 0x02, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x24, 0x03, 0x02, 0xFF, 0x03, 0x03, 0x00, 0x00, 
  0x83, 0x24, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 0xDA, 
  0x83, 0xEC, 0xCE, 0x17, 0x20, 0x6F, 0x6E, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x25, 0x64, 0x2C, 
  0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x25, 0x64, 0x3A, 0xCE, 0x07, 0x20, 0x25, 0x6A, 
  0x20, 0x69, 0x73, 0x20, 0xDA, 0x81, 0x38, 0xDA, 0x43, 0xDA, 0x44, 0xDA, 0x82, 0x44, 0xDA, 0x83, 
  0xC4, 0xDA, 0x82, 0xB4, 0xDA, 0x82, 0xB5, 0xDA, 0x83, 0xBE, 0xDA, 0x82, 0x42, 0x2C, 0x01, 0x00, 
  0x00, 0x2A, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x02, 
  0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x03, 0x00, 0x33, 0x03, 0x04, 
  0x00, 0x3B, 0x02, 0x03, 0x00, 0x19, 0x04, 0x02, 0x00, 0x3B, 0x02, 0x03, 0x01, 0x19, 0x05, 0x02, 
  0x00, 0x2A, 0x02, 0x04, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x02, 0x06, 
  0x00, 0x19, 0x06, 0x02, 0x00, 0x1C, 0x06, 0x07, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x30, 0x08, 0x06, 
  0x00, 0x2A, 0x09, 0x06, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x07, 0x08, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x2A, 0x07, 0x07, 0x00, 0x19, 0x08, 0x07, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x0B, 0x08, 
  0x00, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x1C, 0x0B, 0x03, 0x00, 0x19, 0x0A, 0x0B, 
  0x00, 0x1A, 0x05, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x33, 0x0C, 0x0D, 
  0x00, 0x19, 0x0A, 0x0C, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x2A, 0x09, 0x09, 0x00, 0x1A, 0x06, 0x00, 
  0x00, 0x2A, 0x0B, 0x0A, 0x00, 0x31, 0x0B, 0x04, 0x05, 0x2A, 0x0C, 0x06, 0x00, 0x33, 0x0B, 0x0C, 
  0x00, 0x19, 0x09, 0x0B, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x2A, 0x0B, 0x0B, 0x00, 0x31, 0x08, 0x0A, 
  0x0B, 0x2A, 0x0C, 0x0C, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x2A, 0x0E, 0x0D, 
  0x00, 0x33, 0x0D, 0x0E, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x2A, 0x10, 0x0E, 0x00, 0x31, 0x10, 0x0E, 
  0x00, 0x43, 0x0F, 0x00, 0x00, 0x2A, 0x11, 0x0F, 0x00, 0x30, 0x11, 0x00, 0x00, 0x43, 0x10, 0x00, 
  0x00, 0x2A, 0x12, 0x10, 0x00, 0x31, 0x12, 0x0C, 0x10, 0x43, 0x11, 0x00, 0x00, 0x2A, 0x12, 0x02, 
  0x00, 0x2A, 0x13, 0x11, 0x00, 0x2A, 0x14, 0x12, 0x00, 0x31, 0x12, 0x13, 0x14, 0x43, 0x10, 0x00, 
  0x00, 0x2A, 0x13, 0x13, 0x00, 0x31, 0x13, 0x10, 0x0E, 0x43, 0x12, 0x00, 0x00, 0x2A, 0x13, 0x14, 
  0x00, 0x31, 0x13, 0x0F, 0x11, 0x30, 0x12, 0x0E, 0x00, 0x43, 0x10, 0x00, 0x00, 0x03, 0x10, 0x00, 
  0x00, 0x84, 0xC5, 0x01, 0x04, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x12, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x0E, 0x00, 0x03, 
  0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0F, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0xD8, 0x0F, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0xCF, 0x05, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0xDA, 0x82, 0x57, 0xCF, 0x07, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x07, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xD0, 0x06, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x64, 
  0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0xCF, 0x03, 0x2D, 
  0x3E, 0x3E, 0xD7, 0x00, 0xCD, 0x00, 0xB9, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x01, 0x06, 0x01, 0xCE, 0x03, 0x2D, 0x3E, 0x3E, 0xDA, 0x18, 0xDA, 0x80, 0xDF, 0x2C, 0x02, 
  0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x31, 0x04, 0x00, 0x01, 0x2A, 0x05, 
  0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x06, 
  0x27, 0xDA, 0x80, 0xE1, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x76, 0xDA, 0x80, 0xE2, 0xDA, 0x78, 0xDA, 
  0x80, 0xE3, 0xDA, 0x80, 0xE4, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x00, 
  0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x0C, 
  0x00, 0x29, 0x06, 0x00, 0x00, 0x38, 0x04, 0x01, 0x06, 0x29, 0x06, 0x01, 0x00, 0x30, 0x01, 0x06, 
  0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 0x03, 
  0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x03, 0x07, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x3E, 0x04, 0x00, 
  0x00, 0x30, 0x01, 0x04, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x03, 0x06, 
  0x00, 0x3B, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3B, 0x04, 0x03, 0x01, 0x19, 0x06, 0x04, 
  0x00, 0x2F, 0x05, 0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x3E, 0x07, 0x00, 
  0x00, 0x31, 0x04, 0x06, 0x07, 0x2A, 0x09, 0x04, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x04, 0x08, 
  0x00, 0x29, 0x07, 0x00, 0x00, 0x30, 0x04, 0x07, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x34, 0x07, 0x00, 
  0x00, 0x84, 0xE7, 0x03, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 
  0x01, 0x19, 0x00, 0x19, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0xBF, 0xFF, 0x10, 0x00, 0x10, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 
  0xFE, 0x10, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 
  0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x84, 0xE2, 0x01, 0x05, 0x03, 0x00, 0x03, 0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 
  0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0xD8, 0x0C, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0xCF, 0x09, 0x65, 0x76, 0x2F, 
  0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0xD8, 0x09, 0x65, 0x76, 0x2F, 0x63, 0x61, 0x6E, 0x63, 0x65, 
  0x6C, 0xCF, 0x08, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x2D, 0x6F, 0x66, 0xDA, 0x86, 0x16, 0xCF, 0x05, 
  0x61, 0x73, 0x3F, 0x2D, 0x3E, 0xD7, 0x00, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x07, 0x02, 0x02, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x08, 0x02, 0xCE, 0x05, 0x61, 0x73, 0x3F, 0x2D, 0x3E, 0xDA, 0x18, 
  0xDA, 0x43, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x01, 0x07, 0x01, 
  0xCE, 0x08, 0x70, 0x6F, 0x73, 0x74, 0x77, 0x61, 0x6C, 0x6B, 0xDA, 0x18, 0xDA, 0x81, 0x7E, 0x2C, 
  0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x30, 0x03, 0x01, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 
  0x04, 0x05, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 
  0x02, 0x01, 0x01, 0x01, 0x00, 0x04, 0x01, 0xDA, 0x18, 0x2B, 0x01, 0x00, 0x00, 0x30, 0x01, 0x00, 
  0x00, 0x2B, 0x01, 0x00, 0x02, 0x34, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0x2E, 0x14, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x85, 0x2A, 0x01, 0x04, 0x0C, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 
  0x03, 0x00, 0x03, 0x05, 0x00, 0x00, 0x00, 0xDA, 0x67, 0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 0x00, 
  0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x02, 0x06, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x05, 0x01, 
  0x00, 0x33, 0x05, 0x05, 0x00, 0x03, 0x04, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 
  0x01, 0x01, 0x00, 0x06, 0x01, 0xDA, 0x18, 0x2B, 0x02, 0x00, 0x01, 0x23, 0x01, 0x00, 0x02, 0x1C, 
  0x01, 0x03, 0x00, 0x2B, 0x02, 0x00, 0x08, 0x03, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 
  0xFF, 0x85, 0x4A, 0x2A, 0x00, 0x2A, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0xCD, 0x02, 
  0xFA, 0x00, 0x00, 0x07, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x1C, 0x01, 0x01, 0xCE, 
  0x06, 0x5F, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x86, 0x49, 0xDA, 0x67, 
  0x2B, 0x00, 0x00, 0x06, 0x1E, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x02, 
  0x2B, 0x02, 0x00, 0x06, 0x38, 0x00, 0x01, 0x02, 0x19, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 
  0x33, 0x00, 0x02, 0x00, 0x19, 0x02, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x00, 0x03, 0x00, 0x2B, 0x04, 0x00, 0x04, 
  0x30, 0x02, 0x04, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 0x05, 0x03, 0x00, 
  0x43, 0x04, 0x00, 0x00, 0x2D, 0x04, 0x00, 0x04, 0x2B, 0x05, 0x00, 0x02, 0x2B, 0x06, 0x00, 0x06, 
  0x47, 0x03, 0x05, 0x06, 0x2D, 0x03, 0x00, 0x06, 0x2C, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 
  0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x06, 0x02, 0xDA, 0x18, 
  0x2B, 0x02, 0x00, 0x01, 0x23, 0x01, 0x00, 0x02, 0x1C, 0x01, 0x03, 0x00, 0x2B, 0x02, 0x01, 0x02, 
  0x03, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0x4A, 0x2A, 0x00, 0x2A, 
  0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x85, 0x48, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x1E, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x85, 0x41, 0x01, 0x06, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF9, 0x01, 0x56, 0x01, 0x00, 0x00, 0xCF, 0x06, 0x63, 0x6F, 
  0x6D, 0x70, 0x69, 0x66, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x03, 0x02, 0x03, 0x01, 
  0x07, 0xCE, 0x06, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x66, 0xDA, 0x18, 0xDA, 0x82, 0xE0, 0x2C, 0x03, 
  0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 
  0x02, 0x00, 0x03, 0x01, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x8A, 0x31, 0x01, 0x03, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x77, 
  0x68, 0x65, 0x6E, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x02, 0x0B, 0xCE, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x77, 0x68, 0x65, 0x6E, 0xDA, 0x18, 
  0xDA, 0x82, 0xE0, 0xDA, 0x82, 0x42, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x06, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x2F, 0x05, 
  0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0x8A, 0x38, 0x01, 0x03, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x01, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0xCF, 0x0D, 0x6B, 0x65, 0x79, 0x77, 
  0x6F, 0x72, 0x64, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xD8, 0x0D, 0x6B, 0x65, 0x79, 0x77, 0x6F, 
  0x72, 0x64, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xCF, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x63, 
  0x6C, 0x6F, 0x73, 0x65, 0xDA, 0x83, 0x54, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x6D, 0x6B, 0x64, 0x69, 
  0x72, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0xCF, 0x03, 0x2D, 0x3F, 0x3E, 
  0xD7, 0x00, 0xCD, 0x00, 0xB9, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 
  0x06, 0x01, 0xCE, 0x03, 0x2D, 0x3F, 0x3E, 0xDA, 0x18, 0xDA, 0x80, 0xDF, 0x2C, 0x02, 0x00, 0x00, 
  0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x31, 0x04, 0x00, 0x01, 0x2A, 0x05, 0x00, 0x00, 
  0x34, 0x05, 0x00, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x09, 0x31, 0xDA, 
  0x80, 0xE1, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x76, 0xDA, 0x80, 0xE2, 0xDA, 0x78, 0xDA, 0x43, 0xDA, 
  0x80, 0xE3, 0xDA, 0x80, 0xE4, 0xDA, 0x49, 0xDA, 0x80, 0xC2, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 
  0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 
  0x06, 0x04, 0x1C, 0x05, 0x0C, 0x00, 0x29, 0x06, 0x00, 0x00, 0x38, 0x04, 0x01, 0x06, 0x29, 0x06, 
  0x01, 0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x04, 
  0x06, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x03, 0x07, 0x00, 0x1A, 0x06, 
  0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 0x30, 0x01, 0x04, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 
  0x07, 0x00, 0x19, 0x03, 0x06, 0x00, 0x3B, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3B, 0x04, 
  0x03, 0x01, 0x19, 0x06, 0x04, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x33, 0x04, 0x07, 0x00, 0x19, 0x07, 
  0x04, 0x00, 0x30, 0x05, 0x07, 0x00, 0x3E, 0x08, 0x00, 0x00, 0x30, 0x08, 0x06, 0x00, 0x2A, 0x0A, 
  0x05, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 0x08, 0x09, 0x00, 0x30, 0x07, 0x00, 0x00, 0x44, 0x0A, 
  0x00, 0x00, 0x29, 0x0B, 0x00, 0x00, 0x30, 0x08, 0x0B, 0x00, 0x2A, 0x0C, 0x06, 0x00, 0x33, 0x0B, 
  0x0C, 0x00, 0x2A, 0x0D, 0x07, 0x00, 0x31, 0x0D, 0x07, 0x0B, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 
  0x08, 0x00, 0x31, 0x0D, 0x0A, 0x0C, 0x43, 0x0B, 0x00, 0x00, 0x03, 0x0B, 0x00, 0x00, 0x84, 0xF6, 
  0x03, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x01, 0x19, 0x00, 
  0x19, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 
  0xFF, 0x10, 0x00, 0x10, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFE, 0x10, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x22, 0x00, 
  0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x84, 0xEF, 0x01, 0x07, 0x03, 0x00, 0x03, 0x07, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xCF, 0x0E, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67, 
  0xDA, 0x85, 0x73, 0xCF, 0x09, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x73, 0x79, 0x6D, 0x73, 0xD7, 0x00, 
  0xCD, 0x00, 0x99, 0x00, 0x00, 0x0C, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x16, 0xCE, 
  0x09, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x73, 0x79, 0x6D, 0x73, 0xDA, 0x18, 0xD2, 0x01, 0x00, 0xDA, 
  0x43, 0xDA, 0x81, 0x4C, 0xDA, 0x80, 0xC2, 0x2C, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x3D, 
  0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3E, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x21, 
  0x08, 0x03, 0x05, 0x1C, 0x08, 0x08, 0x00, 0x38, 0x09, 0x00, 0x03, 0x2A, 0x0A, 0x00, 0x00, 0x31, 
  0x07, 0x09, 0x0A, 0x2A, 0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x05, 0x03, 0x03, 0x01, 0x1A, 
  0xF8, 0xFF, 0xFF, 0x32, 0x07, 0x00, 0x00, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x30, 
  0x0A, 0x08, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x09, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x81, 
  0x37, 0x01, 0x03, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 
  0x01, 0x17, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0xBF, 0xFE, 0x03, 0x03, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x07, 0x65, 
  0x78, 0x74, 0x72, 0x65, 0x6D, 0x65, 0xDA, 0x81, 0x49, 0xCF, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x74, 
  0x69, 0x6D, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x04, 
  0xCE, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x74, 0x69, 0x6D, 0x65, 0xDA, 0x18, 0xDA, 0x82, 0xE0, 0x2C, 
  0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x34, 0x02, 0x00, 0x00, 0x8A, 
  0x2C, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 
  0xDA, 0x85, 0xF7, 0xCF, 0x04, 0x68, 0x61, 0x73, 0x68, 0xD8, 0x04, 0x68, 0x61, 0x73, 0x68, 0xCF, 
  0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 0x73, 0x68, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x63, 0x6F, 0x73, 0x68, 0xCF, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x72, 
  0x72, 0x6F, 0x72, 0xDA, 0x82, 0xDD, 0xCF, 0x0A, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 
  0x65, 0x70, 0xDA, 0x83, 0x5C, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 0x66, 0xD8, 
  0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 0x66, 0xCF, 0x0A, 0x6D, 0x65, 0x72, 0x67, 0x65, 
  0x2D, 0x69, 0x6E, 0x74, 0x6F, 0xDA, 0x83, 0xD2, 0xCF, 0x0C, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xD8, 0x0C, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x73, 
  0x6C, 0x69, 0x63, 0x65, 0xCF, 0x0B, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x62, 0x72, 0x65, 0x61, 
  0x6B, 0xD8, 0x0B, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xCF, 0x0C, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x65, 0xD8, 0x0C, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x65, 0xCF, 0x06, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x3F, 0xDA, 0x53, 0xCF, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x69, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0xD8, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 
  0xCF, 0x0E, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 0x6E, 0x66, 0x62, 0x72, 0x65, 0x61, 0x6B, 
  0xDA, 0x83, 0x74, 0xCF, 0x0D, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x2F, 0x76, 0x65, 0x72, 0x73, 0x69, 
  0x6F, 0x6E, 0xCE, 0x06, 0x31, 0x2E, 0x32, 0x36, 0x2E, 0x30, 0xCF, 0x0F, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xD8, 0x0F, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xCF, 0x06, 0x65, 0x6D, 
  0x70, 0x74, 0x79, 0x3F, 0xDA, 0x84, 0x12, 0xCF, 0x08, 0x70, 0x6F, 0x73, 0x74, 0x77, 0x61, 0x6C, 
  0x6B, 0xDA, 0x86, 0x49, 0xCF, 0x03, 0x64, 0x6F, 0x63, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x05, 0x01, 0x00, 0x01, 0x02, 0x08, 0xCE, 0x03, 0x64, 0x6F, 0x63, 0xDA, 0x18, 0xDA, 0x82, 0x44, 
  0xDA, 0x86, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x30, 0x03, 0x00, 0x00, 0x43, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x30, 0x04, 0x02, 0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 
  0x03, 0x00, 0x00, 0x8D, 0x01, 0x01, 0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xCF, 0x0B, 0x62, 0x61, 0x64, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 
  0x65, 0xDA, 0x83, 0xE9, 0xCF, 0x14, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2F, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0x2D, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 0xD8, 0x14, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x2F, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x2D, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 
  0xCF, 0x09, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0xD7, 0x00, 0xCD, 0x00, 0x99, 
  0x00, 0x00, 0x05, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x07, 0xCE, 0x09, 0x64, 0x65, 
  0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0xDA, 0x18, 0xDA, 0x2B, 0xDA, 0x52, 0xDA, 0x81, 0xB7, 
  0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x31, 0x00, 0x03, 0x04, 
  0x32, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x34, 0x03, 0x00, 0x00, 0x3B, 0x01, 0x03, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 0x73, 0x6F, 0x72, 0x74, 
  0x65, 0x64, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x02, 0x01, 0x02, 0x02, 0x07, 0xCE, 
  0x06, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0xDA, 0x18, 0xDA, 0x80, 0xE2, 0xDA, 0x85, 0xE5, 0x2C, 
  0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x30, 
  0x03, 0x01, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x83, 0x56, 0x01, 0x05, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0C, 0x61, 0x6C, 0x6C, 0x2D, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0xDA, 0x86, 0x09, 0xCF, 0x0B, 0x64, 0x69, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x61, 0x72, 0x79, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 
  0x01, 0x01, 0x01, 0x03, 0x0D, 0xCE, 0x0B, 0x64, 0x69, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x72, 
  0x79, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x75, 0xDA, 0x74, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x05, 
  0x01, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x03, 0x00, 0x27, 0x05, 0x00, 0x00, 0x03, 0x05, 
  0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 0x05, 0x03, 0x06, 0x03, 0x05, 0x00, 0x00, 0x75, 0x01, 
  0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xCF, 0x07, 0x2A, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x2A, 0xDA, 0x83, 0xDB, 0xCF, 0x0C, 0x61, 0x6C, 0x6C, 0x2D, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 
  0x63, 0x73, 0xDA, 0x86, 0x0E, 0xCF, 0x08, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0xDA, 
  0x86, 0x10, 0xCF, 0x13, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2D, 0x70, 0x65, 0x67, 0x2D, 
  0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0xD3, 0x14, 0xD0, 0x02, 0x73, 0x2A, 0xD2, 0x02, 0x00, 
  0xCF, 0x03, 0x61, 0x6E, 0x79, 0xD0, 0x01, 0x73, 0xD0, 0x02, 0x73, 0x2B, 0xD2, 0x02, 0x00, 0xCF, 
  0x04, 0x73, 0x6F, 0x6D, 0x65, 0xDA, 0x86, 0x94, 0xD0, 0x01, 0x61, 0xD2, 0x03, 0x00, 0xCF, 0x05, 
  0x72, 0x61, 0x6E, 0x67, 0x65, 0xCE, 0x02, 0x61, 0x7A, 0xCE, 0x02, 0x41, 0x5A, 0xD0, 0x02, 0x77, 
  0x2B, 0xD2, 0x02, 0x00, 0xDA, 0x86, 0x97, 0xD0, 0x01, 0x77, 0xD0, 0x02, 0x77, 0x2A, 0xD2, 0x02, 
  0x00, 0xDA, 0x86, 0x93, 0xDA, 0x86, 0x9F, 0xD0, 0x01, 0x64, 0xD2, 0x02, 0x00, 0xDA, 0x86, 0x9A, 
  0xCE, 0x02, 0x30, 0x39, 0xD0, 0x01, 0x68, 0xD2, 0x04, 0x00, 0xDA, 0x86, 0x9A, 0xDA, 0x86, 0xA4, 
  0xCE, 0x02, 0x61, 0x66, 0xCE, 0x02, 0x41, 0x46, 0xD0, 0x02, 0x64, 0x2A, 0xD2, 0x02, 0x00, 0xDA, 
  0x86, 0x93, 0xDA, 0x86, 0xA3, 0xD0, 0x02, 0x64, 0x2B, 0xD2, 0x02, 0x00, 0xDA, 0x86, 0x97, 0xDA, 
  0x86, 0xA3, 0xD0, 0x02, 0x68, 0x2A, 0xD2, 0x02, 0x00, 0xDA, 0x86, 0x93, 0xDA, 0x86, 0xA6, 0xDA, 
  0x86, 0x94, 0xD2, 0x02, 0x00, 0xDA, 0x29, 0xCE, 0x07, 0x20, 0x09, 0x0D, 0x0A, 0x00, 0x0C, 0x0B, 
  0xD0, 0x02, 0x68, 0x2B, 0xD2, 0x02, 0x00, 0xDA, 0x86, 0x97, 0xDA, 0x86, 0xA6, 0xDA, 0x86, 0x9F, 
  0xD2, 0x04, 0x00, 0xDA, 0x86, 0x9A, 0xDA, 0x86, 0x9B, 0xDA, 0x86, 0x9C, 0xDA, 0x86, 0xA4, 0xD0, 
  0x01, 0x41, 0xD2, 0x03, 0x00, 0xDA, 0x85, 0x90, 0xDA, 0x86, 0x99, 0x01, 0xD0, 0x01, 0x44, 0xD2, 
  0x03, 0x00, 0xDA, 0x85, 0x90, 0xDA, 0x86, 0xA3, 0x01, 0xD0, 0x01, 0x48, 0xD2, 0x03, 0x00, 0xDA, 
  0x85, 0x90, 0xDA, 0x86, 0xA6, 0x01, 0xD0, 0x02, 0x61, 0x2A, 0xD2, 0x02, 0x00, 0xDA, 0x86, 0x93, 
  0xDA, 0x86, 0x99, 0xD0, 0x02, 0x61, 0x2B, 0xD2, 0x02, 0x00, 0xDA, 0x86, 0x97, 0xDA, 0x86, 0x99, 
  0xD0, 0x01, 0x53, 0xD2, 0x03, 0x00, 0xDA, 0x85, 0x90, 0xDA, 0x86, 0x94, 0x01, 0xD0, 0x01, 0x57, 
  0xD2, 0x03, 0x00, 0xDA, 0x85, 0x90, 0xDA, 0x86, 0x9F, 0x01, 0xCF, 0x0A, 0x6E, 0x65, 0x74, 0x2F, 
  0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0xD8, 0x0A, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x63, 0x63, 0x65, 
  0x70, 0x74, 0xCF, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xD8, 0x0A, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xCF, 0x0E, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xDA, 0x86, 0x0D, 0xCF, 0x06, 0x64, 
  0x6F, 0x63, 0x2D, 0x6F, 0x66, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 
  0x07, 0x34, 0xCE, 0x06, 0x64, 0x6F, 0x63, 0x2D, 0x6F, 0x66, 0xDA, 0x18, 0xD2, 0x02, 0x00, 0xD2, 
  0x01, 0x00, 0xDA, 0x00, 0xDA, 0x85, 0x2E, 0xDA, 0x51, 0xDA, 0x06, 0xDA, 0x86, 0x21, 0xCE, 0x18, 
  0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0xDA, 0x86, 0x2A, 0xDA, 0x82, 0x70, 0x2C, 0x01, 
  0x00, 0x00, 0x28, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 
  0x03, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x27, 0x00, 0x38, 0x04, 0x03, 0x05, 0x19, 0x06, 
  0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x47, 0x04, 0x06, 0x07, 0x19, 0x07, 0x04, 0x00, 0x1D, 0x07, 
  0x1F, 0x00, 0x38, 0x04, 0x06, 0x07, 0x19, 0x08, 0x04, 0x00, 0x26, 0x09, 0x00, 0x00, 0x47, 0x04, 
  0x08, 0x09, 0x19, 0x09, 0x04, 0x00, 0x1D, 0x09, 0x17, 0x00, 0x38, 0x04, 0x08, 0x09, 0x19, 0x0A, 
  0x04, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x39, 0x04, 0x0A, 0x0B, 0x19, 0x0B, 0x04, 0x00, 0x1C, 0x0B, 
  0x03, 0x00, 0x19, 0x04, 0x0B, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x0D, 0x02, 0x00, 0x39, 0x0C, 
  0x0A, 0x0D, 0x19, 0x04, 0x0C, 0x00, 0x19, 0x0B, 0x04, 0x00, 0x23, 0x04, 0x0B, 0x00, 0x1C, 0x04, 
  0x07, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0D, 0x03, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x27, 0x02, 
  0x00, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x09, 0x08, 0x09, 0x1A, 0xEA, 
  0xFF, 0xFF, 0x47, 0x07, 0x06, 0x07, 0x1A, 0xE2, 0xFF, 0xFF, 0x47, 0x05, 0x03, 0x05, 0x1A, 0xDA, 
  0xFF, 0xFF, 0x1C, 0x02, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x04, 0x00, 0x2A, 0x04, 
  0x05, 0x00, 0x31, 0x03, 0x00, 0x04, 0x2A, 0x03, 0x06, 0x00, 0x34, 0x03, 0x00, 0x00, 0x8D, 0x09, 
  0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x15, 0x00, 0x15, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x26, 0x00, 0x26, 0x00, 0x11, 0x00, 0x05, 0x01, 0x0D, 0x00, 
  0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x01, 0x09, 0xBF, 0xFD, 0x07, 0xBF, 0xFC, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x08, 0x03, 0x00, 0x03, 0x01, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x0B, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 0xD8, 0x0B, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 
  0x65, 0x61, 0x72, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x6C, 0x69, 0x6E, 0x6B, 0xD8, 0x07, 0x6F, 0x73, 
  0x2F, 0x6C, 0x69, 0x6E, 0x6B, 0xCF, 0x08, 0x65, 0x76, 0x2F, 0x73, 0x6C, 0x65, 0x65, 0x70, 0xD8, 
  0x08, 0x65, 0x76, 0x2F, 0x73, 0x6C, 0x65, 0x65, 0x70, 0xCF, 0x08, 0x66, 0x66, 0x69, 0x2F, 0x66, 
  0x72, 0x65, 0x65, 0xD8, 0x08, 0x66, 0x66, 0x69, 0x2F, 0x66, 0x72, 0x65, 0x65, 0xCF, 0x0A, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x61, 0x73, 0x69, 0x6E, 0x68, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x61, 0x73, 0x69, 0x6E, 0x68, 0xCF, 0x09, 0x62, 0x61, 0x64, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0xDA, 0x83, 0xFC, 0xCF, 0x06, 0x67, 0x65, 0x6E, 0x73, 0x79, 0x6D, 0xDA, 0x43, 0xCF, 0x06, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0xDA, 0x81, 0xBA, 0xCF, 0x09, 0x76, 0x61, 0x72, 0x67, 0x6C, 0x6F, 
  0x62, 0x61, 0x6C, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x03, 0x0E, 
  0xCE, 0x09, 0x76, 0x61, 0x72, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0xDA, 0x18, 0xDA, 0x84, 0xDF, 
  0xDA, 0x51, 0xDA, 0x82, 0x5B, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x3E, 0x05, 0x00, 
  0x00, 0x2A, 0x06, 0x01, 0x00, 0x30, 0x06, 0x05, 0x00, 0x42, 0x05, 0x00, 0x00, 0x30, 0x04, 0x05, 
  0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x5B, 0x01, 0x03, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x05, 0x2A, 0x65, 0x72, 0x72, 
  0x2A, 0xD0, 0x03, 0x65, 0x72, 0x72, 0xCF, 0x05, 0x7A, 0x65, 0x72, 0x6F, 0x3F, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x07, 0xCE, 0x05, 0x7A, 0x65, 0x72, 0x6F, 
  0x3F, 0xDA, 0x18, 0xDA, 0x82, 0xF8, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x30, 0x00, 
  0x02, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x24, 0x03, 0x02, 0x00, 0x03, 0x03, 
  0x00, 0x00, 0x83, 0x22, 0x01, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x27, 0x00, 
  0x27, 0xCF, 0x09, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xDA, 0x80, 0xBA, 0xCF, 
  0x04, 0x66, 0x69, 0x6E, 0x64, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x03, 0x02, 0x03, 
  0x00, 0x13, 0xCE, 0x04, 0x66, 0x69, 0x6E, 0x64, 0xDA, 0x18, 0x2C, 0x03, 0x00, 0x00, 0x26, 0x04, 
  0x00, 0x00, 0x19, 0x05, 0x02, 0x00, 0x47, 0x04, 0x01, 0x04, 0x26, 0x07, 0x00, 0x00, 0x23, 0x06, 
  0x04, 0x07, 0x1C, 0x06, 0x03, 0x00, 0x1A, 0x0B, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x06, 
  0x01, 0x04, 0x19, 0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x06, 0x00, 0x00, 0x1C, 0x06, 
  0x04, 0x00, 0x19, 0x05, 0x07, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xF2, 
  0xFF, 0xFF, 0x03, 0x05, 0x00, 0x00, 0x84, 0x1E, 0x01, 0x04, 0x03, 0x01, 0x03, 0x02, 0x0C, 0x01, 
  0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x13, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x05, 0x01, 0x0B, 0x00, 
  0x0B, 0x00, 0x05, 0x01, 0x07, 0x01, 0x07, 0xBF, 0xFE, 0x05, 0xBF, 0xFC, 0x03, 0xBF, 0xFA, 0x01, 
  0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x62, 0x72, 0x74, 0xD8, 0x09, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x63, 0x62, 0x72, 0x74, 0xCF, 0x10, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x61, 
  0x64, 0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x73, 0xD7, 0x00, 0xCD, 0x00, 0xB8, 0x00, 0x00, 0x13, 
  0x02, 0x02, 0x02, 0x0C, 0x41, 0x01, 0xCE, 0x10, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x61, 
  0x64, 0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x73, 0xDA, 0x18, 0xCE, 0x06, 0x3A, 0x40, 0x61, 0x6C, 
  0x6C, 0x3A, 0xDA, 0x81, 0x38, 0xDA, 0x85, 0x56, 0xDA, 0x85, 0x2B, 0xDA, 0x86, 0x75, 0xCE, 0x06, 
  0x2E, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0xDA, 0x85, 0x4C, 0xCE, 0x05, 0x3A, 0x73, 0x79, 0x73, 0x3A, 
  0xCE, 0x0B, 0x3A, 0x73, 0x79, 0x73, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0xDA, 0x85, 0x41, 
  0xCE, 0x0B, 0x3A, 0x63, 0x75, 0x72, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0xDA, 0x85, 0x36, 
  0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x00, 0x00, 
  0x2F, 0x05, 0x00, 0x00, 0x33, 0x05, 0x04, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x00, 0x00, 
  0x30, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x02, 0x00, 
  0x31, 0x07, 0x01, 0x08, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x08, 0x06, 0x07, 
  0x2A, 0x09, 0x04, 0x00, 0x33, 0x08, 0x09, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x2F, 0x07, 0x00, 0x00, 
  0x33, 0x07, 0x04, 0x00, 0x19, 0x09, 0x07, 0x00, 0x2A, 0x0A, 0x05, 0x00, 0x30, 0x0A, 0x00, 0x00, 
  0x2A, 0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2A, 0x0B, 0x06, 0x00, 0x31, 0x0A, 0x01, 0x0B, 
  0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x03, 0x00, 0x31, 0x0B, 0x09, 0x0A, 0x2A, 0x0C, 0x04, 0x00, 
  0x33, 0x0B, 0x0C, 0x00, 0x2A, 0x0A, 0x07, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0A, 0x04, 0x00, 
  0x19, 0x0C, 0x0A, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x30, 0x0D, 0x00, 0x00, 0x2A, 0x0E, 0x01, 0x00, 
  0x33, 0x0D, 0x0E, 0x00, 0x2A, 0x0E, 0x09, 0x00, 0x31, 0x0D, 0x01, 0x0E, 0x43, 0x0D, 0x00, 0x00, 
  0x2A, 0x0E, 0x03, 0x00, 0x31, 0x0E, 0x0C, 0x0D, 0x2A, 0x0F, 0x04, 0x00, 0x33, 0x0E, 0x0F, 0x00, 
  0x2A, 0x0D, 0x0A, 0x00, 0x2F, 0x0D, 0x00, 0x00, 0x33, 0x0D, 0x04, 0x00, 0x19, 0x0F, 0x0D, 0x00, 
  0x2A, 0x10, 0x0A, 0x00, 0x30, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x01, 0x00, 0x33, 0x10, 0x11, 0x00, 
  0x2A, 0x11, 0x0B, 0x00, 0x31, 0x10, 0x01, 0x11, 0x43, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x03, 0x00, 
  0x31, 0x11, 0x0F, 0x10, 0x2A, 0x12, 0x04, 0x00, 0x33, 0x11, 0x12, 0x00, 0x2A, 0x10, 0x03, 0x00, 
  0x03, 0x10, 0x00, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x0B, 0x01, 
  0xCE, 0x0B, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0xDA, 0x18, 0xDA, 
  0x85, 0x2B, 0xDA, 0x82, 0x24, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 
  0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 
  0x00, 0x1C, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x10, 0x01, 0xDA, 0x18, 0xDA, 
  0x83, 0xF0, 0xDA, 0x84, 0xE8, 0x29, 0x01, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x33, 0x01, 0x00, 
  0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x01, 0x02, 
  0x00, 0x1C, 0x02, 0x08, 0x00, 0x29, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x03, 0x00, 
  0x00, 0x2B, 0x04, 0x00, 0x00, 0x30, 0x04, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 
  0x00, 0x03, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0x6D, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x8A, 0x6B, 0x03, 0x02, 0x15, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x00, 0x00, 0x00, 0x8A, 0x62, 0x01, 0x09, 0x03, 0x00, 0x03, 0x03, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x03, 0x01, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 
  0x01, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 0x29, 
  0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x03, 0x01, 0x2C, 0x00, 0x2C, 
  0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xBF, 0xED, 0x01, 0x00, 0x01, 0xCF, 0x0B, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 
  0x74, 0x61, 0x63, 0x6B, 0xDA, 0x83, 0x44, 0xCF, 0x0C, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2F, 
  0x73, 0x6C, 0x69, 0x63, 0x65, 0xD8, 0x0C, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2F, 0x73, 0x6C, 
  0x69, 0x63, 0x65, 0xCF, 0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x6A, 0x6F, 0x69, 0x6E, 
  0xDA, 0x83, 0xC2, 0xCF, 0x05, 0x6A, 0x75, 0x78, 0x74, 0x2A, 0xD7, 0x00, 0xCD, 0x02, 0xBB, 0x00, 
  0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x01, 0xCE, 0x05, 0x6A, 0x75, 
  0x78, 0x74, 0x2A, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 
  0x00, 0xCD, 0x00, 0xD1, 0x00, 0x00, 0x08, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x16, 
  0x01, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0xDA, 0x80, 0xE4, 0x3E, 0x01, 0x00, 0x00, 0x19, 0x02, 0x01, 
  0x00, 0x2B, 0x04, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x03, 0x04, 0x05, 0x19, 0x04, 0x03, 
  0x00, 0x1D, 0x04, 0x0C, 0x00, 0x2B, 0x05, 0x00, 0x00, 0x38, 0x03, 0x05, 0x04, 0x19, 0x05, 0x03, 
  0x00, 0x32, 0x00, 0x00, 0x00, 0x33, 0x03, 0x05, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x07, 0x00, 
  0x00, 0x33, 0x06, 0x07, 0x00, 0x2B, 0x03, 0x00, 0x00, 0x47, 0x04, 0x03, 0x04, 0x1A, 0xF5, 0xFF, 
  0xFF, 0x29, 0x03, 0x00, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 
  0x00, 0xBF, 0xFF, 0x84, 0x92, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x84, 0x8D, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xCF, 0x0A, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x74, 0x72, 0x75, 0x6E, 0x63, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 
  0x72, 0x75, 0x6E, 0x63, 0xCF, 0x0D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 
  0x65, 0x61, 0x74, 0xDA, 0x81, 0x50, 0xCF, 0x06, 0x66, 0x69, 0x62, 0x65, 0x72, 0x3F, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x06, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x83, 0x33, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 
  0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x65, 0x01, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2B, 
  0x00, 0x2B, 0x00, 0x2B, 0xCF, 0x03, 0x66, 0x6F, 0x72, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 
  0x08, 0x03, 0x03, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x09, 0xCE, 0x03, 0x66, 0x6F, 0x72, 0xDA, 
  0x18, 0xDA, 0x81, 0x47, 0xDA, 0x27, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x07, 0x07, 
  0x07, 0x03, 0x0F, 0xCE, 0x0C, 0x66, 0x6F, 0x72, 0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 
  0x65, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x44, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x13, 0x07, 
  0x07, 0x07, 0x0B, 0x45, 0xCE, 0x10, 0x66, 0x6F, 0x72, 0x2D, 0x76, 0x61, 0x72, 0x2D, 0x74, 0x65, 
  0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x71, 0xDA, 0x29, 0xDA, 0x82, 
  0x43, 0xDA, 0x82, 0x41, 0xDA, 0x44, 0xDA, 0x80, 0xF1, 0xDA, 0x86, 0x3B, 0xDA, 0x84, 0xE5, 0xDA, 
  0x49, 0xDA, 0x4A, 0x2C, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 
  0x09, 0x08, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x1C, 
  0x0A, 0x03, 0x00, 0x19, 0x08, 0x03, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x0C, 0x00, 0x00, 0x33, 
  0x0B, 0x0C, 0x00, 0x19, 0x08, 0x0B, 0x00, 0x19, 0x0A, 0x08, 0x00, 0x31, 0x04, 0x00, 0x09, 0x43, 
  0x08, 0x00, 0x00, 0x31, 0x05, 0x00, 0x0A, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0D, 0x02, 0x00, 0x31, 
  0x0D, 0x00, 0x0B, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x03, 0x00, 0x30, 0x0D, 0x08, 0x00, 0x32, 
  0x06, 0x00, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x43, 0x0B, 0x00, 0x00, 0x19, 0x08, 0x0B, 0x00, 0x2A, 
  0x0C, 0x04, 0x00, 0x31, 0x0C, 0x00, 0x01, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0D, 0x05, 0x00, 0x31, 
  0x0D, 0x09, 0x02, 0x43, 0x0C, 0x00, 0x00, 0x23, 0x0E, 0x0A, 0x03, 0x1C, 0x0E, 0x03, 0x00, 0x2A, 
  0x0D, 0x06, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x2A, 0x10, 0x05, 0x00, 0x31, 0x10, 0x0A, 0x03, 0x43, 
  0x0F, 0x00, 0x00, 0x2F, 0x0F, 0x00, 0x00, 0x43, 0x0F, 0x00, 0x00, 0x19, 0x0D, 0x0F, 0x00, 0x2F, 
  0x0A, 0x00, 0x00, 0x2A, 0x11, 0x07, 0x00, 0x33, 0x10, 0x11, 0x00, 0x19, 0x11, 0x10, 0x00, 0x1C, 
  0x10, 0x04, 0x00, 0x20, 0x12, 0x0A, 0x00, 0x19, 0x0F, 0x12, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 
  0x0F, 0x11, 0x00, 0x1C, 0x0F, 0x03, 0x00, 0x19, 0x0E, 0x08, 0x00, 0x1A, 0x09, 0x00, 0x00, 0x2A, 
  0x11, 0x08, 0x00, 0x29, 0x12, 0x00, 0x00, 0x31, 0x11, 0x0A, 0x12, 0x43, 0x10, 0x00, 0x00, 0x2A, 
  0x12, 0x09, 0x00, 0x31, 0x12, 0x10, 0x08, 0x43, 0x11, 0x00, 0x00, 0x19, 0x0E, 0x11, 0x00, 0x2A, 
  0x10, 0x0A, 0x00, 0x31, 0x10, 0x0B, 0x0C, 0x32, 0x0D, 0x00, 0x00, 0x2F, 0x0E, 0x00, 0x00, 0x43, 
  0x0F, 0x00, 0x00, 0x03, 0x0F, 0x00, 0x00, 0x81, 0x96, 0x01, 0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x29, 0x00, 0x29, 
  0x00, 0x0D, 0x00, 0x05, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x04, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x0E, 0x00, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x0A, 0x01, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x1F, 0x00, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0xBF, 0xFC, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x2C, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 
  0x00, 0x19, 0x09, 0x08, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x31, 0x0B, 0x00, 0x09, 0x43, 0x0A, 0x00, 
  0x00, 0x2F, 0x0A, 0x00, 0x00, 0x32, 0x06, 0x00, 0x00, 0x43, 0x0A, 0x00, 0x00, 0x31, 0x09, 0x01, 
  0x02, 0x31, 0x03, 0x04, 0x05, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x34, 0x0B, 0x00, 
  0x00, 0x81, 0xA6, 0x01, 0x02, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x02, 0x16, 0x00, 0x16, 0x00, 0x16, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x2C, 0x04, 0x00, 0x00, 0x31, 0x00, 0x01, 0x02, 0x29, 0x05, 0x01, 0x00, 0x2A, 0x06, 0x00, 
  0x00, 0x2A, 0x07, 0x01, 0x00, 0x31, 0x05, 0x06, 0x07, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x02, 
  0x00, 0x34, 0x05, 0x00, 0x00, 0x81, 0xFC, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x05, 0x66, 0x69, 0x72, 0x73, 0x74, 0xDA, 
  0x81, 0x5A, 0xCF, 0x04, 0x77, 0x61, 0x6C, 0x6B, 0xDA, 0x81, 0x7E, 0xCF, 0x04, 0x65, 0x61, 0x63, 
  0x68, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x02, 0x06, 0xCE, 0x04, 0x65, 0x61, 0x63, 0x68, 0xDA, 0x18, 0xD0, 0x04, 0x65, 0x61, 0x63, 0x68, 
  0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x13, 0x04, 0x04, 0x04, 0x0E, 0x4F, 0xCE, 0x0D, 0x65, 
  0x61, 0x63, 0x68, 0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0xDA, 0x18, 0xDA, 0x43, 
  0xDA, 0x71, 0xDA, 0x44, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x1C, 0x02, 0x02, 0x01, 0x02, 0x00, 
  0x02, 0xCE, 0x04, 0x6E, 0x65, 0x78, 0x74, 0x47, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0xDA, 
  0x82, 0x41, 0xDA, 0x80, 0xBF, 0xDA, 0x87, 0x0B, 0xDA, 0x80, 0x92, 0xD0, 0x04, 0x6B, 0x65, 0x79, 
  0x73, 0xD0, 0x05, 0x70, 0x61, 0x69, 0x72, 0x73, 0xDA, 0x78, 0xDA, 0x29, 0xDA, 0x82, 0x43, 0xDA, 
  0x4A, 0x2C, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 
  0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x1C, 0x07, 0x03, 
  0x00, 0x19, 0x05, 0x01, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 
  0x00, 0x19, 0x05, 0x08, 0x00, 0x19, 0x07, 0x05, 0x00, 0x23, 0x08, 0x07, 0x01, 0x1C, 0x08, 0x03, 
  0x00, 0x26, 0x05, 0x00, 0x00, 0x1A, 0x05, 0x00, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x31, 0x0A, 0x07, 
  0x01, 0x43, 0x09, 0x00, 0x00, 0x19, 0x05, 0x09, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x26, 0x0A, 0x00, 
  0x00, 0x31, 0x09, 0x07, 0x0A, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x31, 0x0A, 0x06, 
  0x08, 0x43, 0x09, 0x00, 0x00, 0x2A, 0x0A, 0x05, 0x00, 0x26, 0x0B, 0x00, 0x00, 0x31, 0x0A, 0x0B, 
  0x06, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x0C, 0x06, 0x00, 0x23, 0x0B, 0x02, 0x0C, 0x1C, 0x0B, 0x06, 
  0x00, 0x2A, 0x0D, 0x07, 0x00, 0x31, 0x0D, 0x07, 0x06, 0x43, 0x0C, 0x00, 0x00, 0x19, 0x0A, 0x0C, 
  0x00, 0x1A, 0x14, 0x00, 0x00, 0x2A, 0x0E, 0x08, 0x00, 0x23, 0x0D, 0x02, 0x0E, 0x1C, 0x0D, 0x03, 
  0x00, 0x19, 0x0C, 0x06, 0x00, 0x1A, 0x0E, 0x00, 0x00, 0x2A, 0x10, 0x09, 0x00, 0x23, 0x0F, 0x02, 
  0x10, 0x1C, 0x0F, 0x09, 0x00, 0x2A, 0x11, 0x07, 0x00, 0x31, 0x11, 0x07, 0x06, 0x43, 0x10, 0x00, 
  0x00, 0x2A, 0x12, 0x0A, 0x00, 0x31, 0x12, 0x06, 0x10, 0x43, 0x11, 0x00, 0x00, 0x19, 0x0E, 0x11, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x0E, 0x00, 0x00, 0x19, 0x0C, 0x0E, 0x00, 0x19, 0x0A, 0x0C, 
  0x00, 0x2A, 0x0C, 0x02, 0x00, 0x31, 0x0C, 0x00, 0x0A, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x03, 
  0x00, 0x31, 0x0C, 0x07, 0x06, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0D, 0x0B, 0x00, 0x31, 0x0D, 0x06, 
  0x0A, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x0C, 0x00, 0x31, 0x0D, 0x08, 0x0B, 0x32, 0x03, 0x00, 
  0x00, 0x2F, 0x0C, 0x00, 0x00, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x0D, 0x00, 0x31, 0x0B, 0x05, 
  0x09, 0x2F, 0x0A, 0x00, 0x00, 0x43, 0x08, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x81, 0xB6, 0x01, 
  0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x00, 0x0D, 
  0x00, 0x0D, 0x00, 0x27, 0x00, 0x27, 0x00, 0x0D, 0x00, 0x05, 0x02, 0x11, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x09, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x05, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0xBF, 0xFF, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 
  0x00, 0x0D, 0x03, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0xBF, 0xFD, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFB, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x2C, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x00, 0x01, 0x04, 0x2F, 0x02, 0x00, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x82, 0x16, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0E, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x6D, 0x61, 0x78, 
  0x73, 0x74, 0x61, 0x63, 0x6B, 0xD8, 0x0E, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x6D, 0x61, 0x78, 
  0x73, 0x74, 0x61, 0x63, 0x6B, 0xCF, 0x03, 0x73, 0x75, 0x6D, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x06, 0x01, 0x01, 0x01, 0x00, 0x0C, 0xCE, 0x03, 0x73, 0x75, 0x6D, 0xDA, 0x18, 0x2C, 0x01, 
  0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x00, 0x04, 0x19, 0x04, 
  0x03, 0x00, 0x1D, 0x04, 0x06, 0x00, 0x38, 0x03, 0x00, 0x04, 0x19, 0x05, 0x03, 0x00, 0x06, 0x02, 
  0x02, 0x05, 0x47, 0x04, 0x00, 0x04, 0x1A, 0xFB, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x82, 0x7F, 
  0x01, 0x03, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x0E, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x0C, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 
  0x6E, 0x2D, 0x69, 0x6E, 0x74, 0x6F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 
  0x02, 0x02, 0x14, 0xCE, 0x0C, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 0x2D, 0x69, 0x6E, 0x74, 
  0x6F, 0xDA, 0x18, 0xDA, 0x84, 0x0A, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 
  0x00, 0x47, 0x03, 0x01, 0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 0x0F, 0x00, 0x38, 0x03, 0x01, 
  0x04, 0x19, 0x05, 0x03, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x03, 0x06, 
  0x00, 0x1C, 0x03, 0x04, 0x00, 0x30, 0x00, 0x05, 0x00, 0x33, 0x06, 0x02, 0x00, 0x1A, 0x04, 0x00, 
  0x00, 0x30, 0x00, 0x05, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x47, 0x04, 0x01, 
  0x04, 0x1A, 0xF2, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x86, 0x60, 0x01, 0x04, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 
  0x01, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFD, 0x03, 
  0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x06, 0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0xD7, 0x00, 0xCD, 
  0x00, 0x99, 0x00, 0x00, 0x07, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x0B, 0xCE, 0x06, 
  0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0xDA, 0x18, 0xDA, 0x4A, 0xDA, 0x49, 0x2C, 0x02, 0x00, 0x00, 
  0x2A, 0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 
  0x2A, 0x05, 0x01, 0x00, 0x26, 0x06, 0x00, 0x00, 0x31, 0x05, 0x00, 0x06, 0x2F, 0x03, 0x00, 0x00, 
  0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0xC1, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 
  0x0A, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x72, 0x6F, 0x6F, 0x74, 0xD8, 0x0A, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2F, 0x72, 0x6F, 0x6F, 0x74, 0xCF, 0x0B, 0x6F, 0x73, 0x2F, 0x70, 0x65, 0x72, 0x6D, 
  0x2D, 0x69, 0x6E, 0x74, 0xD8, 0x0B, 0x6F, 0x73, 0x2F, 0x70, 0x65, 0x72, 0x6D, 0x2D, 0x69, 0x6E, 
  0x74, 0xCF, 0x0F, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x64, 0x69, 
  0x63, 0x74, 0xDA, 0x85, 0x7D, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0xD8, 
  0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0xCF, 0x0B, 0x70, 0x65, 0x67, 0x2F, 0x72, 
  0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0xD8, 0x0B, 0x70, 0x65, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 
  0x61, 0x63, 0x65, 0xCF, 0x09, 0x67, 0x63, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0xD8, 0x09, 
  0x67, 0x63, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0xCF, 0x06, 0x70, 0x72, 0x69, 0x6E, 0x74, 
  0x66, 0xDA, 0x82, 0xB6, 0xCF, 0x0B, 0x69, 0x64, 0x65, 0x6D, 0x70, 0x6F, 0x74, 0x65, 0x6E, 0x74, 
  0x3F, 0xDA, 0x71, 0xCF, 0x0B, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 
  0xD8, 0x0B, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0xCF, 0x09, 0x64, 
  0x65, 0x66, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 
  0x02, 0x02, 0x02, 0x03, 0x0C, 0xCE, 0x09, 0x64, 0x65, 0x66, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 
  0xDA, 0x18, 0xDA, 0x84, 0xDF, 0xDA, 0x06, 0xDA, 0x82, 0x5B, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 
  0x01, 0x00, 0x30, 0x05, 0x01, 0x00, 0x42, 0x05, 0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x07, 
  0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x01, 0x03, 0x0E, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xBF, 0xFC, 0x01, 0xCF, 0x0A, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x03, 0x03, 0x03, 0x01, 0x12, 0xCE, 0x0A, 0x61, 0x63, 
  0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x03, 0x00, 
  0x00, 0x19, 0x04, 0x01, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x26, 0x08, 0x00, 
  0x00, 0x47, 0x07, 0x02, 0x08, 0x19, 0x08, 0x07, 0x00, 0x1D, 0x08, 0x0A, 0x00, 0x38, 0x07, 0x02, 
  0x08, 0x19, 0x09, 0x07, 0x00, 0x30, 0x04, 0x09, 0x00, 0x33, 0x04, 0x00, 0x00, 0x30, 0x06, 0x04, 
  0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x07, 0x0A, 0x00, 0x47, 0x08, 0x02, 0x08, 0x1A, 0xF7, 0xFF, 
  0xFF, 0x03, 0x06, 0x00, 0x00, 0x83, 0x7C, 0x01, 0x07, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x28, 0x00, 0x28, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF7, 0x01, 0xDA, 0x80, 0xC2, 0xD7, 0x00, 
  0xCD, 0x00, 0x99, 0x00, 0x00, 0x0F, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x08, 0x27, 0xCE, 
  0x03, 0x6C, 0x65, 0x74, 0xDA, 0x18, 0xDA, 0x6D, 0xCE, 0x27, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 
  0x65, 0x64, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6C, 0x65, 
  0x74, 0xDA, 0x4A, 0xDA, 0x44, 0xDA, 0x78, 0xDA, 0x81, 0x4C, 0xDA, 0x80, 0xE3, 0xDA, 0x80, 0xE4, 
  0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 
  0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x04, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x01, 0x03, 0x00, 0x00, 
  0x1A, 0x01, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x05, 0x00, 0x00, 
  0x2A, 0x06, 0x02, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x3E, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 
  0x21, 0x08, 0x05, 0x04, 0x1C, 0x08, 0x0F, 0x00, 0x05, 0x0A, 0x05, 0x01, 0x38, 0x09, 0x00, 0x0A, 
  0x19, 0x0B, 0x09, 0x00, 0x38, 0x09, 0x00, 0x05, 0x19, 0x0C, 0x09, 0x00, 0x2A, 0x09, 0x03, 0x00, 
  0x31, 0x09, 0x0C, 0x0B, 0x2A, 0x0D, 0x04, 0x00, 0x33, 0x09, 0x0D, 0x00, 0x30, 0x07, 0x09, 0x00, 
  0x2A, 0x0E, 0x05, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x05, 0x05, 0x05, 0x02, 0x1A, 0xF1, 0xFF, 0xFF, 
  0x30, 0x07, 0x01, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x33, 0x08, 0x09, 0x00, 0x29, 0x09, 0x00, 0x00, 
  0x30, 0x07, 0x09, 0x00, 0x2A, 0x09, 0x07, 0x00, 0x34, 0x09, 0x00, 0x00, 0x80, 0xE9, 0x01, 0x05, 
  0x0D, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x20, 0x00, 0x20, 0x00, 0x03, 0x01, 
  0x0C, 0x00, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x00, 
  0x03, 0x01, 0x0F, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 
  0x17, 0x00, 0x17, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0xBF, 0xFD, 0x03, 0x04, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x3F, 0xDA, 0x81, 0x69, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x69, 0x74, 
  0xD8, 0x07, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x69, 0x74, 0xCF, 0x05, 0x65, 0x76, 0x65, 0x6E, 0x3F, 
  0xDA, 0x85, 0xD9, 0xCF, 0x03, 0x75, 0x73, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0xB9, 0x00, 0x00, 0x05, 
  0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x0A, 0x01, 0xCE, 0x03, 0x75, 0x73, 0x65, 0xDA, 
  0x18, 0xDA, 0x82, 0x48, 0xDA, 0x4A, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x30, 0x02, 
  0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x2F, 0x04, 
  0x00, 0x00, 0x32, 0x03, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0xCD, 0x00, 
  0x90, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x04, 0x0A, 0xDA, 0x18, 0xDA, 0x81, 0x38, 0xD7, 0x00, 
  0xCD, 0x00, 0x99, 0x00, 0x00, 0x12, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x0B, 0x36, 0xCE, 
  0x07, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x2A, 0xDA, 0x18, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x08, 0x01, 0x00, 0x01, 0x03, 0x17, 0xCE, 0x06, 0x63, 0x75, 0x72, 0x65, 0x6E, 0x76, 0xDA, 
  0x18, 0xDA, 0x82, 0x8F, 0xDA, 0x83, 0x2F, 0xDA, 0x86, 0x0D, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x19, 0x02, 0x03, 0x00, 0x1C, 0x00, 0x0F, 0x00, 0x19, 0x04, 0x00, 0x00, 0x20, 0x05, 
  0x04, 0x00, 0x1C, 0x05, 0x0B, 0x00, 0x26, 0x07, 0x00, 0x00, 0x23, 0x06, 0x07, 0x02, 0x1C, 0x06, 
  0x03, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x06, 
  0x02, 0x00, 0x33, 0x02, 0x06, 0x00, 0x05, 0x04, 0x04, 0xFF, 0x1A, 0xF5, 0xFF, 0xFF, 0x1A, 0x01, 
  0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x89, 0x2C, 0x01, 0x04, 0x18, 0x00, 0x18, 0x00, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x03, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x17, 0x00, 
  0x17, 0x00, 0x13, 0x00, 0x21, 0x00, 0x13, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x03, 0xBF, 0xFB, 0x01, 0xDA, 0x82, 0x57, 0xD0, 0x02, 0x61, 0x73, 0xD0, 0x06, 0x70, 
  0x72, 0x65, 0x66, 0x69, 0x78, 0xD0, 0x06, 0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0xDA, 0x85, 0x27, 
  0xDA, 0x81, 0x9C, 0xDA, 0x81, 0x38, 0xDA, 0x80, 0xEA, 0xDA, 0x81, 0x65, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x0D, 0x04, 0x02, 0x04, 0x06, 0x2B, 0xCE, 0x0C, 0x6D, 0x65, 0x72, 0x67, 0x65, 
  0x2D, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0xDA, 0x18, 0xDA, 0x78, 0xDA, 0x82, 0x3D, 0xDA, 0x52, 
  0xDA, 0x73, 0xDA, 0x83, 0x32, 0xDA, 0x84, 0xDF, 0x2C, 0x04, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 
  0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 0x26, 0x00, 0x38, 0x05, 0x01, 0x06, 
  0x30, 0x06, 0x05, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x07, 0x08, 0x00, 0x3B, 0x05, 0x07, 0x00, 
  0x19, 0x08, 0x05, 0x00, 0x3B, 0x05, 0x07, 0x01, 0x19, 0x09, 0x05, 0x00, 0x2F, 0x08, 0x00, 0x00, 
  0x2A, 0x07, 0x01, 0x00, 0x33, 0x05, 0x07, 0x00, 0x1C, 0x05, 0x18, 0x00, 0x2A, 0x07, 0x02, 0x00, 
  0x2F, 0x07, 0x00, 0x00, 0x33, 0x07, 0x09, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x03, 0x00, 
  0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x10, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x0B, 0x03, 0x00, 
  0x33, 0x07, 0x0B, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x30, 0x0B, 0x07, 0x00, 0x42, 0x07, 0x00, 0x00, 
  0x30, 0x07, 0x09, 0x00, 0x2A, 0x0C, 0x04, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x07, 0x0B, 0x00, 
  0x30, 0x02, 0x08, 0x00, 0x2A, 0x0C, 0x05, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x3A, 0x00, 0x0B, 0x07, 
  0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xDB, 0xFF, 0xFF, 
  0x03, 0x00, 0x00, 0x00, 0x8B, 0x5F, 0x01, 0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x03, 0x00, 0x3B, 0x00, 0x3B, 0x00, 0x3B, 0x00, 0x36, 0x00, 
  0x36, 0x00, 0x36, 0x00, 0x03, 0x01, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0x2C, 0x02, 0x00, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x32, 0x01, 0x00, 
  0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2A, 0x08, 0x02, 
  0x00, 0x38, 0x07, 0x06, 0x08, 0x19, 0x08, 0x07, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x38, 0x07, 0x06, 
  0x09, 0x19, 0x09, 0x07, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x38, 0x07, 0x06, 0x0A, 0x19, 0x0A, 0x07, 
  0x00, 0x31, 0x00, 0x01, 0x06, 0x2A, 0x0B, 0x05, 0x00, 0x33, 0x07, 0x0B, 0x00, 0x19, 0x0B, 0x07, 
  0x00, 0x1C, 0x08, 0x07, 0x00, 0x2A, 0x0D, 0x06, 0x00, 0x30, 0x08, 0x0D, 0x00, 0x2A, 0x0E, 0x07, 
  0x00, 0x33, 0x0D, 0x0E, 0x00, 0x19, 0x0C, 0x0D, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0C, 0x08, 
  0x00, 0x19, 0x0D, 0x0C, 0x00, 0x1C, 0x0D, 0x03, 0x00, 0x19, 0x0C, 0x0D, 0x00, 0x1A, 0x11, 0x00, 
  0x00, 0x1C, 0x09, 0x03, 0x00, 0x19, 0x0E, 0x09, 0x00, 0x1A, 0x0D, 0x00, 0x00, 0x2A, 0x0F, 0x06, 
  0x00, 0x30, 0x0F, 0x00, 0x00, 0x2A, 0x10, 0x08, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x2F, 0x0F, 0x00, 
  0x00, 0x2A, 0x11, 0x09, 0x00, 0x33, 0x10, 0x11, 0x00, 0x2A, 0x0F, 0x06, 0x00, 0x30, 0x10, 0x0F, 
  0x00, 0x2A, 0x11, 0x07, 0x00, 0x33, 0x0F, 0x11, 0x00, 0x19, 0x0E, 0x0F, 0x00, 0x19, 0x0C, 0x0E, 
  0x00, 0x19, 0x0D, 0x0C, 0x00, 0x31, 0x04, 0x0B, 0x0D, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0E, 0x0A, 
  0x00, 0x34, 0x0E, 0x00, 0x00, 0x8B, 0x6A, 0x01, 0x04, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 
  0x02, 0x11, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 
  0xBF, 0xFF, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x03, 
  0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xFD, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x04, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xDA, 0x87, 0x41, 0xDA, 0x81, 0x37, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x02, 
  0x00, 0x00, 0x33, 0x01, 0x02, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x31, 0x03, 
  0x01, 0x04, 0x2A, 0x03, 0x03, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 
  0x00, 0x00, 0x8B, 0x8C, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x8B, 0x88, 0x01, 0x04, 0x0F, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0D, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xDA, 0x46, 0xCF, 0x11, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 
  0xD8, 0x11, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 0x6C, 
  0x6C, 0x65, 0x64, 0xCF, 0x0F, 0x2A, 0x70, 0x72, 0x65, 0x74, 0x74, 0x79, 0x2D, 0x66, 0x6F, 0x72, 
  0x6D, 0x61, 0x74, 0x2A, 0xDA, 0x82, 0xB4, 0xCF, 0x05, 0x73, 0x6C, 0x75, 0x72, 0x70, 0xDA, 0x83, 
  0x4D, 0xCF, 0x07, 0x7A, 0x69, 0x70, 0x63, 0x6F, 0x6C, 0x6C, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x09, 0x02, 0x02, 0x02, 0x00, 0x16, 0xCE, 0x07, 0x7A, 0x69, 0x70, 0x63, 0x6F, 0x6C, 0x6C, 
  0xDA, 0x18, 0x2C, 0x02, 0x00, 0x00, 0x42, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x05, 
  0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x00, 0x05, 0x26, 0x08, 0x00, 0x00, 0x23, 0x07, 
  0x08, 0x05, 0x1C, 0x07, 0x03, 0x00, 0x1A, 0x0C, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x06, 
  0x01, 0x06, 0x26, 0x08, 0x00, 0x00, 0x23, 0x07, 0x08, 0x06, 0x1C, 0x07, 0x03, 0x00, 0x1A, 0x06, 
  0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x07, 0x00, 0x05, 0x38, 0x08, 0x01, 0x06, 0x3A, 0x04, 
  0x07, 0x08, 0x1A, 0xF1, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x85, 0xA8, 0x01, 0x04, 0x03, 0x00, 
  0x03, 0x01, 0x03, 0x01, 0x03, 0x02, 0x0D, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x14, 0x00, 
  0x05, 0x01, 0x0D, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x14, 0x00, 0x05, 0x01, 0x0E, 0x00, 
  0x19, 0x00, 0x05, 0xBF, 0xFB, 0x03, 0xBF, 0xF9, 0x01, 0xCF, 0x0A, 0x66, 0x72, 0x6F, 0x6D, 0x2D, 
  0x70, 0x61, 0x69, 0x72, 0x73, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 
  0x00, 0x10, 0xCE, 0x0A, 0x66, 0x72, 0x6F, 0x6D, 0x2D, 0x70, 0x61, 0x69, 0x72, 0x73, 0xDA, 0x18, 
  0x2C, 0x01, 0x00, 0x00, 0x42, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 
  0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x09, 0x00, 0x38, 0x04, 0x00, 0x05, 
  0x3B, 0x06, 0x04, 0x00, 0x19, 0x07, 0x06, 0x00, 0x3B, 0x06, 0x04, 0x01, 0x19, 0x08, 0x06, 0x00, 
  0x3A, 0x03, 0x07, 0x08, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF8, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 
  0x86, 0x78, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 
  0xBF, 0xFB, 0x01, 0xCF, 0x07, 0x65, 0x76, 0x2F, 0x63, 0x61, 0x6C, 0x6C, 0xDA, 0x38, 0xCF, 0x0C, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 0x65, 0x6E, 0x76, 0xDA, 0x84, 0x10, 0xDA, 
  0x86, 0x9A, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x14, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x05, 0x5E, 0xCE, 0x05, 0x72, 0x61, 0x6E, 0x67, 0x65, 0xDA, 0x18, 0xDA, 0x84, 0x70, 0xDA, 
  0x86, 0xE1, 0xDA, 0x86, 0x33, 0xDA, 0x81, 0x4C, 0xCE, 0x22, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 
  0x65, 0x64, 0x20, 0x31, 0x20, 0x74, 0x6F, 0x20, 0x33, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2C, 0x01, 0x00, 0x00, 
  0x3D, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x24, 0x02, 0x03, 0x01, 0x1C, 0x02, 0x0F, 0x00, 
  0x3B, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 
  0x33, 0x04, 0x06, 0x00, 0x19, 0x06, 0x04, 0x00, 0x29, 0x04, 0x00, 0x00, 0x19, 0x07, 0x05, 0x00, 
  0x21, 0x08, 0x04, 0x07, 0x1C, 0x08, 0x04, 0x00, 0x3A, 0x06, 0x04, 0x04, 0x05, 0x04, 0x04, 0x01, 
  0x1A, 0xFC, 0xFF, 0xFF, 0x03, 0x06, 0x00, 0x00, 0x24, 0x04, 0x03, 0x02, 0x1C, 0x04, 0x13, 0x00, 
  0x3B, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3B, 0x05, 0x00, 0x01, 0x19, 0x07, 0x05, 0x00, 
  0x07, 0x05, 0x07, 0x06, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 
  0x19, 0x05, 0x08, 0x00, 0x19, 0x08, 0x06, 0x00, 0x19, 0x09, 0x07, 0x00, 0x21, 0x0A, 0x08, 0x09, 
  0x1C, 0x0A, 0x05, 0x00, 0x07, 0x0B, 0x08, 0x06, 0x3A, 0x05, 0x0B, 0x08, 0x05, 0x08, 0x08, 0x01, 
  0x1A, 0xFB, 0xFF, 0xFF, 0x03, 0x05, 0x00, 0x00, 0x24, 0x05, 0x03, 0x03, 0x1C, 0x05, 0x33, 0x00, 
  0x3B, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x3B, 0x06, 0x00, 0x01, 0x19, 0x08, 0x06, 0x00, 
  0x3B, 0x06, 0x00, 0x02, 0x19, 0x09, 0x06, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0A, 0x01, 0x00, 
  0x33, 0x06, 0x0A, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x3E, 0x0A, 0x00, 0x00, 0x03, 0x0A, 0x00, 0x00, 
  0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x13, 0x00, 
  0x3E, 0x0B, 0x00, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x19, 0x0B, 0x07, 0x00, 0x19, 0x0D, 0x08, 0x00, 
  0x08, 0x0E, 0x09, 0xFF, 0x19, 0x0F, 0x0E, 0x00, 0x20, 0x0E, 0x0F, 0x00, 0x1C, 0x0E, 0x0A, 0x00, 
  0x1F, 0x10, 0x0B, 0x0D, 0x1C, 0x10, 0x07, 0x00, 0x19, 0x11, 0x0B, 0x00, 0x30, 0x0C, 0x11, 0x00, 
  0x2A, 0x13, 0x03, 0x00, 0x33, 0x12, 0x13, 0x00, 0x07, 0x0B, 0x0B, 0x0F, 0x1A, 0xF9, 0xFF, 0xFF, 
  0x1A, 0x01, 0x00, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x3E, 0x0B, 0x00, 0x00, 0x19, 0x0C, 0x0B, 0x00, 
  0x19, 0x0B, 0x07, 0x00, 0x19, 0x0D, 0x08, 0x00, 0x20, 0x0E, 0x09, 0x00, 0x1C, 0x0E, 0x0A, 0x00, 
  0x21, 0x0F, 0x0B, 0x0D, 0x1C, 0x0F, 0x07, 0x00, 0x19, 0x10, 0x0B, 0x00, 0x30, 0x0C, 0x10, 0x00, 
  0x2A, 0x12, 0x03, 0x00, 0x33, 0x11, 0x12, 0x00, 0x06, 0x0B, 0x0B, 0x09, 0x1A, 0xF9, 0xFF, 0xFF, 
  0x1A, 0x01, 0x00, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x01, 0x06, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x01, 0x05, 0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 
  0x09, 0x00, 0x09, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x15, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFD, 0x07, 0xBF, 0xFF, 0x03, 0x00, 
  0x03, 0x07, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x1D, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x1E, 0x00, 0x15, 0x00, 
  0x09, 0x00, 0x09, 0xBF, 0xFD, 0x07, 0xBF, 0xFA, 0x03, 0x00, 0x03, 0x0C, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFF, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x02, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0x02, 0x14, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x27, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x0B, 0x6E, 0x65, 0x74, 0x2F, 0x73, 0x65, 0x6E, 
  0x64, 0x2D, 0x74, 0x6F, 0xD8, 0x0B, 0x6E, 0x65, 0x74, 0x2F, 0x73, 0x65, 0x6E, 0x64, 0x2D, 0x74, 
  0x6F, 0xCF, 0x05, 0x6D, 0x65, 0x72, 0x67, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x09, 
  0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x15, 0xCE, 0x05, 0x6D, 0x65, 0x72, 0x67, 0x65, 
  0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x42, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 
  0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x0E, 0x00, 0x38, 0x04, 
  0x00, 0x05, 0x19, 0x06, 0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x47, 0x04, 0x06, 0x07, 0x19, 0x07, 
  0x04, 0x00, 0x1D, 0x07, 0x06, 0x00, 0x19, 0x04, 0x07, 0x00, 0x38, 0x08, 0x06, 0x04, 0x3A, 0x03, 
  0x04, 0x08, 0x47, 0x07, 0x06, 0x07, 0x1A, 0xFB, 0xFF, 0xFF, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF3, 
  0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x85, 0xFB, 0x01, 0x05, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x02, 0x18, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xBF, 0xFA, 0x01, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x75, 0x6D, 0x61, 0x73, 0x6B, 0xD8, 0x08, 0x6F, 
  0x73, 0x2F, 0x75, 0x6D, 0x61, 0x73, 0x6B, 0xCF, 0x0B, 0x2A, 0x64, 0x6F, 0x63, 0x2D, 0x63, 0x6F, 
  0x6C, 0x6F, 0x72, 0x2A, 0xDA, 0x81, 0x1E, 0xCF, 0x06, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 0xDA, 
  0x83, 0x45, 0xCF, 0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xD8, 
  0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xCF, 0x0D, 0x2A, 0x70, 
  0x65, 0x67, 0x2D, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0x2A, 0xD0, 0x0B, 0x70, 0x65, 0x67, 
  0x2D, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0xCF, 0x04, 0x61, 0x6E, 0x79, 0x3F, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 0x00, 0x11, 0xCE, 0x04, 0x61, 0x6E, 0x79, 
  0x3F, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x26, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 
  0x03, 0x00, 0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 0x0B, 0x00, 0x38, 0x03, 0x00, 0x04, 0x19, 
  0x05, 0x03, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1C, 
  0x05, 0x03, 0x00, 0x19, 0x02, 0x05, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x04, 0x00, 0x04, 0x1A, 
  0xF6, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x85, 0x7A, 0x01, 0x03, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 
  0x00, 0x0B, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x0A, 0x67, 0x63, 
  0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0xD8, 0x0A, 0x67, 0x63, 0x69, 0x6E, 0x74, 0x65, 
  0x72, 0x76, 0x61, 0x6C, 0xCF, 0x0B, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x62, 0x79, 0x74, 
  0x65, 0xD8, 0x0B, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x62, 0x79, 0x74, 0x65, 0xCF, 0x0B, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 0xDA, 0x82, 0x4C, 0xCF, 0x04, 
  0x6F, 0x64, 0x64, 0x3F, 0xDA, 0x85, 0xE2, 0xCF, 0x06, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0xDA, 
  0x80, 0xDF, 0xCF, 0x0F, 0x65, 0x76, 0x2F, 0x73, 0x70, 0x61, 0x77, 0x6E, 0x2D, 0x74, 0x68, 0x72, 
  0x65, 0x61, 0x64, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x05, 0x10, 0xCE, 0x0F, 0x65, 0x76, 0x2F, 0x73, 0x70, 0x61, 0x77, 0x6E, 0x2D, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0xDA, 0x18, 0xDA, 0x84, 0x36, 0xDA, 0x80, 0xB9, 0xCF, 0x0D, 0x5F, 
  0x73, 0x70, 0x61, 0x77, 0x6E, 0x2D, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0xDA, 0x85, 0xB7, 0xD0, 
  0x01, 0x6E, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x44, 0x02, 
  0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 0x04, 0x05, 0x02, 0x32, 0x00, 
  0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x03, 0x00, 0x26, 0x05, 0x00, 0x00, 0x31, 0x04, 
  0x03, 0x05, 0x2A, 0x04, 0x04, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 
  0x00, 0x00, 0x8D, 0xF4, 0x03, 0x03, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0xCF, 0x0B, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 
  0xD8, 0x0B, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0xCF, 0x06, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x02, 0x01, 0x02, 
  0x01, 0x07, 0xCE, 0x06, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0xDA, 0x18, 0xD8, 0x06, 0x73, 0x69, 
  0x67, 0x6E, 0x61, 0x6C, 0x2C, 0x02, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x43, 0x03, 0x00, 0x00, 
  0x29, 0x04, 0x00, 0x00, 0x30, 0x04, 0x03, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 
  0x81, 0x77, 0x01, 0x03, 0x0D, 0x00, 0x0D, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 
  0x05, 0x64, 0x65, 0x66, 0x65, 0x72, 0xDA, 0x81, 0xB1, 0xCF, 0x05, 0x2A, 0x6F, 0x75, 0x74, 0x2A, 
  0xD0, 0x03, 0x6F, 0x75, 0x74, 0xCF, 0x04, 0x6E, 0x61, 0x6E, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x03, 0xCE, 0x04, 0x6E, 0x61, 0x6E, 0x3F, 0xDA, 0x18, 
  0x2C, 0x01, 0x00, 0x00, 0x48, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x63, 0x01, 0x00, 0x25, 
  0x00, 0x25, 0xCF, 0x03, 0x64, 0x79, 0x6E, 0xDA, 0x81, 0x1D, 0xCF, 0x09, 0x75, 0x6E, 0x6D, 0x61, 
  0x72, 0x73, 0x68, 0x61, 0x6C, 0xD8, 0x09, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 
  0xCF, 0x0B, 0x2A, 0x6C, 0x69, 0x6E, 0x74, 0x2D, 0x77, 0x61, 0x72, 0x6E, 0x2A, 0xDA, 0x84, 0x1C, 
  0xCF, 0x09, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x3F, 0xD8, 0x09, 0x61, 0x62, 0x73, 
  0x74, 0x72, 0x61, 0x63, 0x74, 0x3F, 0xCF, 0x04, 0x6C, 0x61, 0x73, 0x74, 0xDA, 0x81, 0x65, 0xCF, 
  0x04, 0x6E, 0x65, 0x67, 0x3F, 0xDA, 0x86, 0x33, 0xCF, 0x0D, 0x67, 0x63, 0x73, 0x65, 0x74, 0x69, 
  0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0xD8, 0x0D, 0x67, 0x63, 0x73, 0x65, 0x74, 0x69, 0x6E, 
  0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0xCF, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x65, 0x6E, 
  0x73, 0x75, 0x72, 0x65, 0xD8, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x65, 0x6E, 0x73, 0x75, 
  0x72, 0x65, 0xCF, 0x0C, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 0x76, 
  0xDA, 0x83, 0x2F, 0xCF, 0x06, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x99, 
  0x00, 0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x06, 0x17, 0xCE, 0x06, 0x72, 0x65, 
  0x70, 0x65, 0x61, 0x74, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x82, 0x41, 0xCF, 0x01, 0x3E, 0xDA, 0x80, 
  0x9A, 0xDA, 0x82, 0x43, 0xDA, 0x4A, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x04, 0x00, 0x43, 0x03, 
  0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x29, 0x07, 0x00, 0x00, 0x31, 0x06, 0x04, 0x07, 0x43, 0x05, 
  0x00, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x30, 0x07, 0x04, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x08, 
  0x04, 0x00, 0x30, 0x08, 0x05, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x43, 0x07, 
  0x00, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x31, 0x06, 0x03, 0x07, 0x43, 0x05, 0x00, 0x00, 0x03, 0x05, 
  0x00, 0x00, 0x82, 0x0B, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0xCF, 0x08, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x3F, 0xDA, 0x85, 0x76, 0xCF, 0x06, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 
  0x01, 0x02, 0x07, 0xCE, 0x06, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 
  0x75, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 
  0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x6D, 0x01, 0x00, 
  0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0xCF, 0x0F, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x2F, 0x74, 0x6F, 0x2D, 0x74, 0x61, 0x62, 0x6C, 0x65, 0xD8, 0x0F, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x2F, 0x74, 0x6F, 0x2D, 0x74, 0x61, 0x62, 0x6C, 0x65, 0xCF, 0x09, 0x6E, 
  0x65, 0x74, 0x2F, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0xD8, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x68, 
  0x75, 0x6E, 0x6B, 0xCF, 0x0F, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x61, 0x72, 0x67, 0x2D, 0x73, 
  0x74, 0x61, 0x63, 0x6B, 0xD8, 0x0F, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x61, 0x72, 0x67, 0x2D, 
  0x73, 0x74, 0x61, 0x63, 0x6B, 0xCF, 0x07, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0xDA, 0x83, 
  0xBE, 0xCF, 0x0B, 0x65, 0x76, 0x2F, 0x64, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x65, 0xD8, 0x0B, 
  0x65, 0x76, 0x2F, 0x64, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x65, 0xCF, 0x07, 0x64, 0x65, 0x66, 
  0x61, 0x75, 0x6C, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x03, 
  0x0D, 0xCE, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0xDA, 0x18, 0xDA, 0x80, 0xD5, 0xDA, 
  0x49, 0xDA, 0x44, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x31, 
  0x04, 0x05, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x03, 0x01, 0x2F, 
  0x00, 0x00, 0x00, 0x43, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 0x05, 0x00, 0x04, 0x43, 
  0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x80, 0xAD, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x0F, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2D, 0x6C, 
  0x6F, 0x6F, 0x70, 0xDA, 0x3C, 0xCF, 0x07, 0x62, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0xD7, 0x00, 
  0xCD, 0x00, 0x09, 0x00, 0x11, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 
  0x07, 0x62, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 
  0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 
  0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x14, 0x03, 0x03, 0x04, 
  0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 
  0x14, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 
  0x03, 0x03, 0x00, 0x00, 0xCF, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x65, 0x6B, 0xD8, 
  0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x65, 0x6B, 0xCF, 0x08, 0x63, 0x6F, 0x6D, 0x70, 
  0x61, 0x72, 0x65, 0x3C, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 
  0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xCE, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3C, 0xDA, 
  0x18, 0xDA, 0x81, 0x47, 0xDA, 0x85, 0x83, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 
  0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x83, 0x0E, 0x01, 0x03, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3D, 
  0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 
  0x05, 0xCE, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3D, 0xDA, 0x18, 0xDA, 0x83, 0x1D, 
  0xDA, 0x85, 0x83, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 
  0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x83, 0x09, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3E, 0xD7, 0x00, 0xCD, 0x00, 
  0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xCE, 0x08, 0x63, 
  0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3E, 0xDA, 0x18, 0xDA, 0x84, 0xE5, 0xDA, 0x85, 0x83, 0x2C, 
  0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 
  0x02, 0x00, 0x00, 0x83, 0x18, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 
  0x65, 0x76, 0x2F, 0x67, 0x61, 0x74, 0x68, 0x65, 0x72, 0xD7, 0x01, 0xCD, 0x00, 0xD9, 0x00, 0x00, 
  0x0E, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x09, 0x39, 0x01, 0xCE, 0x09, 0x65, 0x76, 0x2F, 
  0x67, 0x61, 0x74, 0x68, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x80, 0xC7, 0xDA, 0x44, 0xDA, 
  0x78, 0xCF, 0x03, 0x70, 0x75, 0x74, 0xDA, 0x80, 0xB9, 0xDA, 0x3A, 0xDA, 0x81, 0x4C, 0xDA, 0x4A, 
  0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 
  0x2A, 0x04, 0x00, 0x00, 0x33, 0x02, 0x04, 0x00, 0x19, 0x04, 0x02, 0x00, 0x2A, 0x05, 0x01, 0x00, 
  0x2F, 0x05, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x31, 0x06, 0x03, 0x02, 
  0x43, 0x05, 0x00, 0x00, 0x3E, 0x02, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x31, 0x07, 0x04, 0x02, 
  0x43, 0x06, 0x00, 0x00, 0x3E, 0x02, 0x00, 0x00, 0x19, 0x07, 0x02, 0x00, 0x26, 0x08, 0x00, 0x00, 
  0x47, 0x02, 0x00, 0x08, 0x19, 0x08, 0x02, 0x00, 0x1D, 0x08, 0x1B, 0x00, 0x38, 0x02, 0x00, 0x08, 
  0x30, 0x08, 0x02, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x3B, 0x02, 0x09, 0x00, 
  0x19, 0x0A, 0x02, 0x00, 0x3B, 0x02, 0x09, 0x01, 0x19, 0x0B, 0x02, 0x00, 0x44, 0x02, 0x00, 0x00, 
  0x2A, 0x0C, 0x04, 0x00, 0x31, 0x0C, 0x04, 0x0A, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x09, 0x00, 0x00, 
  0x2A, 0x0D, 0x05, 0x00, 0x31, 0x0D, 0x02, 0x09, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x09, 0x06, 0x00, 
  0x26, 0x0D, 0x00, 0x00, 0x31, 0x09, 0x0C, 0x0D, 0x2F, 0x03, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 
  0x30, 0x07, 0x02, 0x00, 0x2A, 0x0C, 0x07, 0x00, 0x33, 0x09, 0x0C, 0x00, 0x47, 0x08, 0x00, 0x08, 
  0x1A, 0xE6, 0xFF, 0xFF, 0x2B, 0x08, 0x00, 0x07, 0x31, 0x08, 0x03, 0x07, 0x43, 0x02, 0x00, 0x00, 
  0x2A, 0x09, 0x08, 0x00, 0x31, 0x09, 0x05, 0x06, 0x30, 0x02, 0x04, 0x00, 0x43, 0x08, 0x00, 0x00, 
  0x03, 0x08, 0x00, 0x00, 0xBF, 0xFF, 0x8E, 0x0A, 0x03, 0x06, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x04, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 
  0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 
  0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x01, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0xBF, 
  0xFF, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0xBF, 0xFC, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0A, 0xC9, 0xC9, 0xC9, 
  0xC9, 0xC9, 0xC9, 0xC9, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x02, 0x02, 0x02, 0x05, 
  0x23, 0xCE, 0x0F, 0x77, 0x61, 0x69, 0x74, 0x2D, 0x66, 0x6F, 0x72, 0x2D, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x73, 0xDA, 0x18, 0xD8, 0x07, 0x65, 0x76, 0x2F, 0x74, 0x61, 0x6B, 0x65, 0xD0, 0x02, 0x6F, 
  0x6B, 0xCE, 0x10, 0x73, 0x69, 0x62, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x61, 0x6E, 0x63, 0x65, 
  0x6C, 0x65, 0x64, 0xDA, 0x86, 0x44, 0xDA, 0x83, 0x35, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x20, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x1E, 0x00, 0x2F, 0x00, 0x00, 
  0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 0x3B, 0x06, 0x05, 0x00, 0x19, 0x07, 0x06, 
  0x00, 0x3B, 0x06, 0x05, 0x01, 0x19, 0x08, 0x06, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 0x07, 
  0x06, 0x1C, 0x05, 0x02, 0x00, 0x1A, 0x11, 0x00, 0x00, 0x26, 0x09, 0x00, 0x00, 0x47, 0x06, 0x01, 
  0x09, 0x19, 0x09, 0x06, 0x00, 0x1D, 0x09, 0x09, 0x00, 0x38, 0x06, 0x01, 0x09, 0x19, 0x0A, 0x06, 
  0x00, 0x2A, 0x06, 0x02, 0x00, 0x30, 0x0A, 0x06, 0x00, 0x2A, 0x0B, 0x03, 0x00, 0x33, 0x06, 0x0B, 
  0x00, 0x47, 0x09, 0x01, 0x09, 0x1A, 0xF8, 0xFF, 0xFF, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x04, 
  0x00, 0x33, 0x06, 0x09, 0x00, 0x37, 0x09, 0x06, 0x08, 0x05, 0x04, 0x04, 0xFF, 0x1A, 0xE2, 0xFF, 
  0xFF, 0x04, 0x00, 0x00, 0x00, 0x8E, 0x02, 0x03, 0x02, 0x0D, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x0F, 
  0x00, 0x0F, 0x00, 0x07, 0x00, 0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x09, 0x00, 0x09, 0x01, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x09, 0xBF, 0xFC, 0x05, 0x00, 0x05, 0x00, 0x05, 0xC9, 0xC9, 0xCF, 
  0x04, 0x65, 0x76, 0x61, 0x6C, 0xDA, 0x82, 0xE0, 0xCF, 0x0C, 0x2A, 0x65, 0x78, 0x65, 0x63, 0x75, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x2A, 0xD0, 0x0A, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0xCF, 0x05, 0x6F, 0x73, 0x2F, 0x63, 0x64, 0xD8, 0x05, 0x6F, 0x73, 0x2F, 0x63, 0x64, 
  0xCF, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0xDA, 0x85, 
  0xF0, 0xCF, 0x07, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0xDA, 0x85, 0xED, 0xCF, 0x11, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 0x6B, 
  0xD8, 0x11, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x78, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0xCF, 0x05, 0x74, 0x72, 0x75, 0x65, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 0x05, 0x74, 0x72, 0x75, 0x65, 0x3F, 0xDA, 0x18, 
  0x2C, 0x01, 0x00, 0x00, 0x27, 0x03, 0x00, 0x00, 0x23, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 
  0x7C, 0x01, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0xCF, 0x10, 0x65, 0x76, 0x2F, 0x61, 0x63, 0x71, 
  0x75, 0x69, 0x72, 0x65, 0x2D, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0xD8, 0x10, 0x65, 0x76, 0x2F, 0x61, 
  0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2D, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0xCF, 0x08, 0x64, 0x69, 
  0x73, 0x74, 0x69, 0x6E, 0x63, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x01, 0x01, 
  0x01, 0x01, 0x16, 0xCE, 0x08, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6E, 0x63, 0x74, 0xDA, 0x18, 0xDA, 
  0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x42, 0x04, 
  0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x47, 0x06, 0x00, 0x07, 0x19, 0x07, 
  0x06, 0x00, 0x1D, 0x07, 0x0D, 0x00, 0x38, 0x06, 0x00, 0x07, 0x19, 0x08, 0x06, 0x00, 0x38, 0x06, 
  0x05, 0x08, 0x1C, 0x06, 0x02, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x27, 0x09, 0x00, 0x00, 0x3A, 0x05, 
  0x08, 0x09, 0x30, 0x03, 0x08, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x47, 0x07, 
  0x00, 0x07, 0x1A, 0xF4, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x86, 0x58, 0x01, 0x03, 0x03, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x26, 0x00, 0x26, 0x00, 0x38, 0x00, 0x38, 0x00, 
  0x38, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 0xCF, 0x08, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0xD8, 0x08, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xCF, 0x05, 0x79, 0x69, 
  0x65, 0x6C, 0x64, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x04, 0x02, 0x01, 0x00, 0x01, 0x00, 0x02, 
  0xCE, 0x05, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x36, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0xCF, 
  0x04, 0x70, 0x72, 0x69, 0x6E, 0xD8, 0x04, 0x70, 0x72, 0x69, 0x6E, 0xCF, 0x04, 0x63, 0x61, 0x73, 
  0x65, 0xD7, 0x00, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x0C, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x05, 0x1D, 0x01, 0xCE, 0x04, 0x63, 0x61, 0x73, 0x65, 0xDA, 0x18, 0xDA, 0x71, 0xDA, 0x43, 0xDA, 
  0x44, 0xDA, 0x78, 0xDA, 0x4A, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x19, 0x05, 0x00, 
  0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 
  0x00, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x07, 0x00, 0x00, 0x19, 0x08, 0x07, 0x00, 0x1C, 0x04, 0x04, 
  0x00, 0x29, 0x09, 0x00, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x02, 
  0x00, 0x31, 0x09, 0x06, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x29, 0x0A, 0x00, 
  0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0A, 0x08, 0x00, 0x2A, 0x0B, 0x04, 0x00, 0x31, 0x0B, 0x09, 
  0x0A, 0x2A, 0x0B, 0x03, 0x00, 0x34, 0x0B, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 0x01, 
  0x01, 0x01, 0x03, 0x1F, 0x01, 0xDA, 0x70, 0xDA, 0x18, 0xDA, 0x83, 0x1D, 0xDA, 0x78, 0xDA, 0x49, 
  0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x01, 0x3D, 0x02, 0x03, 0x00, 0x07, 0x03, 0x02, 0x00, 
  0x19, 0x02, 0x03, 0x00, 0x24, 0x04, 0x02, 0x00, 0x1C, 0x04, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 
  0x24, 0x05, 0x02, 0x01, 0x1C, 0x05, 0x04, 0x00, 0x2B, 0x07, 0x00, 0x01, 0x38, 0x06, 0x07, 0x00, 
  0x03, 0x06, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x01, 0x38, 0x06, 0x07, 0x00, 0x2A, 0x07, 0x00, 0x00, 
  0x2B, 0x08, 0x00, 0x06, 0x31, 0x07, 0x08, 0x06, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 
  0x05, 0x06, 0x00, 0x01, 0x2B, 0x09, 0x00, 0x01, 0x38, 0x08, 0x09, 0x06, 0x05, 0x06, 0x00, 0x02, 
  0x2F, 0x06, 0x00, 0x00, 0x33, 0x09, 0x01, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x31, 0x06, 0x07, 0x08, 
  0x2F, 0x09, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x34, 0x06, 0x00, 0x00, 0xBF, 0xFF, 0x80, 0xDC, 
  0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x12, 0x00, 0x05, 0x01, 0x09, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x0B, 0x00, 0x07, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x01, 0x21, 0x00, 0x21, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x01, 0x1A, 0x00, 0x10, 0x00, 0x10, 0x01, 0x15, 0x00, 
  0x10, 0x00, 0x10, 0xBF, 0xFE, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x80, 0xD5, 
  0x01, 0x05, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x1D, 0x00, 0x1D, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x07, 0x03, 0x01, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x01, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x42, 0x00, 0x00, 0x00, 0xCF, 0x0D, 
  0x69, 0x6E, 0x74, 0x2F, 0x74, 0x6F, 0x2D, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0xD8, 0x0D, 0x69, 
  0x6E, 0x74, 0x2F, 0x74, 0x6F, 0x2D, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0xCF, 0x0B, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x6C, 0x69, 0x74, 0xD8, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2F, 0x62, 0x6C, 0x69, 0x74, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 
  0x6E, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0xCF, 0x08, 0x72, 0x65, 
  0x76, 0x65, 0x72, 0x73, 0x65, 0x21, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0D, 0x01, 0x01, 
  0x01, 0x00, 0x15, 0xCE, 0x08, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x21, 0xDA, 0x18, 0x2C, 
  0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x05, 0x03, 0x02, 0xFF, 0x19, 0x02, 0x03, 0x00, 0x0A, 
  0x04, 0x02, 0x02, 0x19, 0x05, 0x04, 0x00, 0x29, 0x06, 0x00, 0x00, 0x19, 0x07, 0x05, 0x00, 0x21, 
  0x08, 0x06, 0x07, 0x1C, 0x08, 0x0B, 0x00, 0x07, 0x09, 0x02, 0x06, 0x19, 0x0A, 0x09, 0x00, 0x38, 
  0x09, 0x00, 0x06, 0x19, 0x0B, 0x09, 0x00, 0x38, 0x09, 0x00, 0x0A, 0x19, 0x0C, 0x09, 0x00, 0x3A, 
  0x00, 0x06, 0x0C, 0x3A, 0x00, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x01, 0x1A, 0xF5, 0xFF, 0xFF, 0x03, 
  0x00, 0x00, 0x00, 0x85, 0x82, 0x01, 0x04, 0x11, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x0D, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x05, 
  0x01, 0x0C, 0x00, 0x05, 0x01, 0x05, 0x01, 0x05, 0xBF, 0xFB, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 
  0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x70, 0x69, 0x70, 0x65, 0xD8, 0x07, 0x6F, 0x73, 0x2F, 0x70, 0x69, 
  0x70, 0x65, 0xCF, 0x04, 0x74, 0x79, 0x70, 0x65, 0xDA, 0x1C, 0xCF, 0x04, 0x6E, 0x61, 0x74, 0x3F, 
  0xDA, 0x84, 0xEB, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x6F, 0x70, 0x65, 0x6E, 0xD8, 0x07, 0x6F, 0x73, 
  0x2F, 0x6F, 0x70, 0x65, 0x6E, 0xCF, 0x06, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0xD8, 0x06, 0x6E, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0xCF, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2D, 0x69, 0x6E, 
  0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x10, 0x03, 0x03, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 
  0x27, 0xCE, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2D, 0x69, 0x6E, 0xDA, 0x18, 0xCE, 0x1D, 
  0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x6C, 0x65, 0x61, 0x73, 
  0x74, 0x20, 0x31, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x6E, 0x20, 0x6B, 0x73, 0xDA, 0x82, 0x57, 
  0x2C, 0x04, 0x00, 0x00, 0x19, 0x05, 0x00, 0x00, 0x3D, 0x06, 0x01, 0x00, 0x05, 0x07, 0x06, 0xFF, 
  0x19, 0x06, 0x07, 0x00, 0x22, 0x08, 0x06, 0x00, 0x1C, 0x08, 0x04, 0x00, 0x2A, 0x09, 0x00, 0x00, 
  0x01, 0x09, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x29, 0x08, 0x00, 0x00, 0x19, 0x09, 0x06, 0x00, 
  0x21, 0x0A, 0x08, 0x09, 0x1C, 0x0A, 0x11, 0x00, 0x39, 0x0B, 0x01, 0x08, 0x19, 0x0C, 0x0B, 0x00, 
  0x39, 0x0B, 0x05, 0x0C, 0x19, 0x0D, 0x0B, 0x00, 0x26, 0x0E, 0x00, 0x00, 0x23, 0x0B, 0x0E, 0x0D, 
  0x1C, 0x0B, 0x07, 0x00, 0x2A, 0x0F, 0x01, 0x00, 0x33, 0x0E, 0x0F, 0x00, 0x19, 0x0F, 0x0E, 0x00, 
  0x3A, 0x05, 0x0C, 0x0F, 0x19, 0x05, 0x0F, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x05, 0x0D, 0x00, 
  0x05, 0x08, 0x08, 0x01, 0x1A, 0xEF, 0xFF, 0xFF, 0x39, 0x08, 0x01, 0x06, 0x19, 0x09, 0x08, 0x00, 
  0x39, 0x0A, 0x05, 0x09, 0x19, 0x0B, 0x0A, 0x00, 0x2F, 0x0B, 0x00, 0x00, 0x32, 0x03, 0x00, 0x00, 
  0x33, 0x0C, 0x02, 0x00, 0x3A, 0x05, 0x09, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x85, 0xBF, 0x01, 0x06, 
  0x03, 0x01, 0x11, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x07, 0x00, 0x03, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x0C, 0x00, 
  0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 0x07, 0x01, 0x09, 0x01, 
  0x09, 0xBF, 0xFD, 0x05, 0x04, 0x07, 0xBF, 0xF9, 0x03, 0x00, 0x03, 0x08, 0x11, 0x00, 0x03, 0x01, 
  0x11, 0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 0xBF, 0xED, 0x01, 0xCF, 0x05, 
  0x64, 0x65, 0x66, 0x6E, 0x2D, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x04, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x06, 0xCE, 0x05, 0x64, 0x65, 0x66, 0x6E, 0x2D, 0xDA, 0x18, 0xDA, 
  0x52, 0xDA, 0x81, 0xB7, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x30, 0x00, 0x03, 0x00, 
  0x32, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 0x40, 0x01, 0x03, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6C, 
  0x6F, 0x73, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x04, 
  0xCE, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xDA, 0x18, 0xD8, 0x08, 0x65, 
  0x76, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x34, 0x02, 0x00, 0x00, 0x8D, 0xDF, 0x03, 0x00, 0x34, 0x00, 0x34, 0x00, 0x34, 
  0xCF, 0x0B, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x32, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0D, 0x02, 0x02, 0x02, 0x01, 0x1D, 0xCE, 0x0B, 0x61, 0x63, 0x63, 0x75, 
  0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x32, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 
  0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x01, 0x04, 0x19, 0x04, 0x03, 0x00, 0x3E, 0x05, 0x00, 0x00, 
  0x19, 0x06, 0x05, 0x00, 0x26, 0x08, 0x00, 0x00, 0x23, 0x07, 0x08, 0x04, 0x1C, 0x07, 0x03, 0x00, 
  0x03, 0x06, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x07, 0x01, 0x04, 0x19, 0x08, 0x07, 0x00, 
  0x30, 0x06, 0x08, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x47, 0x04, 0x01, 0x04, 
  0x26, 0x0B, 0x00, 0x00, 0x48, 0x0A, 0x0B, 0x04, 0x1C, 0x0A, 0x09, 0x00, 0x38, 0x0B, 0x01, 0x04, 
  0x30, 0x08, 0x0B, 0x00, 0x33, 0x08, 0x00, 0x00, 0x30, 0x06, 0x08, 0x00, 0x2A, 0x0C, 0x00, 0x00, 
  0x33, 0x0B, 0x0C, 0x00, 0x47, 0x04, 0x01, 0x04, 0x1A, 0xF6, 0xFF, 0xFF, 0x03, 0x06, 0x00, 0x00, 
  0x83, 0x88, 0x01, 0x05, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x07, 0x00, 
  0x07, 0x00, 0x03, 0x00, 0x11, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x01, 0x0A, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x15, 0x00, 0x0E, 0x00, 0x0E, 0x01, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 0xBF, 0xFD, 0x03, 0xBF, 0xF5, 0x01, 0xCF, 0x06, 0x6D, 
  0x65, 0x6D, 0x63, 0x6D, 0x70, 0xD8, 0x06, 0x6D, 0x65, 0x6D, 0x63, 0x6D, 0x70, 0xCF, 0x06, 0x74, 
  0x6F, 0x67, 0x67, 0x6C, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 
  0x02, 0x08, 0xCE, 0x06, 0x74, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0xDA, 0x18, 0xDA, 0x73, 0xDA, 0x29, 
  0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x30, 0x03, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x31, 0x04, 0x00, 0x02, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 
  0x4F, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xCF, 0x06, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0xD8, 0x06, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 
  0xCF, 0x06, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x66, 0xDA, 0x83, 0xC4, 0xCF, 0x13, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x2F, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x2D, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 
  0xD8, 0x13, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x2D, 0x66, 0x6C, 
  0x61, 0x74, 0x74, 0x65, 0x6E, 0xCF, 0x05, 0x64, 0x65, 0x62, 0x75, 0x67, 0xD7, 0x00, 0xCD, 0x00, 
  0x08, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x02, 0xCE, 0x05, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x36, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x07, 0x65, 0x76, 0x2F, 0x72, 0x65, 0x61, 
  0x64, 0xD8, 0x07, 0x65, 0x76, 0x2F, 0x72, 0x65, 0x61, 0x64, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x73, 
  0x68, 0x65, 0x6C, 0x6C, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0xCF, 0x06, 
  0x66, 0x61, 0x6C, 0x73, 0x65, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 
  0x01, 0x00, 0x04, 0xCE, 0x06, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x3F, 0xDA, 0x18, 0x2C, 0x01, 0x00, 
  0x00, 0x28, 0x03, 0x00, 0x00, 0x23, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x7D, 0x01, 0x00, 
  0x29, 0x00, 0x29, 0x00, 0x29, 0xCF, 0x11, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x72, 
  0x6F, 0x6D, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0xD8, 0x11, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2F, 0x66, 0x72, 0x6F, 0x6D, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0xCF, 0x05, 0x64, 0x65, 0x6C, 
  0x61, 0x79, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0E, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x06, 0x2D, 0xCE, 0x05, 0x64, 0x65, 0x6C, 0x61, 0x79, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x82, 
  0x41, 0xDA, 0x29, 0xDA, 0x4A, 0xDA, 0x49, 0xDA, 0x80, 0xB9, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x44, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x26, 0x09, 
  0x00, 0x00, 0x31, 0x08, 0x03, 0x09, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x26, 0x0A, 
  0x00, 0x00, 0x31, 0x09, 0x05, 0x0A, 0x43, 0x08, 0x00, 0x00, 0x44, 0x09, 0x00, 0x00, 0x2A, 0x0B, 
  0x02, 0x00, 0x27, 0x0C, 0x00, 0x00, 0x31, 0x0B, 0x05, 0x0C, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0C, 
  0x03, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0D, 
  0x02, 0x00, 0x31, 0x0D, 0x03, 0x0B, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x03, 0x00, 0x31, 0x0D, 
  0x0A, 0x0C, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x04, 0x00, 0x31, 0x0C, 0x05, 0x03, 0x2F, 0x0B, 
  0x00, 0x00, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0C, 0x05, 0x00, 0x31, 0x0C, 0x09, 0x0A, 0x43, 0x0B, 
  0x00, 0x00, 0x2A, 0x0A, 0x05, 0x00, 0x31, 0x0A, 0x06, 0x07, 0x30, 0x08, 0x0B, 0x00, 0x43, 0x09, 
  0x00, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x8E, 0x28, 
  0x01, 0x05, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 0x65, 0x70, 0x72, 0x69, 0x6E, 
  0x74, 0xDA, 0x83, 0x55, 0xCF, 0x11, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 
  0x2D, 0x74, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0xD8, 0x11, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 
  0x62, 0x69, 0x74, 0x2D, 0x74, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0xCF, 0x09, 0x70, 0x72, 0x6F, 0x70, 
  0x61, 0x67, 0x61, 0x74, 0x65, 0xDA, 0x80, 0xD7, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 
  0x69, 0x6E, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x69, 0x6E, 0xCF, 0x0B, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xD8, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xCF, 0x08, 0x62, 0x72, 0x75, 0x73, 0x68, 0x69, 0x66, 0x74, 
  0xD7, 0x00, 0xCD, 0x00, 0x09, 0x00, 0x12, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 
  0x13, 0xCE, 0x08, 0x62, 0x72, 0x75, 0x73, 0x68, 0x69, 0x66, 0x74, 0x3D, 0x01, 0x00, 0x00, 0x24, 
  0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 
  0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x16, 
  0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 
  0x04, 0x00, 0x05, 0x16, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 
  0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x08, 0x66, 0x6C, 0x79, 0x63, 0x68, 0x65, 0x63, 
  0x6B, 0xD7, 0x00, 0xCD, 0x03, 0xBB, 0x00, 0x00, 0x0D, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x0A, 0x29, 0x01, 0xCE, 0x08, 0x66, 0x6C, 0x79, 0x63, 0x68, 0x65, 0x63, 0x6B, 0xDA, 0x18, 0xDA, 
  0x85, 0x2E, 0xD8, 0x0B, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0xDA, 
  0x86, 0xCF, 0xDA, 0x80, 0xBB, 0xDA, 0x80, 0xBA, 0xDA, 0x80, 0xBE, 0xDA, 0x80, 0xC1, 0xDA, 0x81, 
  0x37, 0xDA, 0x83, 0xA8, 0xDA, 0x83, 0xD2, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x2F, 
  0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 
  0x05, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2E, 
  0x06, 0x00, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x30, 0x06, 0x07, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x33, 
  0x07, 0x08, 0x00, 0x19, 0x06, 0x07, 0x00, 0x26, 0x08, 0x00, 0x00, 0x35, 0x07, 0x06, 0x08, 0x19, 
  0x08, 0x07, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x33, 0x07, 0x09, 0x00, 0x2A, 
  0x0A, 0x06, 0x00, 0x23, 0x09, 0x07, 0x0A, 0x1C, 0x09, 0x08, 0x00, 0x19, 0x07, 0x08, 0x00, 0x19, 
  0x0A, 0x06, 0x00, 0x2A, 0x0B, 0x07, 0x00, 0x31, 0x0A, 0x07, 0x0B, 0x2A, 0x0C, 0x08, 0x00, 0x33, 
  0x0B, 0x0C, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 
  0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x30, 0x07, 0x04, 0x00, 0x2A, 
  0x08, 0x09, 0x00, 0x33, 0x07, 0x08, 0x00, 0x04, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0x04, 0x0B, 0x01, 0xDA, 0x18, 0xDA, 0x82, 0x55, 0xDA, 0x83, 0xE6, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x10, 0x04, 0x04, 0x04, 0x10, 0x50, 0xCE, 0x12, 0x66, 0x6C, 
  0x79, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 0x72, 
  0xDA, 0x18, 0xDA, 0x81, 0x69, 0xD5, 0x0B, 0xDA, 0x80, 0xF9, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x04, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x0B, 0x69, 0x73, 0x2D, 0x73, 0x61, 0x66, 0x65, 
  0x2D, 0x64, 0x65, 0x66, 0xDA, 0x18, 0xDA, 0x81, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x09, 0x01, 0x01, 0x01, 0x08, 0x2B, 0xCE, 0x0F, 0x6E, 0x6F, 0x2D, 0x73, 0x69, 0x64, 0x65, 0x2D, 
  0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0xDA, 0x18, 0xDA, 0x81, 0x69, 0xDA, 0x80, 0xAC, 0xDA, 
  0x82, 0x47, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x00, 0x10, 0xCE, 
  0x03, 0x61, 0x6C, 0x6C, 0xDA, 0x18, 0x2C, 0x02, 0x00, 0x00, 0x27, 0x03, 0x00, 0x00, 0x26, 0x05, 
  0x00, 0x00, 0x47, 0x04, 0x01, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x0A, 0x00, 0x38, 0x04, 
  0x01, 0x05, 0x19, 0x06, 0x04, 0x00, 0x1C, 0x03, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x1A, 0x05, 
  0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x03, 0x00, 0x00, 0x47, 0x05, 0x01, 0x05, 0x1A, 0xF7, 
  0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x88, 0x13, 0x01, 0x05, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x28, 0x00, 
  0x28, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0xDA, 0x53, 0xDA, 0x86, 0x8B, 0xDA, 0x84, 0xF8, 
  0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x01, 0x10, 0xCE, 0x06, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x73, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 
  0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 
  0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x48, 0x06, 0x07, 0x05, 0x1C, 0x06, 0x07, 0x00, 0x38, 0x07, 
  0x00, 0x05, 0x30, 0x03, 0x07, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x47, 0x05, 
  0x00, 0x05, 0x1A, 0xF8, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x86, 0x10, 0x01, 0x03, 0x03, 0x00, 
  0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x15, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 0xBF, 0xFE, 0x03, 0xBF, 0xFB, 0x01, 0x2C, 0x01, 0x00, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x0B, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2A, 0x05, 0x02, 
  0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x04, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x03, 
  0x00, 0x34, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x04, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x04, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x03, 
  0x00, 0x34, 0x04, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x33, 0x04, 0x05, 
  0x00, 0x1C, 0x04, 0x10, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x06, 0x06, 0x00, 0x33, 0x05, 0x06, 
  0x00, 0x30, 0x01, 0x05, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 
  0x00, 0x1C, 0x06, 0x07, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x33, 0x07, 0x08, 
  0x00, 0x30, 0x01, 0x07, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x34, 0x08, 0x00, 0x00, 0x03, 0x05, 0x00, 
  0x00, 0x27, 0x05, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x8E, 0x6D, 0x01, 0x05, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xBF, 0xFF, 0x03, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0xBF, 0xFC, 0x03, 0x05, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 
  0xFA, 0x03, 0x07, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0xBF, 0xFF, 
  0x05, 0xBF, 0xF9, 0x03, 0x00, 0x03, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 
  0x00, 0x00, 0x8E, 0x7C, 0x01, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x18, 0x00, 0x18, 0x00, 
  0x18, 0xDA, 0x81, 0xB4, 0xCB, 0xCF, 0x05, 0x76, 0x61, 0x72, 0x66, 0x6E, 0xCB, 0xDA, 0x87, 0x2C, 
  0xDA, 0x88, 0x1A, 0xCF, 0x08, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0xCB, 0xDA, 0x82, 
  0x41, 0xDA, 0x88, 0x1A, 0xDA, 0x87, 0xE6, 0xCB, 0xDA, 0x86, 0x83, 0xCB, 0xDA, 0x44, 0xDA, 0x88, 
  0x1A, 0xCF, 0x04, 0x76, 0x61, 0x72, 0x2D, 0xDA, 0x88, 0x1A, 0xDA, 0x86, 0xDB, 0xDA, 0x88, 0x1A, 
  0xDA, 0x82, 0x3D, 0xCE, 0x07, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x2D, 0xDA, 0x84, 0xE8, 0xDA, 
  0x88, 0x1A, 0xDA, 0x85, 0x63, 0xDA, 0x87, 0x39, 0xDA, 0x80, 0xE4, 0xD7, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x05, 0x14, 0xCE, 0x05, 0x75, 0x73, 0x65, 0x2D, 0x32, 0xDA, 
  0x18, 0xDA, 0x81, 0x38, 0xDA, 0x87, 0x41, 0xDA, 0x81, 0x37, 0xDA, 0x83, 0xE6, 0xDA, 0x87, 0x3C, 
  0x2C, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x01, 0x04, 0x19, 0x04, 0x03, 0x00, 
  0x1D, 0x04, 0x0F, 0x00, 0x38, 0x03, 0x01, 0x04, 0x19, 0x05, 0x03, 0x00, 0x2F, 0x05, 0x00, 0x00, 
  0x2A, 0x06, 0x00, 0x00, 0x33, 0x03, 0x06, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x2A, 0x07, 0x02, 0x00, 
  0x31, 0x03, 0x06, 0x07, 0x2A, 0x06, 0x03, 0x00, 0x30, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 
  0x33, 0x06, 0x07, 0x00, 0x47, 0x04, 0x01, 0x04, 0x1A, 0xF2, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 
  0x8E, 0x83, 0x01, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xD5, 0x04, 0xCF, 0x06, 0x69, 0x6D, 0x70, 
  0x6F, 0x72, 0x74, 0xCB, 0xDA, 0x85, 0x22, 0xCB, 0xCF, 0x06, 0x64, 0x6F, 0x66, 0x69, 0x6C, 0x65, 
  0xCB, 0xCF, 0x07, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x2A, 0xCB, 0xDA, 0x84, 0x21, 0xDA, 0x83, 
  0xE6, 0xDA, 0x78, 0xD8, 0x0C, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 
  0x70, 0xDA, 0x80, 0x83, 0x2C, 0x04, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 
  0x33, 0x05, 0x06, 0x00, 0x1C, 0x05, 0x4B, 0x00, 0x29, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 
  0x33, 0x06, 0x01, 0x00, 0x19, 0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 
  0x33, 0x06, 0x08, 0x00, 0x19, 0x08, 0x06, 0x00, 0x1C, 0x08, 0x03, 0x00, 0x19, 0x06, 0x08, 0x00, 
  0x1A, 0x11, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 
  0x1C, 0x0A, 0x0B, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x30, 0x0C, 0x07, 0x00, 0x2A, 0x0D, 0x04, 0x00, 
  0x33, 0x0C, 0x0D, 0x00, 0x1C, 0x0C, 0x03, 0x00, 0x2A, 0x0B, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x26, 0x0B, 0x00, 0x00, 0x19, 0x09, 0x0B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x09, 0x00, 0x00, 
  0x19, 0x06, 0x09, 0x00, 0x19, 0x08, 0x06, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x06, 0x00, 
  0x33, 0x06, 0x09, 0x00, 0x1C, 0x06, 0x06, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x33, 0x09, 0x08, 0x00, 
  0x1C, 0x09, 0x02, 0x00, 0x34, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1C, 0x08, 0x02, 0x00, 
  0x34, 0x00, 0x00, 0x00, 0x2A, 0x0A, 0x07, 0x00, 0x23, 0x09, 0x0A, 0x07, 0x1C, 0x09, 0x08, 0x00, 
  0x29, 0x0A, 0x01, 0x00, 0x30, 0x01, 0x0A, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x33, 0x0A, 0x0B, 0x00, 
  0x30, 0x04, 0x0A, 0x00, 0x2A, 0x0B, 0x09, 0x00, 0x34, 0x0B, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 
  0x2A, 0x0B, 0x0A, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x15, 0x00, 0x2F, 0x01, 0x00, 0x00, 
  0x2A, 0x0C, 0x0B, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x3B, 0x0C, 0x0B, 0x00, 0x19, 0x0D, 0x0C, 0x00, 
  0x3B, 0x0C, 0x0B, 0x01, 0x19, 0x0E, 0x0C, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x0B, 0x0C, 0x00, 
  0x30, 0x0B, 0x04, 0x00, 0x2A, 0x0C, 0x0D, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x31, 0x0B, 0x0D, 0x0E, 
  0x2A, 0x0F, 0x0E, 0x00, 0x33, 0x0C, 0x0F, 0x00, 0x19, 0x0B, 0x0C, 0x00, 0x31, 0x0B, 0x02, 0x03, 
  0x2A, 0x0F, 0x0F, 0x00, 0x33, 0x0C, 0x0F, 0x00, 0x34, 0x0C, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0x8E, 0x86, 0x01, 0x05, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x01, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x03, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x02, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x09, 0x01, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFF, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFE, 0x07, 0xBF, 0xFF, 0x05, 0x07, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0xBF, 0xFE, 0x05, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x1F, 0x00, 0x07, 0xBF, 0xFD, 
  0x05, 0x06, 0x07, 0x02, 0x07, 0x00, 0x07, 0xBF, 0xF8, 0x05, 0x09, 0x21, 0x00, 0x21, 0x00, 0x21, 
  0x00, 0x21, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xF5, 
  0x05, 0x0C, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 
  0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xBF, 
  0xFF, 0x07, 0x02, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x09, 0xBF, 0xF2, 0x05, 0xBF, 0xF9, 0x03, 
  0xD7, 0x00, 0xCD, 0x03, 0xBB, 0x00, 0x00, 0x24, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x16, 
  0x7E, 0x04, 0xCE, 0x06, 0x64, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0xDA, 0x18, 0xDA, 0x83, 0xE1, 0xDA, 
  0x83, 0xE5, 0xDA, 0x83, 0x4C, 0xDA, 0x83, 0xE6, 0xDA, 0x83, 0xE8, 0xDA, 0x83, 0xDE, 0xDA, 0x84, 
  0x03, 0xDA, 0x1C, 0xD0, 0x09, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x66, 0x69, 0x6C, 0x65, 0xD0, 0x0B, 
  0x63, 0x6F, 0x72, 0x65, 0x2F, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0xDA, 0x83, 0x4F, 0xDA, 0x83, 
  0x50, 0xDA, 0x83, 0x30, 0xDA, 0x81, 0x38, 0xCE, 0x14, 0x63, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0xDA, 0x84, 0x00, 
  0xDA, 0x83, 0xE2, 0xDA, 0x83, 0xE4, 0xDA, 0x83, 0xDC, 0xDA, 0x83, 0xDD, 0xDA, 0x83, 0xDF, 0xDA, 
  0x81, 0xB0, 0x2A, 0x0A, 0x00, 0x00, 0x38, 0x09, 0x01, 0x0A, 0x19, 0x0A, 0x09, 0x00, 0x2A, 0x0B, 
  0x01, 0x00, 0x38, 0x09, 0x01, 0x0B, 0x19, 0x0B, 0x09, 0x00, 0x2A, 0x0C, 0x02, 0x00, 0x38, 0x09, 
  0x01, 0x0C, 0x19, 0x0C, 0x09, 0x00, 0x2A, 0x0D, 0x03, 0x00, 0x38, 0x09, 0x01, 0x0D, 0x19, 0x0D, 
  0x09, 0x00, 0x2A, 0x0E, 0x04, 0x00, 0x38, 0x09, 0x01, 0x0E, 0x19, 0x0E, 0x09, 0x00, 0x2A, 0x0F, 
  0x05, 0x00, 0x38, 0x09, 0x01, 0x0F, 0x19, 0x0F, 0x09, 0x00, 0x2A, 0x10, 0x06, 0x00, 0x38, 0x09, 
  0x01, 0x10, 0x19, 0x10, 0x09, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x11, 
  0x07, 0x00, 0x33, 0x09, 0x11, 0x00, 0x19, 0x11, 0x09, 0x00, 0x2A, 0x13, 0x08, 0x00, 0x23, 0x12, 
  0x11, 0x13, 0x1C, 0x12, 0x03, 0x00, 0x19, 0x09, 0x00, 0x00, 0x1A, 0x0C, 0x00, 0x00, 0x2A, 0x15, 
  0x09, 0x00, 0x23, 0x14, 0x11, 0x15, 0x1C, 0x14, 0x03, 0x00, 0x19, 0x13, 0x00, 0x00, 0x1A, 0x06, 
  0x00, 0x00, 0x2A, 0x15, 0x0A, 0x00, 0x30, 0x00, 0x15, 0x00, 0x2A, 0x16, 0x0B, 0x00, 0x33, 0x15, 
  0x16, 0x00, 0x19, 0x13, 0x15, 0x00, 0x19, 0x09, 0x13, 0x00, 0x19, 0x11, 0x09, 0x00, 0x23, 0x12, 
  0x11, 0x00, 0x19, 0x13, 0x12, 0x00, 0x26, 0x16, 0x00, 0x00, 0x23, 0x15, 0x16, 0x0F, 0x1C, 0x15, 
  0x05, 0x00, 0x2A, 0x17, 0x0C, 0x00, 0x33, 0x16, 0x17, 0x00, 0x19, 0x14, 0x16, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x14, 0x0F, 0x00, 0x19, 0x15, 0x14, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x17, 
  0x0D, 0x00, 0x33, 0x16, 0x17, 0x00, 0x19, 0x17, 0x16, 0x00, 0x1C, 0x0C, 0x03, 0x00, 0x19, 0x18, 
  0x0C, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x1C, 0x13, 0x03, 0x00, 0x19, 0x19, 0x00, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x19, 0x17, 0x00, 0x19, 0x18, 0x19, 0x00, 0x2A, 0x19, 0x02, 0x00, 0x3A, 0x15, 
  0x19, 0x18, 0x26, 0x18, 0x00, 0x00, 0x26, 0x19, 0x00, 0x00, 0x2E, 0x1A, 0x00, 0x00, 0x19, 0x1B, 
  0x1A, 0x00, 0x2E, 0x1C, 0x01, 0x00, 0x19, 0x1D, 0x1C, 0x00, 0x2E, 0x1E, 0x02, 0x00, 0x19, 0x1F, 
  0x1E, 0x00, 0x1C, 0x11, 0x02, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 0x20, 0x0E, 0x00, 0x30, 0x20, 
  0x00, 0x00, 0x2A, 0x21, 0x0D, 0x00, 0x33, 0x20, 0x21, 0x00, 0x01, 0x20, 0x00, 0x00, 0x2E, 0x20, 
  0x03, 0x00, 0x1C, 0x0C, 0x03, 0x00, 0x19, 0x21, 0x0C, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x1C, 0x13, 
  0x03, 0x00, 0x2A, 0x22, 0x0F, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x22, 0x17, 0x00, 0x19, 0x21, 
  0x22, 0x00, 0x2A, 0x22, 0x00, 0x00, 0x2A, 0x23, 0x10, 0x00, 0x31, 0x22, 0x0A, 0x23, 0x2A, 0x22, 
  0x05, 0x00, 0x31, 0x1D, 0x22, 0x15, 0x2A, 0x22, 0x11, 0x00, 0x2A, 0x23, 0x12, 0x00, 0x31, 0x22, 
  0x1F, 0x23, 0x2A, 0x22, 0x01, 0x00, 0x31, 0x1B, 0x22, 0x0B, 0x2A, 0x22, 0x13, 0x00, 0x2A, 0x23, 
  0x02, 0x00, 0x31, 0x22, 0x20, 0x23, 0x2A, 0x22, 0x03, 0x00, 0x31, 0x21, 0x22, 0x0D, 0x2A, 0x22, 
  0x04, 0x00, 0x30, 0x22, 0x0E, 0x00, 0x41, 0x20, 0x00, 0x00, 0x2F, 0x20, 0x00, 0x00, 0x2A, 0x22, 
  0x14, 0x00, 0x33, 0x21, 0x22, 0x00, 0x19, 0x20, 0x21, 0x00, 0x1C, 0x13, 0x02, 0x00, 0x1A, 0x04, 
  0x00, 0x00, 0x2F, 0x11, 0x00, 0x00, 0x2A, 0x23, 0x15, 0x00, 0x33, 0x22, 0x23, 0x00, 0x1C, 0x18, 
  0x06, 0x00, 0x1C, 0x19, 0x03, 0x00, 0x37, 0x22, 0x18, 0x19, 0x1A, 0x02, 0x00, 0x00, 0x01, 0x18, 
  0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 
  0x02, 0x02, 0x02, 0x01, 0x06, 0x01, 0xCE, 0x06, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0x73, 0xDA, 0x18, 
  0xDA, 0x83, 0xE1, 0x2C, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x11, 0x29, 0x04, 0x00, 0x10, 0x31, 
  0x03, 0x04, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x34, 0x03, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0x06, 0x03, 
  0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0xCD, 0x02, 0xFA, 0x00, 0x00, 0x08, 
  0x02, 0x00, 0x02, 0x07, 0x22, 0x01, 0x01, 0xCE, 0x02, 0x62, 0x70, 0xDA, 0x18, 0xDA, 0x83, 0xFC, 
  0xDA, 0x87, 0x37, 0xDA, 0x84, 0x03, 0xDA, 0x81, 0x37, 0xDA, 0x82, 0xC9, 0xDA, 0x80, 0xBA, 0xDA, 
  0x81, 0x36, 0x2C, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x10, 0x1C, 0x03, 0x09, 0x00, 0x30, 0x00, 
  0x01, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x29, 0x03, 0x01, 0x00, 0x2F, 0x03, 
  0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2B, 0x03, 
  0x00, 0x15, 0x2A, 0x04, 0x02, 0x00, 0x27, 0x05, 0x00, 0x00, 0x3A, 0x03, 0x04, 0x05, 0x2A, 0x03, 
  0x03, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x3F, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2E, 0x05, 
  0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x30, 0x05, 0x06, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x33, 0x06, 
  0x07, 0x00, 0x26, 0x07, 0x00, 0x00, 0x35, 0x05, 0x06, 0x07, 0x29, 0x06, 0x00, 0x00, 0x29, 0x07, 
  0xFE, 0xFF, 0x31, 0x04, 0x06, 0x07, 0x2A, 0x07, 0x06, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2D, 0x06, 
  0x00, 0x18, 0x2B, 0x07, 0x00, 0x18, 0x03, 0x07, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x0F, 0x01, 0xDA, 0x18, 0xDA, 0x86, 0xDF, 0xDA, 0x82, 0x5B, 
  0xDA, 0x83, 0xA5, 0xDA, 0x83, 0xFC, 0x2A, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x04, 0x30, 0x00, 
  0x01, 0x00, 0x2A, 0x01, 0x01, 0x00, 0x33, 0x00, 0x01, 0x00, 0x2A, 0x01, 0x02, 0x00, 0x28, 0x02, 
  0x00, 0x00, 0x30, 0x01, 0x02, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x33, 0x01, 0x02, 0x00, 0x2B, 0x02, 
  0x00, 0x00, 0x2B, 0x03, 0x00, 0x01, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x02, 0x03, 0x00, 0x34, 0x02, 
  0x00, 0x00, 0xBF, 0xFF, 0x8B, 0x0D, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x8B, 0x07, 0x03, 0x01, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x05, 0x03, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x05, 0x00, 0x05, 0x13, 0x00, 0x00, 0x00, 0xCD, 0x02, 0xFA, 
  0x00, 0x00, 0x0B, 0x05, 0x00, 0x05, 0x07, 0x24, 0x01, 0x01, 0xCE, 0x02, 0x62, 0x63, 0xDA, 0x18, 
  0xDA, 0x83, 0xE9, 0xDA, 0x87, 0x37, 0xDA, 0x84, 0x03, 0xDA, 0x81, 0x37, 0xDA, 0x82, 0xC9, 0xDA, 
  0x80, 0xBA, 0xDA, 0x81, 0x36, 0x2C, 0x05, 0x00, 0x00, 0x2B, 0x06, 0x00, 0x10, 0x1C, 0x06, 0x0A, 
  0x00, 0x31, 0x00, 0x01, 0x02, 0x30, 0x03, 0x04, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 
  0x00, 0x29, 0x06, 0x01, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 
  0x00, 0x1A, 0x01, 0x00, 0x00, 0x2B, 0x06, 0x00, 0x15, 0x2A, 0x07, 0x02, 0x00, 0x27, 0x08, 0x00, 
  0x00, 0x3A, 0x06, 0x07, 0x08, 0x2A, 0x06, 0x03, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x3F, 0x06, 0x00, 
  0x00, 0x19, 0x07, 0x06, 0x00, 0x2E, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x30, 0x08, 0x09, 
  0x00, 0x2A, 0x0A, 0x05, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x26, 0x0A, 0x00, 0x00, 0x35, 0x08, 0x09, 
  0x0A, 0x29, 0x09, 0x00, 0x00, 0x29, 0x0A, 0xFE, 0xFF, 0x31, 0x07, 0x09, 0x0A, 0x2A, 0x0A, 0x06, 
  0x00, 0x33, 0x09, 0x0A, 0x00, 0x2D, 0x09, 0x00, 0x18, 0x2D, 0x01, 0x00, 0x19, 0x2B, 0x0A, 0x00, 
  0x19, 0x03, 0x0A, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
  0x04, 0x13, 0x01, 0xDA, 0x18, 0xDA, 0x86, 0xDF, 0xDA, 0x82, 0x5B, 0xDA, 0x83, 0xA5, 0xDA, 0x83, 
  0xE9, 0x2A, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x07, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x01, 0x01, 
  0x00, 0x33, 0x00, 0x01, 0x00, 0x2A, 0x01, 0x02, 0x00, 0x28, 0x02, 0x00, 0x00, 0x30, 0x01, 0x02, 
  0x00, 0x2A, 0x02, 0x01, 0x00, 0x33, 0x01, 0x02, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x26, 0x03, 0x00, 
  0x00, 0x2B, 0x04, 0x00, 0x02, 0x31, 0x02, 0x03, 0x04, 0x2B, 0x02, 0x00, 0x03, 0x2B, 0x03, 0x00, 
  0x04, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x02, 0x03, 0x00, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 
  0x16, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x8B, 0x10, 0x03, 0x01, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x05, 
  0x03, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x9D, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x09, 0x26, 0x01, 
  0xDA, 0x18, 0xDA, 0x80, 0xBE, 0xDA, 0x80, 0xD6, 0xDA, 0x81, 0x37, 0xDA, 0x83, 0xA8, 0xDA, 0x83, 
  0xDA, 0xDA, 0x87, 0x37, 0xDA, 0x83, 0xDB, 0xDA, 0x83, 0xD7, 0xDA, 0x84, 0x03, 0x2F, 0x00, 0x00, 
  0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x48, 0x03, 0x02, 
  0x04, 0x1C, 0x03, 0x20, 0x00, 0x2B, 0x02, 0x00, 0x10, 0x1C, 0x02, 0x0C, 0x00, 0x2A, 0x02, 0x02, 
  0x00, 0x31, 0x00, 0x01, 0x02, 0x2A, 0x04, 0x03, 0x00, 0x33, 0x02, 0x04, 0x00, 0x2A, 0x04, 0x04, 
  0x00, 0x33, 0x02, 0x04, 0x00, 0x29, 0x02, 0x01, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x05, 
  0x00, 0x33, 0x02, 0x04, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x15, 0x2A, 0x05, 0x06, 
  0x00, 0x39, 0x02, 0x04, 0x05, 0x1C, 0x02, 0x07, 0x00, 0x2B, 0x04, 0x00, 0x15, 0x2F, 0x04, 0x00, 
  0x00, 0x2A, 0x05, 0x07, 0x00, 0x33, 0x04, 0x05, 0x00, 0x30, 0x00, 0x01, 0x00, 0x34, 0x04, 0x00, 
  0x00, 0x2B, 0x04, 0x00, 0x15, 0x2A, 0x05, 0x08, 0x00, 0x27, 0x06, 0x00, 0x00, 0x3A, 0x04, 0x05, 
  0x06, 0x2D, 0x01, 0x00, 0x18, 0x2D, 0x00, 0x00, 0x19, 0x2B, 0x04, 0x00, 0x19, 0x03, 0x04, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8B, 0x22, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x26, 
  0x00, 0x26, 0x00, 0x20, 0x01, 0x22, 0x00, 0x22, 0x01, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 
  0x01, 0x24, 0x00, 0x24, 0x01, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 0xBF, 0xFD, 0x22, 0x04, 
  0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x22, 0x01, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 
  0x24, 0x00, 0x24, 0x02, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x01, 0x26, 0x01, 0x26, 0x00, 
  0x26, 0x00, 0x26, 0xBF, 0xF6, 0x20, 0x8A, 0xF6, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x06, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x03, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFD, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x04, 0x15, 
  0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x14, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x14, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x09, 0x03, 0x00, 0x03, 
  0x0A, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x06, 0x1E, 
  0x10, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x1B, 
  0xBF, 0xEC, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x16, 0x03, 
  0x00, 0x03, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x01, 0x03, 0x01, 0x05, 0x01, 0x07, 0xBF, 0xFF, 
  0x05, 0x02, 0x07, 0xBF, 0xFD, 0x03, 0xBF, 0xC3, 0x01, 0x00, 0x00, 0x23, 0x03, 0x00, 0x00, 0x00, 
  0x00, 0x2B, 0x00, 0x00, 0x01, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x33, 0x00, 0x01, 
  0x00, 0x2B, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x31, 0x01, 0x02, 
  0x03, 0x32, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x03, 0x00, 0x34, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x8E, 
  0xAB, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x8E, 0xA2, 0x01, 0x06, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFD, 0x03, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF3, 0x01, 0x03, 0x00, 0x00, 0x00, 0xCF, 
  0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0x6C, 0xD8, 0x0C, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0x6C, 0xCF, 0x06, 0x2A, 0x65, 0x78, 
  0x69, 0x74, 0x2A, 0xDA, 0x84, 0x03, 0xCF, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 
  0x72, 0x69, 0x6D, 0x72, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 
  0x6D, 0x72, 0xDA, 0x82, 0xC8, 0xDA, 0x82, 0x5B, 0xCF, 0x0B, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 
  0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x80, 0xE2, 0xCF, 0x05, 0x65, 0x76, 0x2F, 0x67, 0x6F, 0xDA, 
  0x3A, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0xD8, 0x0A, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0xCF, 0x05, 0x66, 0x6C, 0x75, 0x73, 0x68, 
  0xDA, 0x82, 0xB7, 0xCF, 0x05, 0x73, 0x74, 0x64, 0x69, 0x6E, 0xD8, 0x05, 0x73, 0x74, 0x64, 0x69, 
  0x6E, 0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 
  0x65, 0x2D, 0x61, 0x6C, 0x6C, 0xDA, 0x81, 0x52, 0xCF, 0x0A, 0x66, 0x66, 0x69, 0x2F, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0xD8, 0x0A, 0x66, 0x66, 0x69, 0x2F, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x32, 0xD8, 0x0A, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x32, 0xCF, 0x0C, 0x69, 0x6E, 0x74, 0x2F, 0x74, 0x6F, 
  0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0xD8, 0x0C, 0x69, 0x6E, 0x74, 0x2F, 0x74, 0x6F, 0x2D, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0xCF, 0x06, 0x63, 0x75, 0x72, 0x65, 0x6E, 0x76, 0xDA, 0x87, 0x3E, 0xCF, 
  0x0C, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 0xDA, 0x85, 0x2B, 
  0xCF, 0x05, 0x70, 0x61, 0x72, 0x73, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 
  0x01, 0x01, 0x09, 0x2A, 0xCE, 0x05, 0x70, 0x61, 0x72, 0x73, 0x65, 0xDA, 0x18, 0xDA, 0x82, 0xDB, 
  0xDA, 0x82, 0x07, 0xDA, 0x82, 0xDC, 0xDA, 0x80, 0xC1, 0xDA, 0x82, 0xDD, 0xDA, 0x82, 0x7B, 0xDA, 
  0x82, 0xDE, 0xDA, 0x82, 0xDF, 0xCE, 0x08, 0x6E, 0x6F, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 
  0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x30, 
  0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x02, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 
  0x04, 0x02, 0x00, 0x33, 0x02, 0x04, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x23, 0x04, 0x05, 0x02, 0x1C, 
  0x04, 0x06, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x33, 0x02, 0x05, 0x00, 0x01, 
  0x02, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x05, 0x00, 0x33, 
  0x02, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x06, 0x00, 0x33, 0x02, 0x04, 0x00, 0x1C, 
  0x02, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x07, 0x00, 0x34, 0x04, 0x00, 0x00, 0x2F, 
  0x03, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x23, 
  0x05, 0x06, 0x04, 0x1C, 0x05, 0x06, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x33, 
  0x04, 0x06, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x08, 0x00, 0x01, 
  0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x89, 0xFB, 0x01, 0x04, 0x0B, 0x00, 0x0B, 0x00, 0x03, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x02, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x01, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0xCF, 0x04, 0x66, 
  0x6F, 0x72, 0x76, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x08, 0x03, 0x03, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x03, 0x09, 0xCE, 0x04, 0x66, 0x6F, 0x72, 0x76, 0xDA, 0x18, 0xDA, 0x81, 0x47, 0xDA, 
  0x27, 0xDA, 0x87, 0x04, 0x2C, 0x04, 0x00, 0x00, 0x31, 0x00, 0x01, 0x02, 0x29, 0x05, 0x01, 0x00, 
  0x2A, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x31, 0x05, 0x06, 0x07, 0x2F, 0x03, 0x00, 0x00, 
  0x2A, 0x05, 0x02, 0x00, 0x34, 0x05, 0x00, 0x00, 0x81, 0xF6, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0xDA, 0x82, 0xD9, 0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2D, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0xD8, 0x12, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2D, 0x6C, 0x6F, 0x77, 0x65, 
  0x72, 0xCF, 0x03, 0x6E, 0x6F, 0x74, 0xDA, 0x73, 0xCF, 0x0A, 0x6F, 0x73, 0x2F, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0xD8, 0x0A, 0x6F, 0x73, 0x2F, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 
  0xCF, 0x08, 0x65, 0x76, 0x2F, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0xD8, 0x08, 0x65, 0x76, 0x2F, 0x63, 
  0x6F, 0x75, 0x6E, 0x74, 0xCF, 0x0B, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 
  0x64, 0xDA, 0x85, 0x29, 0xCF, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 
  0xDA, 0x84, 0x79, 0xCF, 0x09, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xD8, 0x09, 
  0x66, 0x66, 0x69, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xCF, 0x0C, 0x6F, 0x73, 0x2F, 0x70, 0x72, 
  0x6F, 0x63, 0x2D, 0x6B, 0x69, 0x6C, 0x6C, 0xD8, 0x0C, 0x6F, 0x73, 0x2F, 0x70, 0x72, 0x6F, 0x63, 
  0x2D, 0x6B, 0x69, 0x6C, 0x6C, 0xCF, 0x05, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0xD7, 0x00, 0xCD, 0x00, 
  0x99, 0x00, 0x00, 0x07, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x0D, 0xCE, 0x05, 0x6C, 
  0x61, 0x62, 0x65, 0x6C, 0xDA, 0x18, 0xDA, 0x44, 0xD6, 0x00, 0xDA, 0x83, 0x1A, 0xDA, 0x4A, 0x2C, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x04, 0x00, 0x05, 0x43, 
  0x03, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x33, 
  0x04, 0x05, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x31, 0x06, 0x03, 0x04, 0x43, 0x05, 0x00, 0x00, 0x03, 
  0x05, 0x00, 0x00, 0x81, 0x6F, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 
  0x12, 0x65, 0x76, 0x2F, 0x67, 0x69, 0x76, 0x65, 0x2D, 0x73, 0x75, 0x70, 0x65, 0x72, 0x76, 0x69, 
  0x73, 0x6F, 0x72, 0xD8, 0x12, 0x65, 0x76, 0x2F, 0x67, 0x69, 0x76, 0x65, 0x2D, 0x73, 0x75, 0x70, 
  0x65, 0x72, 0x76, 0x69, 0x73, 0x6F, 0x72, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 
  0x61, 0x6E, 0x68, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x68, 0xCF, 
  0x06, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0xDA, 0x85, 0x6B, 0xCF, 0x10, 0x65, 0x76, 0x2F, 0x77, 
  0x69, 0x74, 0x68, 0x2D, 0x64, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x65, 0xD7, 0x00, 0xCD, 0x00, 
  0x99, 0x00, 0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x05, 0x17, 0xCE, 0x10, 0x65, 
  0x76, 0x2F, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x64, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x65, 0xDA, 
  0x18, 0xDA, 0x43, 0xDA, 0x80, 0xEC, 0xDA, 0x87, 0x9A, 0xDA, 0x80, 0xBC, 0xDA, 0x80, 0xC2, 0x2C, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 
  0x05, 0x01, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x30, 
  0x04, 0x03, 0x00, 0x44, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x26, 0x07, 0x00, 0x00, 0x31, 
  0x06, 0x00, 0x07, 0x2F, 0x04, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x30, 
  0x07, 0x04, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x08, 0x05, 0x03, 0x2F, 
  0x06, 0x00, 0x00, 0x43, 0x07, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x8D, 0xF9, 0x03, 0x04, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xDA, 0x84, 0x33, 0xDA, 0x78, 0xCF, 
  0x07, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 
  0x01, 0x01, 0x01, 0x00, 0x06, 0xCE, 0x07, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x3F, 0xDA, 0x18, 
  0x2C, 0x01, 0x00, 0x00, 0x1C, 0x00, 0x03, 0x00, 0x27, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 
  0x28, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x7B, 0x01, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 
  0x00, 0x2B, 0x00, 0x2B, 0xCF, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 
  0xD8, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xCF, 0x07, 0x65, 0x76, 
  0x2F, 0x6C, 0x6F, 0x63, 0x6B, 0xD8, 0x07, 0x65, 0x76, 0x2F, 0x6C, 0x6F, 0x63, 0x6B, 0xDA, 0x86, 
  0x97, 0xDA, 0x82, 0x98, 0xCF, 0x10, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x6C, 0x61, 0x73, 0x74, 
  0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0xDA, 0x83, 0x35, 0xCF, 0x0E, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x2F, 0x73, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xDA, 0x83, 0x32, 0xCF, 0x01, 0x25, 0xD7, 
  0x00, 0xCD, 0x00, 0x08, 0x00, 0x1E, 0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 0xCE, 0x01, 0x25, 0x0D, 
  0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x06, 0x6D, 0x61, 0x78, 0x2D, 0x6F, 0x66, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x02, 0x05, 0xCE, 0x06, 0x6D, 0x61, 
  0x78, 0x2D, 0x6F, 0x66, 0xDA, 0x18, 0xDA, 0x84, 0xE5, 0xDA, 0x81, 0x49, 0x2C, 0x01, 0x00, 0x00, 
  0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 
  0x82, 0xDF, 0x01, 0x02, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0xCF, 0x01, 0x2A, 0xD7, 0x00, 
  0xCD, 0x00, 0x09, 0x00, 0x0B, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xDA, 
  0x81, 0x33, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 
  0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 
  0x01, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x09, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 
  0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x09, 0x03, 0x03, 0x04, 0x05, 0x05, 
  0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x01, 
  0x2B, 0xDA, 0x27, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x73, 0x6C, 0x65, 0x65, 0x70, 0xD8, 0x08, 0x6F, 
  0x73, 0x2F, 0x73, 0x6C, 0x65, 0x65, 0x70, 0xCF, 0x01, 0x2D, 0xDA, 0x80, 0x9F, 0xCF, 0x01, 0x2F, 
  0xDA, 0x81, 0x9B, 0xCF, 0x0B, 0x70, 0x65, 0x67, 0x2F, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 
  0xD8, 0x0B, 0x70, 0x65, 0x67, 0x2F, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0xCF, 0x03, 0x61, 
  0x6C, 0x6C, 0xDA, 0x88, 0x1E, 0xCF, 0x01, 0x3C, 0xDA, 0x81, 0x47, 0xDA, 0x80, 0xD5, 0xDA, 0x83, 
  0x1D, 0xDA, 0x87, 0x8D, 0xDA, 0x84, 0xE5, 0xCF, 0x06, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0xDA, 
  0x87, 0x76, 0xCF, 0x03, 0x63, 0x68, 0x72, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 
  0x01, 0x01, 0x03, 0x15, 0xCE, 0x03, 0x63, 0x68, 0x72, 0xDA, 0x18, 0xDA, 0x83, 0xF0, 0xCE, 0x23, 
  0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 
  0x6F, 0x66, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x31, 0x2C, 0x20, 0x67, 0x6F, 0x74, 
  0x20, 0x25, 0x76, 0xDA, 0x46, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x03, 0x05, 0x00, 0x3D, 0x05, 0x00, 
  0x00, 0x24, 0x06, 0x05, 0x01, 0x19, 0x02, 0x06, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x02, 0x04, 
  0x00, 0x1C, 0x02, 0x02, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x03, 0x00, 
  0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x01, 0x03, 0x00, 0x00, 0x29, 0x02, 0x00, 
  0x00, 0x2F, 0x02, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x81, 0x68, 0x01, 0x03, 0x10, 0x00, 0x10, 
  0x00, 0x10, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x1F, 0x00, 0x1C, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xCF, 0x0D, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x6C, 0x69, 0x6E, 0x65, 
  0x61, 0x67, 0x65, 0xD8, 0x0D, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x6C, 0x69, 0x6E, 0x65, 0x61, 
  0x67, 0x65, 0xCF, 0x07, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 0xD7, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x05, 0xCE, 0x07, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 
  0x6E, 0xDA, 0x18, 0xDA, 0x87, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 0x00, 0x00, 0x30, 0x02, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x34, 0x03, 0x00, 0x00, 0x86, 0x6A, 0x01, 0x04, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0x64, 0x69, 0x72, 0xD8, 
  0x08, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0x64, 0x69, 0x72, 0xCF, 0x0A, 0x65, 0x6E, 0x76, 0x2D, 0x6C, 
  0x6F, 0x6F, 0x6B, 0x75, 0x70, 0xD8, 0x0A, 0x65, 0x6E, 0x76, 0x2D, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 
  0x70, 0xCF, 0x11, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2F, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x70, 
  0x72, 0x6F, 0x74, 0x6F, 0xD8, 0x11, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2F, 0x77, 0x69, 0x74, 
  0x68, 0x2D, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xCF, 0x0B, 0x65, 0x76, 0x2F, 0x63, 0x61, 0x70, 0x61, 
  0x63, 0x69, 0x74, 0x79, 0xD8, 0x0B, 0x65, 0x76, 0x2F, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 
  0x79, 0xCF, 0x0B, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x69, 0x65, 0x73, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x00, 0x15, 0xCE, 0x0B, 0x66, 0x72, 0x65, 
  0x71, 0x75, 0x65, 0x6E, 0x63, 0x69, 0x65, 0x73, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x42, 0x02, 
  0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 
  0x04, 0x00, 0x1D, 0x05, 0x0E, 0x00, 0x38, 0x04, 0x00, 0x05, 0x19, 0x06, 0x04, 0x00, 0x38, 0x04, 
  0x03, 0x06, 0x19, 0x07, 0x04, 0x00, 0x1C, 0x07, 0x05, 0x00, 0x29, 0x09, 0x01, 0x00, 0x06, 0x08, 
  0x09, 0x07, 0x19, 0x04, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 0x3A, 0x03, 
  0x06, 0x04, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF3, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x86, 0x24, 
  0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x14, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x0B, 0x6E, 0x65, 0x74, 
  0x2F, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0xD8, 0x0B, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6F, 
  0x6E, 0x6E, 0x65, 0x63, 0x74, 0xCF, 0x0F, 0x65, 0x76, 0x2F, 0x72, 0x65, 0x6C, 0x65, 0x61, 0x73, 
  0x65, 0x2D, 0x6C, 0x6F, 0x63, 0x6B, 0xD8, 0x0F, 0x65, 0x76, 0x2F, 0x72, 0x65, 0x6C, 0x65, 0x61, 
  0x73, 0x65, 0x2D, 0x6C, 0x6F, 0x63, 0x6B, 0xCF, 0x04, 0x6E, 0x69, 0x6C, 0x3F, 0xDA, 0x82, 0x26, 
  0xCF, 0x0C, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x70, 0xDA, 0x88, 
  0x2D, 0xCF, 0x04, 0x71, 0x75, 0x69, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 
  0x00, 0x01, 0x03, 0x0B, 0xCE, 0x04, 0x71, 0x75, 0x69, 0x74, 0xDA, 0x18, 0xDA, 0x84, 0x03, 0xDA, 
  0x82, 0x5B, 0xDA, 0x81, 0xEC, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x27, 0x03, 0x00, 
  0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x02, 
  0x00, 0x30, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0x89, 0xE9, 0x01, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0xCF, 0x09, 0x6F, 0x73, 0x2F, 0x73, 0x65, 
  0x74, 0x65, 0x6E, 0x76, 0xD8, 0x09, 0x6F, 0x73, 0x2F, 0x73, 0x65, 0x74, 0x65, 0x6E, 0x76, 0xCF, 
  0x06, 0x6D, 0x69, 0x6E, 0x2D, 0x6F, 0x66, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 
  0x01, 0x01, 0x02, 0x05, 0xCE, 0x06, 0x6D, 0x69, 0x6E, 0x2D, 0x6F, 0x66, 0xDA, 0x18, 0xDA, 0x81, 
  0x47, 0xDA, 0x81, 0x49, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 
  0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x82, 0xE3, 0x01, 0x02, 0x0A, 0x00, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0xCF, 0x0E, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x70, 0x72, 0x6F, 0x64, 
  0x75, 0x63, 0x65, 0xDA, 0x82, 0xDF, 0xCF, 0x0A, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 0x6D, 0x61, 
  0x67, 0x65, 0xDA, 0x85, 0x7B, 0xDA, 0x85, 0xE4, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0D, 
  0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x24, 0xCE, 0x03, 0x61, 0x6E, 0x64, 0xDA, 0x18, 
  0xDA, 0x71, 0xDA, 0x49, 0xDA, 0x43, 0xDA, 0x44, 0x2C, 0x01, 0x00, 0x00, 0x27, 0x02, 0x00, 0x00, 
  0x3D, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x20, 0x06, 0x05, 0x00, 
  0x1C, 0x06, 0x1D, 0x00, 0x05, 0x05, 0x05, 0xFF, 0x38, 0x07, 0x00, 0x05, 0x19, 0x08, 0x07, 0x00, 
  0x27, 0x09, 0x00, 0x00, 0x23, 0x07, 0x02, 0x09, 0x1C, 0x07, 0x03, 0x00, 0x19, 0x02, 0x08, 0x00, 
  0x1A, 0x14, 0x00, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x09, 0x0A, 0x00, 
  0x1C, 0x09, 0x06, 0x00, 0x2A, 0x0A, 0x01, 0x00, 0x31, 0x0A, 0x08, 0x02, 0x2F, 0x08, 0x00, 0x00, 
  0x43, 0x02, 0x00, 0x00, 0x1A, 0x0B, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 
  0x19, 0x0B, 0x0A, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x31, 0x0A, 0x0B, 0x08, 0x43, 0x0A, 0x00, 0x00, 
  0x2A, 0x0C, 0x01, 0x00, 0x31, 0x0C, 0x0A, 0x02, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 
  0x1A, 0xE3, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x81, 0x13, 0x01, 0x04, 0x03, 0x01, 0x0C, 0x00, 
  0x03, 0x01, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x05, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x12, 0x00, 
  0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x02, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x01, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFF, 0x10, 0x02, 0x1D, 0x00, 0x1D, 0x00, 0x16, 
  0x01, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xBF, 0xF8, 
  0x03, 0xBF, 0xF9, 0x01, 0xCF, 0x08, 0x65, 0x76, 0x2F, 0x73, 0x70, 0x61, 0x77, 0x6E, 0xD7, 0x00, 
  0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x0D, 0xCE, 
  0x08, 0x65, 0x76, 0x2F, 0x73, 0x70, 0x61, 0x77, 0x6E, 0xDA, 0x18, 0xDA, 0x84, 0x36, 0xDA, 0x80, 
  0xB9, 0xCF, 0x06, 0x5F, 0x73, 0x70, 0x61, 0x77, 0x6E, 0xDA, 0x3A, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x44, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x2A, 
  0x05, 0x02, 0x00, 0x31, 0x04, 0x05, 0x02, 0x32, 0x00, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 
  0x04, 0x03, 0x00, 0x30, 0x04, 0x03, 0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x8D, 
  0xE9, 0x03, 0x03, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x09, 0x6F, 0x73, 0x2F, 0x6D, 
  0x6B, 0x74, 0x69, 0x6D, 0x65, 0xD8, 0x09, 0x6F, 0x73, 0x2F, 0x6D, 0x6B, 0x74, 0x69, 0x6D, 0x65, 
  0xCF, 0x07, 0x65, 0x76, 0x2F, 0x66, 0x75, 0x6C, 0x6C, 0xD8, 0x07, 0x65, 0x76, 0x2F, 0x66, 0x75, 
  0x6C, 0x6C, 0xCF, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 0xD8, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x74, 0x69, 0x6D, 0x65, 0xD8, 0x07, 0x6F, 0x73, 0x2F, 0x74, 0x69, 
  0x6D, 0x65, 0xDA, 0x88, 0x23, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x0A, 0xCE, 0x08, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 
  0xDA, 0x18, 0xDA, 0x82, 0x5B, 0xDA, 0x2B, 0xDA, 0x81, 0xB7, 0x2C, 0x02, 0x00, 0x00, 0x42, 0x03, 
  0x00, 0x00, 0x30, 0x00, 0x03, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x03, 
  0x01, 0x00, 0x30, 0x00, 0x03, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x34, 0x03, 
  0x00, 0x00, 0x2D, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0D, 0x2A, 0x6C, 0x69, 0x6E, 0x74, 0x2D, 0x6C, 0x65, 
  0x76, 0x65, 0x6C, 0x73, 0x2A, 0xDA, 0x84, 0x14, 0xCF, 0x0A, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0x2F, 0x6E, 0x65, 0x77, 0xDA, 0x82, 0xDB, 0xCF, 0x0E, 0x6F, 0x73, 0x2F, 0x70, 0x65, 0x72, 0x6D, 
  0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xD8, 0x0E, 0x6F, 0x73, 0x2F, 0x70, 0x65, 0x72, 0x6D, 
  0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xCF, 0x09, 0x65, 0x76, 0x2F, 0x73, 0x65, 0x6C, 0x65, 
  0x63, 0x74, 0xD8, 0x09, 0x65, 0x76, 0x2F, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0xCF, 0x0E, 0x65, 
  0x76, 0x2F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2D, 0x63, 0x68, 0x61, 0x6E, 0xD8, 0x0E, 0x65, 
  0x76, 0x2F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2D, 0x63, 0x68, 0x61, 0x6E, 0xCF, 0x07, 0x65, 
  0x76, 0x2F, 0x74, 0x61, 0x6B, 0x65, 0xDA, 0x87, 0xB3, 0xCF, 0x07, 0x75, 0x6E, 0x74, 0x72, 0x61, 
  0x63, 0x65, 0xD8, 0x07, 0x75, 0x6E, 0x74, 0x72, 0x61, 0x63, 0x65, 0xCF, 0x08, 0x61, 0x73, 0x2D, 
  0x6D, 0x61, 0x63, 0x72, 0x6F, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0xCE, 0x08, 0x61, 0x73, 0x2D, 0x6D, 0x61, 0x63, 0x72, 0x6F, 
  0xDA, 0x18, 0x2C, 0x02, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x33, 0x01, 
  0x06, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x67, 0x72, 0x6F, 0x75, 0x70, 0x2D, 0x62, 0x79, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x02, 0x02, 0x02, 0x01, 0x19, 0xCE, 0x08, 0x67, 0x72, 0x6F, 
  0x75, 0x70, 0x2D, 0x62, 0x79, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 0x42, 0x03, 
  0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 
  0x05, 0x00, 0x1D, 0x06, 0x12, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 0x2F, 0x07, 
  0x00, 0x00, 0x33, 0x05, 0x00, 0x00, 0x19, 0x08, 0x05, 0x00, 0x39, 0x05, 0x04, 0x08, 0x19, 0x09, 
  0x05, 0x00, 0x1C, 0x09, 0x05, 0x00, 0x30, 0x09, 0x07, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x05, 
  0x0A, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x3A, 0x04, 
  0x08, 0x05, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xEF, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x86, 0x2D, 
  0x01, 0x06, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x12, 0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFC, 0x03, 0x00, 
  0x03, 0xBF, 0xF9, 0x01, 0xCF, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x66, 0x6C, 0x75, 
  0x73, 0x68, 0xD8, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 
  0xCF, 0x07, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x06, 0x01, 0x01, 0x01, 0x00, 0x0C, 0xCE, 0x07, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0xDA, 
  0x18, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x01, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x00, 
  0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 0x06, 0x00, 0x38, 0x03, 0x00, 0x04, 0x19, 0x05, 0x03, 
  0x00, 0x09, 0x02, 0x02, 0x05, 0x47, 0x04, 0x00, 0x04, 0x1A, 0xFB, 0xFF, 0xFF, 0x03, 0x02, 0x00, 
  0x00, 0x82, 0x8B, 0x01, 0x03, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x0E, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x0B, 0x6F, 0x73, 0x2F, 
  0x72, 0x65, 0x61, 0x6C, 0x70, 0x61, 0x74, 0x68, 0xD8, 0x0B, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x61, 
  0x6C, 0x70, 0x61, 0x74, 0x68, 0xCF, 0x04, 0x74, 0x61, 0x6B, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x06, 0x14, 0xCE, 0x04, 0x74, 0x61, 0x6B, 0x65, 0xDA, 0x18, 
  0xDA, 0x1A, 0xDA, 0x81, 0x36, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x03, 0x03, 0x03, 
  0x00, 0x12, 0xCE, 0x07, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x2D, 0x6E, 0xDA, 0x18, 0x2C, 0x03, 0x00, 
  0x00, 0x3D, 0x04, 0x02, 0x00, 0x19, 0x05, 0x04, 0x00, 0x20, 0x07, 0x01, 0x00, 0x1C, 0x07, 0x03, 
  0x00, 0x19, 0x06, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 
  0x00, 0x1F, 0x09, 0x07, 0x05, 0x1C, 0x09, 0x03, 0x00, 0x19, 0x08, 0x05, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x19, 0x08, 0x07, 0x00, 0x19, 0x09, 0x08, 0x00, 0x29, 0x0A, 0x00, 0x00, 0x31, 0x02, 0x0A, 
  0x09, 0x34, 0x00, 0x00, 0x00, 0x84, 0x4C, 0x01, 0x02, 0x0C, 0x00, 0x03, 0x02, 0x0E, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x10, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x84, 0x0A, 0xDA, 0x80, 0xE4, 
  0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x02, 0x02, 0x02, 0x01, 0x19, 0xCE, 0x0F, 0x74, 
  0x61, 0x6B, 0x65, 0x2D, 0x6E, 0x2D, 0x66, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0xDA, 0x18, 
  0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x20, 
  0x05, 0x00, 0x00, 0x1C, 0x05, 0x14, 0x00, 0x19, 0x06, 0x00, 0x00, 0x26, 0x08, 0x00, 0x00, 0x47, 
  0x07, 0x01, 0x08, 0x19, 0x08, 0x07, 0x00, 0x1D, 0x08, 0x0E, 0x00, 0x38, 0x07, 0x01, 0x08, 0x19, 
  0x09, 0x07, 0x00, 0x30, 0x04, 0x09, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x07, 0x0A, 0x00, 0x05, 
  0x06, 0x06, 0xFF, 0x29, 0x0A, 0x00, 0x00, 0x23, 0x07, 0x0A, 0x06, 0x1C, 0x07, 0x03, 0x00, 0x1A, 
  0x04, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x08, 0x01, 0x08, 0x1A, 0xF3, 0xFF, 0xFF, 0x1A, 
  0x01, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x84, 0x39, 0x01, 0x02, 0x03, 0x00, 0x03, 0x01, 0x09, 
  0x00, 0x03, 0x01, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x16, 
  0x00, 0x07, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0xBF, 0xFD, 0x01, 0x2C, 0x02, 0x00, 
  0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x05, 
  0x00, 0x2A, 0x04, 0x01, 0x00, 0x31, 0x04, 0x00, 0x01, 0x2A, 0x04, 0x02, 0x00, 0x34, 0x04, 0x00, 
  0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x05, 
  0x00, 0x2A, 0x05, 0x04, 0x00, 0x31, 0x05, 0x00, 0x01, 0x2A, 0x05, 0x02, 0x00, 0x34, 0x05, 0x00, 
  0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x34, 0x05, 0x00, 0x00, 0x84, 0x54, 0x01, 
  0x04, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x02, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x14, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x05, 0x61, 0x70, 0x70, 0x6C, 0x79, 0xDA, 
  0x84, 0x34, 0xCF, 0x0E, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 
  0x74, 0x73, 0xDA, 0x81, 0x86, 0xCF, 0x0A, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x0A, 
  0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xD0, 0x09, 
  0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 
  0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 
  0x04, 0x03, 0x03, 0x00, 0x00, 0x6C, 0x01, 0x00, 0x33, 0x00, 0x33, 0x00, 0x33, 0x00, 0x30, 0x00, 
  0x30, 0x00, 0x30, 0xCF, 0x07, 0x69, 0x6E, 0x74, 0x2F, 0x73, 0x36, 0x34, 0xD8, 0x07, 0x69, 0x6E, 
  0x74, 0x2F, 0x73, 0x36, 0x34, 0xCF, 0x0E, 0x66, 0x66, 0x69, 0x2F, 0x74, 0x72, 0x61, 0x6D, 0x70, 
  0x6F, 0x6C, 0x69, 0x6E, 0x65, 0xD8, 0x0E, 0x66, 0x66, 0x69, 0x2F, 0x74, 0x72, 0x61, 0x6D, 0x70, 
  0x6F, 0x6C, 0x69, 0x6E, 0x65, 0xCF, 0x06, 0x66, 0x72, 0x65, 0x65, 0x7A, 0x65, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x0E, 0x43, 0xCE, 0x06, 0x66, 0x72, 0x65, 0x65, 
  0x7A, 0x65, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x55, 0xDA, 0x82, 0x48, 0xDA, 0x80, 0xE4, 0xDA, 0x76, 
  0xDA, 0x75, 0xDA, 0x86, 0x0D, 0xDA, 0x88, 0x17, 0xDA, 0x87, 0x58, 0xDA, 0x82, 0x55, 0xDA, 0x82, 
  0x58, 0xDA, 0x74, 0xDA, 0x20, 0xDA, 0x81, 0x38, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 0x00, 
  0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 
  0x33, 0x04, 0x05, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x34, 0x05, 0x00, 0x00, 
  0x2A, 0x05, 0x04, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x07, 0x00, 0x30, 0x01, 0x00, 0x00, 
  0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x03, 0x00, 
  0x34, 0x06, 0x00, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x23, 0x05, 0x03, 0x06, 0x1C, 0x05, 0x17, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 
  0x1C, 0x07, 0x09, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x33, 0x06, 0x08, 0x00, 
  0x30, 0x06, 0x00, 0x00, 0x2A, 0x09, 0x08, 0x00, 0x33, 0x08, 0x09, 0x00, 0x2F, 0x08, 0x00, 0x00, 
  0x34, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x09, 0x00, 0x33, 0x06, 0x08, 0x00, 
  0x30, 0x01, 0x06, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 0x32, 0x08, 0x00, 0x00, 
  0x2A, 0x06, 0x0A, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x0B, 0x00, 0x23, 0x06, 0x03, 0x07, 
  0x1C, 0x06, 0x0A, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x09, 0x00, 0x33, 0x07, 0x08, 0x00, 
  0x30, 0x01, 0x07, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 0x32, 0x08, 0x00, 0x00, 
  0x2A, 0x07, 0x0A, 0x00, 0x34, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x0C, 0x00, 0x23, 0x07, 0x03, 0x08, 
  0x1C, 0x07, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x0D, 0x00, 0x34, 0x08, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x88, 0x39, 0x01, 0x05, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x17, 0x00, 0x17, 0x00, 
  0x17, 0x00, 0x0C, 0x00, 0x0C, 0x01, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x16, 0x00, 0x16, 0x00, 
  0x16, 0x00, 0x0E, 0x00, 0x0E, 0x01, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x17, 0x00, 0x17, 0x00, 
  0x17, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFB, 0x03, 0x00, 0x03, 0x00, 0x03, 0x06, 0x22, 
  0x00, 0x22, 0x00, 0x22, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 
  0xBF, 0xFA, 0x03, 0x00, 0x03, 0x00, 0x03, 0x07, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xF9, 0x03, 
  0xCF, 0x0A, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0xD8, 0x0A, 0x6F, 0x73, 
  0x2F, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0xCF, 0x04, 0x73, 0x6F, 0x72, 0x74, 0xDA, 0x85, 
  0xE5, 0xCF, 0x04, 0x69, 0x6E, 0x74, 0x3F, 0xD8, 0x04, 0x69, 0x6E, 0x74, 0x3F, 0xCF, 0x10, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x75, 0x6E, 0x69, 0x66, 0x6F, 0x72, 0x6D, 0xD8, 
  0x10, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x75, 0x6E, 0x69, 0x66, 0x6F, 0x72, 
  0x6D, 0xCF, 0x0B, 0x2A, 0x64, 0x6F, 0x63, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x2A, 0xDA, 0x81, 
  0x1C, 0xCF, 0x0C, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x69, 0x6E, 0x74, 0xD8, 
  0x0C, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x69, 0x6E, 0x74, 0xCF, 0x07, 0x69, 
  0x66, 0x2D, 0x77, 0x69, 0x74, 0x68, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x03, 0x02, 
  0x03, 0x03, 0x1A, 0xCE, 0x07, 0x69, 0x66, 0x2D, 0x77, 0x69, 0x74, 0x68, 0xDA, 0x18, 0xDA, 0x81, 
  0xB0, 0xDA, 0x81, 0xB1, 0xDA, 0x67, 0x3B, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x3B, 0x03, 
  0x00, 0x01, 0x19, 0x05, 0x03, 0x00, 0x3B, 0x03, 0x00, 0x02, 0x19, 0x06, 0x03, 0x00, 0x2C, 0x00, 
  0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 0x44, 0x03, 0x00, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 0x07, 
  0x06, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x30, 0x07, 0x04, 0x00, 0x43, 0x07, 
  0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x43, 0x08, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x32, 0x08, 
  0x00, 0x00, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x31, 0x08, 
  0x03, 0x09, 0x2F, 0x02, 0x00, 0x00, 0x43, 0x07, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x81, 0x8D, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x05, 0x03, 0x00, 
  0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x14, 0x00, 0x14, 0x00, 0x2F, 0x00, 
  0x2F, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x6F, 0x73, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 0x76, 0xD8, 
  0x09, 0x6F, 0x73, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 0x76, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x61, 0x63, 0x6F, 0x73, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x63, 0x6F, 0x73, 
  0xCF, 0x03, 0x63, 0x6D, 0x70, 0xD7, 0x00, 0xCD, 0x00, 0x08, 0x00, 0x1F, 0x02, 0x02, 0x02, 0x02, 
  0x00, 0x02, 0xCE, 0x03, 0x63, 0x6D, 0x70, 0x25, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0xCF, 
  0x03, 0x67, 0x65, 0x74, 0xDA, 0x85, 0xF4, 0xCF, 0x0C, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 
  0x63, 0x61, 0x63, 0x68, 0x65, 0xDA, 0x85, 0x2E, 0xCF, 0x07, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 
  0x3F, 0xDA, 0x82, 0x3D, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 0x66, 0x63, 0xD8, 
  0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 0x66, 0x63, 0xCF, 0x06, 0x64, 0x65, 0x66, 0x64, 
  0x79, 0x6E, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0A, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x0B, 0x34, 0xCE, 0x06, 0x64, 0x65, 0x66, 0x64, 0x79, 0x6E, 0xDA, 0x18, 0xDA, 0x82, 0x3D, 
  0xCE, 0x16, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 
  0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0xDA, 0x81, 0x5A, 0xDA, 0x81, 0x65, 0xCE, 0x32, 
  0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6C, 
  0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 
  0x69, 0x6E, 0x67, 0x20, 0x27, 0x2A, 0x27, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 
  0x72, 0x73, 0xD0, 0x0D, 0x64, 0x65, 0x66, 0x64, 0x79, 0x6E, 0x2D, 0x70, 0x72, 0x65, 0x66, 0x69, 
  0x78, 0xDA, 0x81, 0x1D, 0xDA, 0x85, 0xBD, 0xD8, 0x07, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 
  0xDA, 0x44, 0xDA, 0x81, 0x07, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x02, 0x00, 0x1A, 0x03, 0x00, 
  0x00, 0x2A, 0x03, 0x01, 0x00, 0x01, 0x03, 0x00, 0x00, 0x3D, 0x04, 0x00, 0x00, 0x20, 0x05, 0x04, 
  0x02, 0x19, 0x04, 0x05, 0x00, 0x1C, 0x05, 0x0D, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x07, 0x02, 
  0x00, 0x33, 0x06, 0x07, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 
  0x00, 0x29, 0x09, 0x2A, 0x00, 0x23, 0x08, 0x09, 0x06, 0x1C, 0x08, 0x02, 0x00, 0x23, 0x08, 0x06, 
  0x07, 0x19, 0x03, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x1C, 0x04, 0x02, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x2A, 0x03, 0x04, 0x00, 0x01, 0x03, 0x00, 
  0x00, 0x2A, 0x03, 0x05, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x06, 0x00, 0x33, 0x03, 0x04, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x05, 0x01, 0x00, 0x29, 0x06, 0xFE, 0xFF, 0x31, 0x00, 0x05, 
  0x06, 0x2A, 0x06, 0x07, 0x00, 0x33, 0x05, 0x06, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x07, 0x08, 
  0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 0x00, 0x2A, 0x08, 0x09, 0x00, 0x2A, 0x09, 0x0A, 
  0x00, 0x31, 0x08, 0x00, 0x09, 0x32, 0x01, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x43, 0x07, 0x00, 
  0x00, 0x03, 0x07, 0x00, 0x00, 0x84, 0xA0, 0x01, 0x07, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x13, 0x00, 0x10, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x39, 0x00, 0x39, 0x00, 0x39, 0x00, 0x25, 0x00, 0x25, 
  0x00, 0x25, 0x00, 0x25, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x1B, 
  0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x04, 
  0x77, 0x69, 0x74, 0x68, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 
  0xFF, 0xFF, 0xFF, 0x04, 0x18, 0xCE, 0x04, 0x77, 0x69, 0x74, 0x68, 0xDA, 0x18, 0xDA, 0x44, 0xDA, 
  0x81, 0xB0, 0xDA, 0x81, 0xB1, 0xDA, 0x4A, 0x3B, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x3B, 
  0x02, 0x00, 0x01, 0x19, 0x04, 0x02, 0x00, 0x3B, 0x02, 0x00, 0x02, 0x19, 0x05, 0x02, 0x00, 0x2C, 
  0x00, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x31, 0x06, 0x03, 0x04, 0x43, 0x02, 0x00, 0x00, 0x1C, 
  0x05, 0x03, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x30, 
  0x06, 0x03, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 
  0x08, 0x02, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x08, 0x02, 0x07, 0x43, 
  0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x81, 0x7C, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 
  0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x14, 0x00, 0x14, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0C, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x2F, 0x72, 0x61, 0x77, 0x67, 0x65, 0x74, 0xD8, 0x0C, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x72, 
  0x61, 0x77, 0x67, 0x65, 0x74, 0xCF, 0x0C, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x2D, 0x6D, 0x6F, 0x64, 
  0x75, 0x6C, 0x65, 0xDA, 0x87, 0x43, 0xCF, 0x08, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x74, 0x79, 
  0xDA, 0x82, 0x45, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x69, 0x6E, 0x68, 0xD8, 0x09, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x69, 0x6E, 0x68, 0xCF, 0x08, 0x6D, 0x61, 0x63, 0x6C, 0x69, 
  0x6E, 0x74, 0x66, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0F, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x08, 0x35, 0xCE, 0x08, 0x6D, 0x61, 0x63, 0x6C, 0x69, 0x6E, 0x74, 0x66, 0xDA, 0x18, 
  0xDA, 0x82, 0x11, 0xDA, 0x81, 0x1D, 0xDA, 0x81, 0xF1, 0xDA, 0x81, 0x69, 0xDA, 0x84, 0x21, 0xDA, 
  0x85, 0xE3, 0xDA, 0x46, 0xDA, 0x81, 0x4C, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2F, 
  0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x1C, 
  0x05, 0x2E, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 
  0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x33, 
  0x08, 0x09, 0x00, 0x1C, 0x08, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x33, 
  0x09, 0x0A, 0x00, 0x19, 0x06, 0x09, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x3B, 
  0x08, 0x06, 0x00, 0x19, 0x09, 0x08, 0x00, 0x3B, 0x08, 0x06, 0x01, 0x19, 0x0A, 0x08, 0x00, 0x29, 
  0x0B, 0xFF, 0xFF, 0x23, 0x08, 0x0B, 0x09, 0x1C, 0x08, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x19, 0x06, 0x09, 0x00, 0x19, 0x08, 0x06, 0x00, 0x29, 0x0C, 0xFF, 0xFF, 0x23, 
  0x0B, 0x0C, 0x0A, 0x1C, 0x0B, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 
  0x06, 0x0A, 0x00, 0x19, 0x0B, 0x06, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x32, 0x02, 0x00, 0x00, 0x2A, 
  0x0C, 0x06, 0x00, 0x33, 0x06, 0x0C, 0x00, 0x19, 0x0C, 0x06, 0x00, 0x31, 0x00, 0x08, 0x0B, 0x2F, 
  0x0C, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x30, 0x05, 0x06, 0x00, 0x2A, 0x0E, 0x07, 0x00, 0x33, 
  0x0D, 0x0E, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x87, 0xA0, 0x01, 0x04, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x05, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x00, 0x22, 0x00, 0x22, 
  0x00, 0x22, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x14, 0x00, 0x14, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x14, 
  0x00, 0x14, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xBF, 0xFA, 0x03, 0xBF, 0xFB, 0x01, 0xCF, 0x0A, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 
  0x6D, 0x61, 0x67, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x02, 
  0x05, 0xCE, 0x0A, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xDA, 0x18, 0xD3, 
  0x00, 0xDA, 0x82, 0x17, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x00, 0x02, 0x00, 
  0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x8A, 0x3E, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0xCF, 0x05, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0xD8, 0x05, 0x6F, 0x73, 0x2F, 0x72, 
  0x6D, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x63, 0x6D, 0xD8, 0x08, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x6C, 0x63, 0x6D, 0xCF, 0x06, 0x6D, 0x61, 0x70, 0x63, 0x61, 0x74, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x01, 0x11, 0xCE, 0x06, 0x6D, 0x61, 0x70, 0x63, 
  0x61, 0x74, 0xDA, 0x18, 0xDA, 0x80, 0xE3, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 0x00, 0x00, 0x19, 
  0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 0x05, 0x00, 0x1D, 
  0x06, 0x0A, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 
  0x05, 0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x47, 
  0x06, 0x01, 0x06, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x83, 0xCF, 0x01, 0x04, 0x03, 
  0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x17, 
  0x00, 0x17, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 
  0xCF, 0x0D, 0x2A, 0x66, 0x66, 0x69, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x2A, 0xDA, 
  0x85, 0xC7, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x30, 0xD8, 0x0A, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x30, 0xCF, 0x05, 0x65, 0x61, 0x63, 0x68, 
  0x6B, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x02, 0x06, 0xCE, 0x05, 0x65, 0x61, 0x63, 0x68, 0x6B, 0xDA, 0x18, 0xDA, 0x87, 0x10, 0xDA, 0x87, 
  0x0C, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x00, 0x01, 0x04, 0x2F, 0x02, 0x00, 
  0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x82, 0x01, 0x01, 0x03, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x04, 0x6E, 0x65, 0x78, 0x74, 0xDA, 0x87, 0x0E, 0xCF, 
  0x08, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x61, 0x6C, 0x6C, 0xDA, 0x85, 0xC2, 0xCF, 0x03, 0x61, 0x73, 
  0x6D, 0xD8, 0x03, 0x61, 0x73, 0x6D, 0xCF, 0x05, 0x65, 0x61, 0x63, 0x68, 0x70, 0xD7, 0x00, 0xCD, 
  0x00, 0x99, 0x00, 0x00, 0x05, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x06, 0xCE, 0x05, 
  0x65, 0x61, 0x63, 0x68, 0x70, 0xDA, 0x18, 0xDA, 0x87, 0x11, 0xDA, 0x87, 0x0C, 0x2C, 0x03, 0x00, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x00, 0x01, 0x04, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 
  0x00, 0x34, 0x04, 0x00, 0x00, 0x82, 0x06, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x04, 0x6F, 0x6E, 0x65, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 
  0x01, 0x01, 0x01, 0x01, 0x07, 0xCE, 0x04, 0x6F, 0x6E, 0x65, 0x3F, 0xDA, 0x18, 0xDA, 0x82, 0xF8, 
  0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x01, 0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x33, 0x02, 0x03, 0x00, 0x24, 0x03, 0x02, 0x00, 0x03, 0x03, 0x00, 0x00, 0x83, 0x25, 0x01, 0x00, 
  0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2C, 0x00, 0x2C, 0xCF, 0x06, 0x65, 0x76, 0x65, 
  0x72, 0x79, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 0x00, 0x11, 
  0xCE, 0x06, 0x65, 0x76, 0x65, 0x72, 0x79, 0x3F, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x27, 0x02, 
  0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x00, 0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 
  0x0B, 0x00, 0x38, 0x03, 0x00, 0x04, 0x19, 0x05, 0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x1C, 0x05, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x02, 
  0x05, 0x00, 0x47, 0x04, 0x00, 0x04, 0x1A, 0xF6, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x85, 0x71, 
  0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x0F, 0xBF, 0xFF, 0x03, 0x00, 0x03, 
  0xBF, 0xFB, 0x01, 0xCF, 0x07, 0x78, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0xD8, 0x07, 0x78, 0x70, 
  0x72, 0x69, 0x6E, 0x74, 0x66, 0xCF, 0x05, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x85, 0xBD, 0xCF, 
  0x0D, 0x2A, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x70, 0x61, 0x74, 0x68, 0x2A, 0xD0, 0x0B, 
  0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x70, 0x61, 0x74, 0x68, 0xDA, 0x87, 0xB0, 0xDA, 0x85, 
  0xD2, 0xCF, 0x07, 0x69, 0x6E, 0x74, 0x2F, 0x75, 0x36, 0x34, 0xD8, 0x07, 0x69, 0x6E, 0x74, 0x2F, 
  0x75, 0x36, 0x34, 0xCF, 0x10, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x63, 0x68, 0x65, 0x63, 
  0x6B, 0x2D, 0x73, 0x65, 0x74, 0xD8, 0x10, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x63, 0x68, 
  0x65, 0x63, 0x6B, 0x2D, 0x73, 0x65, 0x74, 0xDA, 0x88, 0x22, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x16, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x12, 0x67, 0xCE, 0x05, 0x76, 0x61, 0x72, 
  0x66, 0x6E, 0xDA, 0x18, 0xDA, 0x81, 0xB7, 0xDA, 0x81, 0x65, 0xDA, 0x80, 0xE4, 0xDA, 0x85, 0x76, 
  0xDA, 0x83, 0xF0, 0xDA, 0x08, 0xCE, 0x11, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x6D, 
  0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0xDA, 0x81, 0x38, 0xDA, 0x43, 0xDA, 0x82, 0x44, 
  0xDA, 0x81, 0x1D, 0xDA, 0x51, 0xDA, 0x82, 0x5D, 0xDA, 0x44, 0xDA, 0x82, 0x5B, 0xD7, 0x00, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0F, 0x03, 0x03, 0x03, 0x02, 0x24, 0xCE, 0x06, 0x70, 0x75, 0x74, 0x2D, 
  0x69, 0x6E, 0xDA, 0x18, 0xDA, 0x87, 0xE5, 0xDA, 0x82, 0x57, 0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 
  0x00, 0x00, 0x3D, 0x05, 0x01, 0x00, 0x05, 0x06, 0x05, 0xFF, 0x19, 0x05, 0x06, 0x00, 0x22, 0x07, 
  0x05, 0x00, 0x1C, 0x07, 0x04, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x29, 0x07, 0x00, 0x00, 0x19, 0x08, 0x05, 0x00, 0x21, 0x09, 0x07, 0x08, 0x1C, 0x09, 
  0x11, 0x00, 0x39, 0x0A, 0x01, 0x07, 0x19, 0x0B, 0x0A, 0x00, 0x39, 0x0A, 0x04, 0x0B, 0x19, 0x0C, 
  0x0A, 0x00, 0x26, 0x0D, 0x00, 0x00, 0x23, 0x0A, 0x0D, 0x0C, 0x1C, 0x0A, 0x07, 0x00, 0x2A, 0x0E, 
  0x01, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x3A, 0x04, 0x0B, 0x0E, 0x19, 0x04, 
  0x0E, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x04, 0x0C, 0x00, 0x05, 0x07, 0x07, 0x01, 0x1A, 0xEF, 
  0xFF, 0xFF, 0x39, 0x07, 0x01, 0x05, 0x19, 0x08, 0x07, 0x00, 0x39, 0x09, 0x04, 0x08, 0x19, 0x0A, 
  0x09, 0x00, 0x3A, 0x04, 0x08, 0x02, 0x03, 0x00, 0x00, 0x00, 0x85, 0xD5, 0x01, 0x05, 0x03, 0x01, 
  0x11, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x07, 0x00, 0x03, 0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x05, 0x01, 
  0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 0x07, 0x01, 0x09, 0x01, 0x09, 0xBF, 
  0xFD, 0x05, 0x04, 0x07, 0xBF, 0xF9, 0x03, 0x00, 0x03, 0x08, 0x11, 0x00, 0x03, 0x01, 0x11, 0x00, 
  0x03, 0x01, 0x03, 0xBF, 0xEE, 0x01, 0xDA, 0x83, 0xD2, 0xDA, 0x80, 0xC2, 0x2C, 0x02, 0x00, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 
  0x19, 0x04, 0x03, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 
  0x19, 0x06, 0x05, 0x00, 0x29, 0x07, 0x02, 0x00, 0x29, 0x08, 0xFE, 0xFF, 0x31, 0x04, 0x07, 0x08, 
  0x2A, 0x08, 0x02, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x08, 0x07, 0x00, 0x42, 0x09, 0x00, 0x00, 
  0x19, 0x0A, 0x09, 0x00, 0x26, 0x0C, 0x00, 0x00, 0x47, 0x0B, 0x08, 0x0C, 0x19, 0x0C, 0x0B, 0x00, 
  0x1D, 0x0C, 0x18, 0x00, 0x38, 0x0B, 0x08, 0x0C, 0x19, 0x0D, 0x0B, 0x00, 0x2F, 0x0D, 0x00, 0x00, 
  0x2A, 0x0E, 0x03, 0x00, 0x33, 0x0B, 0x0E, 0x00, 0x1C, 0x0B, 0x04, 0x00, 0x27, 0x0E, 0x00, 0x00, 
  0x3A, 0x0A, 0x0D, 0x0E, 0x1A, 0x0D, 0x00, 0x00, 0x2F, 0x0D, 0x00, 0x00, 0x2A, 0x0F, 0x04, 0x00, 
  0x33, 0x0E, 0x0F, 0x00, 0x1C, 0x0E, 0x04, 0x00, 0x2A, 0x0F, 0x05, 0x00, 0x3A, 0x0A, 0x0F, 0x0D, 
  0x1A, 0x06, 0x00, 0x00, 0x2A, 0x0F, 0x06, 0x00, 0x30, 0x0F, 0x0D, 0x00, 0x2A, 0x10, 0x07, 0x00, 
  0x33, 0x0F, 0x10, 0x00, 0x01, 0x0F, 0x00, 0x00, 0x47, 0x0C, 0x08, 0x0C, 0x1A, 0xE9, 0xFF, 0xFF, 
  0x2A, 0x0C, 0x08, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x2A, 0x0D, 0x08, 0x00, 
  0x33, 0x0B, 0x0D, 0x00, 0x19, 0x0D, 0x0B, 0x00, 0x2A, 0x0E, 0x08, 0x00, 0x33, 0x0B, 0x0E, 0x00, 
  0x19, 0x0E, 0x0B, 0x00, 0x2A, 0x0F, 0x09, 0x00, 0x30, 0x0F, 0x00, 0x00, 0x43, 0x0B, 0x00, 0x00, 
  0x2A, 0x10, 0x0A, 0x00, 0x30, 0x10, 0x0B, 0x00, 0x43, 0x0F, 0x00, 0x00, 0x30, 0x0D, 0x0F, 0x00, 
  0x44, 0x0B, 0x00, 0x00, 0x26, 0x10, 0x00, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x3E, 0x0F, 0x00, 0x00, 
  0x2A, 0x11, 0x0B, 0x00, 0x30, 0x11, 0x0F, 0x00, 0x42, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x0C, 0x00, 
  0x31, 0x11, 0x0D, 0x10, 0x43, 0x0F, 0x00, 0x00, 0x2A, 0x11, 0x0D, 0x00, 0x31, 0x11, 0x0C, 0x0F, 
  0x43, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x09, 0x00, 0x30, 0x11, 0x00, 0x00, 0x43, 0x0F, 0x00, 0x00, 
  0x2A, 0x12, 0x0E, 0x00, 0x31, 0x12, 0x0F, 0x0C, 0x43, 0x11, 0x00, 0x00, 0x2A, 0x12, 0x0D, 0x00, 
  0x31, 0x12, 0x0E, 0x06, 0x43, 0x0F, 0x00, 0x00, 0x2A, 0x13, 0x0B, 0x00, 0x29, 0x14, 0x00, 0x00, 
  0x30, 0x13, 0x14, 0x00, 0x44, 0x12, 0x00, 0x00, 0x2A, 0x14, 0x0F, 0x00, 0x31, 0x14, 0x0C, 0x12, 
  0x2F, 0x0E, 0x00, 0x00, 0x43, 0x13, 0x00, 0x00, 0x2A, 0x14, 0x09, 0x00, 0x30, 0x14, 0x0A, 0x00, 
  0x43, 0x12, 0x00, 0x00, 0x2A, 0x15, 0x10, 0x00, 0x31, 0x15, 0x0C, 0x12, 0x43, 0x14, 0x00, 0x00, 
  0x2A, 0x15, 0x11, 0x00, 0x31, 0x15, 0x0B, 0x10, 0x31, 0x11, 0x0F, 0x13, 0x30, 0x14, 0x0E, 0x00, 
  0x43, 0x12, 0x00, 0x00, 0x03, 0x12, 0x00, 0x00, 0x88, 0x59, 0x01, 0x06, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 
  0xFF, 0x05, 0x01, 0x14, 0x00, 0x14, 0xBF, 0xFF, 0x05, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 
  0xFE, 0x05, 0x02, 0x13, 0x00, 0x13, 0xBF, 0xFE, 0x05, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0x00, 0x07, 0xBF, 0xFC, 0x03, 0x00, 0x03, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x08, 0x65, 0x76, 
  0x2F, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0xD8, 0x08, 0x65, 0x76, 0x2F, 0x63, 0x68, 0x75, 0x6E, 0x6B, 
  0xCF, 0x07, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0xDA, 0x89, 0x06, 0xCF, 0x07, 0x63, 0x6F, 
  0x6D, 0x70, 0x61, 0x72, 0x65, 0xDA, 0x82, 0xF8, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x64, 0x61, 0x74, 
  0x65, 0xD8, 0x07, 0x6F, 0x73, 0x2F, 0x64, 0x61, 0x74, 0x65, 0xCF, 0x0A, 0x69, 0x6E, 0x74, 0x65, 
  0x72, 0x6C, 0x65, 0x61, 0x76, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x13, 0x00, 0x00, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x24, 0xCE, 0x0A, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6C, 0x65, 
  0x61, 0x76, 0x65, 0xDA, 0x18, 0xDA, 0x85, 0xF7, 0xDA, 0x82, 0x48, 0xDA, 0x81, 0x45, 0xDA, 0x81, 
  0x4C, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x3D, 0x04, 0x00, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x20, 0x06, 0x05, 0x00, 0x1C, 0x06, 0x1D, 0x00, 0x2A, 0x07, 0x00, 
  0x00, 0x30, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x32, 0x07, 0x00, 
  0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x07, 0x08, 0x00, 0x29, 0x08, 0x00, 
  0x00, 0x19, 0x09, 0x07, 0x00, 0x21, 0x0A, 0x08, 0x09, 0x1C, 0x0A, 0x10, 0x00, 0x19, 0x0B, 0x08, 
  0x00, 0x29, 0x0C, 0x00, 0x00, 0x19, 0x0D, 0x05, 0x00, 0x21, 0x0E, 0x0C, 0x0D, 0x1C, 0x0E, 0x09, 
  0x00, 0x19, 0x0F, 0x0C, 0x00, 0x38, 0x10, 0x00, 0x0F, 0x38, 0x11, 0x10, 0x0B, 0x30, 0x03, 0x11, 
  0x00, 0x2A, 0x12, 0x03, 0x00, 0x33, 0x10, 0x12, 0x00, 0x05, 0x0C, 0x0C, 0x01, 0x1A, 0xF7, 0xFF, 
  0xFF, 0x05, 0x08, 0x08, 0x01, 0x1A, 0xF0, 0xFF, 0xFF, 0x1A, 0x01, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x86, 0x4C, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x0D, 0x00, 0x03, 0x01, 0x09, 0x00, 0x03, 
  0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x02, 0x1B, 0x00, 0x17, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0xBF, 0xFB, 0x01, 0xCF, 0x0D, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0xD8, 0x0D, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x2F, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0xCF, 0x06, 0x73, 0x79, 0x6D, 
  0x62, 0x6F, 0x6C, 0xDA, 0x84, 0xDF, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x65, 0x69, 
  0x6C, 0xDA, 0x84, 0x6F, 0xCF, 0x09, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x70, 0x6F, 0x73, 0x65, 0xDA, 
  0x85, 0x6E, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x70, 0xD8, 0x0A, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x70, 0xCF, 0x10, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x63, 0x6C, 0x65, 0x61, 0x72, 0xD8, 0x10, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x63, 0x6C, 0x65, 0x61, 0x72, 0xCF, 0x0D, 
  0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 0x6E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xD8, 0x0D, 0x64, 
  0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 0x6E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xCF, 0x0F, 0x6D, 0x61, 
  0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x64, 0x69, 0x63, 0x74, 0xDA, 0x89, 0x16, 
  0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x77, 0x68, 0x69, 0x63, 0x68, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x77, 
  0x68, 0x69, 0x63, 0x68, 0xCF, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 0x6F, 0x6E, 0x63, 
  0x61, 0x74, 0xDA, 0x80, 0xE3, 0xCF, 0x0B, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 
  0x78, 0x74, 0xD7, 0x01, 0xCD, 0x03, 0xFB, 0x00, 0x00, 0x0E, 0x01, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x07, 0x2B, 0x01, 0x01, 0xCE, 0x0B, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 
  0x78, 0x74, 0xDA, 0x18, 0xDA, 0x85, 0xBF, 0xDA, 0x85, 0xC0, 0xDA, 0x81, 0xFC, 0xD0, 0x0B, 0x6E, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x70, 0x61, 0x74, 0x68, 0xDA, 0x85, 0xC1, 0xDA, 0x85, 0x3E, 
  0xDA, 0x82, 0x5B, 0x2A, 0x05, 0x00, 0x00, 0x38, 0x04, 0x01, 0x05, 0x19, 0x05, 0x04, 0x00, 0x2A, 
  0x06, 0x01, 0x00, 0x38, 0x04, 0x01, 0x06, 0x19, 0x06, 0x04, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x26, 
  0x08, 0x00, 0x00, 0x23, 0x07, 0x08, 0x06, 0x1C, 0x07, 0x03, 0x00, 0x2B, 0x04, 0x00, 0x02, 0x1A, 
  0x02, 0x00, 0x00, 0x19, 0x04, 0x06, 0x00, 0x19, 0x07, 0x04, 0x00, 0x1C, 0x05, 0x03, 0x00, 0x26, 
  0x08, 0x00, 0x00, 0x1A, 0x05, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x33, 
  0x09, 0x0A, 0x00, 0x19, 0x08, 0x09, 0x00, 0x19, 0x09, 0x08, 0x00, 0x1C, 0x05, 0x05, 0x00, 0x2E, 
  0x0B, 0x00, 0x00, 0x33, 0x0C, 0x0B, 0x00, 0x19, 0x0A, 0x0C, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 
  0x0A, 0x00, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x2A, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x03, 0x00, 0x31, 
  0x0C, 0x05, 0x0D, 0x2A, 0x0C, 0x04, 0x00, 0x31, 0x00, 0x0C, 0x0B, 0x2A, 0x0C, 0x01, 0x00, 0x2A, 
  0x0D, 0x05, 0x00, 0x31, 0x0C, 0x07, 0x0D, 0x2F, 0x09, 0x00, 0x00, 0x42, 0x0C, 0x00, 0x00, 0x2B, 
  0x0D, 0x00, 0x00, 0x30, 0x0D, 0x0C, 0x00, 0x2A, 0x0D, 0x06, 0x00, 0x34, 0x0D, 0x00, 0x00, 0xBF, 
  0xFF, 0xCD, 0x02, 0xF2, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x01, 0xDA, 0x18, 
  0x26, 0x00, 0x00, 0x00, 0x26, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 
  0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x0D, 0x02, 0xDA, 0x18, 
  0xDA, 0x81, 0xFC, 0x2B, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x03, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x03, 
  0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x01, 0x2B, 0x00, 0x01, 0x00, 0x2F, 
  0x00, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x33, 0x00, 0x01, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x2B, 
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x00, 0x8E, 0x47, 0x1C, 0x00, 0x1C, 0x00, 
  0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 
  0x23, 0x00, 0x1C, 0x00, 0x1C, 0x8E, 0x47, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x03, 0x00, 
  0x00, 0x00, 0x8E, 0x41, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x04, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0E, 0x00, 0x05, 0x01, 
  0x13, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x05, 0x01, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0xDB, 0x02, 0xCF, 
  0x08, 0x63, 0x6C, 0x69, 0x2D, 0x6D, 0x61, 0x69, 0x6E, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 
  0x26, 0x01, 0x01, 0x01, 0x3F, 0x81, 0x2E, 0x18, 0xCE, 0x08, 0x63, 0x6C, 0x69, 0x2D, 0x6D, 0x61, 
  0x69, 0x6E, 0xDA, 0x18, 0xDA, 0x81, 0x09, 0xDA, 0x82, 0x5B, 0xCE, 0x0A, 0x4A, 0x41, 0x4E, 0x45, 
  0x54, 0x5F, 0x50, 0x41, 0x54, 0x48, 0xDA, 0x88, 0xF5, 0xDA, 0x84, 0xB9, 0xCE, 0x0D, 0x4A, 0x41, 
  0x4E, 0x45, 0x54, 0x5F, 0x50, 0x52, 0x4F, 0x46, 0x49, 0x4C, 0x45, 0xDA, 0x89, 0x35, 0xDA, 0x81, 
  0x3A, 0xCE, 0x01, 0x64, 0xCE, 0x01, 0x65, 0xCE, 0x01, 0x68, 0xCE, 0x01, 0x69, 0xCE, 0x01, 0x6B, 
  0xCE, 0x01, 0x6C, 0xCE, 0x01, 0x6D, 0xDA, 0x80, 0xA0, 0xCE, 0x01, 0x6E, 0xCE, 0x01, 0x70, 0xCE, 
  0x01, 0x71, 0xCE, 0x01, 0x72, 0xCE, 0x01, 0x73, 0xCE, 0x01, 0x76, 0xCE, 0x01, 0x77, 0xCE, 0x01, 
  0x78, 0xCE, 0x01, 0x45, 0xCE, 0x01, 0x52, 0xDA, 0x81, 0x36, 0xDA, 0x80, 0xE2, 0xDA, 0x83, 0x4D, 
  0xDA, 0x85, 0x7B, 0xDA, 0x84, 0x1B, 0xDA, 0x84, 0x1C, 0xDA, 0x83, 0xDB, 0xDA, 0x81, 0x8B, 0xD7, 
  0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x0E, 0x03, 0x03, 0x03, 0x0C, 0x38, 0x01, 0xCE, 0x08, 0x72, 
  0x75, 0x6E, 0x2D, 0x6D, 0x61, 0x69, 0x6E, 0xDA, 0x18, 0xCF, 0x04, 0x6D, 0x61, 0x69, 0x6E, 0xDA, 
  0x06, 0xDA, 0x51, 0xDA, 0x83, 0xDB, 0xDA, 0x84, 0x01, 0xD0, 0x01, 0x79, 0xDA, 0x80, 0xBA, 0xDA, 
  0x84, 0x10, 0xDA, 0x84, 0x11, 0xDA, 0x80, 0xBE, 0xDA, 0x80, 0xD6, 0xDA, 0x83, 0xD7, 0x2C, 0x03, 
  0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x38, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1C, 0x05, 
  0x33, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x39, 0x04, 0x05, 0x06, 0x19, 0x06, 0x04, 0x00, 0x1C, 0x06, 
  0x03, 0x00, 0x19, 0x04, 0x06, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x39, 0x07, 
  0x05, 0x08, 0x29, 0x09, 0x00, 0x00, 0x38, 0x08, 0x07, 0x09, 0x19, 0x04, 0x08, 0x00, 0x19, 0x06, 
  0x04, 0x00, 0x1C, 0x06, 0x25, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x39, 0x07, 0x00, 0x08, 0x1C, 0x07, 
  0x03, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x05, 0x00, 0x19, 0x07, 
  0x04, 0x00, 0x2E, 0x04, 0x00, 0x00, 0x19, 0x08, 0x04, 0x00, 0x30, 0x08, 0x07, 0x00, 0x2A, 0x09, 
  0x06, 0x00, 0x33, 0x04, 0x09, 0x00, 0x19, 0x09, 0x04, 0x00, 0x30, 0x09, 0x00, 0x00, 0x2A, 0x0A, 
  0x07, 0x00, 0x33, 0x04, 0x0A, 0x00, 0x26, 0x04, 0x00, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 
  0x08, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x0F, 0x00, 0x35, 0x04, 0x09, 0x04, 0x2F, 0x09, 
  0x00, 0x00, 0x2A, 0x0C, 0x09, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x2A, 0x0D, 0x0A, 0x00, 0x48, 0x0C, 
  0x0D, 0x0B, 0x1C, 0x0C, 0x07, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0D, 0x0B, 0x00, 0x33, 0x0B, 
  0x0D, 0x00, 0x30, 0x09, 0x04, 0x00, 0x33, 0x0D, 0x0B, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xEF, 
  0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xCD, 0x00, 
  0xD8, 0x00, 0x00, 0x02, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x05, 0x01, 0xCE, 0x09, 
  0x77, 0x72, 0x61, 0x70, 0x2D, 0x6D, 0x61, 0x69, 0x6E, 0xDA, 0x18, 0x2C, 0x00, 0x00, 0x00, 0x2B, 
  0x01, 0x00, 0x01, 0x32, 0x01, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x06, 0x34, 0x01, 0x00, 0x00, 0xBF, 
  0xFF, 0x8E, 0xC1, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x8E, 0xBC, 0x01, 0x02, 
  0x14, 0x00, 0x14, 0x00, 0x03, 0x00, 0x03, 0x01, 0x17, 0x00, 0x17, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x13, 0xBF, 0xFF, 0x03, 
  0x00, 0x03, 0x02, 0x14, 0x00, 0x14, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 
  0x01, 0x05, 0x00, 0x05, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x10, 0x01, 0x19, 
  0x00, 0x19, 0x00, 0x19, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x07, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0xBF, 0xF8, 0x03, 0x00, 
  0x03, 0x42, 0x00, 0x00, 0x00, 0xDA, 0x83, 0x30, 0xDA, 0x84, 0x03, 0xDA, 0x83, 0xDE, 0xDA, 0x88, 
  0x15, 0xDA, 0x88, 0x2E, 0xDA, 0x88, 0x41, 0xDA, 0x83, 0x4C, 0xD0, 0x05, 0x73, 0x74, 0x64, 0x69, 
  0x6E, 0xDA, 0x89, 0x55, 0xD8, 0x07, 0x6F, 0x73, 0x2F, 0x61, 0x72, 0x63, 0x68, 0xCE, 0x06, 0x4A, 
  0x61, 0x6E, 0x65, 0x74, 0x20, 0xDA, 0x86, 0x78, 0xDA, 0x82, 0xE7, 0xDA, 0x81, 0x4F, 0xDA, 0x81, 
  0x9C, 0xCE, 0x13, 0x20, 0x2D, 0x20, 0x27, 0x28, 0x64, 0x6F, 0x63, 0x29, 0x27, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x68, 0x65, 0x6C, 0x70, 0xDA, 0x82, 0x70, 0xDA, 0x82, 0xB7, 0xDA, 0x81, 0x1D, 0xDA, 
  0x81, 0x37, 0xDA, 0x87, 0x43, 0xDA, 0x84, 0x0D, 0xCE, 0x05, 0x25, 0x2E, 0x32, 0x30, 0x51, 0xCE, 
  0x05, 0x25, 0x2E, 0x32, 0x30, 0x71, 0xDA, 0x82, 0xB4, 0xDA, 0x83, 0xA5, 0xDA, 0x81, 0x1E, 0xD7, 
  0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x0D, 0x05, 0x00, 0x05, 0x0A, 0x2A, 0x01, 0xCE, 0x04, 0x72, 
  0x65, 0x70, 0x6C, 0xDA, 0x18, 0xDA, 0x83, 0x30, 0xDA, 0x83, 0xD7, 0xDA, 0x83, 0xE1, 0xDA, 0x83, 
  0xDC, 0xDA, 0x83, 0xE5, 0xDA, 0x83, 0xDD, 0xDA, 0x83, 0x4C, 0xD0, 0x04, 0x72, 0x65, 0x70, 0x6C, 
  0xDA, 0x83, 0xDE, 0xDA, 0x83, 0xDF, 0x2C, 0x05, 0x00, 0x00, 0x26, 0x08, 0x00, 0x00, 0x23, 0x07, 
  0x08, 0x02, 0x1C, 0x07, 0x05, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x06, 
  0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x06, 0x02, 0x00, 0x19, 0x07, 0x06, 0x00, 0x26, 0x0A, 
  0x00, 0x00, 0x23, 0x09, 0x0A, 0x00, 0x1C, 0x09, 0x04, 0x00, 0x2E, 0x0A, 0x00, 0x00, 0x19, 0x08, 
  0x0A, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x08, 0x00, 0x00, 0x19, 0x09, 0x08, 0x00, 0x1C, 0x01, 
  0x03, 0x00, 0x19, 0x0A, 0x01, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x29, 0x0B, 0x01, 0x00, 0x27, 0x0C, 
  0x00, 0x00, 0x31, 0x07, 0x0B, 0x0C, 0x2A, 0x0C, 0x01, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x0A, 
  0x0B, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x31, 0x0B, 0x04, 0x0C, 0x2A, 0x0B, 
  0x04, 0x00, 0x31, 0x09, 0x0B, 0x03, 0x2A, 0x0B, 0x05, 0x00, 0x2A, 0x0C, 0x06, 0x00, 0x31, 0x0B, 
  0x0A, 0x0C, 0x2A, 0x0B, 0x07, 0x00, 0x2A, 0x0C, 0x08, 0x00, 0x31, 0x0B, 0x0C, 0x07, 0x41, 0x0A, 
  0x00, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x09, 0x00, 0x34, 0x0B, 0x00, 0x00, 0xCD, 0x00, 
  0xD0, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x08, 0x15, 0x01, 0xDA, 0x18, 0xDA, 0x83, 0xFE, 0xDA, 
  0x84, 0x25, 0xDA, 0x84, 0x26, 0xCE, 0x05, 0x72, 0x65, 0x70, 0x6C, 0x3A, 0xDA, 0x83, 0xEC, 0xDA, 
  0x83, 0xC0, 0xDA, 0x81, 0x38, 0xDA, 0x84, 0x0D, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x33, 0x02, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x03, 0x02, 0x00, 
  0x2A, 0x02, 0x01, 0x00, 0x30, 0x01, 0x02, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x02, 0x04, 0x00, 
  0x2A, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x31, 0x04, 0x03, 0x05, 0x2A, 0x04, 0x05, 0x00, 
  0x30, 0x02, 0x04, 0x00, 0x2A, 0x05, 0x06, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2B, 0x02, 0x00, 0x07, 
  0x31, 0x04, 0x00, 0x02, 0x2A, 0x02, 0x07, 0x00, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8D, 0xCC, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x02, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0xBF, 0xFC, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x8D, 0xBE, 0x01, 0x08, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x0B, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 
  0x29, 0x00, 0x1C, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 
  0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x28, 0x03, 0x00, 0x00, 0x27, 0x04, 
  0x00, 0x00, 0x28, 0x05, 0x00, 0x00, 0x28, 0x06, 0x00, 0x00, 0x27, 0x07, 0x00, 0x00, 0x27, 0x08, 
  0x00, 0x00, 0x27, 0x09, 0x00, 0x00, 0x28, 0x0A, 0x00, 0x00, 0x28, 0x0B, 0x00, 0x00, 0x26, 0x0C, 
  0x00, 0x00, 0x26, 0x0D, 0x00, 0x00, 0x28, 0x0E, 0x00, 0x00, 0x2A, 0x0F, 0x02, 0x00, 0x2F, 0x0F, 
  0x00, 0x00, 0x2A, 0x10, 0x03, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x1C, 0x10, 
  0x06, 0x00, 0x2A, 0x0F, 0x04, 0x00, 0x30, 0x0F, 0x10, 0x00, 0x2A, 0x11, 0x01, 0x00, 0x33, 0x0F, 
  0x11, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x0F, 0x05, 0x00, 0x2F, 0x0F, 0x00, 0x00, 0x2A, 0x10, 
  0x03, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x1C, 0x10, 0x06, 0x00, 0x2A, 0x0F, 
  0x06, 0x00, 0x30, 0x0F, 0x10, 0x00, 0x2A, 0x11, 0x01, 0x00, 0x33, 0x0F, 0x11, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x2E, 0x0F, 0x00, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x2E, 0x11, 0x01, 0x00, 0x2E, 0x12, 
  0x02, 0x00, 0x2E, 0x13, 0x03, 0x00, 0x2E, 0x14, 0x04, 0x00, 0x2E, 0x15, 0x05, 0x00, 0x2E, 0x16, 
  0x06, 0x00, 0x2E, 0x17, 0x07, 0x00, 0x2E, 0x18, 0x08, 0x00, 0x2E, 0x19, 0x09, 0x00, 0x2E, 0x1A, 
  0x0A, 0x00, 0x2E, 0x1B, 0x0B, 0x00, 0x2E, 0x1C, 0x0C, 0x00, 0x2E, 0x1D, 0x0D, 0x00, 0x2E, 0x1E, 
  0x0E, 0x00, 0x2E, 0x1F, 0x0F, 0x00, 0x2E, 0x20, 0x10, 0x00, 0x2E, 0x21, 0x11, 0x00, 0x2E, 0x22, 
  0x12, 0x00, 0x2E, 0x23, 0x13, 0x00, 0x2A, 0x24, 0x07, 0x00, 0x2A, 0x25, 0x08, 0x00, 0x31, 0x24, 
  0x11, 0x25, 0x2A, 0x24, 0x09, 0x00, 0x31, 0x12, 0x24, 0x13, 0x2A, 0x24, 0x0A, 0x00, 0x2A, 0x25, 
  0x0B, 0x00, 0x31, 0x24, 0x14, 0x25, 0x2A, 0x24, 0x0C, 0x00, 0x31, 0x15, 0x24, 0x16, 0x2A, 0x24, 
  0x0D, 0x00, 0x2A, 0x25, 0x0E, 0x00, 0x31, 0x24, 0x17, 0x25, 0x2A, 0x24, 0x0F, 0x00, 0x31, 0x18, 
  0x24, 0x19, 0x2A, 0x24, 0x10, 0x00, 0x2A, 0x25, 0x11, 0x00, 0x31, 0x24, 0x1A, 0x25, 0x2A, 0x24, 
  0x12, 0x00, 0x31, 0x1B, 0x24, 0x1C, 0x2A, 0x24, 0x13, 0x00, 0x2A, 0x25, 0x14, 0x00, 0x31, 0x24, 
  0x1D, 0x25, 0x2A, 0x24, 0x15, 0x00, 0x31, 0x1E, 0x24, 0x1F, 0x2A, 0x24, 0x16, 0x00, 0x2A, 0x25, 
  0x17, 0x00, 0x31, 0x24, 0x20, 0x25, 0x2A, 0x24, 0x18, 0x00, 0x31, 0x21, 0x24, 0x22, 0x2A, 0x24, 
  0x19, 0x00, 0x30, 0x24, 0x23, 0x00, 0x41, 0x11, 0x00, 0x00, 0x19, 0x12, 0x11, 0x00, 0x2E, 0x13, 
  0x14, 0x00, 0x19, 0x14, 0x13, 0x00, 0x29, 0x15, 0x00, 0x00, 0x3D, 0x16, 0x00, 0x00, 0x19, 0x17, 
  0x16, 0x00, 0x21, 0x18, 0x15, 0x17, 0x1C, 0x18, 0x5A, 0x00, 0x38, 0x19, 0x00, 0x15, 0x19, 0x1A, 
  0x19, 0x00, 0x1C, 0x07, 0x0A, 0x00, 0x29, 0x1B, 0x00, 0x00, 0x29, 0x1C, 0x01, 0x00, 0x31, 0x1A, 
  0x1B, 0x1C, 0x2A, 0x1C, 0x1A, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x2A, 0x1D, 0x0F, 0x00, 0x23, 0x1C, 
  0x1D, 0x1B, 0x19, 0x19, 0x1C, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x19, 0x07, 0x00, 0x1C, 0x19, 
  0x09, 0x00, 0x29, 0x1B, 0x01, 0x00, 0x30, 0x1A, 0x1B, 0x00, 0x2A, 0x1C, 0x1A, 0x00, 0x33, 0x1B, 
  0x1C, 0x00, 0x30, 0x1B, 0x15, 0x00, 0x33, 0x1C, 0x14, 0x00, 0x06, 0x15, 0x15, 0x1C, 0x1A, 0x43, 
  0x00, 0x00, 0x30, 0x00, 0x15, 0x00, 0x2A, 0x1C, 0x1B, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x19, 0x1C, 
  0x1B, 0x00, 0x28, 0x04, 0x00, 0x00, 0x1C, 0x0E, 0x1A, 0x00, 0x2F, 0x1A, 0x00, 0x00, 0x2A, 0x1D, 
  0x1C, 0x00, 0x33, 0x1B, 0x1D, 0x00, 0x2F, 0x1B, 0x00, 0x00, 0x2A, 0x1E, 0x1D, 0x00, 0x33, 0x1D, 
  0x1E, 0x00, 0x19, 0x1B, 0x1D, 0x00, 0x2A, 0x1D, 0x00, 0x00, 0x3A, 0x1B, 0x1D, 0x1C, 0x2A, 0x1D, 
  0x1E, 0x00, 0x3A, 0x1B, 0x1D, 0x0D, 0x2A, 0x1D, 0x1F, 0x00, 0x3A, 0x1B, 0x1D, 0x0C, 0x1C, 0x0A, 
  0x08, 0x00, 0x2A, 0x1D, 0x20, 0x00, 0x27, 0x1E, 0x00, 0x00, 0x3A, 0x1B, 0x1D, 0x1E, 0x2A, 0x1D, 
  0x21, 0x00, 0x27, 0x1E, 0x00, 0x00, 0x3A, 0x1B, 0x1D, 0x1E, 0x1A, 0x01, 0x00, 0x00, 0x31, 0x1B, 
  0x1C, 0x1A, 0x2A, 0x1E, 0x22, 0x00, 0x33, 0x1D, 0x1E, 0x00, 0x1A, 0x23, 0x00, 0x00, 0x2A, 0x1D, 
  0x23, 0x00, 0x33, 0x1B, 0x1D, 0x00, 0x19, 0x1D, 0x1B, 0x00, 0x2A, 0x1B, 0x00, 0x00, 0x3A, 0x1D, 
  0x1B, 0x1C, 0x2A, 0x1B, 0x1E, 0x00, 0x3A, 0x1D, 0x1B, 0x0D, 0x2A, 0x1B, 0x1F, 0x00, 0x3A, 0x1D, 
  0x1B, 0x0C, 0x1C, 0x0A, 0x08, 0x00, 0x2A, 0x1B, 0x20, 0x00, 0x27, 0x1E, 0x00, 0x00, 0x3A, 0x1D, 
  0x1B, 0x1E, 0x2A, 0x1B, 0x21, 0x00, 0x27, 0x1E, 0x00, 0x00, 0x3A, 0x1D, 0x1B, 0x1E, 0x1A, 0x01, 
  0x00, 0x00, 0x1C, 0x0B, 0x08, 0x00, 0x2A, 0x1B, 0x24, 0x00, 0x31, 0x1A, 0x1B, 0x08, 0x2A, 0x1B, 
  0x25, 0x00, 0x30, 0x1B, 0x1D, 0x00, 0x2A, 0x1E, 0x26, 0x00, 0x33, 0x1B, 0x1E, 0x00, 0x1A, 0x0A, 
  0x00, 0x00, 0x2A, 0x1B, 0x24, 0x00, 0x31, 0x1A, 0x1B, 0x08, 0x2A, 0x1B, 0x25, 0x00, 0x30, 0x1B, 
  0x1D, 0x00, 0x2A, 0x1E, 0x27, 0x00, 0x33, 0x1B, 0x1E, 0x00, 0x31, 0x1D, 0x1C, 0x1A, 0x2A, 0x1E, 
  0x22, 0x00, 0x33, 0x1B, 0x1E, 0x00, 0x19, 0x15, 0x17, 0x00, 0x1A, 0xA6, 0xFF, 0xFF, 0x1C, 0x03, 
  0x03, 0x00, 0x19, 0x18, 0x03, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x18, 0x04, 0x00, 0x1C, 0x18, 
  0x6B, 0x00, 0x1C, 0x0B, 0x09, 0x00, 0x2A, 0x19, 0x28, 0x00, 0x2A, 0x1A, 0x29, 0x00, 0x2A, 0x1B, 
  0x2A, 0x00, 0x31, 0x19, 0x1A, 0x1B, 0x2A, 0x19, 0x24, 0x00, 0x30, 0x19, 0x08, 0x00, 0x2A, 0x19, 
  0x26, 0x00, 0x34, 0x19, 0x00, 0x00, 0x1C, 0x05, 0x02, 0x00, 0x1A, 0x11, 0x00, 0x00, 0x2A, 0x1A, 
  0x2B, 0x00, 0x33, 0x19, 0x1A, 0x00, 0x2A, 0x1B, 0x2C, 0x00, 0x33, 0x1A, 0x1B, 0x00, 0x2A, 0x1B, 
  0x2D, 0x00, 0x2A, 0x1C, 0x2E, 0x00, 0x2A, 0x1D, 0x0F, 0x00, 0x31, 0x1B, 0x1C, 0x1D, 0x2A, 0x1B, 
  0x2F, 0x00, 0x2A, 0x1C, 0x30, 0x00, 0x31, 0x1B, 0x1C, 0x19, 0x2A, 0x1B, 0x31, 0x00, 0x2A, 0x1C, 
  0x32, 0x00, 0x31, 0x1B, 0x1A, 0x1C, 0x2A, 0x1C, 0x33, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x2A, 0x1A, 
  0x34, 0x00, 0x33, 0x19, 0x1A, 0x00, 0x2E, 0x19, 0x15, 0x00, 0x19, 0x1A, 0x19, 0x00, 0x2E, 0x19, 
  0x16, 0x00, 0x19, 0x1B, 0x19, 0x00, 0x2A, 0x1C, 0x23, 0x00, 0x33, 0x19, 0x1C, 0x00, 0x19, 0x1C, 
  0x19, 0x00, 0x2A, 0x19, 0x06, 0x00, 0x2F, 0x19, 0x00, 0x00, 0x2A, 0x1D, 0x35, 0x00, 0x33, 0x19, 
  0x1D, 0x00, 0x19, 0x1D, 0x19, 0x00, 0x1C, 0x1D, 0x0E, 0x00, 0x2A, 0x19, 0x24, 0x00, 0x27, 0x1E, 
  0x00, 0x00, 0x31, 0x1D, 0x19, 0x1E, 0x2A, 0x1E, 0x27, 0x00, 0x33, 0x19, 0x1E, 0x00, 0x19, 0x1E, 
  0x19, 0x00, 0x2A, 0x19, 0x36, 0x00, 0x31, 0x1C, 0x1E, 0x19, 0x28, 0x19, 0x00, 0x00, 0x2F, 0x19, 
  0x00, 0x00, 0x2A, 0x1F, 0x37, 0x00, 0x33, 0x19, 0x1F, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1C, 0x0A, 
  0x08, 0x00, 0x2A, 0x19, 0x20, 0x00, 0x27, 0x1D, 0x00, 0x00, 0x3A, 0x1C, 0x19, 0x1D, 0x2A, 0x19, 
  0x21, 0x00, 0x27, 0x1D, 0x00, 0x00, 0x3A, 0x1C, 0x19, 0x1D, 0x1A, 0x01, 0x00, 0x00, 0x1C, 0x06, 
  0x03, 0x00, 0x19, 0x19, 0x1B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x19, 0x38, 0x00, 0x19, 0x1D, 
  0x19, 0x00, 0x2E, 0x19, 0x17, 0x00, 0x19, 0x1E, 0x19, 0x00, 0x1C, 0x09, 0x03, 0x00, 0x2A, 0x19, 
  0x39, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x19, 0x3A, 0x00, 0x2A, 0x1F, 0x3B, 0x00, 0x30, 0x1F, 
  0x19, 0x00, 0x2A, 0x20, 0x01, 0x00, 0x33, 0x1F, 0x20, 0x00, 0x1C, 0x09, 0x03, 0x00, 0x27, 0x19, 
  0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x19, 0x00, 0x00, 0x2A, 0x1F, 0x3C, 0x00, 0x30, 0x1F, 
  0x19, 0x00, 0x2A, 0x20, 0x01, 0x00, 0x33, 0x1F, 0x20, 0x00, 0x1C, 0x09, 0x03, 0x00, 0x27, 0x19, 
  0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x19, 0x00, 0x00, 0x2A, 0x1F, 0x3D, 0x00, 0x30, 0x1F, 
  0x19, 0x00, 0x2A, 0x20, 0x01, 0x00, 0x33, 0x1F, 0x20, 0x00, 0x2A, 0x19, 0x1E, 0x00, 0x30, 0x19, 
  0x0D, 0x00, 0x2A, 0x1F, 0x01, 0x00, 0x33, 0x19, 0x1F, 0x00, 0x2A, 0x19, 0x1F, 0x00, 0x30, 0x19, 
  0x0D, 0x00, 0x2A, 0x1F, 0x01, 0x00, 0x33, 0x19, 0x1F, 0x00, 0x26, 0x19, 0x00, 0x00, 0x31, 0x1E, 
  0x19, 0x1C, 0x2A, 0x19, 0x3E, 0x00, 0x34, 0x19, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xCD, 0x00, 
  0xD8, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 0x02, 0x0E, 0x01, 0xCE, 0x0E, 0x67, 0x65, 0x74, 0x2D, 
  0x6C, 0x69, 0x6E, 0x74, 0x2D, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0xDA, 0x18, 0xDA, 0x84, 0xEA, 0xDA, 
  0x89, 0x06, 0x2C, 0x01, 0x00, 0x00, 0x05, 0x02, 0x00, 0x01, 0x2B, 0x04, 0x00, 0x00, 0x38, 0x03, 
  0x04, 0x02, 0x19, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x1C, 0x05, 0x02, 0x00, 0x03, 0x05, 0x00, 0x00, 0x2F, 0x02, 
  0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0xBF, 0xFF, 0x8E, 0xEC, 0x03, 0x02, 
  0x15, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 0x01, 
  0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x16, 0x01, 0xCE, 0x08, 0x63, 0x2D, 0x73, 0x77, 0x69, 
  0x74, 0x63, 0x68, 0xDA, 0x18, 0xDA, 0x88, 0x2E, 0xDA, 0x89, 0x14, 0xDA, 0x84, 0x75, 0x2C, 0x01, 
  0x00, 0x00, 0x05, 0x02, 0x00, 0x01, 0x2B, 0x04, 0x00, 0x00, 0x38, 0x03, 0x04, 0x02, 0x19, 0x02, 
  0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 
  0x04, 0x00, 0x05, 0x06, 0x00, 0x02, 0x2B, 0x08, 0x00, 0x00, 0x38, 0x07, 0x08, 0x06, 0x2F, 0x05, 
  0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x06, 0x08, 0x00, 0x30, 0x07, 0x06, 0x00, 0x2A, 0x09, 
  0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 0x28, 0x06, 0x00, 0x00, 0x2D, 0x06, 0x00, 0x04, 0x29, 0x06, 
  0x03, 0x00, 0x03, 0x06, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x17, 0x0A, 0x01, 0x1F, 0x00, 0x16, 0x00, 
  0x16, 0x00, 0x0C, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0C, 0x01, 0x1B, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x01, 0x0C, 0x00, 
  0x0C, 0xBF, 0xFC, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 
  0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x18, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x0A, 
  0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x2F, 0x12, 0x00, 0x12, 0x00, 
  0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x01, 0x0B, 0x01, 0xCE, 0x08, 0x65, 0x2D, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0xDA, 0x18, 0xDA, 
  0x82, 0xD7, 0x2C, 0x01, 0x00, 0x00, 0x28, 0x02, 0x00, 0x00, 0x2D, 0x02, 0x00, 0x04, 0x05, 0x02, 
  0x00, 0x01, 0x2B, 0x04, 0x00, 0x00, 0x38, 0x03, 0x04, 0x02, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x33, 0x02, 0x04, 0x00, 0x29, 0x03, 0x02, 0x00, 0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 
  0x8F, 0x22, 0x0A, 0x01, 0x0C, 0x00, 0x0C, 0x01, 0x22, 0x00, 0x19, 0x00, 0x19, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0xBF, 0xFE, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x04, 0x00, 0x00, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x08, 0x14, 0xDA, 0x18, 0xDA, 0x87, 0xB8, 0xCE, 0x05, 0x6A, 0x61, 
  0x6E, 0x65, 0x74, 0xDA, 0x81, 0x1D, 0xCE, 0x07, 0x75, 0x73, 0x61, 0x67, 0x65, 0x3A, 0x20, 0xCE, 
  0x19, 0x20, 0x5B, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x5D, 0x20, 0x73, 0x63, 0x72, 0x69, 
  0x70, 0x74, 0x20, 0x61, 0x72, 0x67, 0x73, 0x2E, 0x2E, 0x2E, 0xDA, 0x82, 0x70, 0xCE, 0x83, 0xD7, 
  0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 0x3A, 0x0A, 0x20, 0x20, 0x2D, 
  0x68, 0x20, 0x3A, 0x20, 0x53, 0x68, 0x6F, 0x77, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x68, 0x65, 
  0x6C, 0x70, 0x0A, 0x20, 0x20, 0x2D, 0x76, 0x20, 0x3A, 0x20, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x0A, 0x20, 0x20, 0x2D, 0x73, 0x20, 0x3A, 0x20, 0x55, 0x73, 0x65, 0x20, 0x72, 0x61, 
  0x77, 0x20, 0x73, 0x74, 0x64, 0x69, 0x6E, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 
  0x6F, 0x66, 0x20, 0x67, 0x65, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x0A, 0x20, 0x20, 
  0x2D, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x3A, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 
  0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x20, 0x6A, 0x61, 
  0x6E, 0x65, 0x74, 0x0A, 0x20, 0x20, 0x2D, 0x45, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x61, 0x72, 
  0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x2E, 0x2E, 0x20, 0x3A, 0x20, 0x45, 0x76, 0x61, 
  0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 
  0x73, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x2D, 
  0x66, 0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x0A, 0x20, 0x20, 0x2D, 0x64, 0x20, 0x3A, 0x20, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x52, 0x45, 0x50, 0x4C, 0x0A, 0x20, 0x20, 0x2D, 0x72, 0x20, 0x3A, 0x20, 0x45, 
  0x6E, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x52, 0x45, 0x50, 0x4C, 0x20, 0x61, 0x66, 
  0x74, 0x65, 0x72, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6C, 0x6C, 0x20, 
  0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x73, 0x0A, 0x20, 0x20, 0x2D, 0x52, 0x20, 0x3A, 0x20, 0x44, 
  0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 
  0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x77, 0x68, 
  0x65, 0x6E, 0x20, 0x4A, 0x41, 0x4E, 0x45, 0x54, 0x5F, 0x50, 0x52, 0x4F, 0x46, 0x49, 0x4C, 0x45, 
  0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x0A, 0x20, 0x20, 0x2D, 0x70, 
  0x20, 0x3A, 0x20, 0x4B, 0x65, 0x65, 0x70, 0x20, 0x6F, 0x6E, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 
  0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x20, 0x74, 0x6F, 0x70, 0x2D, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x20, 0x28, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x29, 0x0A, 
  0x20, 0x20, 0x2D, 0x71, 0x20, 0x3A, 0x20, 0x48, 0x69, 0x64, 0x65, 0x20, 0x6C, 0x6F, 0x67, 0x6F, 
  0x20, 0x28, 0x71, 0x75, 0x69, 0x65, 0x74, 0x29, 0x0A, 0x20, 0x20, 0x2D, 0x6B, 0x20, 0x3A, 0x20, 
  0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x73, 0x20, 
  0x62, 0x75, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 
  0x74, 0x65, 0x20, 0x28, 0x66, 0x6C, 0x79, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x29, 0x0A, 0x20, 0x20, 
  0x2D, 0x6D, 0x20, 0x73, 0x79, 0x73, 0x70, 0x61, 0x74, 0x68, 0x20, 0x3A, 0x20, 0x53, 0x65, 0x74, 
  0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 
  0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x0A, 0x20, 0x20, 0x2D, 0x63, 0x20, 0x73, 0x6F, 0x75, 
  0x72, 0x63, 0x65, 0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x3A, 0x20, 0x43, 0x6F, 0x6D, 
  0x70, 0x69, 0x6C, 0x65, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 
  0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x69, 
  0x6D, 0x61, 0x67, 0x65, 0x0A, 0x20, 0x20, 0x2D, 0x69, 0x20, 0x3A, 0x20, 0x4C, 0x6F, 0x61, 0x64, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6D, 0x61, 0x67, 0x65, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 
  0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x0A, 0x20, 0x20, 0x2D, 
  0x6E, 0x20, 0x3A, 0x20, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x41, 0x4E, 0x53, 0x49, 
  0x20, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x52, 0x45, 0x50, 0x4C, 0x0A, 0x20, 0x20, 0x2D, 0x6C, 0x20, 0x6C, 
  0x69, 0x62, 0x20, 0x3A, 0x20, 0x55, 0x73, 0x65, 0x20, 0x61, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 
  0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x73, 0x0A, 0x20, 0x20, 0x2D, 0x77, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x3A, 0x20, 
  0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x69, 0x6E, 0x74, 0x20, 0x77, 0x61, 0x72, 
  0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 
  0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x22, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x22, 
  0x0A, 0x20, 0x20, 0x2D, 0x78, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x3A, 0x20, 0x53, 0x65, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x69, 0x6E, 0x74, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x22, 0x6E, 0x6F, 0x6E, 0x65, 0x22, 0x0A, 0x20, 0x20, 0x2D, 0x2D, 0x20, 
  0x3A, 0x20, 0x53, 0x74, 0x6F, 0x70, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x69, 0x6E, 0x67, 0x20, 
  0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0xDA, 0x87, 0x37, 0x2A, 0x00, 0x00, 0x00, 0x2A, 0x01, 
  0x01, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x01, 0x02, 0x00, 0x33, 0x00, 0x01, 0x00, 0x2A, 0x01, 
  0x03, 0x00, 0x2A, 0x02, 0x04, 0x00, 0x31, 0x01, 0x00, 0x02, 0x2A, 0x02, 0x05, 0x00, 0x33, 0x01, 
  0x02, 0x00, 0x2A, 0x00, 0x06, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x05, 0x00, 0x33, 0x00, 
  0x02, 0x00, 0x29, 0x02, 0x00, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x07, 0x00, 0x33, 0x02, 
  0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x8E, 0xF4, 0x1D, 0x00, 0x1D, 0x00, 
  0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x01, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x17, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 
  0xE7, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x00, 0x04, 0x01, 0xDA, 0x18, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x0E, 0x29, 0x00, 
  0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x13, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 
  0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 
  0x01, 0xDA, 0x18, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x0B, 0x28, 0x00, 0x00, 0x00, 0x2D, 
  0x00, 0x00, 0x08, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x14, 0x12, 
  0x00, 0x12, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 
  0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x0E, 0x01, 0xCE, 0x08, 0x6C, 0x2D, 0x73, 0x77, 
  0x69, 0x74, 0x63, 0x68, 0xDA, 0x18, 0xDA, 0x87, 0x41, 0xDA, 0x81, 0x37, 0xDA, 0x84, 0x03, 0xDA, 
  0x87, 0x3C, 0x2C, 0x01, 0x00, 0x00, 0x05, 0x02, 0x00, 0x01, 0x2B, 0x04, 0x00, 0x00, 0x38, 0x03, 
  0x04, 0x02, 0x2A, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x31, 0x03, 0x02, 0x04, 0x2A, 0x02, 
  0x02, 0x00, 0x2B, 0x04, 0x00, 0x08, 0x30, 0x02, 0x04, 0x00, 0x2A, 0x04, 0x03, 0x00, 0x33, 0x02, 
  0x04, 0x00, 0x29, 0x03, 0x02, 0x00, 0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x1E, 0x0A, 0x01, 
  0x1E, 0x00, 0x15, 0x00, 0x15, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFF, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x04, 
  0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x09, 0x01, 0xDA, 0x18, 0xDA, 0x84, 0xB9, 0xDA, 
  0x82, 0x5B, 0x05, 0x01, 0x00, 0x01, 0x2B, 0x03, 0x00, 0x00, 0x38, 0x02, 0x03, 0x01, 0x2A, 0x01, 
  0x00, 0x00, 0x30, 0x01, 0x02, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x01, 0x03, 0x00, 0x29, 0x02, 
  0x02, 0x00, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x16, 0x2F, 0x00, 0x26, 0x00, 0x26, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x18, 0x28, 0x00, 0x00, 
  0x00, 0x2D, 0x00, 0x00, 0x07, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 
  0x1D, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x18, 0x28, 0x00, 0x00, 0x00, 0x2D, 0x00, 
  0x00, 0x09, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x15, 0x12, 0x00, 
  0x12, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x18, 0x28, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x08, 0x29, 
  0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x11, 0x12, 0x00, 0x12, 0x00, 0x0A, 
  0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 
  0x04, 0x01, 0xDA, 0x18, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x05, 0x29, 0x00, 0x01, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x12, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 
  0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 
  0x18, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x03, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 
  0x00, 0xBF, 0xFF, 0x8F, 0x10, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 
  0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x01, 0xDA, 0x18, 0x27, 0x00, 
  0x00, 0x00, 0x2D, 0x00, 0x00, 0x06, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x03, 0x29, 0x00, 
  0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x0F, 0x12, 0x00, 0x12, 0x00, 0x27, 0x00, 
  0x27, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x05, 0x0C, 0xDA, 0x18, 0xDA, 0x86, 0x78, 0xDA, 0x80, 0xA0, 0xDA, 0x82, 0xE7, 0xDA, 
  0x82, 0x70, 0xDA, 0x87, 0x37, 0x2A, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x01, 0x00, 0x2A, 0x02, 0x02, 
  0x00, 0x31, 0x00, 0x01, 0x02, 0x2A, 0x01, 0x03, 0x00, 0x33, 0x00, 0x01, 0x00, 0x29, 0x01, 0x00, 
  0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x04, 0x00, 0x33, 0x01, 0x02, 0x00, 0x29, 0x02, 0x01, 
  0x00, 0x03, 0x02, 0x00, 0x00, 0x8F, 0x0E, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 
  0xD0, 0x00, 0x00, 0x03, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x01, 0xDA, 0x18, 
  0x2F, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x10, 0x33, 0x01, 0x02, 0x00, 0x2D, 0x01, 0x00, 0x0C, 
  0x29, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x30, 0x24, 0x00, 0x24, 0x00, 
  0x24, 0x00, 0x24, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x01, 0xDA, 0x18, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 
  0x10, 0x33, 0x01, 0x02, 0x00, 0x2D, 0x01, 0x00, 0x0D, 0x29, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 
  0x00, 0xBF, 0xFF, 0x8F, 0x31, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x0A, 0x00, 0x0A, 
  0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0B, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x08, 0x25, 0x01, 
  0xCE, 0x08, 0x45, 0x2D, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0xDA, 0x18, 0xDA, 0x80, 0xE2, 0xDA, 
  0x88, 0x4C, 0xDA, 0x84, 0xD6, 0xCF, 0x0C, 0x45, 0x2D, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 
  0x69, 0x6F, 0x6E, 0xDA, 0x80, 0x83, 0xDA, 0x85, 0x63, 0xDA, 0x80, 0xC1, 0xDA, 0x84, 0x15, 0x2C, 
  0x01, 0x00, 0x00, 0x28, 0x02, 0x00, 0x00, 0x2D, 0x02, 0x00, 0x04, 0x05, 0x02, 0x00, 0x02, 0x2B, 
  0x03, 0x00, 0x00, 0x30, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 
  0x02, 0x03, 0x00, 0x05, 0x04, 0x00, 0x01, 0x2B, 0x06, 0x00, 0x00, 0x38, 0x05, 0x06, 0x04, 0x2F, 
  0x05, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x04, 0x06, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x2A, 
  0x07, 0x03, 0x00, 0x31, 0x06, 0x04, 0x07, 0x43, 0x05, 0x00, 0x00, 0x19, 0x04, 0x05, 0x00, 0x2F, 
  0x04, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x2F, 
  0x07, 0x00, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x33, 0x08, 0x09, 0x00, 0x1C, 0x08, 0x05, 0x00, 0x33, 
  0x09, 0x07, 0x00, 0x32, 0x02, 0x00, 0x00, 0x33, 0x0A, 0x09, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 
  0x0A, 0x06, 0x00, 0x39, 0x09, 0x07, 0x0A, 0x01, 0x09, 0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x03, 
  0x08, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x26, 0x0A, 0x01, 0x0C, 0x00, 0x0C, 0x01, 0x2B, 0x00, 0x19, 
  0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x0C, 0x01, 0x31, 0x00, 0x28, 0x00, 0x28, 0x00, 0x21, 
  0x00, 0x21, 0x00, 0x21, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x0C, 0x01, 0x17, 
  0x00, 0x17, 0x00, 0x17, 0x00, 0x0C, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x0C, 0x01, 0x0F, 
  0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x0C, 0x02, 0x15, 0x00, 0x15, 0x00, 0x0E, 0xBF, 0xF9, 0x0A, 
  0x00, 0x0A, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x02, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 
  0x07, 0xDA, 0x18, 0xDA, 0x89, 0x35, 0xDA, 0x82, 0x5B, 0x2A, 0x00, 0x00, 0x00, 0x26, 0x01, 0x00, 
  0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x01, 0x01, 0x00, 0x33, 0x00, 0x01, 0x00, 0x29, 0x01, 0x01, 
  0x00, 0x03, 0x01, 0x00, 0x00, 0x8F, 0x32, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x03, 0x0F, 0x01, 0xCE, 0x09, 0x64, 0x6F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0xDA, 
  0x18, 0xCE, 0x0E, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x20, 
  0x2D, 0xDA, 0x82, 0x70, 0xDA, 0x89, 0x62, 0x2C, 0x02, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x12, 0x38, 
  0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x34, 
  0x04, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x30, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 
  0x05, 0x06, 0x00, 0x2B, 0x06, 0x00, 0x12, 0x2A, 0x07, 0x02, 0x00, 0x38, 0x05, 0x06, 0x07, 0x34, 
  0x05, 0x00, 0x00, 0xBF, 0xFF, 0x8F, 0x34, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x05, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x31, 0x00, 0x31, 
  0x00, 0x31, 0x00, 0x30, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x07, 0x11, 0xCE, 
  0x09, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0xDA, 0x18, 0xDA, 0x82, 0x8A, 0xDA, 
  0x84, 0x25, 0xDA, 0x86, 0x72, 0xDA, 0x89, 0x7F, 0xDA, 0x83, 0xEC, 0xDA, 0x83, 0xC0, 0xDA, 0x81, 
  0x38, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 
  0x00, 0x3B, 0x03, 0x02, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x00, 0x03, 
  0x00, 0x2A, 0x05, 0x02, 0x00, 0x33, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x2A, 0x06, 0x04, 
  0x00, 0x31, 0x05, 0x04, 0x06, 0x2A, 0x05, 0x05, 0x00, 0x30, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x06, 
  0x00, 0x34, 0x05, 0x00, 0x00, 0x8F, 0x62, 0x09, 0x01, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x0B, 
  0x00, 0x0B, 0x01, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x03, 0x03, 
  0x03, 0x06, 0x0E, 0xCE, 0x08, 0x67, 0x65, 0x74, 0x73, 0x74, 0x64, 0x69, 0x6E, 0xDA, 0x18, 0xDA, 
  0x87, 0xF6, 0xDA, 0x84, 0x79, 0xDA, 0x88, 0x70, 0xDA, 0x88, 0x41, 0xDA, 0x84, 0x1E, 0xDA, 0x83, 
  0x53, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x30, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 
  0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 
  0x00, 0x33, 0x05, 0x06, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x31, 0x06, 0x07, 
  0x01, 0x2A, 0x06, 0x05, 0x00, 0x34, 0x06, 0x00, 0x00, 0x8F, 0x65, 0x09, 0x01, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x00, 
  0x08, 0x01, 0xCE, 0x08, 0x67, 0x65, 0x74, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0xDA, 0x18, 0x2C, 0x02, 
  0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x1A, 0x33, 0x03, 0x04, 0x00, 0x2B, 0x04, 
  0x00, 0x1C, 0x31, 0x03, 0x00, 0x04, 0x2B, 0x04, 0x00, 0x1D, 0x34, 0x04, 0x00, 0x00, 0xBF, 0xFF, 
  0x8F, 0x71, 0x09, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x8E, 0xD5, 0x01, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x03, 0x01, 0x03, 
  0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 
  0x01, 0x03, 0x01, 0x03, 0x02, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x03, 0x00, 0x03, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x03, 
  0x02, 0x03, 0x00, 0x03, 0x2B, 0x0A, 0x18, 0x0A, 0xBF, 0xF3, 0x0A, 0xBF, 0xD1, 0x0A, 0x20, 0x0A, 
  0x01, 0x0A, 0x0A, 0x0A, 0xBF, 0xF8, 0x0A, 0x07, 0x0A, 0xBF, 0xF8, 0x0A, 0xBF, 0xFC, 0x0A, 0x01, 
  0x0A, 0xBF, 0xFE, 0x0A, 0xBF, 0xFF, 0x0A, 0xBF, 0xFF, 0x0A, 0x22, 0x0A, 0x01, 0x0A, 0xBF, 0xF5, 
  0x0A, 0x0C, 0x0A, 0xBF, 0xC0, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x42, 0x03, 0x00, 0x03, 0x05, 0x03, 0x01, 0x10, 
  0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x05, 0x01, 0x09, 0x00, 0x20, 0x00, 0x20, 
  0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x19, 0x00, 0x19, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x05, 0x01, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x07, 
  0xBF, 0xFF, 0x05, 0x03, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x09, 0x01, 0x09, 0x01, 0x09, 0x02, 
  0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x0D, 0x01, 0x0D, 0x00, 
  0x0D, 0x01, 0x0D, 0x00, 0x0D, 0x01, 0x0D, 0x00, 0x0D, 0x01, 0x0D, 0x01, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFE, 0x0D, 0x03, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 
  0xBF, 0xF7, 0x09, 0x0B, 0x16, 0x00, 0x16, 0x00, 0x0D, 0x01, 0x0D, 0x00, 0x0D, 0x01, 0x0D, 0x00, 
  0x0D, 0x01, 0x0D, 0x00, 0x0D, 0x01, 0x0D, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0xBF, 0xFE, 0x0D, 0x03, 0x0D, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFF, 0x0D, 0x03, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x01, 0x09, 0xBF, 0xE2, 0x03, 0x20, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x01, 0x05, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x02, 0x09, 0x00, 0x09, 0x01, 0x3D, 
  0x00, 0x3D, 0x00, 0x4C, 0x00, 0x4C, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 0x09, 
  0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x03, 0x09, 0x00, 0x09, 0x04, 0x12, 0x00, 0x12, 0x00, 0x09, 
  0x01, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x09, 0x00, 0x09, 0x01, 0x18, 0x00, 0x18, 
  0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x0B, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0x03, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0x03, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x02, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xE3, 
  0x03, 0xF9, 0x7F, 0x05, 0x34, 0x00, 0x00, 0x00, 0x00, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x68, 0x79, 0x70, 0x6F, 0x74, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x68, 0x79, 0x70, 0x6F, 
  0x74, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x73, 0x74, 0x61, 0x74, 0xDA, 0x85, 0x69, 0xCF, 0x0F, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x61, 0x6C, 0x6C, 0xD8, 0x0F, 
  0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x61, 0x6C, 0x6C, 0xCF, 
  0x06, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0xDA, 0x80, 0xBC, 0xCF, 0x10, 0x65, 0x76, 0x2F, 0x72, 
  0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x2D, 0x72, 0x6C, 0x6F, 0x63, 0x6B, 0xD8, 0x10, 0x65, 0x76, 
  0x2F, 0x72, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x2D, 0x72, 0x6C, 0x6F, 0x63, 0x6B, 0xCF, 0x0A, 
  0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0xDA, 0x83, 0x0F, 0xCF, 0x05, 0x70, 
  0x61, 0x69, 0x72, 0x73, 0xDA, 0x85, 0xEB, 0xCF, 0x12, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 
  0x72, 0x2D, 0x6F, 0x6E, 0x2D, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xDA, 0x83, 0xD7, 0xCF, 0x07, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 
  0x01, 0x01, 0x02, 0x07, 0xCE, 0x07, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x3F, 0xDA, 0x18, 0xDA, 
  0x1C, 0xDA, 0x74, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x6E, 
  0x01, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0xCF, 0x04, 0x6B, 
  0x65, 0x65, 0x70, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x01, 0x14, 
  0xCE, 0x04, 0x6B, 0x65, 0x65, 0x70, 0xDA, 0x18, 0xDA, 0x81, 0x4C, 0x2C, 0x02, 0x00, 0x00, 0x3E, 
  0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 
  0x06, 0x05, 0x00, 0x1D, 0x06, 0x0D, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 0x2F, 
  0x07, 0x00, 0x00, 0x33, 0x05, 0x00, 0x00, 0x19, 0x08, 0x05, 0x00, 0x1C, 0x08, 0x05, 0x00, 0x30, 
  0x04, 0x08, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x05, 0x09, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 
  0x06, 0x01, 0x06, 0x1A, 0xF4, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x83, 0xEC, 0x01, 0x06, 0x03, 
  0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x10, 
  0x00, 0x10, 0x00, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0xBF, 
  0xFF, 0x03, 0x00, 0x03, 0xBF, 0xF9, 0x01, 0xCF, 0x07, 0x67, 0x65, 0x74, 0x6C, 0x69, 0x6E, 0x65, 
  0xDA, 0x84, 0x0D, 0xCF, 0x0F, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6F, 0x75, 0x72, 0x63, 
  0x65, 0x6D, 0x61, 0x70, 0xDA, 0x84, 0x21, 0xCF, 0x12, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 
  0x70, 0x75, 0x73, 0x68, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xDA, 0x81, 0xBB, 0xCF, 0x12, 
  0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x61, 
  0x74, 0x68, 0xDA, 0x85, 0x65, 0xCF, 0x06, 0x6F, 0x73, 0x2F, 0x63, 0x77, 0x64, 0xD8, 0x06, 0x6F, 
  0x73, 0x2F, 0x63, 0x77, 0x64, 0xDA, 0x88, 0x2A, 0xDA, 0x88, 0x2E, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 
  0x74, 0x6F, 0x75, 0x63, 0x68, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x74, 0x6F, 0x75, 0x63, 0x68, 0xCF, 
  0x04, 0x72, 0x65, 0x70, 0x6C, 0xDA, 0x89, 0x7C, 0xCF, 0x07, 0x66, 0x6F, 0x72, 0x65, 0x76, 0x65, 
  0x72, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x01, 0x07, 0xCE, 0x07, 0x66, 0x6F, 0x72, 0x65, 0x76, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x82, 0x43, 
  0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x27, 0x04, 0x00, 0x00, 0x30, 0x03, 0x04, 0x00, 
  0x32, 0x00, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x82, 0x11, 0x01, 0x03, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x69, 0x6E, 0x64, 
  0x65, 0x78, 0x65, 0x64, 0x3F, 0xDA, 0x84, 0x0A, 0xCF, 0x02, 0x25, 0x3D, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 0x08, 0xCE, 0x02, 0x25, 0x3D, 0xDA, 0x18, 0xDA, 
  0x88, 0x76, 0xDA, 0x29, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x04, 0x00, 0x01, 
  0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 
  0x03, 0x04, 0x00, 0x00, 0x80, 0x9C, 0x01, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 
  0x35, 0x00, 0x35, 0x00, 0x35, 0xCF, 0x0E, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x2D, 
  0x67, 0x61, 0x6D, 0x6D, 0x61, 0xD8, 0x0E, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x2D, 
  0x67, 0x61, 0x6D, 0x6D, 0x61, 0xCF, 0x04, 0x62, 0x6E, 0x6F, 0x74, 0xD7, 0x00, 0xCD, 0x00, 0x08, 
  0x00, 0x13, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02, 0xCE, 0x04, 0x62, 0x6E, 0x6F, 0x74, 0x11, 0x00, 
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x09, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 
  0x77, 0xDA, 0x84, 0x70, 0xDA, 0x84, 0x8D, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x04, 0x01, 
  0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x05, 0xCE, 0x04, 0x6C, 0x6F, 0x6F, 0x70, 0xDA, 0x18, 
  0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x15, 0x03, 0x03, 0x03, 0x27, 0x80, 0xCC, 0xCE, 0x05, 
  0x6C, 0x6F, 0x6F, 0x70, 0x31, 0xDA, 0x18, 0xDA, 0x4A, 0xDA, 0x85, 0x76, 0xD0, 0x05, 0x75, 0x6E, 
  0x74, 0x69, 0x6C, 0xDA, 0x82, 0x40, 0xDA, 0x49, 0xD0, 0x05, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xD0, 
  0x03, 0x6C, 0x65, 0x74, 0xDA, 0x80, 0xC2, 0xD0, 0x05, 0x61, 0x66, 0x74, 0x65, 0x72, 0xD0, 0x06, 
  0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0xD0, 0x06, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0xDA, 0x43, 
  0xDA, 0x82, 0x41, 0xDA, 0x87, 0x8D, 0xDA, 0x80, 0x9A, 0xDA, 0x82, 0x43, 0xD0, 0x04, 0x77, 0x68, 
  0x65, 0x6E, 0xDA, 0x81, 0x73, 0xCE, 0x19, 0x75, 0x6E, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 
  0x64, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 
  0xDA, 0x81, 0x38, 0xD0, 0x05, 0x72, 0x61, 0x6E, 0x67, 0x65, 0xDA, 0x27, 0xDA, 0x81, 0x47, 0xD7, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x05, 0x05, 0x05, 0x02, 0x15, 0xCE, 0x0E, 0x72, 0x61, 
  0x6E, 0x67, 0x65, 0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0xDA, 0x18, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x03, 0x0C, 0xCE, 0x0D, 0x63, 0x68, 0x65, 
  0x63, 0x6B, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0xDA, 0x18, 0xDA, 0x84, 0x0A, 0xCE, 
  0x1E, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2C, 0x20, 0x67, 0x6F, 0x74, 0x20, 0xDA, 
  0x81, 0x38, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 
  0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x03, 
  0x00, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x01, 0x03, 0x00, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0x81, 0xAC, 0x01, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x02, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x00, 0x05, 0xDA, 0x87, 0x02, 0x2C, 0x05, 
  0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x3B, 0x07, 
  0x06, 0x00, 0x19, 0x08, 0x07, 0x00, 0x3B, 0x07, 0x06, 0x01, 0x19, 0x09, 0x07, 0x00, 0x3B, 0x07, 
  0x06, 0x02, 0x19, 0x0A, 0x07, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x19, 0x06, 0x0A, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x29, 0x06, 0x01, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x43, 0x07, 0x00, 0x00, 0x31, 0x00, 
  0x08, 0x09, 0x31, 0x06, 0x04, 0x03, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x34, 0x0B, 
  0x00, 0x00, 0x81, 0xB1, 0x01, 0x02, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 
  0x40, 0x00, 0x40, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xD0, 0x08, 0x72, 
  0x61, 0x6E, 0x67, 0x65, 0x2D, 0x74, 0x6F, 0xDA, 0x85, 0x81, 0xD0, 0x04, 0x64, 0x6F, 0x77, 0x6E, 
  0xDA, 0x80, 0x9F, 0xDA, 0x84, 0xE5, 0xD0, 0x07, 0x64, 0x6F, 0x77, 0x6E, 0x2D, 0x74, 0x6F, 0xDA, 
  0x85, 0xAE, 0xDA, 0x87, 0x10, 0xDA, 0x87, 0x0C, 0xDA, 0x87, 0x11, 0xD0, 0x02, 0x69, 0x6E, 0xDA, 
  0x87, 0x0B, 0xD0, 0x07, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0xD7, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x0A, 0x03, 0x03, 0x03, 0x06, 0x16, 0xCE, 0x10, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 
  0x65, 0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x82, 
  0x41, 0xDA, 0x29, 0xDA, 0x44, 0xDA, 0x82, 0x43, 0xDA, 0x4A, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x05, 
  0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x26, 0x07, 
  0x00, 0x00, 0x31, 0x06, 0x05, 0x07, 0x43, 0x04, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x31, 0x07, 
  0x05, 0x01, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x08, 0x00, 0x05, 0x43, 0x07, 
  0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x09, 0x06, 0x07, 0x2F, 0x02, 0x00, 0x00, 0x43, 0x08, 
  0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x31, 0x07, 0x04, 0x08, 0x43, 0x06, 0x00, 0x00, 0x03, 0x06, 
  0x00, 0x00, 0x81, 0xC6, 0x01, 0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCE, 
  0x15, 0x75, 0x6E, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 
  0x20, 0x76, 0x65, 0x72, 0x62, 0x20, 0x2C, 0x03, 0x00, 0x00, 0x3D, 0x04, 0x01, 0x00, 0x46, 0x05, 
  0x04, 0x02, 0x1C, 0x05, 0x07, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x32, 0x00, 
  0x00, 0x00, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x05, 0x05, 
  0x02, 0x01, 0x38, 0x04, 0x01, 0x05, 0x19, 0x06, 0x04, 0x00, 0x38, 0x04, 0x01, 0x02, 0x19, 0x07, 
  0x04, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x04, 0x08, 0x00, 0x1C, 0x04, 
  0x65, 0x00, 0x05, 0x08, 0x02, 0x02, 0x31, 0x00, 0x01, 0x08, 0x33, 0x09, 0x03, 0x00, 0x19, 0x08, 
  0x09, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x23, 0x09, 0x07, 0x0A, 0x1C, 0x09, 0x0D, 0x00, 0x2A, 0x0B, 
  0x03, 0x00, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0C, 0x04, 0x00, 0x31, 0x0C, 
  0x06, 0x0A, 0x26, 0x0C, 0x00, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 
  0x00, 0x00, 0x31, 0x0C, 0x0B, 0x08, 0x43, 0x0A, 0x00, 0x00, 0x03, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 
  0x05, 0x00, 0x23, 0x0A, 0x07, 0x0B, 0x1C, 0x0A, 0x0D, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x2F, 0x0C, 
  0x00, 0x00, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0D, 0x04, 0x00, 0x26, 0x0E, 0x00, 0x00, 0x31, 0x0D, 
  0x06, 0x0E, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x00, 0x00, 0x31, 0x0D, 
  0x0C, 0x08, 0x43, 0x0B, 0x00, 0x00, 0x03, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x06, 0x00, 0x23, 0x0B, 
  0x07, 0x0C, 0x1C, 0x0B, 0x08, 0x00, 0x2A, 0x0D, 0x00, 0x00, 0x30, 0x0D, 0x08, 0x00, 0x43, 0x0C, 
  0x00, 0x00, 0x2A, 0x0E, 0x07, 0x00, 0x31, 0x0E, 0x06, 0x0C, 0x43, 0x0D, 0x00, 0x00, 0x03, 0x0D, 
  0x00, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x23, 0x0C, 0x07, 0x0D, 0x1C, 0x0C, 0x07, 0x00, 0x2A, 0x0E, 
  0x00, 0x00, 0x31, 0x0E, 0x08, 0x06, 0x26, 0x0E, 0x00, 0x00, 0x2F, 0x0E, 0x00, 0x00, 0x43, 0x0D, 
  0x00, 0x00, 0x03, 0x0D, 0x00, 0x00, 0x2A, 0x0E, 0x09, 0x00, 0x23, 0x0D, 0x07, 0x0E, 0x1C, 0x0D, 
  0x07, 0x00, 0x2A, 0x0F, 0x00, 0x00, 0x31, 0x0F, 0x06, 0x08, 0x26, 0x0F, 0x00, 0x00, 0x2F, 0x0F, 
  0x00, 0x00, 0x43, 0x0E, 0x00, 0x00, 0x03, 0x0E, 0x00, 0x00, 0x2A, 0x0F, 0x0A, 0x00, 0x23, 0x0E, 
  0x07, 0x0F, 0x1C, 0x0E, 0x16, 0x00, 0x2A, 0x10, 0x0B, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x19, 0x10, 
  0x0F, 0x00, 0x2A, 0x11, 0x0C, 0x00, 0x31, 0x11, 0x10, 0x06, 0x43, 0x0F, 0x00, 0x00, 0x2A, 0x12, 
  0x0D, 0x00, 0x29, 0x13, 0x00, 0x00, 0x31, 0x12, 0x10, 0x13, 0x43, 0x11, 0x00, 0x00, 0x2A, 0x13, 
  0x0E, 0x00, 0x30, 0x13, 0x10, 0x00, 0x43, 0x12, 0x00, 0x00, 0x2A, 0x14, 0x0F, 0x00, 0x31, 0x14, 
  0x11, 0x08, 0x2F, 0x12, 0x00, 0x00, 0x43, 0x13, 0x00, 0x00, 0x2A, 0x12, 0x00, 0x00, 0x31, 0x12, 
  0x0F, 0x13, 0x43, 0x11, 0x00, 0x00, 0x03, 0x11, 0x00, 0x00, 0x2A, 0x10, 0x10, 0x00, 0x23, 0x0F, 
  0x07, 0x10, 0x1C, 0x0F, 0x05, 0x00, 0x2A, 0x11, 0x11, 0x00, 0x31, 0x11, 0x06, 0x08, 0x43, 0x10, 
  0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x2A, 0x10, 0x12, 0x00, 0x30, 0x10, 0x07, 0x00, 0x2A, 0x11, 
  0x13, 0x00, 0x33, 0x10, 0x11, 0x00, 0x01, 0x10, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x05, 0x08, 0x02, 0x02, 0x38, 0x04, 0x01, 0x08, 0x19, 0x09, 0x04, 0x00, 0x05, 0x04, 
  0x02, 0x03, 0x31, 0x00, 0x01, 0x04, 0x33, 0x0A, 0x03, 0x00, 0x19, 0x04, 0x0A, 0x00, 0x2A, 0x0B, 
  0x14, 0x00, 0x23, 0x0A, 0x06, 0x0B, 0x1C, 0x0A, 0x07, 0x00, 0x31, 0x07, 0x09, 0x04, 0x2A, 0x0B, 
  0x15, 0x00, 0x2A, 0x0C, 0x16, 0x00, 0x30, 0x0B, 0x0C, 0x00, 0x2A, 0x0B, 0x17, 0x00, 0x34, 0x0B, 
  0x00, 0x00, 0x2A, 0x0C, 0x18, 0x00, 0x23, 0x0B, 0x06, 0x0C, 0x1C, 0x0B, 0x07, 0x00, 0x31, 0x07, 
  0x09, 0x04, 0x2A, 0x0C, 0x15, 0x00, 0x2A, 0x0D, 0x19, 0x00, 0x30, 0x0C, 0x0D, 0x00, 0x2A, 0x0C, 
  0x17, 0x00, 0x34, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x1A, 0x00, 0x23, 0x0C, 0x06, 0x0D, 0x1C, 0x0C, 
  0x07, 0x00, 0x31, 0x07, 0x09, 0x04, 0x2A, 0x0D, 0x1B, 0x00, 0x2A, 0x0E, 0x1C, 0x00, 0x30, 0x0D, 
  0x0E, 0x00, 0x2A, 0x0D, 0x17, 0x00, 0x34, 0x0D, 0x00, 0x00, 0x2A, 0x0E, 0x1D, 0x00, 0x23, 0x0D, 
  0x06, 0x0E, 0x1C, 0x0D, 0x07, 0x00, 0x31, 0x07, 0x09, 0x04, 0x2A, 0x0E, 0x1B, 0x00, 0x2A, 0x0F, 
  0x1E, 0x00, 0x30, 0x0E, 0x0F, 0x00, 0x2A, 0x0E, 0x17, 0x00, 0x34, 0x0E, 0x00, 0x00, 0x2A, 0x0F, 
  0x1F, 0x00, 0x23, 0x0E, 0x06, 0x0F, 0x1C, 0x0E, 0x08, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x43, 0x0F, 
  0x00, 0x00, 0x2A, 0x10, 0x1F, 0x00, 0x31, 0x07, 0x09, 0x10, 0x2F, 0x0F, 0x00, 0x00, 0x2A, 0x10, 
  0x20, 0x00, 0x34, 0x10, 0x00, 0x00, 0x2A, 0x10, 0x21, 0x00, 0x23, 0x0F, 0x06, 0x10, 0x1C, 0x0F, 
  0x08, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x43, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x21, 0x00, 0x31, 0x07, 
  0x09, 0x11, 0x2F, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x20, 0x00, 0x34, 0x11, 0x00, 0x00, 0x2A, 0x11, 
  0x22, 0x00, 0x23, 0x10, 0x06, 0x11, 0x1C, 0x10, 0x08, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x43, 0x11, 
  0x00, 0x00, 0x2A, 0x12, 0x23, 0x00, 0x31, 0x07, 0x09, 0x12, 0x2F, 0x11, 0x00, 0x00, 0x2A, 0x12, 
  0x20, 0x00, 0x34, 0x12, 0x00, 0x00, 0x2A, 0x12, 0x24, 0x00, 0x23, 0x11, 0x06, 0x12, 0x1C, 0x11, 
  0x04, 0x00, 0x31, 0x07, 0x09, 0x04, 0x2A, 0x12, 0x25, 0x00, 0x34, 0x12, 0x00, 0x00, 0x2A, 0x12, 
  0x26, 0x00, 0x30, 0x12, 0x06, 0x00, 0x2A, 0x13, 0x13, 0x00, 0x33, 0x12, 0x13, 0x00, 0x01, 0x12, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x81, 0xCF, 0x01, 0x04, 0x0D, 0x00, 0x09, 0x00, 0x03, 0x01, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFF, 0x03, 0x04, 0x09, 0xBF, 0xFF, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x04, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x02, 
  0x23, 0x00, 0x12, 0x00, 0x12, 0x00, 0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFF, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0xBF, 0xFE, 0x09, 0x00, 0x09, 0x00, 0x09, 0x03, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFD, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x04, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFC, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x05, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0xBF, 
  0xFB, 0x09, 0x00, 0x09, 0x00, 0x09, 0x06, 0x13, 0x00, 0x13, 0x00, 0x13, 0x01, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0xBF, 0xF9, 0x09, 0x00, 0x09, 0x00, 0x09, 0x08, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x01, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xF4, 0x03, 0x0F, 0x09, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x1F, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFC, 0x05, 0x00, 0x05, 0x00, 0x05, 0x05, 0x31, 
  0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFB, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x06, 0x33, 0x00, 0x33, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0xBF, 0xFA, 0x05, 0x00, 0x05, 0x00, 0x05, 0x07, 0x2F, 0x00, 0x2F, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xF9, 0x05, 0x00, 0x05, 0x00, 0x05, 0x08, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x07, 0x2C, 
  0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x31, 0x01, 0x00, 0x03, 0x2A, 0x03, 0x00, 0x00, 0x34, 
  0x03, 0x00, 0x00, 0x82, 0x1B, 0x01, 0x44, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x04, 
  0x6D, 0x65, 0x61, 0x6E, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x01, 
  0x07, 0xCE, 0x04, 0x6D, 0x65, 0x61, 0x6E, 0xDA, 0x18, 0xDA, 0x87, 0x15, 0x2C, 0x01, 0x00, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x3D, 0x03, 0x00, 0x00, 
  0x0B, 0x04, 0x02, 0x03, 0x03, 0x04, 0x00, 0x00, 0x82, 0x86, 0x01, 0x03, 0x06, 0x00, 0x06, 0x00, 
  0x06, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x63, 
  0x6F, 0x73, 0x68, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x63, 0x6F, 0x73, 0x68, 0xCF, 
  0x0B, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0xDA, 0x88, 0x17, 0xCF, 
  0x0F, 0x2A, 0x64, 0x65, 0x66, 0x64, 0x79, 0x6E, 0x2D, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x2A, 
  0xDA, 0x89, 0x05, 0xCF, 0x07, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x3F, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x07, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x3F, 0xDA, 0x18, 0xDA, 0x1C, 0xDA, 0x20, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 
  0x03, 0x03, 0x00, 0x00, 0x69, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 
  0x00, 0x2D, 0xCF, 0x08, 0x72, 0x6F, 0x6F, 0x74, 0x2D, 0x65, 0x6E, 0x76, 0xDA, 0x00, 0xDA, 0x88, 
  0x29, 0xD7, 0x00, 0xCD, 0x00, 0xB9, 0x00, 0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x05, 0x13, 0x01, 0xCE, 0x06, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0xDA, 0x18, 0xDA, 0x84, 0x6D, 
  0xDA, 0x89, 0x1C, 0xDA, 0x81, 0x38, 0xDA, 0x87, 0x3C, 0xDA, 0x78, 0x2C, 0x02, 0x00, 0x00, 0x29, 
  0x03, 0x02, 0x00, 0x30, 0x03, 0x01, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 
  0x04, 0x03, 0x00, 0x2E, 0x05, 0x00, 0x00, 0x30, 0x05, 0x04, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 
  0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x33, 
  0x07, 0x08, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x30, 0x08, 0x07, 0x00, 0x32, 0x05, 0x00, 0x00, 0x2A, 
  0x08, 0x04, 0x00, 0x34, 0x08, 0x00, 0x00, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 
  0x02, 0x10, 0xDA, 0x18, 0xDA, 0x87, 0x40, 0xDA, 0x81, 0x38, 0x3B, 0x01, 0x00, 0x00, 0x19, 0x02, 
  0x01, 0x00, 0x3B, 0x01, 0x00, 0x01, 0x19, 0x03, 0x01, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x23, 0x01, 
  0x02, 0x04, 0x1C, 0x01, 0x06, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x19, 0x00, 0x04, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x00, 0x03, 0x00, 0x30, 0x02, 
  0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x8B, 0x85, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x28, 0x00, 0x28, 0x00, 0x24, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 
  0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x8B, 0x7A, 0x01, 0x0A, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x15, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 
  0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x63, 0x68, 0x6D, 0x6F, 0x64, 0xD8, 0x08, 0x6F, 0x73, 
  0x2F, 0x63, 0x68, 0x6D, 0x6F, 0x64, 0xCF, 0x06, 0x70, 0x75, 0x74, 0x2D, 0x69, 0x6E, 0xDA, 0x89, 
  0x3D, 0xCF, 0x03, 0x6D, 0x61, 0x70, 0xDA, 0x82, 0x48, 0xCF, 0x03, 0x74, 0x72, 0x79, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x0D, 0x3B, 0xCE, 0x03, 0x74, 0x72, 0x79, 
  0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x80, 0xB9, 0xDA, 0x80, 0xBA, 0xDA, 0x80, 0xBB, 0xDA, 0x80, 0xBC, 
  0xDA, 0x80, 0xBE, 0xDA, 0x83, 0x1D, 0xDA, 0x80, 0xC1, 0xDA, 0x44, 0xDA, 0x80, 0xE4, 0xDA, 0x4A, 
  0xDA, 0x49, 0xDA, 0x80, 0xC2, 0x2C, 0x02, 0x00, 0x00, 0x3B, 0x03, 0x01, 0x00, 0x3B, 0x04, 0x03, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x3B, 0x04, 0x03, 0x01, 0x19, 0x06, 0x04, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x03, 0x07, 
  0x00, 0x19, 0x07, 0x03, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x31, 0x09, 0x03, 
  0x00, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x31, 0x09, 0x08, 
  0x0A, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x30, 0x09, 0x04, 0x00, 0x43, 0x08, 0x00, 
  0x00, 0x31, 0x04, 0x03, 0x07, 0x2F, 0x08, 0x00, 0x00, 0x44, 0x09, 0x00, 0x00, 0x2A, 0x08, 0x05, 
  0x00, 0x30, 0x08, 0x04, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 0x06, 0x00, 0x2A, 0x0B, 0x07, 
  0x00, 0x31, 0x0A, 0x03, 0x0B, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x08, 0x00, 0x31, 0x0A, 0x05, 
  0x07, 0x43, 0x03, 0x00, 0x00, 0x1C, 0x06, 0x06, 0x00, 0x2A, 0x0C, 0x08, 0x00, 0x31, 0x0C, 0x06, 
  0x04, 0x43, 0x0B, 0x00, 0x00, 0x19, 0x0A, 0x0B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x0A, 0x00, 
  0x00, 0x29, 0x0B, 0x01, 0x00, 0x30, 0x01, 0x0B, 0x00, 0x2A, 0x0C, 0x09, 0x00, 0x33, 0x0B, 0x0C, 
  0x00, 0x2A, 0x0D, 0x0A, 0x00, 0x31, 0x0D, 0x03, 0x0A, 0x32, 0x0B, 0x00, 0x00, 0x43, 0x0C, 0x00, 
  0x00, 0x2A, 0x0A, 0x0B, 0x00, 0x31, 0x0A, 0x08, 0x0C, 0x2F, 0x07, 0x00, 0x00, 0x43, 0x03, 0x00, 
  0x00, 0x2A, 0x0A, 0x0C, 0x00, 0x31, 0x0A, 0x09, 0x03, 0x43, 0x08, 0x00, 0x00, 0x03, 0x08, 0x00, 
  0x00, 0x80, 0xF9, 0x01, 0x07, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0B, 
  0x00, 0x0B, 0xBF, 0xFF, 0x03, 0x02, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x03, 0x03, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x1D, 0x00, 0x25, 
  0x00, 0x25, 0x00, 0x25, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x37, 0x00, 0x37, 0x00, 0x37, 
  0x00, 0x37, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x08, 0x65, 0x76, 0x2F, 
  0x63, 0x6C, 0x6F, 0x73, 0x65, 0xDA, 0x87, 0xEC, 0xCF, 0x04, 0x61, 0x73, 0x2D, 0x3E, 0xD7, 0x00, 
  0xCD, 0x02, 0xBB, 0x00, 0x00, 0x07, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x08, 0x02, 
  0xCE, 0x04, 0x61, 0x73, 0x2D, 0x3E, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x86, 0x49, 0xDA, 0x80, 0xC2, 
  0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x02, 0x06, 
  0x19, 0x06, 0x05, 0x00, 0x2E, 0x05, 0x01, 0x00, 0x33, 0x05, 0x05, 0x00, 0x03, 0x04, 0x00, 0x00, 
  0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x06, 0x01, 0xDA, 0x18, 0x2B, 0x02, 
  0x00, 0x01, 0x23, 0x01, 0x00, 0x02, 0x1C, 0x01, 0x03, 0x00, 0x2B, 0x02, 0x00, 0x08, 0x03, 0x02, 
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0x3D, 0x2A, 0x00, 0x2A, 0x00, 0x26, 0x00, 
  0x26, 0x00, 0x26, 0x00, 0x26, 0xCD, 0x02, 0xFA, 0x00, 0x00, 0x07, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x03, 0x1C, 0x01, 0x01, 0xDA, 0x86, 0x4B, 0xDA, 0x18, 0xDA, 0x43, 0xDA, 0x86, 0x49, 
  0xDA, 0x80, 0xC2, 0x2B, 0x00, 0x00, 0x06, 0x1E, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2B, 
  0x01, 0x00, 0x02, 0x2B, 0x02, 0x00, 0x06, 0x38, 0x00, 0x01, 0x02, 0x19, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00, 0x19, 0x02, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x30, 
  0x00, 0x01, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x00, 0x03, 0x00, 0x2B, 
  0x04, 0x00, 0x04, 0x30, 0x02, 0x04, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 
  0x05, 0x03, 0x00, 0x43, 0x04, 0x00, 0x00, 0x2D, 0x04, 0x00, 0x04, 0x2B, 0x05, 0x00, 0x02, 0x2B, 
  0x06, 0x00, 0x06, 0x47, 0x03, 0x05, 0x06, 0x2D, 0x03, 0x00, 0x06, 0x2C, 0x05, 0x00, 0x00, 0x34, 
  0x05, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x06, 
  0x02, 0xDA, 0x18, 0x2B, 0x02, 0x00, 0x01, 0x23, 0x01, 0x00, 0x02, 0x1C, 0x01, 0x03, 0x00, 0x2B, 
  0x02, 0x01, 0x02, 0x03, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0x3D, 
  0x2A, 0x00, 0x2A, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x85, 0x3B, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x05, 
  0x01, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x85, 0x35, 0x01, 0x05, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0x56, 0x01, 0x00, 0x00, 0xCF, 
  0x03, 0x6D, 0x61, 0x78, 0xDA, 0x84, 0xE3, 0xCF, 0x0A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 
  0x62, 0x69, 0x74, 0xD8, 0x0A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0xCF, 
  0x08, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2D, 0x66, 0x6E, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 
  0x05, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x0B, 0xCE, 0x08, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2D, 0x66, 0x6E, 0xDA, 0x18, 0xDA, 0x80, 0xB9, 0xDA, 0x80, 0xF1, 0xDA, 0x78, 0xDA, 0x80, 
  0xBA, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x30, 0x03, 0x04, 
  0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2A, 0x04, 0x03, 
  0x00, 0x31, 0x04, 0x03, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x34, 0x04, 0x00, 0x00, 0x82, 0x7A, 0x01, 
  0x03, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xCF, 0x05, 0x74, 0x72, 0x61, 0x63, 0x65, 0xD8, 0x05, 0x74, 0x72, 0x61, 
  0x63, 0x65, 0xCF, 0x0C, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2D, 0x65, 0x6E, 0x76, 
  0xDA, 0x83, 0x37, 0xCF, 0x0B, 0x73, 0x63, 0x61, 0x6E, 0x2D, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0xDA, 0x84, 0xEA, 0xCF, 0x09, 0x66, 0x66, 0x69, 0x2F, 0x6A, 0x69, 0x74, 0x66, 0x6E, 0xD8, 0x09, 
  0x66, 0x66, 0x69, 0x2F, 0x6A, 0x69, 0x74, 0x66, 0x6E, 0xDA, 0x88, 0x2B, 0xDA, 0x87, 0x3C, 0xCF, 
  0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x72, 0x65, 0x61, 0x64, 0xDA, 0x83, 0x53, 0xCF, 0x0C, 0x77, 
  0x61, 0x72, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0xDA, 0x83, 0xF7, 0xCF, 0x0A, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x75, 0x73, 0x68, 0xDA, 0x81, 0x4C, 0xCF, 0x04, 0x63, 
  0x6F, 0x6D, 0x70, 0xD7, 0x00, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x18, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x01, 0x3A, 0x04, 0xCE, 0x04, 0x63, 0x6F, 0x6D, 0x70, 0xDA, 0x18, 0xDA, 0x80, 0xE4, 
  0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x24, 0x02, 0x03, 0x00, 
  0x1C, 0x02, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x24, 0x04, 0x03, 0x01, 0x1C, 0x04, 0x04, 0x00, 
  0x29, 0x06, 0x00, 0x00, 0x38, 0x05, 0x00, 0x06, 0x03, 0x05, 0x00, 0x00, 0x24, 0x05, 0x03, 0x02, 
  0x1C, 0x05, 0x07, 0x00, 0x3B, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x3B, 0x06, 0x00, 0x01, 
  0x19, 0x08, 0x06, 0x00, 0x2E, 0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x24, 0x06, 0x03, 0x03, 
  0x1C, 0x06, 0x09, 0x00, 0x3B, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x3B, 0x09, 0x00, 0x01, 
  0x19, 0x0B, 0x09, 0x00, 0x3B, 0x09, 0x00, 0x02, 0x19, 0x0C, 0x09, 0x00, 0x2E, 0x09, 0x01, 0x00, 
  0x03, 0x09, 0x00, 0x00, 0x24, 0x09, 0x03, 0x04, 0x1C, 0x09, 0x0B, 0x00, 0x3B, 0x0D, 0x00, 0x00, 
  0x19, 0x0E, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x01, 0x19, 0x0F, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x02, 
  0x19, 0x10, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x03, 0x19, 0x11, 0x0D, 0x00, 0x2E, 0x0D, 0x02, 0x00, 
  0x03, 0x0D, 0x00, 0x00, 0x3B, 0x0D, 0x00, 0x00, 0x19, 0x12, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x01, 
  0x19, 0x13, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x02, 0x19, 0x14, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x03, 
  0x19, 0x15, 0x0D, 0x00, 0x2E, 0x0D, 0x03, 0x00, 0x29, 0x16, 0x04, 0x00, 0x29, 0x17, 0xFF, 0xFF, 
  0x31, 0x00, 0x16, 0x17, 0x2A, 0x17, 0x00, 0x00, 0x33, 0x16, 0x17, 0x00, 0x2F, 0x0D, 0x00, 0x00, 
  0x32, 0x16, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0xCD, 0x00, 0xD1, 0x00, 0x00, 0x03, 0x00, 0x00, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x01, 0xDA, 0x18, 0x32, 0x00, 0x00, 0x00, 0x2B, 0x02, 
  0x00, 0x08, 0x33, 0x01, 0x02, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x07, 0x34, 0x02, 
  0x00, 0x00, 0xBF, 0xFF, 0x82, 0xBD, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x28, 0x00, 0x28, 0x00, 
  0x28, 0xCD, 0x00, 0xD1, 0x00, 0x00, 0x04, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x09, 
  0x01, 0xDA, 0x18, 0x32, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x0C, 0x33, 0x01, 0x02, 0x00, 0x2F, 
  0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x0B, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 
  0x01, 0x00, 0x0A, 0x34, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x82, 0xBE, 0x30, 0x00, 0x30, 0x00, 0x30, 
  0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0xCD, 0x00, 0xD1, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x0C, 0x01, 0xDA, 0x18, 0x32, 0x00, 
  0x00, 0x00, 0x2B, 0x02, 0x00, 0x11, 0x33, 0x01, 0x02, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x03, 
  0x00, 0x10, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x0F, 0x33, 0x01, 
  0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x0E, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 
  0x82, 0xBF, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x2F, 0x00, 
  0x2F, 0x00, 0x2F, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x04, 0x01, 
  0x01, 0x01, 0x00, 0x0C, 0x01, 0xDA, 0x18, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x15, 0x33, 
  0x01, 0x02, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x14, 0x33, 0x02, 0x03, 0x00, 0x2F, 
  0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x13, 0x33, 0x01, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 
  0x02, 0x00, 0x12, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x82, 0xC1, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 
  0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x82, 0xB6, 0x01, 0x04, 0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x03, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x1E, 0x00, 0x1E, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x04, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x20, 0x00, 0x20, 0xBF, 
  0xFC, 0x03, 0x00, 0x03, 0x05, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x22, 0x00, 0x22, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0D, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 0x80, 0xDD, 0x3F, 0x00, 0xDA, 
  0x88, 0x24, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x02, 0x07, 0xCE, 0x04, 0x76, 0x61, 0x72, 0x2D, 0xDA, 0x18, 0xDA, 0x82, 0x41, 0xDA, 0x52, 
  0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x04, 0x00, 0x05, 
  0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x4A, 0x01, 0x03, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x07, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x3F, 0xDA, 0x83, 0xF0, 0xCF, 0x06, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x74, 0xD7, 0x00, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x00, 0x0D, 0xCE, 0x06, 0x69, 0x6E, 0x76, 
  0x65, 0x72, 0x74, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x42, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 
  0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x06, 
  0x00, 0x19, 0x04, 0x05, 0x00, 0x38, 0x06, 0x00, 0x04, 0x3A, 0x03, 0x06, 0x04, 0x47, 0x05, 0x00, 
  0x05, 0x1A, 0xFB, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x85, 0x9D, 0x01, 0x06, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x05, 0xBF, 0xFF, 
  0x03, 0x00, 0x03, 0xBF, 0xF9, 0x01, 0xCF, 0x0C, 0x65, 0x76, 0x2F, 0x64, 0x6F, 0x2D, 0x74, 0x68, 
  0x72, 0x65, 0x61, 0x64, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x00, 0x00, 0xCD, 0x7F, 
  0xFF, 0xFF, 0xFF, 0x04, 0x0D, 0xCE, 0x0C, 0x65, 0x76, 0x2F, 0x64, 0x6F, 0x2D, 0x74, 0x68, 0x72, 
  0x65, 0x61, 0x64, 0xDA, 0x18, 0xDA, 0x84, 0x36, 0xDA, 0x80, 0xB9, 0xCF, 0x0A, 0x5F, 0x64, 0x6F, 
  0x2D, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0xDA, 0x85, 0xB7, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x44, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x2A, 0x05, 
  0x02, 0x00, 0x31, 0x04, 0x05, 0x02, 0x32, 0x00, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x04, 
  0x03, 0x00, 0x30, 0x04, 0x03, 0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x8D, 0xEE, 
  0x03, 0x04, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x04, 0x63, 0x6F, 0x6E, 0x64, 0xD7, 
  0x00, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x05, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 
  0x01, 0xCE, 0x04, 0x63, 0x6F, 0x6E, 0x64, 0xDA, 0x18, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 
  0x00, 0x19, 0x03, 0x02, 0x00, 0x29, 0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x34, 0x03, 0x00, 
  0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x02, 0x1A, 0x01, 0xDA, 0x70, 0xDA, 
  0x18, 0xDA, 0x49, 0xDA, 0x78, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x00, 0x3D, 0x02, 0x03, 
  0x00, 0x07, 0x03, 0x02, 0x00, 0x19, 0x02, 0x03, 0x00, 0x24, 0x04, 0x02, 0x00, 0x1C, 0x04, 0x02, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0x24, 0x05, 0x02, 0x01, 0x1C, 0x05, 0x04, 0x00, 0x2B, 0x07, 0x00, 
  0x00, 0x38, 0x06, 0x07, 0x00, 0x03, 0x06, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x00, 0x38, 0x06, 0x07, 
  0x00, 0x05, 0x07, 0x00, 0x01, 0x2B, 0x09, 0x00, 0x00, 0x38, 0x08, 0x09, 0x07, 0x05, 0x07, 0x00, 
  0x02, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x09, 0x01, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x31, 0x07, 0x06, 
  0x08, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x34, 0x07, 0x00, 0x00, 0xBF, 0xFF, 0x80, 
  0xCC, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x12, 0x00, 0x05, 0x01, 0x09, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x0B, 0x00, 0x07, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x01, 0x14, 0x00, 0x14, 0x01, 0x1A, 
  0x00, 0x10, 0x00, 0x10, 0x01, 0x15, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFE, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x80, 0xC6, 0x01, 0x06, 0x03, 0x00, 0x03, 0x07, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xCF, 0x0C, 0x6F, 0x73, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x2D, 
  0x77, 0x61, 0x69, 0x74, 0xD8, 0x0C, 0x6F, 0x73, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x2D, 0x77, 0x61, 
  0x69, 0x74, 0xCF, 0x07, 0x70, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6C, 0xD7, 0x00, 0xCD, 0x02, 0xBB, 
  0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x09, 0x01, 0xCE, 0x07, 0x70, 
  0x61, 0x72, 0x74, 0x69, 0x61, 0x6C, 0xDA, 0x18, 0xDA, 0x86, 0xE1, 0x2C, 0x02, 0x00, 0x00, 0x3D, 
  0x03, 0x01, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 
  0x04, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xCD, 
  0x00, 0xD1, 0x00, 0x00, 0x02, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x05, 0x01, 0xDA, 
  0x18, 0x2B, 0x01, 0x00, 0x01, 0x32, 0x01, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 
  0x00, 0x34, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0x6F, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x85, 0x6B, 0x01, 0x03, 0x0E, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 
  0x03, 0x01, 0x05, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x61, 0x62, 0x73, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x62, 0x73, 0xCF, 0x07, 0x73, 
  0x6F, 0x72, 0x74, 0x2D, 0x62, 0x79, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x05, 0x02, 0x02, 
  0x02, 0x01, 0x05, 0x01, 0xCE, 0x07, 0x73, 0x6F, 0x72, 0x74, 0x2D, 0x62, 0x79, 0xDA, 0x18, 0xDA, 
  0x85, 0xE5, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x30, 0x01, 0x03, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x00, 
  0x08, 0x01, 0xDA, 0x18, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x2F, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x21, 0x04, 0x02, 0x03, 
  0x03, 0x04, 0x00, 0x00, 0xBF, 0xFF, 0x83, 0x54, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x20, 0x00, 
  0x20, 0x00, 0x20, 0x00, 0x17, 0x00, 0x17, 0x83, 0x50, 0x01, 0x04, 0x0D, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xCF, 0x04, 0x62, 0x61, 0x6E, 0x64, 0xD7, 0x00, 0xCD, 0x00, 
  0x09, 0x00, 0x0D, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x04, 0x62, 
  0x61, 0x6E, 0x64, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 
  0x03, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 
  0x03, 0xFF, 0xFF, 0x3B, 0x04, 0x00, 0x00, 0x0E, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 
  0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x0E, 0x03, 0x03, 0x04, 0x05, 
  0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 
  0x09, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2D, 0x62, 0x79, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 
  0x00, 0x05, 0x02, 0x02, 0x02, 0x01, 0x05, 0x01, 0xCE, 0x09, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 
  0x2D, 0x62, 0x79, 0xDA, 0x18, 0xDA, 0x86, 0x87, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 
  0x30, 0x01, 0x03, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 
  0x00, 0x05, 0x02, 0x02, 0x02, 0x00, 0x08, 0x01, 0xDA, 0x18, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x21, 0x04, 0x02, 0x03, 0x03, 0x04, 0x00, 0x00, 0xBF, 0xFF, 0x83, 0x61, 0x1C, 0x00, 
  0x1C, 0x00, 0x1C, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x19, 0x00, 0x19, 0x83, 0x5D, 0x01, 
  0x04, 0x0F, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xCF, 0x0B, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x6F, 0x70, 0x6E, 0xD8, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2F, 0x70, 0x6F, 0x70, 0x6E, 0xCF, 0x02, 0x2A, 0x3D, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 0x08, 0xCE, 0x02, 0x2A, 0x3D, 0xDA, 0x18, 0xDA, 0x88, 0x7C, 
  0xDA, 0x29, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x04, 0x00, 0x01, 0x43, 0x03, 
  0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 
  0x00, 0x00, 0x80, 0x9A, 0x01, 0x00, 0x37, 0x00, 0x37, 0x00, 0x37, 0x00, 0x37, 0x00, 0x37, 0x00, 
  0x37, 0x00, 0x37, 0xCF, 0x07, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x32, 0xD7, 0x00, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x09, 0x02, 0x02, 0x02, 0x00, 0x15, 0xCE, 0x07, 0x72, 0x65, 0x64, 0x75, 0x63, 
  0x65, 0x32, 0xDA, 0x18, 0x2C, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x01, 0x04, 
  0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x03, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x05, 0x01, 0x04, 0x19, 0x06, 0x05, 0x00, 
  0x47, 0x04, 0x01, 0x04, 0x26, 0x08, 0x00, 0x00, 0x48, 0x07, 0x08, 0x04, 0x1C, 0x07, 0x06, 0x00, 
  0x38, 0x08, 0x01, 0x04, 0x30, 0x06, 0x08, 0x00, 0x33, 0x06, 0x00, 0x00, 0x47, 0x04, 0x01, 0x04, 
  0x1A, 0xF9, 0xFF, 0xFF, 0x03, 0x06, 0x00, 0x00, 0x83, 0x6F, 0x01, 0x04, 0x0A, 0x00, 0x0A, 0x00, 
  0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x11, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 
  0x0A, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x15, 0x00, 0x0E, 0x00, 0x0E, 0x01, 0x0C, 0xBF, 
  0xFE, 0x03, 0xBF, 0xF8, 0x01, 0xCF, 0x08, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0xD7, 
  0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x07, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x06, 0x14, 
  0xCE, 0x08, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0xDA, 0x18, 0xDA, 0x4A, 0xDA, 0x87, 
  0xC9, 0xDA, 0x84, 0x8D, 0xDA, 0x80, 0xB9, 0xDA, 0x80, 0xBA, 0xDA, 0x80, 0xF2, 0x2C, 0x02, 0x00, 
  0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x32, 0x01, 0x00, 
  0x00, 0x43, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x30, 0x06, 0x04, 0x00, 0x43, 0x05, 0x00, 
  0x00, 0x2A, 0x06, 0x02, 0x00, 0x31, 0x06, 0x00, 0x05, 0x43, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x03, 
  0x00, 0x31, 0x06, 0x03, 0x04, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x2A, 0x06, 0x05, 
  0x00, 0x31, 0x04, 0x05, 0x06, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x82, 0x6F, 0x01, 
  0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x61, 0x72, 0x63, 0x68, 0xDA, 
  0x89, 0x77, 0xCF, 0x06, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0xDA, 0x88, 0x20, 0xCF, 0x0A, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x2F, 0x66, 0x69, 0x6C, 0x6C, 0xD8, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2F, 0x66, 0x69, 0x6C, 0x6C, 0xCF, 0x02, 0x2B, 0x2B, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x05, 0x01, 0x01, 0x01, 0x02, 0x09, 0xCE, 0x02, 0x2B, 0x2B, 0xDA, 0x18, 0xDA, 0x27, 0xDA, 0x29, 
  0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 0x31, 0x03, 0x00, 0x04, 
  0x43, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x31, 0x04, 0x00, 0x02, 0x43, 0x03, 0x00, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0x80, 0x96, 0x01, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 
  0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xCF, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xDA, 
  0x81, 0x38, 0xDA, 0x87, 0x7F, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x00, 0x02, 
  0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x8A, 0x44, 0x01, 0x03, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 
  0x8B, 0x47, 0x0C, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0xDA, 
  0x85, 0x3E, 0xD7, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x02, 0x06, 0xCE, 0x0D, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x6C, 0x6F, 0x61, 0x64, 
  0x65, 0x72, 0xDA, 0x18, 0xDA, 0x83, 0x30, 0xDA, 0x87, 0xE1, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 
  0x00, 0x00, 0x8B, 0x3D, 0x0D, 0x00, 0x35, 0x00, 0x35, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0xDA, 
  0x85, 0x2F, 0xD7, 0x00, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x07, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x02, 0x11, 0xCE, 0x0E, 0x70, 0x72, 0x65, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x6C, 0x6F, 0x61, 
  0x64, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x85, 0x2E, 0xDA, 0x85, 0x63, 0x2C, 0x02, 0x00, 0x00, 0x2A, 
  0x04, 0x00, 0x00, 0x38, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x0C, 0x00, 0x2F, 
  0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x03, 0x05, 0x00, 0x1C, 0x03, 0x07, 0x00, 0x2F, 
  0x00, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x33, 0x05, 0x04, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x3A, 
  0x06, 0x00, 0x05, 0x03, 0x05, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x8B, 
  0x42, 0x0E, 0x01, 0x1D, 0x00, 0x1D, 0x00, 0x10, 0x00, 0x10, 0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 
  0x00, 0x12, 0x01, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xBF, 0xFF, 
  0x12, 0xBF, 0xFF, 0x10, 0xDA, 0x83, 0x4C, 0xD7, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x08, 0x02, 
  0x02, 0x02, 0x05, 0x19, 0x01, 0xCE, 0x0D, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2D, 0x6C, 0x6F, 
  0x61, 0x64, 0x65, 0x72, 0xDA, 0x18, 0xDA, 0x85, 0x73, 0xDA, 0x80, 0xD4, 0xDA, 0x80, 0xBA, 0xDA, 
  0x80, 0xBE, 0xDA, 0x80, 0xD6, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x27, 0x04, 0x00, 
  0x00, 0x3A, 0x03, 0x00, 0x04, 0x2E, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x30, 0x03, 0x04, 
  0x00, 0x2A, 0x05, 0x02, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x03, 0x04, 0x00, 0x26, 0x05, 0x00, 
  0x00, 0x35, 0x04, 0x03, 0x05, 0x19, 0x05, 0x04, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x26, 0x06, 0x00, 
  0x00, 0x3A, 0x04, 0x00, 0x06, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x33, 0x04, 0x06, 
  0x00, 0x2A, 0x07, 0x04, 0x00, 0x23, 0x06, 0x04, 0x07, 0x1C, 0x06, 0x02, 0x00, 0x03, 0x05, 0x00, 
  0x00, 0x37, 0x04, 0x05, 0x03, 0x03, 0x04, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 
  0x00, 0x00, 0x01, 0x06, 0x01, 0xDA, 0x18, 0xDA, 0x88, 0x2E, 0x2B, 0x00, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2B, 0x00, 0x00, 0x01, 0x32, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x34, 0x00, 
  0x00, 0x00, 0xBF, 0xFF, 0x8B, 0x41, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0x8B, 0x3E, 0x0D, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x16, 0x00, 0x16, 
  0x00, 0x16, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x00, 0xCE, 0x0C, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0xCE, 0x08, 0x20, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 
  0x2C, 0x03, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 
  0x3B, 0x05, 0x04, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3B, 0x05, 0x04, 0x01, 0x19, 0x07, 0x05, 0x00, 
  0x1C, 0x06, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x01, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 
  0x2F, 0x08, 0x00, 0x00, 0x33, 0x08, 0x02, 0x00, 0x1C, 0x08, 0x03, 0x00, 0x26, 0x05, 0x00, 0x00, 
  0x1A, 0x04, 0x00, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x38, 0x09, 0x0A, 0x06, 0x19, 0x05, 0x09, 0x00, 
  0x19, 0x08, 0x05, 0x00, 0x1C, 0x08, 0x02, 0x00, 0x03, 0x08, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 
  0x2A, 0x09, 0x03, 0x00, 0x33, 0x05, 0x09, 0x00, 0x1C, 0x05, 0x08, 0x00, 0x2A, 0x09, 0x04, 0x00, 
  0x2A, 0x0A, 0x05, 0x00, 0x31, 0x09, 0x06, 0x0A, 0x2A, 0x0A, 0x06, 0x00, 0x33, 0x09, 0x0A, 0x00, 
  0x01, 0x09, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x07, 0x00, 
  0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0C, 0x08, 0x00, 
  0x33, 0x0B, 0x0C, 0x00, 0x19, 0x09, 0x0B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x09, 0x07, 0x00, 
  0x19, 0x0A, 0x09, 0x00, 0x1C, 0x0A, 0x02, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x09, 0x00, 
  0x2A, 0x0B, 0x0A, 0x00, 0x31, 0x09, 0x07, 0x0B, 0x2A, 0x0B, 0x06, 0x00, 0x33, 0x09, 0x0B, 0x00, 
  0x01, 0x09, 0x00, 0x00, 0x30, 0x06, 0x01, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 0x0B, 0x09, 0x00, 
  0x2A, 0x09, 0x02, 0x00, 0x3A, 0x09, 0x06, 0x0B, 0x03, 0x0B, 0x00, 0x00, 0x8B, 0x49, 0x01, 0x02, 
  0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x14, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x29, 0x00, 0x29, 0x00, 0x12, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x00, 
  0x07, 0x02, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x15, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x1F, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x18, 0x01, 0x12, 0x00, 0x12, 0x00, 0x09, 0x01, 0x09, 0x00, 
  0x09, 0xBF, 0xFC, 0x07, 0x2C, 0x02, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x33, 0x03, 0x04, 0x00, 0x31, 0x00, 0x01, 0x03, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 
  0x8B, 0x58, 0x01, 0x05, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 
  0x08, 0xCE, 0x80, 0xB6, 0x28, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x71, 0x75, 0x69, 
  0x72, 0x65, 0x20, 0x61, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x2E, 
  0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x20, 0x61, 0x6C, 0x6C, 
  0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x69, 0x6E, 
  0x0A, 0x60, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 0x60, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x0A, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 
  0x6C, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x85, 0x7E, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x13, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x7F, 0xDA, 0x08, 
  0xCE, 0x65, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3C, 0x3D, 0x20, 0x26, 0x20, 0x78, 
  0x73, 0x29, 0x0A, 0x0A, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 
  0x66, 0x20, 0x60, 0x3C, 0x3D, 0x60, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 
  0x20, 0x70, 0x6F, 0x6C, 0x79, 0x6D, 0x6F, 0x72, 0x70, 0x68, 0x69, 0x63, 0x20, 0x60, 0x63, 0x6F, 
  0x6D, 0x70, 0x61, 0x72, 0x65, 0x60, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 
  0x66, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 
  0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0xDA, 0x85, 0x85, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x81, 0x01, 0x80, 0x8D, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x50, 0xDA, 0x08, 0xCE, 0x82, 
  0x98, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 0x0A, 0x0A, 0x4F, 0x70, 0x65, 
  0x6E, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x60, 0x70, 0x61, 0x74, 0x68, 0x60, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 
  0x6F, 0x72, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x65, 0x60, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x69, 
  0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 
  0x64, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x2E, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x65, 0x60, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x77, 0x68, 0x65, 0x72, 
  0x65, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 
  0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x20, 0x66, 0x6C, 
  0x61, 0x67, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x65, 0x64, 
  0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x6F, 
  0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x68, 0x61, 
  0x6E, 0x64, 0x6C, 0x65, 0x2E, 0x20, 0x4D, 0x6F, 0x64, 0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 
  0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x72, 0x20, 0x2D, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x72, 
  0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x6C, 0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x77, 0x20, 0x2D, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 
  0x77, 0x20, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x61, 0x20, 0x2D, 0x20, 0x61, 0x70, 0x70, 
  0x65, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 
  0x0A, 0x46, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x20, 0x66, 0x6C, 
  0x61, 0x67, 0x73, 0x2C, 0x20, 0x30, 0x20, 0x6F, 0x72, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x20, 
  0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x61, 0x70, 0x70, 
  0x65, 0x6E, 0x64, 0x65, 0x64, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x62, 0x20, 0x2D, 0x20, 0x6F, 0x70, 
  0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x62, 
  0x69, 0x6E, 0x61, 0x72, 0x79, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x28, 0x72, 0x61, 0x74, 0x68, 
  0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x6D, 0x6F, 0x64, 
  0x65, 0x29, 0x0A, 0x0A, 0x2A, 0x20, 0x2B, 0x20, 0x2D, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x73, 
  0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x77, 0x72, 0x69, 0x74, 
  0x69, 0x6E, 0x67, 0x20, 0x69, 0x74, 0x0A, 0x0A, 0x2A, 0x20, 0x6E, 0x20, 0x2D, 0x20, 0x65, 0x72, 
  0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x65, 0x64, 
  0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x69, 0x6C, 0xDA, 0x85, 0x86, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 0x86, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x87, 0xDA, 0x08, 
  0xCE, 0x80, 0xB1, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 
  0x63, 0x65, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 0x20, 0x73, 0x74, 
  0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6F, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x63, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x60, 0x70, 0x61, 0x74, 0x74, 0x60, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x60, 0x73, 0x75, 0x62, 0x73, 0x74, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x73, 0x74, 0x72, 0x60, 0x2E, 0x20, 0x57, 0x69, 0x6C, 
  0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x66, 0x20, 0x60, 0x70, 0x61, 0x74, 0x74, 
  0x60, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 
  0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x60, 0x73, 
  0x74, 0x72, 0x60, 0x2E, 0xDA, 0x85, 0x88, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x84, 0xB9, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x1B, 0xDA, 0x08, 0xCE, 0x7E, 
  0x54, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x69, 0x6E, 0x74, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x2E, 0x20, 0x54, 0x68, 
  0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x69, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x69, 0x6E, 0x74, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 
  0x61, 0x74, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x6E, 0x75, 0x65, 0x2E, 0xDA, 0x85, 
  0x89, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xB1, 0x01, 0xDA, 0x06, 0xDA, 
  0x85, 0x8A, 0xDA, 0x08, 0xCE, 0x43, 0x28, 0x77, 0x68, 0x65, 0x6E, 0x2D, 0x6C, 0x65, 0x74, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 
  0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x69, 0x66, 0x2D, 0x6C, 
  0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x28, 0x64, 0x6F, 0x20, 
  0x3B, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x29, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x85, 0x8C, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x6A, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x63, 0xDA, 
  0x08, 0xCE, 0x3A, 0x28, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x28, 0x6E, 0x6F, 0x74, 0x20, 
  0x61, 0x20, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0x2E, 0xDA, 0x85, 0x8D, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 0xA6, 0x01, 0xDA, 0x06, 0xDA, 0x85, 
  0x8E, 0xDA, 0x08, 0xCE, 0x4E, 0x28, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x6E, 0x61, 0x6D, 0x65, 0x20, 
  0x6F, 0x6C, 0x64, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x6E, 0x61, 0x6D, 0x65, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0x6F, 0x6E, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 
  0x69, 0x6C, 0x2E, 0xDA, 0x85, 0x8F, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x47, 0xDA, 0x08, 0xCE, 0x4E, 
  0x28, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x65, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x6F, 0x77, 
  0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x65, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x75, 0x67, 0x68, 0x74, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 
  0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x85, 
  0x90, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0xB7, 0x01, 0xDA, 0x06, 0xDA, 
  0x85, 0x91, 0xDA, 0x08, 0xCE, 0x52, 0x28, 0x69, 0x66, 0x2D, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 
  0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x65, 0x6C, 0x73, 0x65, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x68, 0x61, 
  0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x28, 0x69, 0x66, 0x20, 0x28, 0x6E, 0x6F, 0x74, 
  0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0x20, 0x65, 0x6C, 0x73, 0x65, 
  0x20, 0x74, 0x68, 0x65, 0x6E, 0x29, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x85, 0x93, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x11, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x94, 
  0xDA, 0x08, 0xCE, 0x80, 0xB0, 0x28, 0x78, 0x70, 0x72, 0x69, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x26, 
  0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x61, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x6C, 0x79, 0x20, 
  0x28, 0x6E, 0x6F, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 
  0x69, 0x6E, 0x67, 0x73, 0x29, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 
  0x6E, 0x74, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 
  0x77, 0x69, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 
  0x20, 0x60, 0x70, 0x72, 0x69, 0x6E, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x85, 0x95, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x04, 0x86, 0x3C, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x96, 0xDA, 0x08, 0xCE, 0x54, 0x28, 0x6F, 0x73, 
  0x2F, 0x72, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 
  0x20, 0x6C, 0x69, 0x6E, 0x6B, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x77, 0x6F, 0x72, 0x6B, 0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 
  0x0A, 0xDA, 0x85, 0x97, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x84, 0x3B, 0x01, 
  0xDA, 0x06, 0xDA, 0x85, 0x98, 0xDA, 0x08, 0xCE, 0x62, 0x28, 0x65, 0x76, 0x2F, 0x72, 0x73, 0x65, 
  0x6C, 0x65, 0x63, 0x74, 0x20, 0x26, 0x20, 0x63, 0x6C, 0x61, 0x75, 0x73, 0x65, 0x73, 0x29, 0x0A, 
  0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x76, 0x2F, 0x73, 
  0x65, 0x6C, 0x65, 0x63, 0x74, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x74, 0x72, 0x79, 0x20, 0x63, 0x6C, 0x61, 0x75, 0x73, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 
  0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x66, 0x61, 0x69, 0x72, 0x6E, 0x65, 0x73, 0x73, 0x2E, 0xDA, 0x85, 0x99, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x0B, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x9A, 
  0xDA, 0x08, 0xCE, 0x26, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 0x73, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 
  0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0x9B, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x76, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x9C, 0xDA, 0x08, 
  0xCE, 0x63, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x74, 0x65, 0x6D, 0x70, 0x29, 0x0A, 0x0A, 0x4F, 
  0x70, 0x65, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 0x73, 
  0x20, 0x74, 0x65, 0x6D, 0x70, 0x6F, 0x72, 0x61, 0x72, 0x79, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x64, 0x20, 
  0x6F, 0x6E, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x2E, 0x20, 0x52, 0x61, 0x69, 0x73, 0x65, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x66, 0x61, 0x69, 
  0x6C, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x85, 0x9D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x81, 0x13, 0x80, 0xC4, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x9E, 0xDA, 0x08, 0xCE, 0x80, 0x90, 0x28, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x29, 0x0A, 0x0A, 0x46, 
  0x69, 0x6C, 0x6C, 0x20, 0x75, 0x70, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2C, 0x20, 0x64, 0x65, 0x66, 0x61, 
  0x75, 0x6C, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x30, 0x73, 0x2E, 0x20, 0x44, 0x6F, 
  0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x27, 0x73, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 
  0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 
  0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 
  0x85, 0x9F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x80, 0xA8, 0x01, 0xDA, 
  0x06, 0xDA, 0x85, 0xA0, 0xDA, 0x08, 0xCE, 0x80, 0x85, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x2F, 0x6E, 0x65, 0x77, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x29, 0x0A, 0x0A, 
  0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x2C, 0x20, 0x65, 
  0x6D, 0x70, 0x74, 0x79, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x65, 0x6E, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 
  0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x63, 0x61, 0x70, 0x61, 
  0x63, 0x69, 0x74, 0x79, 0x60, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x20, 0x6F, 0x66, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x30, 0x2E, 0xDA, 0x85, 
  0xA1, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 0x24, 0x01, 0xDA, 0x06, 0xDA, 
  0x82, 0x96, 0xDA, 0x08, 0xCE, 0x80, 0x99, 0x28, 0x64, 0x65, 0x65, 0x70, 0x2D, 0x6E, 0x6F, 0x74, 
  0x3D, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 0x69, 0x6B, 0x65, 0x20, 0x60, 0x6E, 0x6F, 
  0x74, 0x3D, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6D, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2C, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x29, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x0A, 
  0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x68, 0x61, 
  0x76, 0x65, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x4D, 0x75, 0x63, 0x68, 0x20, 0x73, 0x6C, 0x6F, 
  0x77, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x60, 0x6E, 0x6F, 0x74, 0x3D, 0x60, 0x2E, 
  0xCF, 0x0E, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x2D, 0x6D, 0x69, 0x6E, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x9A, 0x01, 0xDA, 0x06, 0xCD, 
  0x80, 0x00, 0x00, 0x00, 0xDA, 0x08, 0xCE, 0x47, 0x54, 0x68, 0x65, 0x20, 0x6D, 0x69, 0x6E, 0x69, 
  0x6D, 0x75, 0x6D, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x20, 0x69, 
  0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x33, 0x32, 0x20, 0x62, 0x69, 0x74, 
  0x20, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0xDA, 
  0x85, 0xA2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x80, 0xF5, 0x01, 0xDA, 
  0x06, 0xDA, 0x85, 0xA3, 0xDA, 0x08, 0xCE, 0x6E, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x65, 
  0x65, 0x64, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x73, 0x65, 0x65, 0x64, 0x29, 0x0A, 0x0A, 
  0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0x20, 0x60, 0x73, 
  0x65, 0x65, 0x64, 0x60, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 
  0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x85, 0xA4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x84, 0x63, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xA5, 0xDA, 0x08, 0xCE, 0x44, 0x28, 0x74, 
  0x61, 0x6B, 0x65, 0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 
  0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x74, 
  0x61, 0x6B, 0x65, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x70, 0x72, 0x65, 0x64, 0x29, 0x20, 0x69, 0x6E, 0x64, 0x29, 
  0x60, 0x2E, 0xDA, 0x85, 0xAB, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x1D, 
  0x01, 0xDA, 0x06, 0xDA, 0x85, 0xAC, 0xDA, 0x08, 0xCE, 0x65, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 
  0x72, 0x65, 0x3E, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x71, 0x75, 0x69, 
  0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x3E, 0x3D, 0x60, 0x20, 0x62, 
  0x75, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x6F, 0x6C, 0x79, 0x6D, 0x6F, 0x72, 
  0x70, 0x68, 0x69, 0x63, 0x20, 0x60, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x60, 0x20, 0x69, 
  0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 
  0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0xDA, 
  0x85, 0xB0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x83, 0x0D, 0x01, 0xDA, 
  0x06, 0xDA, 0x85, 0xB1, 0xDA, 0x08, 0xCE, 0x18, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6E, 
  0x64, 0x61, 0x72, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 
  0xDA, 0x85, 0xB2, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x85, 0x81, 0xDA, 0x08, 0xCE, 0x45, 0x28, 0x3C, 
  0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 
  0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x64, 
  0x65, 0x73, 0x63, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 
  0x61, 0x6E, 0x2E, 0xDA, 0x85, 0xB3, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8C, 
  0x43, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xB4, 0xDA, 0x08, 0xCE, 0x44, 0x28, 0x65, 0x76, 0x2F, 0x61, 
  0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2D, 0x72, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x72, 0x77, 0x6C, 
  0x6F, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x41, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x61, 0x20, 
  0x72, 0x65, 0x61, 0x64, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x20, 0x72, 
  0x65, 0x61, 0x64, 0x2D, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x2E, 0xDA, 
  0x85, 0xB5, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8B, 0x39, 0x01, 0xDA, 0x06, 
  0xDA, 0x85, 0x78, 0xDA, 0x08, 0xCE, 0x80, 0x8B, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 
  0x6F, 0x66, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x74, 0x68, 0x6F, 
  0x64, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x0A, 0x54, 0x68, 
  0x69, 0x73, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6C, 0x65, 0x74, 0x73, 0x20, 0x60, 0x72, 
  0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x69, 0x6D, 0x70, 
  0x6F, 0x72, 0x74, 0x60, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x6D, 0x61, 0x6E, 0x79, 0x20, 0x64, 
  0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6B, 0x69, 0x6E, 0x64, 0x73, 0x0A, 0x6F, 
  0x66, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x73, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 
  0x65, 0x73, 0x2E, 0xDA, 0x85, 0xB6, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8B, 
  0x4E, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xB7, 0xDA, 0x08, 0xCE, 0x82, 0xFA, 0x28, 0x65, 0x76, 0x2F, 
  0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x6D, 0x61, 0x69, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x73, 0x75, 0x70, 
  0x65, 0x72, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x60, 0x6D, 
  0x61, 0x69, 0x6E, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x6F, 0x70, 
  0x65, 0x72, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 
  0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x60, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x20, 
  0x60, 0x6D, 0x61, 0x69, 0x6E, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 
  0x72, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2C, 0x20, 0x6F, 0x72, 
  0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x73, 0x20, 0x30, 0x20, 0x6F, 0x72, 0x20, 0x31, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x20, 0x55, 0x6E, 0x6C, 0x69, 0x6B, 
  0x65, 0x20, 0x60, 0x65, 0x76, 0x2F, 0x67, 0x6F, 0x60, 0x2C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x75, 
  0x73, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 
  0x6C, 0x65, 0x74, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x79, 0x6F, 0x75, 0x20, 0x77, 0x61, 0x6E, 
  0x74, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x68, 0x72, 
  0x65, 0x61, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x77, 0x61, 0x69, 0x74, 
  0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 
  0x2C, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x3A, 0x6E, 0x60, 0x20, 
  0x66, 0x6C, 0x61, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 
  0x69, 0x6C, 0x20, 0x69, 0x6D, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x6C, 0x79, 0x2E, 0x20, 
  0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x41, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x6E, 0x60, 
  0x20, 0x2D, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x69, 0x6D, 0x6D, 0x65, 0x64, 0x69, 
  0x61, 0x74, 0x65, 0x6C, 0x79, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x74, 0x60, 0x20, 0x2D, 0x20, 0x73, 
  0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6B, 0x2D, 0x69, 0x64, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 
  0x20, 0x74, 0x6F, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 
  0x61, 0x73, 0x6B, 0x2D, 0x69, 0x64, 0x20, 0x69, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 
  0x20, 0x69, 0x6E, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x70, 0x65, 0x72, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x20, 0x63, 
  0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x2E, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x61, 0x60, 0x20, 0x2D, 
  0x20, 0x64, 0x6F, 0x6E, 0x27, 0x74, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x20, 0x61, 0x62, 0x73, 0x74, 
  0x72, 0x61, 0x63, 0x74, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x20, 0x74, 0x6F, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x28, 0x70, 0x65, 0x72, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6D, 0x69, 0x7A, 
  0x61, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x63, 0x60, 0x20, 0x2D, 0x20, 
  0x64, 0x6F, 0x6E, 0x27, 0x74, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x20, 0x63, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x20, 0x74, 0x6F, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x28, 0x70, 0x65, 0x72, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6D, 0x69, 0x7A, 
  0x61, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0xDA, 0x85, 0xB8, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x82, 0x2B, 0x82, 0x76, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x11, 0xDA, 0x08, 0xCE, 0x4E, 0x28, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 0x61, 0x6E, 0x2D, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 
  0x3F, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 
  0x69, 0x66, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x66, 0x69, 
  0x6E, 0x69, 0x73, 0x68, 0x65, 0x64, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 
  0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x64, 0x2E, 0xDA, 0x85, 0xB9, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x89, 0x3B, 0x01, 0xDA, 0x06, 0xDA, 0x83, 
  0xDF, 0xDA, 0x08, 0xCE, 0x85, 0x6A, 0x28, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 
  0x78, 0x74, 0x20, 0x6F, 0x70, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 0x20, 
  0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x65, 0x76, 
  0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 
  0x6F, 0x6E, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 
  0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x0A, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 0x63, 0x61, 0x70, 
  0x73, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x69, 0x6E, 0x67, 0x2C, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x69, 0x6F, 0x6E, 
  0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x60, 0x28, 0x69, 0x6E, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x3A, 0x65, 0x78, 0x69, 0x74, 
  0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x29, 0x60, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 
  0x74, 0x65, 0x2E, 0x0A, 0x60, 0x6F, 0x70, 0x74, 0x73, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 
  0x6F, 0x66, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x73, 0x20, 0x66, 
  0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 0x3A, 0x63, 
  0x68, 0x75, 0x6E, 0x6B, 0x73, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 
  0x63, 0x6B, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 
  0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 
  0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x67, 0x65, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x0A, 0x0A, 0x20, 
  0x20, 0x2A, 0x20, 0x60, 0x3A, 0x6F, 0x6E, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 0x65, 0x72, 
  0x72, 0x6F, 0x72, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 
  0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x61, 
  0x69, 0x6C, 0x73, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x62, 0x61, 0x64, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 
  0x60, 0x3A, 0x65, 0x6E, 0x76, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 
  0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x69, 0x6C, 0x65, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6E, 0x73, 0x74, 0x20, 0x2D, 0x20, 0x64, 
  0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 
  0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x62, 0x65, 0x74, 0x74, 
  0x65, 0x72, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x28, 0x75, 0x73, 0x65, 0x20, 0x6B, 
  0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 
  0x70, 0x61, 0x74, 0x68, 0x73, 0x29, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 
  0x0A, 0x20, 0x20, 0x20, 0x20, 0x69, 0x73, 0x20, 0x3A, 0x3C, 0x61, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 
  0x6F, 0x75, 0x73, 0x3E, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 0x3A, 0x6F, 0x6E, 0x2D, 0x63, 
  0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x2D, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x60, 0x20, 0x2D, 0x2D, 
  0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 
  0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x73, 
  0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x62, 0x61, 
  0x64, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 
  0x3A, 0x6F, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x2D, 0x77, 0x61, 0x72, 0x6E, 
  0x69, 0x6E, 0x67, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6C, 0x69, 0x6E, 0x74, 0x69, 0x6E, 0x67, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x77, 0x61, 0x72, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 
  0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 0x3A, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 
  0x72, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x75, 
  0x6E, 0x6B, 0x73, 0x2E, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 
  0x73, 0x20, 0x28, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x75, 
  0x6E, 0x6B, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6E, 
  0x76, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 0x3A, 
  0x6F, 0x6E, 0x2D, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x63, 0x61, 
  0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x64, 
  0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 
  0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x74, 0x72, 0x61, 0x63, 0x65, 0x2E, 0x0A, 
  0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 0x3A, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2D, 0x66, 0x6C, 0x61, 
  0x67, 0x73, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x77, 0x68, 0x61, 0x74, 0x20, 0x66, 0x6C, 0x61, 0x67, 
  0x73, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x61, 0x70, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 
  0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x2E, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x3A, 0x69, 0x61, 0x2E, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 0x3A, 0x65, 0x78, 0x70, 
  0x61, 0x6E, 0x64, 0x65, 0x72, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 
  0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x6F, 0x6E, 
  0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x74, 0x6F, 0x70, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x0A, 0x20, 0x20, 0x20, 0x20, 
  0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x0A, 
  0x0A, 0x20, 0x20, 0x2A, 0x20, 0x60, 0x3A, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x60, 0x20, 0x2D, 
  0x2D, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x20, 0x61, 0x20, 0x63, 0x75, 0x73, 0x74, 
  0x6F, 0x6D, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 
  0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 
  0x6D, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x20, 0x61, 0x73, 0x20, 
  0x4A, 0x61, 0x6E, 0x65, 0x74, 0x27, 0x73, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x62, 0x75, 0x69, 0x6C, 
  0x74, 0x2D, 0x69, 0x6E, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 0x0A, 0x0A, 0x20, 0x20, 
  0x2A, 0x20, 0x60, 0x3A, 0x72, 0x65, 0x61, 0x64, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x6F, 0x70, 0x74, 
  0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 
  0x6F, 0x20, 0x67, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x2C, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x6C, 0x69, 0x6B, 0x65, 
  0x20, 0x60, 0x28, 0x72, 0x65, 0x61, 0x64, 0x20, 0x65, 0x6E, 0x76, 0x20, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x29, 0x60, 0x2E, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x4F, 0x76, 0x65, 0x72, 0x72, 0x69, 
  0x64, 0x65, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x2E, 
  0xDA, 0x85, 0xBA, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8E, 0x4F, 0x03, 0xDA, 
  0x06, 0xDA, 0x85, 0xBB, 0xDA, 0x08, 0xCE, 0x62, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x64, 0x65, 0x66, 
  0x62, 0x69, 0x6E, 0x64, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x72, 0x65, 0x74, 0x2D, 0x74, 0x79, 
  0x70, 0x65, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x6E, 0x65, 
  0x72, 0x61, 0x74, 0x65, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x6E, 0x69, 0x65, 
  0x6E, 0x74, 0x20, 0x6D, 0x61, 0x6E, 0x6E, 0x65, 0x72, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x85, 0xCA, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 0x82, 0x19, 0x01, 0xDA, 0x06, 0xDA, 0x85, 
  0xCB, 0xDA, 0x08, 0xCE, 0x81, 0xCF, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x73, 0x68, 0x75, 0x74, 0x64, 
  0x6F, 0x77, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x6D, 0x6F, 0x64, 0x65, 0x29, 0x0A, 0x0A, 0x53, 0x74, 0x6F, 0x70, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 
  0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x69, 
  0x73, 0x20, 0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x67, 0x72, 
  0x61, 0x63, 0x65, 0x66, 0x75, 0x6C, 0x20, 0x6D, 0x61, 0x6E, 0x6E, 0x65, 0x72, 0x2C, 0x20, 0x65, 
  0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x6F, 0x74, 0x68, 0x20, 0x64, 0x69, 
  0x72, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x6A, 0x75, 0x73, 0x74, 
  0x20, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6E, 0x67, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 
  0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x65, 0x60, 0x20, 0x70, 0x61, 0x72, 
  0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x73, 0x20, 
  0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x74, 0x6F, 0x70, 0x20, 0x6F, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x2E, 0x20, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 
  0x3A, 0x77, 0x72, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 
  0x75, 0x6C, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x72, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x73, 
  0x20, 0x62, 0x6F, 0x74, 0x68, 0x20, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 
  0x77, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x77, 0x72, 0x69, 0x74, 0x69, 
  0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x2E, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x72, 
  0x60, 0x20, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x2E, 0x0A, 0x2A, 0x20, 0x60, 
  0x3A, 0x77, 0x60, 0x20, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 
  0x69, 0x6E, 0x67, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x2E, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x6F, 
  0x63, 0x6B, 0x65, 0x74, 0x2E, 0xDA, 0x85, 0xCC, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x80, 0xB3, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xCD, 0xDA, 0x08, 0xCE, 0x2D, 0x28, 0x63, 0x6F, 
  0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x26, 0x29, 0x0A, 0x0A, 0x49, 0x67, 0x6E, 0x6F, 0x72, 0x65, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x2B, 0xCB, 0xCF, 0x11, 0x6A, 
  0x61, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x2D, 0x62, 0x69, 0x74, 0x73, 
  0xD3, 0x02, 0xDA, 0x06, 0x01, 0xDA, 0x08, 0xCE, 0x7E, 0x54, 0x68, 0x65, 0x20, 0x66, 0x6C, 0x61, 
  0x67, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x20, 
  0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0x63, 0x6F, 0x6E, 0x66, 0x2E, 0x68, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 
  0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x20, 
  0x69, 0x66, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x74, 0x69, 0x62, 0x6C, 0x65, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x70, 
  0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 0x85, 0xCF, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x82, 0x68, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xD0, 0xDA, 0x08, 0xCE, 0x7D, 0x28, 
  0x74, 0x61, 0x62, 0x73, 0x65, 0x71, 0x20, 0x68, 0x65, 0x61, 0x64, 0x20, 0x6B, 0x65, 0x79, 0x2D, 
  0x62, 0x6F, 0x64, 0x79, 0x20, 0x26, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2D, 0x62, 0x6F, 0x64, 
  0x79, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x60, 
  0x6C, 0x6F, 0x6F, 0x70, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x61, 0x63, 0x63, 0x75, 0x6D, 
  0x75, 0x6C, 0x61, 0x74, 0x65, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x2E, 0x0A, 0x53, 0x65, 0x65, 0x20, 0x60, 0x6C, 0x6F, 0x6F, 0x70, 0x60, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 
  0x85, 0xD4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0x67, 0x80, 0xF5, 0x01, 0xDA, 
  0x06, 0xDA, 0x83, 0x65, 0xDA, 0x08, 0xCE, 0x80, 0xD3, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 
  0x66, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x20, 0x66, 0x75, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x70, 0x63, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 
  0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x70, 0x63, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x6F, 0x66, 0x66, 
  0x73, 0x65, 0x74, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x66, 0x75, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x61, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 
  0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x66, 0x66, 0x73, 
  0x65, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x6F, 0x6F, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65, 0x20, 
  0x6F, 0x72, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2E, 0xDA, 0x85, 0xD5, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 0x51, 0x01, 0xDA, 0x06, 0xDA, 0x85, 
  0x62, 0xDA, 0x08, 0xCE, 0x42, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 
  0x2D, 0x73, 0x75, 0x66, 0x66, 0x69, 0x78, 0x3F, 0x20, 0x73, 0x66, 0x78, 0x20, 0x73, 0x74, 0x72, 
  0x29, 0x0A, 0x0A, 0x54, 0x65, 0x73, 0x74, 0x73, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 
  0x20, 0x60, 0x73, 0x74, 0x72, 0x60, 0x20, 0x65, 0x6E, 0x64, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x60, 0x73, 0x66, 0x78, 0x60, 0x2E, 0xDA, 0x85, 0xD6, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x85, 0x59, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xD7, 0xDA, 0x08, 0xCE, 0x80, 0x90, 
  0x28, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x76, 0x61, 0x72, 0x73, 0x20, 0x76, 0x61, 0x72, 0x73, 0x20, 
  0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 
  0x65, 0x73, 0x20, 0x60, 0x62, 0x6F, 0x64, 0x79, 0x60, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x65, 
  0x61, 0x63, 0x68, 0x20, 0x76, 0x61, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x76, 0x61, 0x72, 0x73, 
  0x60, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6F, 0x72, 0x61, 0x72, 0x69, 0x6C, 0x79, 0x20, 0x62, 0x6F, 
  0x75, 0x6E, 0x64, 0x2E, 0x20, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x73, 0x69, 0x67, 
  0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 0x74, 0x6F, 0x0A, 0x60, 0x6C, 0x65, 0x74, 0x60, 0x2C, 
  0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x76, 0x61, 0x72, 0x2E, 
  0xDA, 0x2B, 0xCB, 0xDA, 0x85, 0xDC, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 
  0x6B, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xDD, 0xDA, 0x08, 0xCE, 0x80, 0xCE, 0x28, 0x74, 0x61, 0x6B, 
  0x65, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 
  0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 
  0x63, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2C, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x2C, 0x20, 
  0x6F, 0x72, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x73, 0x61, 0x74, 0x69, 0x73, 0x66, 0x79, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x62, 
  0x6F, 0x72, 0x74, 0x20, 0x6F, 0x6E, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x61, 0x69, 
  0x6C, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x2C, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x72, 0x65, 0x73, 
  0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x2E, 0xDA, 0x85, 0xDF, 0xD3, 0x04, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0xC5, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xE0, 0xDA, 0x08, 
  0xCE, 0x85, 0x18, 0x28, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x78, 0x20, 0x26, 0x20, 0x63, 0x61, 
  0x73, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x6D, 0x61, 
  0x74, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x4D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 0x6E, 
  0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x60, 0x78, 0x60, 0x20, 
  0x61, 0x67, 0x61, 0x69, 0x6E, 0x73, 0x74, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x63, 0x61, 0x73, 0x65, 0x73, 0x2E, 0x0A, 0x45, 0x61, 0x63, 
  0x68, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x74, 
  0x65, 0x72, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 0x67, 0x61, 
  0x69, 0x6E, 0x73, 0x74, 0x2C, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x20, 0x62, 
  0x79, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 
  0x74, 0x6F, 0x0A, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x69, 
  0x66, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6D, 
  0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x2E, 0x20, 0x20, 0x4C, 0x65, 0x67, 0x61, 0x6C, 0x20, 0x70, 
  0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 
  0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x2D, 0x2D, 0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x74, 
  0x65, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 
  0x61, 0x6E, 0x79, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x20, 0x60, 0x78, 0x60, 0x27, 0x73, 0x0A, 0x20, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0x0A, 
  0x0A, 0x2A, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x62, 0x72, 0x61, 0x63, 
  0x6B, 0x65, 0x74, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x2D, 0x2D, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 0x63, 
  0x68, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x69, 0x66, 0x0A, 0x20, 0x20, 0x61, 0x6C, 0x6C, 0x20, 
  0x6F, 0x66, 0x20, 0x69, 0x74, 0x73, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 
  0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x72, 0x72, 0x65, 0x73, 
  0x70, 0x6F, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x60, 0x78, 0x60, 0x2E, 0x0A, 0x20, 0x20, 0x55, 0x73, 0x65, 0x20, 0x60, 
  0x26, 0x20, 0x72, 0x65, 0x73, 0x74, 0x60, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 
  0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 
  0x72, 0x20, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x65, 0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 
  0x65, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x72, 0x65, 
  0x6D, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 
  0x6F, 0x20, 0x60, 0x72, 0x65, 0x73, 0x74, 0x60, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x2D, 0x2D, 0x20, 
  0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x69, 0x66, 0x20, 
  0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x0A, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x72, 0x72, 
  0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x60, 0x78, 0x60, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x74, 0x75, 0x70, 0x6C, 
  0x65, 0x20, 0x2D, 0x2D, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x74, 
  0x74, 0x65, 0x72, 0x6E, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 
  0x69, 0x66, 0x20, 0x69, 0x74, 0x73, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x2C, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x74, 0x68, 0x65, 0x0A, 0x20, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 
  0x67, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 
  0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x72, 0x75, 
  0x65, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x5F, 0x60, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 
  0x20, 0x2D, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x73, 0x70, 0x65, 
  0x63, 0x69, 0x61, 0x6C, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x60, 0x5F, 0x60, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2C, 0x20, 0x77, 0x68, 0x69, 
  0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x77, 0x69, 0x6C, 0x64, 0x63, 0x61, 0x72, 0x64, 
  0x0A, 0x20, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 
  0x63, 0x68, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x6F, 0x75, 0x74, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x0A, 0x0A, 0x57, 0x68, 0x69, 0x6C, 0x65, 0x20, 
  0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6F, 0x72, 0x64, 0x69, 0x6E, 0x61, 0x72, 0x69, 0x6C, 0x79, 
  0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x60, 0x28, 
  0x40, 0x20, 0x3C, 0x73, 0x79, 0x6D, 0x3E, 0x29, 0x60, 0x2C, 0x0A, 0x77, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x3C, 0x73, 0x79, 0x6D, 0x3E, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6D, 
  0x70, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x60, 0x78, 0x60, 0x20, 
  0x61, 0x67, 0x61, 0x69, 0x6E, 0x73, 0x74, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x0A, 
  0x61, 0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x60, 0x3C, 0x73, 0x79, 0x6D, 0x3E, 0x60, 0x2C, 0x20, 0x72, 0x61, 0x74, 0x68, 0x65, 0x72, 
  0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x72, 0x65, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x74, 0x2E, 
  0x0A, 0x0A, 0x41, 0x6E, 0x79, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6F, 
  0x6E, 0x6C, 0x79, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x78, 0x60, 0x2E, 
  0x0A, 0x51, 0x75, 0x6F, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 
  0x72, 0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x27, 0x60, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x74, 0x72, 0x65, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x6C, 0x69, 0x74, 0x65, 0x72, 
  0x61, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 
  0x68, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6E, 0x73, 0x74, 0x2E, 0x0A, 0xDA, 0x2B, 0xCB, 0xDA, 0x85, 
  0xFF, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 0x48, 0x01, 0xDA, 0x06, 0xDA, 
  0x84, 0xDB, 0xDA, 0x08, 0xCE, 0x81, 0x61, 0x28, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x20, 0x78, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x29, 
  0x0A, 0x0A, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x6C, 0x79, 0x2E, 0x0A, 0x60, 0x6F, 0x6E, 0x2D, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 
  0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x65, 0x76, 0x65, 0x72, 0x20, 0x61, 0x20, 
  0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x0A, 0x69, 0x73, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x75, 
  0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x61, 0x6C, 0x6C, 
  0x6F, 0x77, 0x73, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x61, 
  0x73, 0x69, 0x6C, 0x79, 0x20, 0x73, 0x65, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x69, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 
  0x65, 0x69, 0x72, 0x0A, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x62, 0x79, 
  0x20, 0x63, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x60, 
  0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 
  0x74, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 
  0x69, 0x74, 0x73, 0x65, 0x6C, 0x66, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x0A, 0x72, 
  0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 
  0x20, 0x60, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x60, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 
  0x64, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0xDA, 0x86, 0x00, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x88, 0xD5, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x30, 0xDA, 0x08, 0xCE, 0x80, 
  0xB8, 0x28, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x65, 0x6E, 0x76, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 
  0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x0A, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x69, 0x6E, 0x68, 0x65, 0x72, 0x69, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x65, 
  0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 
  0x62, 0x75, 0x74, 0x20, 0x6E, 0x65, 0x77, 0x0A, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x6F, 0x6C, 0x6C, 0x75, 0x74, 
  0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x86, 0x01, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8B, 0xF1, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x02, 0xDA, 0x08, 0xCE, 
  0x80, 0xEC, 0x28, 0x65, 0x76, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 
  0x61, 0x6D, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x69, 0x6D, 
  0x65, 0x6F, 0x75, 0x74, 0x29, 0x0A, 0x0A, 0x57, 0x72, 0x69, 0x74, 0x65, 0x20, 0x64, 0x61, 0x74, 
  0x61, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2C, 0x20, 0x73, 
  0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x75, 0x6E, 0x74, 0x69, 
  0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 
  0x6C, 0x65, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x20, 
  0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 
  0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x2C, 0x20, 0x61, 0x66, 0x74, 
  0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0xDA, 0x86, 
  0x03, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x85, 0xAE, 0xDA, 0x08, 0xCE, 0x44, 0x28, 0x3E, 0x3D, 0x20, 
  0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 
  0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x61, 0x73, 0x63, 
  0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 
  0xDA, 0x86, 0x04, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8C, 0xE5, 0x01, 0xDA, 
  0x06, 0xDA, 0x86, 0x05, 0xDA, 0x08, 0xCE, 0x63, 0x28, 0x64, 0x6F, 0x63, 0x2A, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x69, 0x6E, 0x20, 0x61, 
  0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x2E, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 
  0x6D, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x64, 0x6F, 0x63, 0x60, 0x2E, 0xDA, 0x86, 0x2B, 0xD3, 0x02, 
  0xDA, 0x06, 0xDA, 0x86, 0x2C, 0xDA, 0x08, 0xCE, 0x59, 0x28, 0x62, 0x6F, 0x72, 0x20, 0x26, 0x20, 
  0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x69, 0x74, 0x2D, 0x77, 0x69, 0x73, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x66, 0x20, 
  0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 
  0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x78, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x20, 0x6D, 
  0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 
  0x72, 0x2E, 0xDA, 0x86, 0x2E, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xC5, 
  0x01, 0xDA, 0x06, 0xDA, 0x86, 0x2F, 0xDA, 0x08, 0xCE, 0x6B, 0x28, 0x74, 0x72, 0x61, 0x63, 0x65, 
  0x76, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x73, 
  0x74, 0x64, 0x65, 0x72, 0x72, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x61, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0x64, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x2E, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x78, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x86, 0x37, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x80, 0xA4, 0x80, 0xBB, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x38, 0xDA, 0x08, 0xCE, 
  0x80, 0xB8, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x72, 0x6E, 0x67, 0x20, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 
  0x66, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x6E, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x75, 0x74, 0x20, 0x74, 
  0x68, 0x65, 0x6D, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0x20, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 
  0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 
  0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x86, 0x39, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0xB1, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x57, 0xDA, 
  0x08, 0xCE, 0x80, 0xD1, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x26, 0x20, 0x6B, 0x76, 0x73, 
  0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x76, 0x61, 
  0x72, 0x69, 0x61, 0x64, 0x69, 0x63, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 
  0x2E, 0x20, 0x6B, 0x76, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 
  0x6E, 0x63, 0x65, 0x20, 0x6B, 0x31, 0x2C, 0x20, 0x76, 0x31, 0x2C, 0x20, 0x6B, 0x32, 0x2C, 0x20, 
  0x76, 0x32, 0x2C, 0x20, 0x6B, 0x33, 0x2C, 0x20, 0x76, 0x33, 0x2C, 0x20, 0x2E, 0x2E, 0x2E, 0x20, 
  0x49, 0x66, 0x20, 0x6B, 0x76, 0x73, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x64, 
  0x64, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x6E, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x86, 0x3A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x64, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x3B, 0xDA, 0x08, 0xCE, 0x24, 0x28, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 
  0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2E, 
  0xDA, 0x86, 0x3E, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xE2, 0x01, 0xDA, 
  0x06, 0xDA, 0x86, 0x3F, 0xDA, 0x08, 0xCE, 0x80, 0xDC, 0x28, 0x2D, 0x3E, 0x3E, 0x20, 0x78, 0x20, 
  0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 
  0x69, 0x6E, 0x67, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x49, 0x6E, 0x73, 0x65, 0x72, 
  0x74, 0x73, 0x20, 0x78, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x0A, 0x69, 0x6E, 0x20, 0x60, 0x66, 0x6F, 0x72, 
  0x6D, 0x73, 0x60, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x0A, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x6D, 0x61, 0x6E, 0x6E, 0x65, 0x72, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x6F, 0x20, 0x6F, 0x6E, 0x2E, 0x20, 0x55, 0x73, 0x65, 
  0x66, 0x75, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 
  0x6E, 0x67, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x86, 0x41, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x82, 0x05, 0x84, 0xF2, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x42, 0xDA, 0x08, 0xCE, 
  0x80, 0xD1, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x20, 
  0x70, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x64, 0x65, 
  0x65, 0x70, 0x20, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x64, 0x65, 
  0x6E, 0x74, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 
  0x70, 0x75, 0x74, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 
  0x20, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x63, 
  0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 
  0x6E, 0x74, 0x69, 0x6E, 0x75, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x67, 0x6F, 0x6F, 0x64, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 
  0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x69, 0x66, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 
  0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x73, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x2E, 0xDA, 0x86, 0x43, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8B, 
  0xB5, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x44, 0xDA, 0x08, 0xCE, 0x80, 0x89, 0x28, 0x65, 0x76, 0x2F, 
  0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x65, 0x72, 0x72, 
  0x29, 0x0A, 0x0A, 0x43, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x20, 0x61, 0x20, 0x73, 0x75, 0x73, 0x70, 
  0x65, 0x6E, 0x64, 0x65, 0x64, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2E, 0x20, 0x44, 
  0x69, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x63, 
  0x65, 0x6C, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x74, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 
  0x65, 0x64, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x6D, 0x6D, 0x65, 0x64, 0x69, 0x61, 
  0x74, 0x65, 0x6C, 0x79, 0x2E, 0xCF, 0x0C, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x69, 0x6E, 0x74, 0x2D, 
  0x6D, 0x69, 0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x9E, 0x01, 
  0xDA, 0x06, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xC3, 0xDA, 0x08, 0xCE, 0x3F, 0x54, 
  0x68, 0x65, 0x20, 0x6D, 0x69, 0x6E, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x69, 
  0x67, 0x75, 0x6F, 0x75, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x72, 0x65, 
  0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x62, 0x79, 0x20, 0x61, 
  0x20, 0x64, 0x6F, 0x75, 0x62, 0x6C, 0x65, 0x20, 0x28, 0x32, 0x5E, 0x35, 0x33, 0x29, 0xDA, 0x86, 
  0x45, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0x2D, 0x01, 0xDA, 0x06, 0xDA, 
  0x86, 0x16, 0xDA, 0x08, 0xCE, 0x80, 0xBB, 0x28, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x2D, 0x6F, 0x66, 
  0x20, 0x78, 0x20, 0x69, 0x6E, 0x64, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 0x6C, 0x74, 
  0x29, 0x0A, 0x0A, 0x46, 0x69, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 
  0x74, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x65, 0x64, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x78, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x75, 0x72, 0x65, 0x2C, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x6C, 0x69, 0x6B, 0x65, 
  0x20, 0x61, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 
  0x70, 0x2E, 0x0A, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 
  0x20, 0x61, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 
  0x79, 0x70, 0x65, 0x73, 0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x60, 0x64, 
  0x66, 0x6C, 0x74, 0x60, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 
  0x64, 0x2E, 0xDA, 0x86, 0x46, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0x41, 
  0x01, 0xDA, 0x06, 0xDA, 0x86, 0x47, 0xDA, 0x08, 0xCE, 0x80, 0xE0, 0x28, 0x61, 0x73, 0x3F, 0x2D, 
  0x3E, 0x20, 0x78, 0x20, 0x61, 0x73, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 
  0x0A, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x20, 0x74, 0x6F, 
  0x67, 0x65, 0x74, 0x68, 0x65, 0x72, 0x2C, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x69, 0x6E, 
  0x67, 0x20, 0x60, 0x61, 0x73, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x66, 0x6F, 0x72, 0x6D, 0x73, 
  0x60, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x0A, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6F, 0x75, 0x73, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x78, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x79, 0x0A, 0x69, 0x6E, 0x74, 
  0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x3B, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 
  0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x0A, 
  0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x86, 
  0x4C, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x31, 0x01, 0xDA, 0x06, 0xDA, 
  0x86, 0x4D, 0xDA, 0x08, 0xCE, 0x77, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x66, 0x20, 0x63, 0x6E, 
  0x64, 0x20, 0x74, 0x72, 0x75, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x64, 
  0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x60, 0x63, 0x6E, 0x64, 0x60, 0x20, 0x61, 0x74, 0x20, 0x63, 
  0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x2D, 0x2D, 0x20, 0x69, 
  0x66, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 
  0x65, 0x20, 0x60, 0x74, 0x72, 0x75, 0x60, 0x2C, 0x20, 0x65, 0x6C, 0x73, 0x65, 0x20, 0x63, 0x6F, 
  0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x60, 0x66, 0x61, 0x6C, 0x73, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 
  0xDA, 0x86, 0x4F, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x38, 0x01, 0xDA, 
  0x06, 0xDA, 0x86, 0x50, 0xDA, 0x08, 0xCE, 0x7B, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x77, 0x68, 0x65, 
  0x6E, 0x20, 0x63, 0x6E, 0x64, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x60, 0x63, 0x6E, 0x64, 0x60, 0x20, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 
  0x69, 0x6C, 0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x2D, 0x2D, 0x20, 0x69, 0x66, 0x20, 0x74, 
  0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x60, 
  0x28, 0x75, 0x70, 0x73, 0x63, 0x6F, 0x70, 0x65, 0x20, 0x3B, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x60, 
  0x2C, 0x20, 0x65, 0x6C, 0x73, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x6E, 
  0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x86, 0x52, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x80, 0xE8, 0x80, 0xC3, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x53, 0xDA, 0x08, 0xCE, 0x52, 0x28, 
  0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x62, 0x79, 
  0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x65, 
  0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 
  0x2E, 0xDA, 0x86, 0x54, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x81, 0x22, 
  0x01, 0xDA, 0x06, 0xDA, 0x83, 0x54, 0xDA, 0x08, 0xCE, 0x80, 0xAC, 0x28, 0x66, 0x69, 0x6C, 0x65, 
  0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x66, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x6F, 0x73, 0x65, 
  0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x6C, 0x65, 
  0x61, 0x73, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x20, 
  0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2E, 0x20, 0x57, 0x68, 0x65, 0x6E, 0x20, 
  0x79, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x64, 0x6F, 0x6E, 0x65, 0x20, 0x72, 0x65, 0x61, 
  0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0x20, 0x69, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x76, 0x65, 0x6E, 0x74, 
  0x20, 0x61, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x61, 0x6B, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x6C, 0x65, 0x74, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x70, 
  0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x86, 0x55, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x04, 0x85, 0xEF, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x56, 0xDA, 0x08, 0xCE, 0x80, 0xF7, 
  0x28, 0x6F, 0x73, 0x2F, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 
  0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x64, 0x69, 
  0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x69, 0x66, 0x20, 0x72, 
  0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 
  0x73, 0x65, 0x20, 0x69, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 
  0x20, 0x61, 0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x77, 0x61, 
  0x73, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x2C, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 
  0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 
  0x79, 0x20, 0x61, 0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x6F, 0x74, 0x68, 
  0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2E, 0xDA, 0x86, 0x57, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x84, 0xEF, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x58, 0xDA, 0x08, 0xCE, 0x81, 0x2A, 
  0x28, 0x2D, 0x3F, 0x3E, 0x20, 0x78, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 
  0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x20, 0x63, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x20, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 
  0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x78, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x0A, 
  0x69, 0x6E, 0x20, 0x60, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x60, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 
  0x66, 0x69, 0x65, 0x64, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 
  0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x0A, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 
  0x20, 0x6D, 0x61, 0x6E, 0x6E, 0x65, 0x72, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x6F, 0x20, 
  0x6F, 0x6E, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 
  0x0A, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 
  0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x69, 0x6C, 
  0x2E, 0x0A, 0x55, 0x73, 0x65, 0x66, 0x75, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 
  0x72, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 
  0x73, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x61, 0x74, 0x61, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x86, 0x5A, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0xAE, 0x01, 0xDA, 0x06, 0xDA, 0x85, 
  0x73, 0xDA, 0x08, 0xCE, 0x5A, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x6D, 0x61, 
  0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 
  0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x70, 0x72, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x0A, 0x63, 0x69, 0x72, 0x63, 0x75, 0x6C, 0x61, 
  0x72, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x6E, 0x63, 0x69, 0x65, 0x73, 0x2E, 0xDA, 
  0x86, 0x5B, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x37, 0x01, 0xDA, 0x06, 
  0xDA, 0x86, 0x5C, 0xDA, 0x08, 0xCE, 0x69, 0x28, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x73, 0x79, 0x6D, 
  0x73, 0x20, 0x73, 0x79, 0x6D, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 
  0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x60, 0x62, 0x6F, 0x64, 0x79, 0x60, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x73, 0x79, 0x6D, 0x73, 0x60, 0x20, 0x62, 0x6F, 0x75, 0x6E, 
  0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 
  0x2C, 0x20, 0x75, 0x6E, 0x69, 0x71, 0x75, 0x65, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 
  0xDA, 0x2B, 0xCB, 0xDA, 0x86, 0x5F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 
  0xCE, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x49, 0xDA, 0x08, 0xCE, 0x80, 0xC5, 0x28, 0x65, 0x78, 0x74, 
  0x72, 0x65, 0x6D, 0x65, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 
  0x73, 0x74, 0x20, 0x65, 0x78, 0x74, 0x72, 0x65, 0x6D, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x69, 0x6E, 0x20, 0x60, 0x61, 0x72, 0x67, 0x73, 0x60, 0x20, 0x62, 0x61, 0x73, 0x65, 0x64, 
  0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x60, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x60, 0x2E, 0x0A, 0x60, 0x6F, 0x72, 0x64, 0x65, 0x72, 
  0x60, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x74, 0x77, 
  0x6F, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x66, 0x61, 0x6C, 0x73, 
  0x65, 0x20, 0x28, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x69, 0x73, 0x6F, 0x6E, 0x29, 
  0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 
  0x20, 0x60, 0x61, 0x72, 0x67, 0x73, 0x60, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 
  0x2E, 0xDA, 0x86, 0x60, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x2C, 0x01, 
  0xDA, 0x06, 0xDA, 0x86, 0x61, 0xDA, 0x08, 0xCE, 0x5D, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x74, 0x69, 
  0x6D, 0x65, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x73, 0x20, 0x78, 0x20, 0x61, 
  0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 
  0x65, 0x73, 0x75, 0x6C, 0x74, 0x2E, 0x20, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x20, 0x74, 0x6F, 0x70, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x75, 0x6E, 
  0x71, 0x75, 0x6F, 0x74, 0x65, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x86, 0x63, 0xD3, 0x02, 0xDA, 0x06, 
  0xDA, 0x85, 0xF7, 0xDA, 0x08, 0xCE, 0x80, 0xB1, 0x28, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 
  0x64, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x72, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 
  0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x67, 0x65, 0x72, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 
  0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 
  0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 
  0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x86, 0x64, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x82, 0x2C, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x65, 0xDA, 0x08, 
  0xCE, 0x80, 0xBF, 0x28, 0x68, 0x61, 0x73, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x61, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x68, 0x61, 0x73, 0x68, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 
  0x73, 0x20, 0x61, 0x20, 0x63, 0x68, 0x65, 0x61, 0x70, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 0x6C, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 
  0x6C, 0x79, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x79, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x2E, 0xDA, 0x86, 0x66, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 
  0x0C, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x67, 0xDA, 0x08, 0xCE, 0x32, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x63, 0x6F, 0x73, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 0x63, 
  0x20, 0x63, 0x6F, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x86, 0x68, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x84, 0x0D, 0x01, 0xDA, 0x06, 0xDA, 
  0x82, 0xDD, 0xDA, 0x08, 0xCE, 0x80, 0xFF, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x49, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x69, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 
  0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 
  0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x65, 
  0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x41, 0x6C, 0x73, 0x6F, 0x20, 
  0x66, 0x6C, 0x75, 0x73, 0x68, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x62, 0x65, 
  0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x20, 
  0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x63, 
  0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x60, 0x2E, 0xDA, 0x86, 0x69, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x84, 0x67, 0x81, 0x8C, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x5C, 0xDA, 0x08, 0xCE, 0x80, 0xF9, 
  0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x65, 0x70, 0x20, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x76, 
  0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4A, 0x61, 0x6E, 0x65, 0x74, 0x20, 
  0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 
  0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 0x20, 0x77, 0x68, 0x69, 
  0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x75, 0x73, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x20, 
  0x62, 0x65, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x61, 0x73, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 
  0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x20, 0x6E, 0x69, 0x6C, 
  0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x2E, 0xDA, 0x86, 0x6A, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x24, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x6B, 0xDA, 0x08, 
  0xCE, 0x2E, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 0x66, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 
  0xDA, 0x86, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0xF2, 0x01, 0xDA, 
  0x06, 0xDA, 0x83, 0xD2, 0xDA, 0x08, 0xCE, 0x80, 0xBF, 0x28, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x2D, 
  0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x61, 0x62, 0x20, 0x26, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x73, 
  0x29, 0x0A, 0x0A, 0x4D, 0x65, 0x72, 0x67, 0x65, 0x73, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 
  0x6C, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2F, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x60, 0x74, 0x61, 
  0x62, 0x60, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x61, 0x70, 0x70, 
  0x65, 0x61, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 
  0x6E, 0x20, 0x6F, 0x6E, 0x65, 0x0A, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x69, 0x6E, 0x20, 0x60, 0x63, 0x6F, 0x6C, 0x6C, 0x73, 0x60, 0x2C, 0x20, 0x74, 0x68, 0x65, 
  0x6E, 0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x72, 
  0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 
  0x6F, 0x75, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x60, 0x74, 0x61, 0x62, 0x60, 0x2E, 0xDA, 0x86, 0x6D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0x4E, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x6E, 0xDA, 0x08, 0xCE, 
  0x81, 0x30, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x20, 0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 
  0x6C, 0x69, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 
  0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x60, 0x73, 0x74, 
  0x61, 0x72, 0x74, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x65, 0x6E, 0x64, 0x60, 0x2E, 0x20, 0x54, 
  0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x68, 0x61, 0x6C, 0x66, 
  0x20, 0x6F, 0x70, 0x65, 0x6E, 0x2C, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 
  0x6E, 0x64, 0x29, 0x2E, 0x20, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x2C, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x42, 0x79, 0x20, 
  0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x60, 0x73, 0x74, 0x61, 0x72, 0x74, 0x60, 
  0x20, 0x69, 0x73, 0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x65, 0x6E, 0x64, 0x60, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0xDA, 0x86, 0x6F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0x67, 0x80, 
  0xDD, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x70, 0xDA, 0x08, 0xCE, 0x81, 0x0C, 0x28, 0x64, 0x65, 0x62, 
  0x75, 0x67, 0x2F, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 
  0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x73, 0x20, 
  0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 
  0x60, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x60, 0x20, 0x61, 0x74, 0x20, 0x61, 0x20, 0x67, 0x69, 
  0x76, 0x65, 0x6E, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6C, 
  0x75, 0x6D, 0x6E, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 
  0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6F, 
  0x75, 0x6E, 0x64, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 
  0x0A, 0x0A, 0x09, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x20, 
  0x22, 0x63, 0x6F, 0x72, 0x65, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x22, 0x20, 0x31, 0x30, 0x20, 
  0x34, 0x29, 0x0A, 0x0A, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61, 0x20, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x61, 0x74, 0x20, 0x6C, 0x69, 0x6E, 
  0x65, 0x20, 0x31, 0x30, 0x2C, 0x20, 0x34, 0x74, 0x68, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 
  0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x63, 0x6F, 0x72, 
  0x65, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x2E, 0xDA, 0x86, 0x71, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x82, 0x05, 0x84, 0xD2, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x72, 0xDA, 0x08, 0xCE, 
  0x82, 0x9B, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 0x72, 
  0x65, 0x73, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 0x20, 
  0x49, 0x66, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 
  0x65, 0x64, 0x2C, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x65, 0x64, 0x2E, 0x20, 0x41, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x20, 0x6B, 
  0x65, 0x79, 0x73, 0x20, 0x61, 0x72, 0x65, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x64, 0x65, 0x6C, 
  0x69, 0x6D, 0x69, 0x74, 0x65, 0x72, 0x73, 0x20, 0x2D, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x20, 0x6E, 
  0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 
  0x65, 0x2C, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x27, 0x28, 0x5B, 0x22, 0x27, 0x2C, 
  0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x69, 0x64, 0x64, 0x6C, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x20, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x20, 
  0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x68, 0x65, 0x73, 
  0x65, 0x73, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 
  0x74, 0x6F, 0x20, 0x61, 0x75, 0x67, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x20, 0x52, 0x45, 0x50, 
  0x4C, 0x20, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x66, 0x72, 
  0x61, 0x6D, 0x65, 0x73, 0x20, 0x2D, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x72, 
  0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x20, 0x27, 0x66, 0x72, 0x61, 
  0x6D, 0x65, 0x27, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2E, 0x20, 0x46, 0x72, 0x61, 0x6D, 0x65, 0x73, 0x20, 
  0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 
  0x61, 0x72, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 
  0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 
  0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x6F, 
  0x6D, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2D, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 
  0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x86, 0x73, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x6F, 0x01, 0xDA, 0x06, 0xDA, 0x53, 0xDA, 
  0x08, 0xCE, 0x23, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x86, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x82, 0xA1, 0x81, 0x07, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x75, 0xDA, 0x08, 0xCE, 0x81, 0x19, 
  0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x61, 0x72, 
  0x72, 0x20, 0x61, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x60, 0x78, 0x73, 0x60, 0x20, 0x69, 0x6E, 0x74, 0x6F, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x60, 0x61, 0x72, 0x72, 0x60, 0x20, 0x61, 0x74, 0x20, 
  0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 0x61, 0x74, 0x60, 0x2E, 0x20, 0x60, 0x61, 0x74, 0x60, 
  0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x30, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x41, 0x20, 0x6E, 
  0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x60, 0x61, 0x74, 0x60, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x64, 0x65, 
  0x78, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x77, 0x61, 0x72, 0x64, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x74, 0x20, 0x2D, 0x31, 
  0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x86, 0x76, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x84, 0x67, 0x80, 0xFF, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x74, 0xDA, 0x08, 
  0xCE, 0x47, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 0x6E, 0x66, 0x62, 0x72, 0x65, 0x61, 
  0x6B, 0x20, 0x66, 0x75, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 0x63, 0x29, 0x0A, 0x0A, 
  0x55, 0x6E, 0x73, 0x65, 0x74, 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 
  0x6E, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x2F, 0x66, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x2E, 0xDA, 0x86, 0x77, 0xD3, 0x02, 0xDA, 0x06, 
  0xDA, 0x86, 0x78, 0xDA, 0x08, 0xCE, 0x30, 0x54, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 
  0x6F, 0x6E, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x70, 
  0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 0x86, 0x79, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xCE, 0x11, 0x73, 0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x2E, 0x63, 0x80, 0xE1, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x7A, 0xDA, 0x08, 0xCE, 0x56, 
  0x28, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 
  0x20, 0x73, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 
  0x66, 0x20, 0x69, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x6E, 0x27, 0x74, 0x20, 0x68, 0x61, 0x76, 
  0x65, 0x20, 0x6F, 0x6E, 0x65, 0x2E, 0xDA, 0x86, 0x7B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x7F, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x12, 0xDA, 0x08, 0xCE, 0x22, 0x28, 0x65, 0x6D, 
  0x70, 0x74, 0x79, 0x3F, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 
  0x69, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2E, 0xDA, 
  0x86, 0x7C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0x2A, 0x01, 0xDA, 0x06, 
  0xDA, 0x86, 0x49, 0xDA, 0x08, 0xCE, 0x66, 0x28, 0x70, 0x6F, 0x73, 0x74, 0x77, 0x61, 0x6C, 0x6B, 
  0x20, 0x66, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x29, 0x0A, 0x0A, 0x44, 0x6F, 0x20, 0x61, 0x20, 0x70, 
  0x6F, 0x73, 0x74, 0x2D, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x74, 0x72, 0x61, 0x76, 0x65, 0x72, 
  0x73, 0x61, 0x6C, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 0x6C, 0x6C, 
  0x20, 0x60, 0x28, 0x66, 0x20, 0x78, 0x29, 0x60, 0x0A, 0x6F, 0x6E, 0x20, 0x65, 0x76, 0x65, 0x72, 
  0x79, 0x20, 0x76, 0x69, 0x73, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x86, 0x7D, 
  0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0x01, 0x01, 0xDA, 0x06, 0xDA, 0x86, 
  0x7E, 0xDA, 0x08, 0xCE, 0x81, 0x60, 0x28, 0x64, 0x6F, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x73, 0x79, 0x6D, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x77, 0x73, 0x20, 0x64, 0x6F, 0x63, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2C, 0x20, 
  0x6F, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x6C, 0x69, 
  0x73, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2E, 0x0A, 0x49, 0x66, 0x20, 0x60, 0x73, 0x79, 
  0x6D, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2C, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 0x6F, 
  0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0x20, 0x49, 0x66, 0x20, 
  0x60, 0x73, 0x79, 0x6D, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x0A, 0x6F, 0x72, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x76, 
  0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x20, 
  0x61, 0x6C, 0x6C, 0x20, 0x6C, 0x65, 0x78, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 
  0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x0A, 0x63, 0x6F, 0x6E, 0x74, 
  0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x20, 0x28, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x6E, 0x20, 0x69, 
  0x66, 0x20, 0x6E, 0x6F, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 0x67, 
  0x69, 0x76, 0x65, 0x6E, 0x29, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x86, 0x80, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x89, 0x18, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0xE9, 0xDA, 0x08, 0xCE, 
  0x52, 0x28, 0x62, 0x61, 0x64, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x6D, 0x73, 
  0x67, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x66, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x29, 0x0A, 0x0A, 0x44, 
  0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x2E, 0xDA, 0x86, 0x81, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x8B, 0x1B, 
  0x80, 0xEC, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x82, 0xDA, 0x08, 0xCE, 0x80, 0xA8, 0x28, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x2F, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x2D, 0x66, 0x6C, 0x61, 0x74, 0x74, 
  0x65, 0x6E, 0x20, 0x73, 0x74, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70, 0x72, 
  0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6E, 0x6F, 0x20, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x62, 0x79, 0x20, 0x6D, 0x65, 0x72, 0x67, 0x69, 
  0x6E, 0x67, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x72, 0x65, 0x63, 0x75, 
  0x72, 0x73, 0x69, 0x76, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x73, 
  0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x2E, 0xDA, 0x86, 0x83, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x3B, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x84, 0xDA, 0x08, 0xCE, 0x4A, 0x28, 0x64, 0x65, 0x66, 
  0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 0x6D, 0x6F, 
  0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 
  0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 0x70, 
  0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x86, 0x86, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x56, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x87, 0xDA, 0x08, 0xCE, 
  0x80, 0xB3, 0x28, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x3F, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x6F, 0x72, 0x74, 0x65, 
  0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 
  0x6D, 0x6F, 0x64, 0x69, 0x66, 0x79, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x6C, 
  0x64, 0x20, 0x6F, 0x6E, 0x65, 0x2E, 0x0A, 0x49, 0x66, 0x20, 0x61, 0x20, 0x60, 0x62, 0x65, 0x66, 
  0x6F, 0x72, 0x65, 0x3F, 0x60, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 
  0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x73, 0x6F, 0x72, 0x74, 0x73, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x2C, 0x0A, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x75, 0x73, 0x65, 0x73, 
  0x20, 0x60, 0x3C, 0x60, 0x2E, 0xDA, 0x86, 0x89, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x8B, 0xA0, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x09, 0xDA, 0x08, 0xCE, 0x80, 0xC8, 0x28, 0x61, 
  0x6C, 0x6C, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x65, 0x6E, 0x76, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 
  0x20, 0x61, 0x6C, 0x6C, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 0x61, 0x76, 0x61, 
  0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 
  0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x0A, 0x66, 0x69, 0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 
  0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 
  0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x20, 0x69, 0x6E, 0x68, 0x65, 0x72, 
  0x69, 0x74, 0x65, 0x64, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x0A, 0x28, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x73, 0x29, 0x2E, 0xDA, 0x86, 0x8A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x75, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x8B, 0xDA, 0x08, 0xCE, 0x31, 0x28, 0x64, 0x69, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x72, 0x79, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 
  0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 0xDA, 0x86, 
  0x8D, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xB2, 
  0x01, 0xDA, 0x06, 0xDA, 0x83, 0xDB, 0xDA, 0x08, 0xCE, 0x58, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 
  0x73, 0x20, 0x61, 0x20, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x64, 0x65, 0x62, 
  0x75, 0x67, 0x67, 0x65, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x75, 0x73, 0x65, 0x66, 0x75, 0x6C, 
  0x20, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 0x65, 
  0x62, 0x75, 0x67, 0x67, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 
  0x6C, 0x2E, 0xDA, 0x86, 0x8E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8B, 0xA7, 
  0x01, 0xDA, 0x06, 0xDA, 0x86, 0x0E, 0xDA, 0x08, 0xCE, 0x80, 0xC7, 0x28, 0x61, 0x6C, 0x6C, 0x2D, 
  0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x6E, 
  0x76, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x6C, 
  0x6C, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 
  0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x74, 
  0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x0A, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x60, 0x20, 0x69, 0x73, 
  0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x20, 0x69, 0x6E, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 
  0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x0A, 0x28, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 
  0x29, 0x2E, 0xDA, 0x86, 0x8F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 
  0x3E, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x10, 0xDA, 0x08, 0xCE, 0x80, 0xC9, 0x28, 0x64, 0x65, 0x73, 
  0x63, 0x72, 0x69, 0x62, 0x65, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x61, 0x20, 0x68, 0x75, 0x6D, 0x61, 0x6E, 0x2D, 0x72, 0x65, 0x61, 0x64, 0x61, 
  0x62, 0x6C, 0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x6F, 0x66, 0x20, 0x60, 0x78, 0x60, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x72, 0x65, 0x63, 0x75, 
  0x72, 0x73, 0x69, 0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x75, 0x72, 0x65, 0x73, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 
  0x69, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x74, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x60, 
  0x78, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6D, 
  0x69, 0x6E, 0x65, 0x64, 0x2E, 0xDA, 0x86, 0x90, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x88, 0xAD, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x91, 0xDA, 0x08, 0xCE, 0x80, 0x8A, 0x54, 0x68, 
  0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 
  0x72, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x65, 0x67, 0x73, 0x2E, 
  0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0x20, 0x64, 0x65, 
  0x66, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x73, 0x65, 0x76, 0x65, 0x72, 0x61, 0x6C, 0x20, 0x63, 0x6F, 
  0x6D, 0x6D, 0x6F, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x73, 0x0A, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x69, 
  0x74, 0x20, 0x65, 0x61, 0x73, 0x69, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 
  0x65, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x78, 0x20, 0x70, 
  0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x73, 0x2E, 0xDA, 0x86, 0xC3, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x12, 0x82, 0xF1, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xC4, 0xDA, 0x08, 0xCE, 0x81, 
  0x16, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x20, 0x73, 0x74, 0x72, 
  0x65, 0x61, 0x6D, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 
  0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 
  0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 
  0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0x20, 0x54, 
  0x68, 0x69, 0x73, 0x20, 0x77, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x75, 0x73, 0x75, 0x61, 0x6C, 0x6C, 
  0x79, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x61, 
  0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x65, 0x64, 0x69, 0x63, 
  0x61, 0x74, 0x65, 0x64, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x61, 0x6B, 0x65, 
  0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x69, 
  0x6D, 0x65, 0x6F, 0x75, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 
  0x2C, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x64, 0x75, 0x70, 
  0x6C, 0x65, 0x78, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 
  0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x20, 0x63, 0x6F, 
  0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x86, 0xC5, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x82, 0xA1, 0x81, 0x41, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xC6, 0xDA, 0x08, 0xCE, 0x69, 
  0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0x20, 0x61, 0x72, 0x72, 0x29, 
  0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 
  0x67, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 0x73, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 
  0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x86, 0xC7, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x80, 0xB0, 0x81, 0x36, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x0D, 0xDA, 0x08, 
  0xCE, 0x80, 0x85, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0x20, 0x74, 0x61, 0x62, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6E, 0x6F, 0x20, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 
  0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 
  0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2E, 0xDA, 0x86, 0xC8, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x8D, 0x09, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xC9, 0xDA, 0x08, 0xCE, 0x80, 
  0xAA, 0x28, 0x64, 0x6F, 0x63, 0x2D, 0x6F, 0x66, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x61, 
  0x72, 0x63, 0x68, 0x65, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x64, 
  0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x6F, 0x64, 0x75, 
  0x6C, 0x65, 0x2F, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x67, 
  0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x20, 0x69, 0x74, 0x73, 0x20, 
  0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x54, 
  0x68, 0x69, 0x73, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 
  0x68, 0x20, 0x62, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 
  0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x86, 0xCE, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xB0, 0x81, 0x69, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xCF, 
  0xDA, 0x08, 0xCE, 0x5D, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 
  0x20, 0x74, 0x61, 0x62, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x61, 0x6C, 
  0x6C, 0x20, 0x6B, 0x65, 0x79, 0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 
  0x66, 0x69, 0x65, 0x64, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x60, 0x74, 0x61, 0x62, 0x60, 
  0x2E, 0xDA, 0x86, 0xD0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x85, 0xC7, 0x01, 
  0xDA, 0x06, 0xDA, 0x86, 0xD1, 0xDA, 0x08, 0xCE, 0x80, 0xE8, 0x28, 0x6F, 0x73, 0x2F, 0x6C, 0x69, 
  0x6E, 0x6B, 0x20, 0x6F, 0x6C, 0x64, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6E, 0x65, 0x77, 0x70, 0x61, 
  0x74, 0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x29, 
  0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 
  0x61, 0x74, 0x20, 0x6E, 0x65, 0x77, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6F, 0x6C, 0x64, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 
  0x6C, 0x2E, 0x20, 0x49, 0x66, 0x66, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x69, 
  0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 
  0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x2E, 0x20, 0x49, 0x66, 0x66, 
  0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x6C, 0x73, 
  0x65, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 
  0x65, 0x64, 0x2C, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x68, 0x61, 
  0x72, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x6B, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x77, 0x6F, 0x72, 0x6B, 0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 
  0x73, 0x2E, 0xDA, 0x86, 0xD2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8B, 0x99, 
  0x01, 0xDA, 0x06, 0xDA, 0x86, 0xD3, 0xDA, 0x08, 0xCE, 0x5A, 0x28, 0x65, 0x76, 0x2F, 0x73, 0x6C, 
  0x65, 0x65, 0x70, 0x20, 0x73, 0x65, 0x63, 0x29, 0x0A, 0x0A, 0x53, 0x75, 0x73, 0x70, 0x65, 0x6E, 
  0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x73, 0x65, 0x63, 0x20, 0x73, 0x65, 0x63, 0x6F, 
  0x6E, 0x64, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x62, 0x6C, 0x6F, 0x63, 
  0x6B, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x20, 0x6C, 
  0x6F, 0x6F, 0x70, 0x2E, 0xDA, 0x86, 0xD4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 
  0x85, 0xC9, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xD5, 0xDA, 0x08, 0xCE, 0x3C, 0x28, 0x66, 0x66, 0x69, 
  0x2F, 0x66, 0x72, 0x65, 0x65, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x29, 0x0A, 0x0A, 
  0x46, 0x72, 0x65, 0x65, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 
  0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x66, 0x66, 0x69, 0x2F, 
  0x6D, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x60, 0x2E, 0xDA, 0x86, 0xD6, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x10, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xD7, 0xDA, 0x08, 0xCE, 
  0x35, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x73, 0x69, 0x6E, 0x68, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 
  0x62, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x20, 0x61, 0x72, 0x63, 0x73, 0x69, 0x6E, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x86, 0xD8, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x88, 0xE1, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0xFC, 0xDA, 0x08, 0xCE, 0x37, 0x28, 0x62, 
  0x61, 0x64, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x70, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 
  0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 
  0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x86, 0xD9, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x84, 0xC1, 0x81, 0xE4, 0x01, 0xDA, 0x06, 0xDA, 0x43, 0xDA, 0x08, 0xCE, 0x80, 0xD1, 0x28, 0x67, 
  0x65, 0x6E, 0x73, 0x79, 0x6D, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6E, 0x69, 0x71, 0x75, 0x65, 0x20, 0x61, 0x63, 0x72, 0x6F, 
  0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0x20, 
  0x54, 0x68, 0x69, 0x73, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x69, 0x64, 0x65, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x61, 0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 
  0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 
  0x64, 0x75, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x69, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 
  0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x61, 0x75, 0x74, 0x6F, 
  0x6D, 0x61, 0x74, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2E, 0xCF, 
  0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x69, 0x6E, 0x66, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x80, 0xA4, 0x81, 0x96, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x15, 0xDA, 0x08, 0xCE, 0x29, 0x54, 
  0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 
  0x65, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 
  0x69, 0x6E, 0x66, 0x69, 0x6E, 0x69, 0x74, 0x79, 0xDA, 0x86, 0xDA, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0x6A, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0xBA, 0xDA, 0x08, 0xCE, 
  0x80, 0xB6, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 
  0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x20, 0x62, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 0x74, 0x69, 
  0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 
  0x6F, 0x66, 0x20, 0x60, 0x78, 0x73, 0x60, 0x20, 0x74, 0x6F, 0x67, 0x65, 0x74, 0x68, 0x65, 0x72, 
  0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 
  0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6F, 
  0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 
  0x20, 0x76, 0x69, 0x61, 0x20, 0x60, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x60, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x86, 0xDB, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x5B, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xDC, 0xDA, 0x08, 0xCE, 0x37, 0x28, 
  0x76, 0x61, 0x72, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x69, 
  0x6E, 0x69, 0x74, 0x29, 0x0A, 0x0A, 0x44, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x61, 0x6C, 0x6C, 
  0x79, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x67, 0x6C, 0x6F, 0x62, 0x61, 
  0x6C, 0x20, 0x76, 0x61, 0x72, 0x2E, 0xDA, 0x86, 0xDE, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xB0, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xDF, 0xDA, 0x08, 
  0xCE, 0x26, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x70, 0x72, 
  0x69, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x75, 
  0x74, 0x70, 0x75, 0x74, 0x20, 0x74, 0x6F, 0x2E, 0xDA, 0x86, 0xE0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x83, 0x22, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xE1, 0xDA, 0x08, 0xCE, 0x1E, 
  0x28, 0x7A, 0x65, 0x72, 0x6F, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x7A, 0x65, 0x72, 0x6F, 0x2E, 0xDA, 0x86, 
  0xE3, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x2B, 0x81, 0xF6, 0x01, 0xDA, 0x06, 
  0xDA, 0x80, 0xBA, 0xDA, 0x08, 0xCE, 0x84, 0x1F, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x6E, 
  0x65, 0x77, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x69, 0x67, 
  0x6D, 0x61, 0x73, 0x6B, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 
  0x79, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6F, 0x66, 0x20, 
  0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 
  0x68, 0x65, 0x6E, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x6D, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 
  0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x77, 
  0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 
  0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 
  0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 
  0x20, 0x74, 0x6F, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x65, 0x76, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x65, 
  0x6E, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x69, 0x73, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 
  0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 
  0x20, 0x60, 0x65, 0x76, 0x2F, 0x67, 0x6F, 0x60, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 
  0x22, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x22, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 
  0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x6E, 
  0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 
  0x73, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x70, 0x65, 
  0x72, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6D, 
  0x61, 0x73, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x3A, 0x79, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x65, 
  0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x0A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x28, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0x20, 0x6D, 0x79, 0x66, 0x75, 0x6E, 0x20, 0x3A, 0x65, 
  0x31, 0x32, 0x33, 0x29, 0x0A, 0x0A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x75, 
  0x73, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x31, 0x2C, 0x20, 0x32, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x33, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6E, 
  0x61, 0x6C, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 
  0x77, 0x73, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x61, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 
  0x6B, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x0A, 0x2A, 0x20, 
  0x3A, 0x64, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x0A, 0x2A, 0x20, 0x3A, 0x65, 0x20, 0x2D, 0x20, 
  0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 
  0x61, 0x6C, 0x73, 0x0A, 0x2A, 0x20, 0x3A, 0x74, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 
  0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x69, 0x67, 
  0x6E, 0x61, 0x6C, 0x73, 0x3A, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x2B, 0x20, 0x75, 0x73, 
  0x65, 0x72, 0x5B, 0x30, 0x2D, 0x34, 0x5D, 0x0A, 0x2A, 0x20, 0x3A, 0x75, 0x20, 0x2D, 0x20, 0x62, 
  0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 
  0x73, 0x0A, 0x2A, 0x20, 0x3A, 0x79, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x79, 
  0x69, 0x65, 0x6C, 0x64, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x0A, 0x2A, 0x20, 0x3A, 
  0x30, 0x2D, 0x39, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x61, 0x20, 0x73, 0x70, 
  0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 
  0x61, 0x6C, 0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6D, 0x61, 0x73, 0x6B, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x63, 0x61, 
  0x6E, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x79, 
  0x20, 0x6D, 0x75, 0x74, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x65, 0x78, 0x63, 0x6C, 0x75, 0x73, 
  0x69, 0x76, 0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 0x72, 
  0x65, 0x73, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 
  0x66, 0x6C, 0x61, 0x67, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x70, 0x72, 0x65, 0x63, 0x65, 
  0x64, 0x65, 0x6E, 0x63, 0x65, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x69, 0x20, 0x2D, 0x20, 0x69, 
  0x6E, 0x68, 0x65, 0x72, 0x69, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 
  0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x0A, 0x2A, 0x20, 
  0x3A, 0x70, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x27, 0x73, 0x20, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0xDA, 0x86, 0xE4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x84, 0x1E, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xE5, 0xDA, 0x08, 0xCE, 0x80, 0x81, 
  0x28, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x46, 0x69, 0x6E, 0x64, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x63, 0x6F, 
  0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x61, 
  0x74, 0x69, 0x73, 0x66, 0x69, 0x65, 0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 
  0x61, 0x74, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x0A, 0x60, 0x64, 0x66, 
  0x6C, 0x74, 0x60, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 
  0x2E, 0xDA, 0x86, 0xE7, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x1B, 
  0x01, 0xDA, 0x06, 0xDA, 0x86, 0xE8, 0xDA, 0x08, 0xCE, 0x2A, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x63, 0x62, 0x72, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x62, 0x65, 0x20, 0x72, 0x6F, 0x6F, 0x74, 0x20, 0x6F, 
  0x66, 0x20, 0x78, 0x2E, 0xDA, 0x86, 0xF2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 
  0x67, 0x81, 0x5E, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x44, 0xDA, 0x08, 0xCE, 0x83, 0x4C, 0x28, 0x64, 
  0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x69, 0x62, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x63, 
  0x6B, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 
  0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 
  0x6F, 0x70, 0x2D, 0x6D, 0x6F, 0x73, 0x74, 0x2C, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 
  0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x74, 0x74, 0x6F, 0x6D, 0x2D, 0x6D, 0x6F, 0x73, 
  0x74, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 
  0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 
  0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 
  0x20, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 
  0x3A, 0x63, 0x20, 0x2D, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x20, 0x63, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x76, 
  0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x2D, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 
  0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 
  0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 
  0x65, 0x6E, 0x74, 0x73, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2D, 
  0x6C, 0x69, 0x6E, 0x65, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 
  0x6E, 0x74, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 
  0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x68, 0x75, 0x6D, 0x61, 0x6E, 0x2D, 0x66, 0x72, 0x69, 0x65, 0x6E, 0x64, 0x6C, 0x79, 0x20, 
  0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x70, 0x63, 0x20, 0x2D, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x6F, 0x75, 
  0x6E, 0x74, 0x65, 0x72, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 
  0x2D, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6F, 0x72, 0x20, 0x6F, 
  0x74, 0x68, 0x65, 0x72, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 
  0x6F, 0x64, 0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x20, 0x2D, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x73, 0x6C, 0x6F, 0x74, 
  0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x74, 0x61, 0x69, 0x6C, 0x20, 0x2D, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 
  0x65, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 
  0x20, 0x74, 0x61, 0x69, 0x6C, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0xDA, 0x86, 0xE9, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x62, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xEA, 0xDA, 0x08, 
  0xCE, 0x81, 0x71, 0x28, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x61, 0x64, 0x64, 0x2D, 0x70, 
  0x61, 0x74, 0x68, 0x73, 0x20, 0x65, 0x78, 0x74, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 0x29, 
  0x0A, 0x0A, 0x41, 0x64, 0x64, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x60, 
  0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 0x60, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 
  0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x67, 
  0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x62, 
  0x65, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 
  0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2C, 0x20, 0x69, 
  0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x0A, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x79, 
  0x73, 0x70, 0x61, 0x74, 0x68, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x73, 0x2E, 0x20, 0x60, 
  0x65, 0x78, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x0A, 0x74, 0x6F, 0x20, 0x61, 0x73, 
  0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x69, 
  0x73, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2C, 0x20, 0x69, 
  0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x6F, 0x74, 
  0x2E, 0x20, 0x60, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x0A, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x61, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x6D, 
  0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 0x73, 0x60, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 
  0x66, 0x69, 0x65, 0x64, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x70, 0x61, 0x74, 
  0x68, 0x73, 0x60, 0x2E, 0xDA, 0x86, 0xF3, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 
  0xE8, 0x80, 0xBB, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xF4, 0xDA, 0x08, 0xCE, 0x50, 0x28, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x29, 
  0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0xDA, 0x86, 0xF5, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 0xEB, 0x01, 0xDA, 0x06, 0xDA, 
  0x83, 0xC2, 0xDA, 0x08, 0xCE, 0x7A, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x6A, 0x6F, 
  0x69, 0x6E, 0x20, 0x70, 0x61, 0x72, 0x74, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x65, 
  0x70, 0x29, 0x0A, 0x0A, 0x4A, 0x6F, 0x69, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x69, 0x6E, 
  0x74, 0x6F, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6F, 
  0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 
  0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 
  0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x73, 0x65, 0x70, 0x60, 0x2E, 
  0xDA, 0x86, 0xF6, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0x8D, 0x01, 0xDA, 
  0x06, 0xDA, 0x86, 0xF7, 0xDA, 0x08, 0xCE, 0x7F, 0x28, 0x6A, 0x75, 0x78, 0x74, 0x2A, 0x20, 0x26, 
  0x20, 0x66, 0x75, 0x6E, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6A, 0x75, 0x78, 0x74, 0x61, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 
  0x49, 0x6E, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x77, 0x6F, 0x72, 0x64, 0x73, 0x2C, 0x0A, 
  0x60, 0x28, 0x28, 0x6A, 0x75, 0x78, 0x74, 0x2A, 0x20, 0x61, 0x20, 0x62, 0x20, 0x63, 0x29, 0x20, 
  0x78, 0x29, 0x60, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x60, 0x5B, 0x28, 0x61, 0x20, 0x78, 0x29, 0x20, 0x28, 0x62, 0x20, 0x78, 0x29, 0x20, 0x28, 
  0x63, 0x20, 0x78, 0x29, 0x5D, 0x60, 0x2E, 0xDA, 0x86, 0xF9, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x80, 0xA4, 0x81, 0x1F, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0xFA, 0xDA, 0x08, 0xCE, 0x41, 
  0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 0x72, 0x75, 0x6E, 0x63, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x67, 0x65, 0x72, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x78, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x30, 0x20, 0x6E, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x78, 
  0x2E, 0xDA, 0x86, 0xFB, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x80, 0xCB, 
  0x01, 0xDA, 0x06, 0xDA, 0x81, 0x50, 0xDA, 0x08, 0xCE, 0x55, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2F, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6E, 
  0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x60, 0x6E, 0x60, 0x20, 
  0x63, 0x6F, 0x70, 0x69, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x62, 0x79, 0x74, 0x65, 0x73, 
  0x60, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 0x74, 0x65, 0x64, 0x2E, 0xDA, 
  0x86, 0xFC, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x65, 0x01, 0xDA, 0x06, 0xDA, 
  0x86, 0xFD, 0xDA, 0x08, 0xCE, 0x22, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x3F, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x86, 0xFF, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x81, 0xFC, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x00, 0xDA, 0x08, 0xCE, 0x4F, 
  0x28, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x73, 0x74, 0x6F, 
  0x70, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x44, 0x6F, 0x20, 0x61, 0x20, 
  0x43, 0x2D, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x2D, 0x6C, 0x6F, 0x6F, 0x70, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 
  0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 
  0x2B, 0xCB, 0xDA, 0x87, 0x06, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xE7, 
  0x01, 0xDA, 0x06, 0xDA, 0x81, 0x5A, 0xDA, 0x08, 0xCE, 0x41, 0x28, 0x66, 0x69, 0x72, 0x73, 0x74, 
  0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x87, 0x07, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0x1A, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x7E, 0xDA, 
  0x08, 0xCE, 0x80, 0xAB, 0x28, 0x77, 0x61, 0x6C, 0x6B, 0x20, 0x66, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x29, 0x0A, 0x0A, 0x49, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x73, 
  0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x79, 0x20, 0x60, 0x66, 0x60, 0x0A, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x6D, 0x2E, 0x20, 0x43, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 
  0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x61, 0x0A, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2C, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x2C, 0x0A, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2E, 0xDA, 
  0x87, 0x08, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x16, 0x01, 0xDA, 0x06, 
  0xDA, 0x87, 0x09, 0xDA, 0x08, 0xCE, 0x3E, 0x28, 0x65, 0x61, 0x63, 0x68, 0x20, 0x78, 0x20, 0x64, 
  0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x6F, 0x70, 0x20, 
  0x6F, 0x76, 0x65, 0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x69, 0x6E, 0x20, 0x60, 0x64, 0x73, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x87, 0x12, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x82, 0x2B, 0x82, 0x60, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x13, 0xDA, 0x08, 0xCE, 
  0x81, 0x08, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 
  0x6B, 0x20, 0x66, 0x69, 0x62, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x73, 
  0x69, 0x7A, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x6D, 
  0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x20, 
  0x66, 0x72, 0x6F, 0x6E, 0x74, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 
  0x74, 0x65, 0x64, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x74, 0x68, 
  0x69, 0x73, 0x20, 0x61, 0x6D, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 
  0x2D, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 
  0x69, 0x66, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x69, 
  0x73, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x65, 0x64, 0x2E, 0x20, 0xDA, 0x87, 0x14, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x7F, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x15, 0xDA, 0x08, 
  0xCE, 0x3B, 0x28, 0x73, 0x75, 0x6D, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x78, 
  0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 
  0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x30, 0x2E, 0xDA, 0x87, 0x17, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x60, 0x01, 0xDA, 0x06, 0xDA, 0x87, 
  0x18, 0xDA, 0x08, 0xCE, 0x80, 0x87, 0x28, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 0x2D, 0x69, 
  0x6E, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x61, 
  0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x28, 0x74, 0x72, 0x65, 0x65, 0x29, 0x20, 0x60, 0x78, 0x73, 0x60, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 
  0x65, 0x70, 0x74, 0x68, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 0x61, 0x76, 0x65, 
  0x72, 0x73, 0x61, 0x6C, 0x20, 0x6F, 0x66, 0x0A, 0x60, 0x78, 0x73, 0x60, 0x20, 0x74, 0x6F, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x60, 0x69, 0x6E, 0x74, 0x6F, 0x60, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x60, 0x69, 0x6E, 0x74, 0x6F, 0x60, 0x2E, 0xDA, 0x87, 0x1A, 
  0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0xC1, 0x01, 0xDA, 0x06, 0xDA, 0x87, 
  0x1B, 0xDA, 0x08, 0xCE, 0x49, 0x28, 0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x63, 0x6F, 0x6E, 
  0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 
  0x53, 0x68, 0x6F, 0x72, 0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x28, 
  0x77, 0x68, 0x65, 0x6E, 0x20, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 
  0x69, 0x6F, 0x6E, 0x29, 0x20, 0x3B, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x60, 0x2E, 0x20, 0xDA, 0x2B, 
  0xCB, 0xDA, 0x87, 0x1D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x2B, 0x82, 0x56, 
  0x01, 0xDA, 0x06, 0xDA, 0x87, 0x1E, 0xDA, 0x08, 0xCE, 0x70, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x2F, 0x72, 0x6F, 0x6F, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x72, 0x6F, 0x6F, 0x74, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x6F, 0x6F, 0x74, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x6C, 
  0x64, 0x65, 0x73, 0x74, 0x20, 0x61, 0x6E, 0x63, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 
  0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x87, 0x1F, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 0xD2, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x20, 0xDA, 0x08, 
  0xCE, 0x6B, 0x28, 0x6F, 0x73, 0x2F, 0x70, 0x65, 0x72, 0x6D, 0x2D, 0x69, 0x6E, 0x74, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x61, 0x72, 0x73, 0x65, 0x20, 0x61, 0x20, 0x39, 
  0x2D, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 
  0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 
  0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x63, 0x68, 0x6D, 0x6F, 0x64, 0x2E, 0xDA, 0x87, 0x21, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x22, 0x01, 0xDA, 0x06, 0xDA, 0x85, 
  0x7D, 0xDA, 0x08, 0xCE, 0x80, 0xB4, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x75, 0x73, 
  0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x62, 0x69, 0x6E, 0x61, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 
  0x6C, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x63, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x0A, 0x62, 0x79, 0x20, 0x60, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 
  0x69, 0x6D, 0x61, 0x67, 0x65, 0x60, 0x2C, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x60, 0x28, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x29, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 
  0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 
  0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 0x6D, 0x61, 
  0x67, 0x65, 0x2D, 0x64, 0x69, 0x63, 0x74, 0x29, 0x60, 0x2E, 0xDA, 0x87, 0x22, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x14, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x23, 0xDA, 
  0x08, 0xCE, 0x2A, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x87, 0x24, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x1B, 0x86, 0xE5, 0x01, 0xDA, 0x06, 0xDA, 
  0x87, 0x25, 0xDA, 0x08, 0xCE, 0x80, 0xF1, 0x28, 0x70, 0x65, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 
  0x61, 0x63, 0x65, 0x20, 0x70, 0x65, 0x67, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x20, 0x74, 0x65, 0x78, 
  0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x26, 0x20, 0x61, 
  0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x65, 0x67, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x72, 0x65, 
  0x70, 0x6C, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x70, 0x65, 0x67, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6E, 0x65, 0x65, 
  0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 
  0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x64, 0x6F, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 
  0x68, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x87, 0x26, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0xEC, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x27, 0xDA, 0x08, 0xCE, 
  0x50, 0x28, 0x67, 0x63, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x75, 
  0x6E, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x59, 0x6F, 0x75, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 
  0x20, 0x70, 0x72, 0x6F, 0x62, 0x61, 0x62, 0x6C, 0x79, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x61, 
  0x6C, 0x6C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6D, 0x61, 0x6E, 0x75, 0x61, 0x6C, 0x6C, 0x79, 
  0x2E, 0xDA, 0x87, 0x28, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x55, 
  0x01, 0xDA, 0x06, 0xDA, 0x82, 0xB6, 0xDA, 0x08, 0xCE, 0x7F, 0x28, 0x70, 0x72, 0x69, 0x6E, 0x74, 
  0x66, 0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 
  0x6E, 0x74, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 
  0x74, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x69, 0x66, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x60, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 
  0x66, 0x6D, 0x74, 0x20, 0x3B, 0x78, 0x73, 0x29, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x28, 0x64, 
  0x79, 0x6E, 0x20, 0x3A, 0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x60, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 
  0x20, 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x87, 0x29, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0x84, 0x01, 0xDA, 0x06, 0xDA, 0x71, 0xDA, 0x08, 0xCE, 0x4E, 
  0x28, 0x69, 0x64, 0x65, 0x6D, 0x70, 0x6F, 0x74, 0x65, 0x6E, 0x74, 0x3F, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 0x76, 0x61, 0x6C, 
  0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 0x73, 0x65, 0x6C, 0x66, 0x20, 
  0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0xDA, 0x87, 
  0x2A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x80, 0xEA, 0x01, 0xDA, 0x06, 
  0xDA, 0x87, 0x2B, 0xDA, 0x08, 0xCE, 0x4D, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x61, 0x6E, 
  0x64, 0x6F, 0x6D, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x75, 0x6E, 0x69, 0x66, 0x6F, 0x72, 0x6D, 0x6C, 0x79, 0x20, 0x64, 0x69, 0x73, 0x74, 0x72, 0x69, 
  0x62, 0x75, 0x74, 0x65, 0x64, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x30, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x31, 0x2E, 0xDA, 0x87, 0x2C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 
  0x54, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x2D, 0xDA, 0x08, 0xCE, 0x38, 0x28, 0x64, 0x65, 0x66, 0x67, 
  0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x29, 0x0A, 0x0A, 0x44, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x63, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x64, 
  0x65, 0x66, 0x2E, 0xDA, 0x87, 0x2F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 
  0x7C, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x30, 0xDA, 0x08, 0xCE, 0x81, 0x32, 0x28, 0x61, 0x63, 0x63, 
  0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x20, 0x69, 
  0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 
  0x60, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x61, 0x63, 
  0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 
  0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 
  0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x0A, 0x54, 0x68, 0x65, 
  0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x77, 0x68, 
  0x61, 0x74, 0x20, 0x77, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x60, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x60, 0x2E, 0x0A, 0x54, 0x68, 0x65, 0x20, 
  0x60, 0x69, 0x6E, 0x69, 0x74, 0x60, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x61, 0x64, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x28, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x68, 0x61, 
  0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x0A, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 
  0x73, 0x20, 0x60, 0x69, 0x6E, 0x64, 0x60, 0x29, 0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x80, 
  0xC2, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0xE9, 0x01, 0xDA, 0x06, 0xDA, 
  0x87, 0x32, 0xDA, 0x08, 0xCE, 0x80, 0xAE, 0x28, 0x6C, 0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 
  0x69, 0x6E, 0x67, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 
  0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x63, 0x6F, 0x70, 0x65, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x62, 0x69, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x70, 0x61, 
  0x69, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x60, 
  0x20, 0x69, 0x73, 0x0A, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 
  0x69, 0x66, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x64, 0x65, 0x66, 0x60, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x60, 0x6C, 0x65, 0x74, 0x60, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x0A, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x87, 0x35, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x70, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x69, 0xDA, 0x08, 0xCE, 0x22, 0x28, 
  0x74, 0x75, 0x70, 0x6C, 0x65, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x2E, 0xDA, 0x87, 0x36, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x80, 0xC5, 0x01, 
  0xDA, 0x06, 0xDA, 0x87, 0x37, 0xDA, 0x08, 0xCE, 0x80, 0x81, 0x28, 0x6F, 0x73, 0x2F, 0x65, 0x78, 
  0x69, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x69, 0x74, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x65, 0x71, 
  0x75, 0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x78, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x20, 0x69, 
  0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 
  0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x87, 0x38, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x26, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xD9, 0xDA, 
  0x08, 0xCE, 0x1E, 0x28, 0x65, 0x76, 0x65, 0x6E, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 
  0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x65, 0x76, 0x65, 0x6E, 
  0x2E, 0xDA, 0x87, 0x39, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8B, 0x88, 0x01, 
  0xDA, 0x06, 0xDA, 0x87, 0x3A, 0xDA, 0x08, 0xCE, 0x80, 0x94, 0x28, 0x75, 0x73, 0x65, 0x20, 0x26, 
  0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 
  0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x60, 0x2C, 0x20, 
  0x62, 0x75, 0x74, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x62, 0x69, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 
  0x65, 0x66, 0x69, 0x78, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x6D, 0x6F, 
  0x64, 0x75, 0x6C, 0x65, 0x0A, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x2E, 
  0x20, 0x43, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 
  0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x73, 0x68, 0x6F, 0x74, 0x2E, 0xDA, 0x2B, 
  0xCB, 0xDA, 0x87, 0x45, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x82, 0x16, 
  0x01, 0xDA, 0x06, 0xDA, 0x46, 0xDA, 0x08, 0xCE, 0x80, 0x82, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 
  0x26, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 
  0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x43, 0x27, 0x73, 0x20, 0x60, 0x73, 0x6E, 0x70, 0x72, 0x69, 
  0x6E, 0x74, 0x66, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 
  0x6C, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 
  0x69, 0x6E, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x4A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x87, 0x46, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x80, 0xB2, 0x01, 0xDA, 0x06, 0xDA, 0x87, 
  0x47, 0xDA, 0x08, 0xCE, 0x80, 0x90, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 
  0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 
  0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x6F, 0x66, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x60, 0x63, 0x6F, 0x75, 0x6E, 0x74, 
  0x60, 0x20, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x62, 
  0x79, 0x74, 0x65, 0x60, 0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 
  0x2C, 0x20, 0x60, 0x62, 0x79, 0x74, 0x65, 0x60, 0x20, 0x69, 0x73, 0x20, 0x30, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x87, 0x48, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0xB6, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0xB4, 0xDA, 0x08, 
  0xCE, 0x26, 0x46, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 
  0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x70, 0x70, 0x60, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0xDA, 0x87, 0x49, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x86, 0xA3, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x4D, 0xDA, 0x08, 0xCE, 0x51, 
  0x28, 0x73, 0x6C, 0x75, 0x72, 0x70, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x61, 0x64, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6E, 0x61, 0x6D, 
  0x65, 0x20, 0x60, 0x70, 0x61, 0x74, 0x68, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 
  0x6E, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x2E, 0xDA, 0x87, 0x4A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0xA8, 0x01, 
  0xDA, 0x06, 0xDA, 0x87, 0x4B, 0xDA, 0x08, 0xCE, 0x4D, 0x28, 0x7A, 0x69, 0x70, 0x63, 0x6F, 0x6C, 
  0x6C, 0x20, 0x6B, 0x73, 0x20, 0x76, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 
  0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 
  0x77, 0x6F, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2F, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 
  0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x87, 0x4D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x86, 0x78, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x4E, 0xDA, 0x08, 0xCE, 0x80, 0x8C, 0x28, 
  0x66, 0x72, 0x6F, 0x6D, 0x2D, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x70, 0x73, 0x29, 0x0A, 0x0A, 
  0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x72, 
  0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x70, 0x61, 0x69, 0x72, 0x2E, 0x20, 0x49, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 
  0x6F, 0x66, 0x0A, 0x60, 0x70, 0x61, 0x69, 0x72, 0x73, 0x60, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x87, 0x50, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0xE1, 0x03, 0xDA, 0x06, 0xDA, 0x38, 0xDA, 0x08, 
  0xCE, 0x6A, 0x28, 0x65, 0x76, 0x2F, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x66, 0x20, 0x26, 0x20, 0x61, 
  0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x61, 0x6C, 0x6C, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x73, 0x79, 0x6E, 0x63, 0x68, 0x72, 0x6F, 0x6E, 0x6F, 
  0x75, 0x73, 0x6C, 0x79, 0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x73, 0x63, 
  0x68, 0x65, 0x64, 0x75, 0x6C, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x87, 0x51, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x2B, 0x81, 0xD4, 0x01, 0xDA, 0x06, 0xDA, 0x84, 
  0x10, 0xDA, 0x08, 0xCE, 0x71, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 0x65, 
  0x6E, 0x76, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x29, 0x0A, 
  0x0A, 0x53, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 
  0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x53, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 
  0x6E, 0x69, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 
  0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x86, 0x9A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x83, 0xF8, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x52, 0xDA, 0x08, 0xCE, 0x80, 0xDD, 0x28, 
  0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x43, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 
  0x66, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 
  0x20, 0x65, 0x6E, 0x64, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 
  0x65, 0x6E, 0x20, 0x73, 0x74, 0x65, 0x70, 0x2E, 0x0A, 0x57, 0x69, 0x74, 0x68, 0x20, 0x6F, 0x6E, 
  0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x5B, 0x30, 0x2C, 0x20, 
  0x65, 0x6E, 0x64, 0x29, 0x2E, 0x20, 0x57, 0x69, 0x74, 0x68, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x61, 
  0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x0A, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x2C, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x2E, 0x20, 0x57, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x72, 
  0x65, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x61, 
  0x6E, 0x67, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 
  0x6C, 0x20, 0x73, 0x74, 0x65, 0x70, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x2E, 0xDA, 0x87, 0x55, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 0x83, 0x47, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x56, 
  0xDA, 0x08, 0xCE, 0x80, 0xD6, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x73, 0x65, 0x6E, 0x64, 0x2D, 0x74, 
  0x6F, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x64, 0x65, 0x73, 0x74, 0x20, 0x64, 0x61, 
  0x74, 0x61, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x29, 
  0x0A, 0x0A, 0x57, 0x72, 0x69, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x67, 
  0x72, 0x61, 0x6D, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 
  0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0x20, 0x64, 0x65, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6E, 0x61, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x2E, 0x20, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 
  0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 
  0x75, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x2C, 0x20, 0x61, 
  0x66, 0x74, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0xDA, 0x87, 0x57, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0xFB, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x58, 0xDA, 
  0x08, 0xCE, 0x80, 0xC0, 0x28, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x20, 0x26, 0x20, 0x63, 0x6F, 0x6C, 
  0x6C, 0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x65, 0x72, 0x67, 0x65, 0x73, 0x20, 0x6D, 0x75, 0x6C, 0x74, 
  0x69, 0x70, 0x6C, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2F, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 
  0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x6F, 0x72, 0x65, 
  0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E, 0x65, 0x0A, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x63, 0x6F, 0x6C, 0x6C, 0x73, 0x60, 0x2C, 
  0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x73, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x70, 
  0x72, 0x65, 0x76, 0x69, 0x6F, 0x75, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x73, 0x2E, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x87, 0x5A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 
  0x87, 0x72, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x5B, 0xDA, 0x08, 0xCE, 0x38, 0x28, 0x6F, 0x73, 0x2F, 
  0x75, 0x6D, 0x61, 0x73, 0x6B, 0x20, 0x6D, 0x61, 0x73, 0x6B, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 
  0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x75, 0x6D, 0x61, 0x73, 0x6B, 0x2C, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x6C, 0x64, 0x20, 0x75, 0x6D, 
  0x61, 0x73, 0x6B, 0x2E, 0xDA, 0x87, 0x5C, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x8B, 0xB1, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x1E, 0xDA, 0x08, 0xCE, 0x43, 
  0x57, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 
  0x6F, 0x20, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x20, 0x64, 0x6F, 0x63, 0x75, 0x6D, 
  0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x65, 0x64, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x64, 0x6F, 0x63, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 0x61, 
  0x74, 0x60, 0x2E, 0xDA, 0x87, 0x5D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x0E, 0x73, 
  0x72, 0x63, 0x2F, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x61, 0x73, 0x6D, 0x2E, 0x63, 0x83, 0xDA, 0x01, 
  0xDA, 0x06, 0xDA, 0x83, 0x45, 0xDA, 0x08, 0xCE, 0x84, 0x99, 0x28, 0x64, 0x69, 0x73, 0x61, 0x73, 
  0x6D, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x66, 0x69, 0x65, 0x6C, 
  0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x73, 0x73, 0x65, 
  0x6D, 0x62, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x75, 0x6C, 0x64, 0x20, 
  0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 
  0x6C, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x20, 0x6D, 0x75, 0x73, 0x74, 
  0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x63, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x6F, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x62, 0x61, 0x64, 0x6C, 0x79, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x64, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 
  0x20, 0x49, 0x66, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x66, 0x69, 0x65, 0x6C, 
  0x64, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6F, 0x6E, 0x6C, 
  0x79, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x70, 0x61, 
  0x72, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x2E, 0x20, 0x50, 0x6F, 0x73, 
  0x73, 0x69, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6C, 0x64, 0x73, 0x20, 0x61, 0x72, 0x65, 
  0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x61, 0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 0x6E, 0x75, 
  0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x61, 0x72, 
  0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x6D, 0x69, 0x6E, 0x2D, 
  0x61, 0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 0x6D, 0x69, 0x6E, 0x69, 0x6D, 0x75, 0x6D, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x2E, 
  0x0A, 0x2A, 0x20, 0x3A, 0x6D, 0x61, 0x78, 0x2D, 0x61, 0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 
  0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 
  0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x76, 0x61, 0x72, 0x61, 
  0x72, 0x67, 0x20, 0x2D, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x61, 
  0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x0A, 0x2A, 
  0x20, 0x3A, 0x62, 0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x2D, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 
  0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x77, 0x61, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x2D, 
  0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x6C, 0x6F, 0x74, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x20, 
  0x2D, 0x20, 0x68, 0x6F, 0x77, 0x20, 0x6D, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x69, 0x72, 0x74, 0x75, 
  0x61, 0x6C, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x73, 0x2C, 0x20, 0x6F, 0x72, 
  0x20, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x2C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x75, 0x73, 0x65, 0x73, 0x2E, 0x20, 0x43, 0x6F, 0x72, 0x72, 
  0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 
  0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x63, 0x6F, 0x6E, 0x73, 
  0x74, 0x61, 0x6E, 0x74, 0x73, 0x20, 0x2D, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x6F, 0x66, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x73, 0x20, 0x72, 0x65, 
  0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x6F, 
  0x75, 0x72, 0x63, 0x65, 0x6D, 0x61, 0x70, 0x20, 0x2D, 0x20, 0x61, 0x20, 0x6D, 0x61, 0x70, 0x70, 
  0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 
  0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 
  0x72, 0x63, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x2D, 0x20, 0x61, 0x6E, 0x20, 0x69, 
  0x6E, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 
  0x6F, 0x66, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x65, 0x6E, 0x63, 0x6C, 0x6F, 0x73, 0x69, 
  0x6E, 0x67, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 
  0x20, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x64, 0x65, 0x66, 
  0x73, 0x20, 0x2D, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x69, 0x61, 0x74, 
  0x65, 0x2E, 0x0A, 0xDA, 0x87, 0x5E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 
  0x82, 0x41, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x5F, 0xDA, 0x08, 0xCE, 0x80, 0xAD, 0x28, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x73, 0x65, 0x74, 0x29, 0x0A, 0x0A, 0x54, 0x72, 0x69, 0x6D, 0x20, 0x6C, 0x65, 
  0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 
  0x6E, 0x67, 0x20, 0x77, 0x68, 0x69, 0x74, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 
  0x63, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x60, 0x73, 0x65, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 
  0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 
  0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x60, 0x73, 0x65, 0x74, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x77, 
  0x68, 0x69, 0x74, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x87, 0x60, 0xD3, 0x04, 0xDA, 
  0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 0xA9, 0x01, 0xDA, 0x06, 0xDA, 
  0x87, 0x61, 0xDA, 0x08, 0xCE, 0x80, 0x91, 0x54, 0x68, 0x65, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x69, 
  0x63, 0x69, 0x74, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 
  0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 
  0x6C, 0x69, 0x6E, 0x67, 0x20, 0x50, 0x45, 0x47, 0x73, 0x2E, 0x20, 0x41, 0x6E, 0x79, 0x20, 0x75, 
  0x6E, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x64, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 
  0x73, 0x0A, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x70, 0x65, 0x67, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x69, 0x6E, 0x20, 
  0x74, 0x68, 0x69, 0x73, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x28, 0x69, 0x66, 0x20, 0x64, 
  0x65, 0x66, 0x69, 0x6E, 0x65, 0x64, 0x29, 0x2E, 0xDA, 0x87, 0x62, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x85, 0x7A, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x63, 0xDA, 0x08, 0xCE, 0x43, 
  0x28, 0x61, 0x6E, 0x79, 0x3F, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 
  0x75, 0x74, 0x68, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x69, 
  0x6E, 0x64, 0x60, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x6E, 
  0x69, 0x6C, 0x2E, 0xDA, 0x87, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 
  0x82, 0x07, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x66, 0xDA, 0x08, 0xCE, 0x70, 0x28, 0x67, 0x63, 0x69, 
  0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6E, 0x75, 
  0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 
  0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x74, 0x65, 0x72, 
  0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 
  0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x87, 0x67, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x83, 0xE5, 0x01, 0xDA, 0x06, 0xDA, 0x87, 
  0x68, 0xDA, 0x08, 0xCE, 0x60, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x62, 0x79, 0x74, 
  0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x62, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x70, 
  0x75, 0x74, 0x20, 0x61, 0x20, 0x73, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x20, 0x60, 0x62, 0x60, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x2E, 0xDA, 0x87, 0x69, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x82, 0xA1, 0x81, 0x58, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x4C, 0xDA, 0x08, 0xCE, 0x80, 0x80, 0x28, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x20, 0x61, 0x72, 0x72, 0x29, 
  0x0A, 0x0A, 0x45, 0x6D, 0x70, 0x74, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x2C, 0x20, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x74, 0x27, 0x73, 
  0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x30, 0x20, 0x62, 0x75, 0x74, 0x20, 
  0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x72, 0x65, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 
  0x74, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 
  0x87, 0x6A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x27, 0x01, 0xDA, 0x06, 
  0xDA, 0x85, 0xE2, 0xDA, 0x08, 0xCE, 0x1C, 0x28, 0x6F, 0x64, 0x64, 0x3F, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x6F, 
  0x64, 0x64, 0x2E, 0xDA, 0x87, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 
  0x63, 0x01, 0xDA, 0x06, 0xDA, 0x80, 0xDF, 0xDA, 0x08, 0xCE, 0x81, 0xC7, 0x28, 0x72, 0x65, 0x64, 
  0x75, 0x63, 0x65, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x2C, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x6B, 0x6E, 
  0x6F, 0x77, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x6C, 0x64, 0x2D, 0x6C, 0x65, 0x66, 0x74, 0x20, 
  0x69, 0x6E, 0x20, 0x6D, 0x61, 0x6E, 0x79, 0x20, 0x6C, 0x61, 0x6E, 0x67, 0x75, 0x61, 0x67, 0x65, 
  0x73, 0x2C, 0x20, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x0A, 0x61, 0x6E, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x28, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x29, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 
  0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x62, 0x79, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x79, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x66, 0x60, 0x20, 
  0x74, 0x6F, 0x0A, 0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x60, 0x66, 0x60, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x32, 
  0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x60, 0x28, 0x66, 0x20, 
  0x61, 0x63, 0x63, 0x75, 0x6D, 0x20, 0x65, 0x6C, 0x29, 0x60, 0x2C, 0x20, 0x77, 0x68, 0x65, 0x72, 
  0x65, 0x0A, 0x60, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x60, 0x65, 0x6C, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 
  0x65, 0x78, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x60, 0x69, 
  0x6E, 0x64, 0x60, 0x2E, 0x0A, 0x60, 0x66, 0x60, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x60, 0x61, 
  0x63, 0x63, 0x75, 0x6D, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 
  0x74, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x66, 0x60, 0x2E, 0x20, 0x60, 
  0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x60, 0x0A, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x60, 
  0x66, 0x60, 0x2E, 0xDA, 0x87, 0x6C, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 
  0xF4, 0x03, 0xDA, 0x06, 0xDA, 0x87, 0x6D, 0xDA, 0x08, 0xCE, 0x6A, 0x28, 0x65, 0x76, 0x2F, 0x73, 
  0x70, 0x61, 0x77, 0x6E, 0x2D, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x26, 0x20, 0x62, 0x6F, 
  0x64, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x63, 0x6F, 
  0x64, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x68, 0x72, 0x65, 
  0x61, 0x64, 0x2E, 0x20, 0x4C, 0x69, 0x6B, 0x65, 0x20, 0x60, 0x65, 0x76, 0x2F, 0x64, 0x6F, 0x2D, 
  0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x6D, 0x6D, 0x65, 0x64, 0x69, 0x61, 
  0x74, 0x65, 0x6C, 0x79, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x87, 0x71, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x12, 0x81, 0x4F, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x72, 0xDA, 0x08, 0xCE, 0x82, 
  0x1C, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x68, 0x6F, 
  0x73, 0x74, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x79, 0x70, 
  0x65, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x6F, 0x6B, 0x20, 0x75, 
  0x70, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x68, 0x6F, 0x73, 0x74, 0x6E, 0x61, 0x6D, 
  0x65, 0x2C, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6E, 
  0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 
  0x74, 0x6F, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x67, 0x72, 0x61, 0x6D, 
  0x73, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x6E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x65, 0x73, 0x74, 0x61, 0x62, 0x6C, 0x69, 0x73, 0x68, 
  0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x2E, 0x20, 0x4F, 0x6E, 0x20, 0x50, 0x6F, 0x73, 0x69, 0x78, 0x20, 0x70, 0x6C, 0x61, 0x74, 0x66, 
  0x6F, 0x72, 0x6D, 0x73, 0x2C, 0x20, 0x79, 0x6F, 0x75, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x75, 0x73, 
  0x65, 0x20, 0x3A, 0x75, 0x6E, 0x69, 0x78, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x68, 0x6F, 0x73, 0x74, 
  0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x61, 
  0x20, 0x75, 0x6E, 0x69, 0x78, 0x20, 0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E, 0x20, 0x73, 0x6F, 0x63, 
  0x6B, 0x65, 0x74, 0x2C, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 
  0x61, 0x6D, 0x65, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x69, 0x6E, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x2E, 0x20, 0x4F, 0x6E, 0x20, 0x4C, 0x69, 0x6E, 0x75, 0x78, 0x2C, 0x20, 0x61, 0x62, 0x73, 
  0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x75, 0x6E, 0x69, 0x78, 0x20, 0x64, 0x6F, 0x6D, 0x61, 0x69, 
  0x6E, 0x20, 0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x70, 
  0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x6C, 
  0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x27, 0x40, 0x27, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 
  0x63, 0x74, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x2E, 0x20, 0x49, 0x66, 
  0x20, 0x60, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 
  0x68, 0x79, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 
  0x61, 0x6C, 0x6C, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x6A, 0x75, 
  0x73, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x2E, 0xDA, 0x87, 0x73, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x77, 0x01, 0xDA, 0x06, 0xDA, 0x87, 
  0x74, 0xDA, 0x08, 0xCE, 0x31, 0x28, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x6F, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x20, 
  0x70, 0x6F, 0x69, 0x6E, 0x74, 0x2E, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x2D, 0x69, 0x6E, 
  0x66, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x98, 0x01, 0xDA, 0x06, 
  0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xDA, 0x08, 0xCE, 0x29, 0x54, 0x68, 0x65, 
  0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 
  0x74, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6E, 
  0x66, 0x69, 0x6E, 0x69, 0x74, 0x79, 0xDA, 0x87, 0x77, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x81, 0x42, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0xB1, 0xDA, 0x08, 0xCE, 0x80, 0x96, 0x28, 
  0x64, 0x65, 0x66, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 
  0x79, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x60, 0x66, 0x6F, 0x72, 0x6D, 0x60, 0x20, 0x75, 
  0x6E, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x61, 
  0x66, 0x74, 0x65, 0x72, 0x20, 0x60, 0x62, 0x6F, 0x64, 0x79, 0x60, 0x2C, 0x20, 0x65, 0x76, 0x65, 
  0x6E, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x74, 0x68, 
  0x72, 0x6F, 0x77, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0x0A, 0x57, 
  0x69, 0x6C, 0x6C, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x60, 0x66, 0x6F, 
  0x72, 0x6D, 0x60, 0x20, 0x69, 0x66, 0x20, 0x61, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x69, 
  0x67, 0x6E, 0x61, 0x6C, 0x20, 0x30, 0x2D, 0x34, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 
  0x69, 0x76, 0x65, 0x64, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x87, 0x78, 0xD3, 0x04, 0xDA, 0x81, 0x07, 
  0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xAF, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x79, 
  0xDA, 0x08, 0xCE, 0x2D, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 
  0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 
  0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x74, 0x6F, 
  0x2E, 0xDA, 0x87, 0x7A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x63, 0x01, 0xDA, 
  0x06, 0xDA, 0x87, 0x7B, 0xDA, 0x08, 0xCE, 0x1C, 0x28, 0x6E, 0x61, 0x6E, 0x3F, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 
  0x4E, 0x61, 0x4E, 0x2E, 0xDA, 0x87, 0x7D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 
  0xC1, 0x81, 0x06, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x1D, 0xDA, 0x08, 0xCE, 0x66, 0x28, 0x64, 0x79, 
  0x6E, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 
  0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 
  0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x28, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x29, 0x20, 0x69, 
  0x66, 0x20, 0x6E, 0x6F, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x75, 
  0x6E, 0x64, 0x2E, 0xDA, 0x87, 0x7E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x15, 
  0x85, 0xE7, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x7F, 0xDA, 0x08, 0xCE, 0x80, 0xBE, 0x28, 0x75, 0x6E, 
  0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x29, 0x0A, 0x0A, 0x55, 0x6E, 0x6D, 
  0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x41, 0x6E, 
  0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 
  0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x62, 
  0x65, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x75, 0x6E, 
  0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x87, 0x80, 0xD3, 0x04, 
  0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xBC, 0x01, 0xDA, 0x06, 
  0xDA, 0x84, 0x1C, 0xDA, 0x08, 0xCE, 0x80, 0x8F, 0x54, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 
  0x65, 0x6E, 0x74, 0x20, 0x6C, 0x69, 0x6E, 0x74, 0x20, 0x77, 0x61, 0x72, 0x6E, 0x69, 0x6E, 0x67, 
  0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x77, 0x61, 0x72, 0x6E, 
  0x69, 0x6E, 0x67, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6C, 0x69, 0x6E, 0x74, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x61, 0x74, 0x20, 0x77, 
  0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x65, 0x64, 0x20, 0x62, 
  0x75, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x6E, 0x75, 0x65, 0x20, 0x61, 0x73, 0x20, 
  0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x2E, 0xDA, 0x87, 0x81, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x84, 0xC1, 0x81, 0x73, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x82, 0xDA, 0x08, 0xCE, 0x2E, 
  0x28, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0xDA, 0x87, 
  0x83, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xEC, 0x01, 0xDA, 0x06, 0xDA, 
  0x81, 0x65, 0xDA, 0x08, 0xCE, 0x3F, 0x28, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x78, 0x73, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x87, 0x84, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x83, 0x24, 0x01, 0xDA, 0x06, 0xDA, 0x86, 0x33, 0xDA, 0x08, 0xCE, 0x24, 0x28, 0x6E, 0x65, 
  0x67, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 
  0x78, 0x20, 0x69, 0x73, 0x20, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x30, 
  0x2E, 0xDA, 0x87, 0x85, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0xF7, 
  0x01, 0xDA, 0x06, 0xDA, 0x87, 0x86, 0xDA, 0x08, 0xCE, 0x80, 0xD3, 0x28, 0x67, 0x63, 0x73, 0x65, 
  0x74, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 
  0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x67, 0x65, 0x72, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 
  0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 
  0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x67, 
  0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x2E, 0x20, 0x4C, 0x6F, 0x77, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x62, 0x65, 0x20, 0x73, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 
  0x65, 0x20, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x2E, 0x20, 0x48, 
  0x69, 0x67, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x62, 0x65, 0x20, 0x66, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 
  0x65, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x2E, 0xDA, 0x87, 
  0x87, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0xA1, 0x80, 0xC7, 0x01, 0xDA, 0x06, 
  0xDA, 0x87, 0x88, 0xDA, 0x08, 0xCE, 0x81, 0x56, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x65, 
  0x6E, 0x73, 0x75, 0x72, 0x65, 0x20, 0x61, 0x72, 0x72, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 
  0x74, 0x79, 0x20, 0x67, 0x72, 0x6F, 0x77, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x45, 0x6E, 0x73, 0x75, 
  0x72, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x65, 0x6D, 
  0x6F, 0x72, 0x79, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65, 0x20, 0x65, 
  0x6E, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x63, 0x61, 0x70, 0x61, 0x63, 
  0x69, 0x74, 0x79, 0x60, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x67, 0x72, 0x6F, 0x77, 0x74, 0x68, 0x2E, 0x20, 0x60, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 
  0x79, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x67, 0x72, 0x6F, 0x77, 0x74, 0x68, 0x60, 0x20, 
  0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x73, 
  0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 
  0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6C, 0x72, 
  0x65, 0x61, 0x64, 0x79, 0x20, 0x65, 0x6E, 0x6F, 0x75, 0x67, 0x68, 0x2C, 0x20, 0x74, 0x68, 0x65, 
  0x6E, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x4F, 0x74, 
  0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x63, 
  0x6B, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 
  0x73, 0x6F, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 
  0x20, 0x65, 0x6E, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x87, 
  0x89, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x2B, 0x81, 0xC9, 0x01, 0xDA, 0x06, 
  0xDA, 0x83, 0x2F, 0xDA, 0x08, 0xCE, 0x60, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x67, 0x65, 
  0x74, 0x65, 0x6E, 0x76, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 
  0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x73, 
  0x65, 0x74, 0x20, 0x79, 0x65, 0x74, 0x2E, 0xDA, 0x87, 0x8A, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x82, 0x0B, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x8B, 0xDA, 0x08, 0xCE, 0x6D, 0x28, 
  0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x20, 0x6E, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 
  0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 
  0x6E, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x20, 0x69, 0x73, 
  0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2C, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 
  0x64, 0x20, 0x30, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x2E, 0x20, 0x45, 0x76, 0x61, 0x6C, 0x75, 
  0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 
  0x87, 0x8E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x68, 0x01, 0xDA, 0x06, 0xDA, 
  0x85, 0x76, 0xDA, 0x08, 0xCE, 0x26, 0x28, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x3F, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2E, 0xDA, 0x87, 0x8F, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x6D, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x90, 0xDA, 
  0x08, 0xCE, 0x1F, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x2E, 0xDA, 0x87, 0x92, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x8B, 0x1B, 0x81, 
  0x0D, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x93, 0xDA, 0x08, 0xCE, 0x80, 0xA5, 0x28, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x2F, 0x74, 0x6F, 0x2D, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x74, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65, 0x29, 0x0A, 
  0x0A, 0x43, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x49, 0x66, 
  0x20, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 
  0x75, 0x65, 0x2C, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x27, 0x73, 0x20, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x27, 0x73, 0x20, 0x70, 0x72, 
  0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6C, 0x6C, 
  0x2E, 0xDA, 0x87, 0x94, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 0x83, 0x14, 0x01, 
  0xDA, 0x06, 0xDA, 0x87, 0x95, 0xDA, 0x08, 0xCE, 0x80, 0xC1, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x63, 
  0x68, 0x75, 0x6E, 0x6B, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x6E, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x6F, 0x75, 0x74, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x74, 
  0x2F, 0x72, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x77, 0x61, 0x69, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6E, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x72, 0x72, 0x69, 0x76, 0x65, 0x20, 0x72, 
  0x61, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x20, 0x65, 0x61, 0x72, 0x6C, 0x79, 0x2E, 0x20, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 
  0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 
  0x75, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x2C, 0x20, 0x61, 
  0x66, 0x74, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x87, 0x96, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0x67, 0x81, 0x7F, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x97, 
  0xDA, 0x08, 0xCE, 0x80, 0xCF, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x61, 0x72, 0x67, 0x2D, 
  0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x47, 0x65, 
  0x74, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x73, 0x74, 0x61, 0x63, 0x6B, 0x2E, 0x20, 0x4E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x6C, 0x79, 0x2C, 
  0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 
  0x65, 0x6D, 0x70, 0x74, 0x79, 0x20, 0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x77, 
  0x68, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x75, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x72, 0x67, 
  0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x61, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2E, 0xDA, 0x87, 0x98, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 
  0x01, 0x82, 0x61, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0xBE, 0xDA, 0x08, 0xCE, 0x80, 0x80, 0x28, 0x65, 
  0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 
  0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x69, 0x66, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 
  0x72, 0x6D, 0x61, 0x74, 0x20, 0x66, 0x6D, 0x74, 0x20, 0x3B, 0x78, 0x73, 0x29, 0x60, 0x20, 0x74, 
  0x6F, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x20, 0x73, 0x74, 0x64, 
  0x65, 0x72, 0x72, 0x29, 0x60, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x74, 0x72, 0x61, 
  0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x87, 
  0x99, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8B, 0xA4, 0x01, 0xDA, 0x06, 0xDA, 
  0x87, 0x9A, 0xDA, 0x08, 0xCE, 0x81, 0x33, 0x28, 0x65, 0x76, 0x2F, 0x64, 0x65, 0x61, 0x64, 0x6C, 
  0x69, 0x6E, 0x65, 0x20, 0x73, 0x65, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x6F, 0x63, 
  0x61, 0x6E, 0x63, 0x65, 0x6C, 0x20, 0x74, 0x6F, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 
  0x53, 0x65, 0x74, 0x20, 0x61, 0x20, 0x64, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x60, 0x74, 0x6F, 0x63, 0x68, 
  0x65, 0x63, 0x6B, 0x60, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x74, 0x6F, 0x63, 0x68, 0x65, 0x63, 
  0x6B, 0x60, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x6E, 0x69, 0x73, 0x68, 
  0x65, 0x64, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x60, 0x73, 0x65, 0x63, 0x60, 0x20, 0x73, 
  0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x2C, 0x20, 0x60, 0x74, 0x6F, 0x63, 0x61, 0x6E, 0x63, 0x65, 
  0x6C, 0x60, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x63, 0x65, 
  0x6C, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x65, 0x76, 0x2F, 
  0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x60, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x74, 0x6F, 0x63, 
  0x61, 0x6E, 0x63, 0x65, 0x6C, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x74, 0x6F, 0x63, 0x68, 
  0x65, 0x63, 0x6B, 0x60, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x67, 0x69, 0x76, 
  0x65, 0x6E, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 
  0x20, 0x74, 0x6F, 0x20, 0x60, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x72, 0x6F, 0x6F, 0x74, 
  0x29, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 
  0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x29, 0x60, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 
  0x69, 0x76, 0x65, 0x6C, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x60, 
  0x74, 0x6F, 0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x60, 0x2E, 0xDA, 0x87, 0x9B, 0xD3, 0x04, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0xAD, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x9C, 0xDA, 0x08, 
  0xCE, 0x74, 0x28, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x20, 0x76, 
  0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 0x64, 0x65, 
  0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x0A, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x60, 0x28, 0x64, 0x65, 0x66, 0x20, 0x73, 0x79, 0x6D, 0x20, 0x28, 0x69, 0x66, 0x20, 0x28, 
  0x3D, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x73, 0x79, 0x6D, 0x29, 0x20, 0x76, 0x61, 0x6C, 0x20, 0x73, 
  0x79, 0x6D, 0x29, 0x29, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x84, 0xB9, 0xCE, 0x14, 0x2F, 0x75, 
  0x73, 0x72, 0x2F, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x2F, 0x6C, 0x69, 0x62, 0x2F, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0xDA, 0x87, 0x9E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x12, 0x82, 0xE5, 
  0x01, 0xDA, 0x06, 0xDA, 0x3C, 0xDA, 0x08, 0xCE, 0x80, 0xC7, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x61, 
  0x63, 0x63, 0x65, 0x70, 0x74, 0x2D, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 
  0x6D, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 
  0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 
  0x67, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 
  0x6D, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x63, 0x6F, 0x6E, 0x74, 
  0x69, 0x6E, 0x75, 0x6F, 0x75, 0x73, 0x6C, 0x79, 0x20, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 
  0x20, 0x42, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 
  0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6C, 
  0x6F, 0x73, 0x65, 0x64, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 
  0x2E, 0xDA, 0x87, 0x9F, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x87, 0xA0, 0xDA, 0x08, 0xCE, 0x80, 0x92, 
  0x28, 0x62, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x78, 0x20, 0x26, 0x20, 0x73, 0x68, 0x69, 
  0x66, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x20, 0x62, 0x69, 0x74, 
  0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x65, 0x64, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x62, 
  0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 
  0x73, 0x2E, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x6D, 
  0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 
  0x72, 0x2E, 0xDA, 0x87, 0xA2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x81, 
  0x3A, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xA3, 0xDA, 0x08, 0xCE, 0x81, 0xCF, 0x28, 0x66, 0x69, 0x6C, 
  0x65, 0x2F, 0x73, 0x65, 0x65, 0x6B, 0x20, 0x66, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x77, 0x68, 
  0x65, 0x6E, 0x63, 0x65, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x4A, 0x75, 0x6D, 0x70, 0x20, 0x74, 0x6F, 
  0x20, 0x61, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x60, 0x66, 0x60, 0x2E, 0x20, 0x60, 0x77, 0x68, 0x65, 0x6E, 0x63, 0x65, 0x60, 0x20, 0x6D, 
  0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 
  0x2A, 0x20, 0x3A, 0x63, 0x75, 0x72, 0x20, 0x2D, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x20, 0x72, 0x65, 
  0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x65, 0x74, 0x20, 0x2D, 0x20, 0x6A, 0x75, 
  0x6D, 0x70, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x62, 0x65, 0x67, 0x69, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x65, 0x6E, 0x64, 
  0x20, 0x2D, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x0A, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 
  0x75, 0x6C, 0x74, 0x2C, 0x20, 0x60, 0x77, 0x68, 0x65, 0x6E, 0x63, 0x65, 0x60, 0x20, 0x69, 0x73, 
  0x20, 0x3A, 0x63, 0x75, 0x72, 0x2E, 0x20, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 
  0x79, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x60, 0x6E, 0x60, 0x20, 0x6D, 0x61, 
  0x79, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x73, 0x65, 0x65, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x2E, 0x20, 0x60, 0x6E, 0x60, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x72, 
  0x65, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x68, 0x61, 
  0x6E, 0x64, 0x6C, 0x65, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 
  0x20, 0x6F, 0x66, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x34, 0x47, 
  0x42, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x2E, 0xDA, 0x87, 0xA4, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x0E, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xA5, 0xDA, 
  0x08, 0xCE, 0x63, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3C, 0x20, 0x26, 0x20, 0x78, 
  0x73, 0x29, 0x0A, 0x0A, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 
  0x66, 0x20, 0x60, 0x3C, 0x60, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 
  0x70, 0x6F, 0x6C, 0x79, 0x6D, 0x6F, 0x72, 0x70, 0x68, 0x69, 0x63, 0x20, 0x60, 0x63, 0x6F, 0x6D, 
  0x70, 0x61, 0x72, 0x65, 0x60, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 
  0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 
  0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0xDA, 0x87, 0xA7, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x83, 0x09, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xA8, 0xDA, 0x08, 0xCE, 0x63, 0x28, 0x63, 
  0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x45, 
  0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x3D, 0x60, 
  0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x6F, 0x6C, 0x79, 0x6D, 
  0x6F, 0x72, 0x70, 0x68, 0x69, 0x63, 0x20, 0x60, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x60, 
  0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x72, 0x69, 0x6D, 
  0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 
  0x2E, 0xDA, 0x87, 0xAA, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x18, 0x01, 
  0xDA, 0x06, 0xDA, 0x87, 0xAB, 0xDA, 0x08, 0xCE, 0x63, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 
  0x65, 0x3E, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 
  0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x3E, 0x60, 0x20, 0x62, 0x75, 0x74, 0x20, 
  0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x6F, 0x6C, 0x79, 0x6D, 0x6F, 0x72, 0x70, 0x68, 0x69, 
  0x63, 0x20, 0x60, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x60, 0x20, 0x69, 0x6E, 0x73, 0x74, 
  0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2E, 0xDA, 0x87, 0xAD, 0xD3, 
  0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8E, 0x0A, 0x03, 0xDA, 0x06, 0xDA, 0x87, 0xAE, 
  0xDA, 0x08, 0xCE, 0x80, 0x92, 0x28, 0x65, 0x76, 0x2F, 0x67, 0x61, 0x74, 0x68, 0x65, 0x72, 0x20, 
  0x26, 0x20, 0x62, 0x6F, 0x64, 0x69, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 
  0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6C, 0x6C, 0x65, 0x6C, 0x20, 0x6F, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2C, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x6A, 0x6F, 0x69, 0x6E, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x79, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x2E, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x61, 0x74, 0x68, 0x65, 0x72, 
  0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x87, 0xB6, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x89, 0xF2, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0xE0, 0xDA, 0x08, 
  0xCE, 0x7C, 0x28, 0x65, 0x76, 0x61, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x29, 0x0A, 0x0A, 0x45, 
  0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6D, 
  0x6F, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x20, 0x6F, 0x76, 0x65, 0x72, 
  0x20, 0x74, 0x68, 0x65, 0x0A, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x75, 0x73, 0x65, 0x20, 
  0x60, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x60, 0x2E, 0xDA, 0x87, 
  0xB7, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8E, 0xCE, 
  0x01, 0xDA, 0x06, 0xDA, 0x87, 0xB8, 0xDA, 0x08, 0xCE, 0x80, 0x8E, 0x4E, 0x61, 0x6D, 0x65, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 
  0x65, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x75, 0x73, 
  0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x74, 0x68, 
  0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0x20, 0x43, 0x6F, 0x72, 0x72, 
  0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x61, 0x72, 0x67, 0x76, 
  0x5B, 0x30, 0x5D, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 
  0x20, 0x74, 0x6F, 0x0A, 0x20, 0x20, 0x60, 0x69, 0x6E, 0x74, 0x20, 0x6D, 0x61, 0x69, 0x6E, 0x28, 
  0x69, 0x6E, 0x74, 0x20, 0x61, 0x72, 0x67, 0x63, 0x2C, 0x20, 0x63, 0x68, 0x61, 0x72, 0x20, 0x2A, 
  0x2A, 0x61, 0x72, 0x67, 0x76, 0x29, 0x3B, 0x60, 0x2E, 0xDA, 0x87, 0xB9, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x04, 0x86, 0x0C, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xBA, 0xDA, 0x08, 0xCE, 
  0x5A, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x64, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x64, 0x69, 
  0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x6F, 0x6E, 0x20, 
  0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x2C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 
  0x6F, 0x6E, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x87, 0xBB, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0xA1, 0x81, 0x26, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xF0, 
  0xDA, 0x08, 0xCE, 0x80, 0xEF, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x72, 0x65, 0x6D, 0x6F, 
  0x76, 0x65, 0x20, 0x61, 0x72, 0x72, 0x20, 0x61, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 
  0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 
  0x60, 0x6E, 0x60, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 
  0x61, 0x74, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x60, 0x61, 0x72, 
  0x72, 0x60, 0x2E, 0x20, 0x60, 0x61, 0x74, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 
  0x65, 0x78, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6E, 0x64, 
  0x65, 0x78, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x6E, 0x60, 0x20, 0x6D, 0x75, 0x73, 0x74, 
  0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 
  0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x60, 0x6E, 0x60, 0x20, 0x69, 0x73, 0x20, 0x31, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2E, 0xDA, 0x87, 0xBC, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 
  0x85, 0x90, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xED, 0xDA, 0x08, 0xCE, 0x80, 0xB4, 0x28, 0x72, 0x65, 
  0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x76, 0x65, 0x72, 0x73, 
  0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x0A, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 
  0x49, 0x66, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 
  0x64, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x69, 0x74, 0x73, 0x0A, 0x62, 0x79, 0x74, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2C, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x64, 
  0x2E, 0xDA, 0x87, 0xBD, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x2B, 0x82, 0x69, 
  0x01, 0xDA, 0x06, 0xDA, 0x87, 0xBE, 0xDA, 0x08, 0xCE, 0x80, 0x8E, 0x28, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x69, 
  0x62, 0x20, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x6A, 0x61, 0x6E, 0x65, 
  0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 
  0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x75, 0x61, 
  0x6C, 0x6C, 0x79, 0x20, 0x38, 0x31, 0x39, 0x32, 0x2E, 0xDA, 0x87, 0xBF, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x7C, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xC0, 0xDA, 0x08, 0xCE, 0x1E, 
  0x28, 0x74, 0x72, 0x75, 0x65, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0xDA, 0x87, 
  0xC2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8C, 0x4C, 0x01, 0xDA, 0x06, 0xDA, 
  0x87, 0xC3, 0xDA, 0x08, 0xCE, 0x45, 0x28, 0x65, 0x76, 0x2F, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72, 
  0x65, 0x2D, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x72, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0x29, 0x0A, 
  0x0A, 0x41, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x61, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 
  0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2D, 
  0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x2E, 0xDA, 0x87, 0xC4, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x58, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xC5, 0xDA, 
  0x08, 0xCE, 0x43, 0x28, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6E, 0x63, 0x74, 0x20, 0x78, 0x73, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x64, 0x75, 0x70, 0x6C, 
  0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x60, 0x78, 0x73, 0x60, 0x2E, 0xDA, 0x87, 0xC7, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x84, 0xC1, 0x81, 0xBE, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xC8, 0xDA, 0x08, 0xCE, 0x5E, 0x28, 
  0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x60, 0x78, 0x60, 0x20, 0x68, 0x61, 0x73, 0x20, 
  0x6E, 0x6F, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2E, 0xDA, 0x87, 0xC9, 
  0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x87, 0xCA, 0xDA, 0x08, 0xCE, 0x80, 0xE3, 0x28, 0x79, 0x69, 0x65, 
  0x6C, 0x64, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x59, 0x69, 0x65, 0x6C, 
  0x64, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x70, 
  0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x68, 0x65, 
  0x6E, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x73, 
  0x2C, 0x20, 0x69, 0x74, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x69, 0x73, 0x20, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 
  0x61, 0x6E, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x72, 
  0x65, 0x73, 0x75, 0x6D, 0x65, 0x73, 0x20, 0x69, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x72, 
  0x65, 0x73, 0x75, 0x6D, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 
  0x61, 0x73, 0x74, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x61, 0x73, 0x20, 0x70, 0x61, 
  0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x2E, 0xDA, 
  0x87, 0xCC, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x81, 0xF5, 0x01, 0xDA, 
  0x06, 0xDA, 0x87, 0xCD, 0xDA, 0x08, 0xCE, 0x40, 0x28, 0x70, 0x72, 0x69, 0x6E, 0x20, 0x26, 0x20, 
  0x78, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x70, 0x72, 
  0x69, 0x6E, 0x74, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x61, 0x64, 0x64, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 
  0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x87, 0xCE, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x80, 0xD5, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xCF, 0xDA, 0x08, 0xCE, 0x80, 
  0xBB, 0x28, 0x63, 0x61, 0x73, 0x65, 0x20, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 
  0x26, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x6C, 0x65, 0x63, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 
  0x71, 0x75, 0x61, 0x6C, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 
  0x63, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x57, 0x68, 0x65, 0x6E, 0x20, 0x60, 
  0x70, 0x61, 0x69, 0x72, 0x73, 0x60, 0x0A, 0x68, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x64, 
  0x64, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x69, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x65, 0x78, 
  0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 
  0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 
  0x87, 0xD1, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xCE, 0x13, 0x73, 0x72, 0x63, 0x2F, 0x63, 
  0x6F, 0x72, 0x65, 0x2F, 0x69, 0x6E, 0x74, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2E, 0x63, 0x80, 0xD4, 
  0x01, 0xDA, 0x06, 0xDA, 0x87, 0xD2, 0xDA, 0x08, 0xCE, 0x73, 0x28, 0x69, 0x6E, 0x74, 0x2F, 0x74, 
  0x6F, 0x2D, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 
  0x0A, 0x43, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x2F, 
  0x75, 0x36, 0x34, 0x20, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x74, 0x2F, 0x73, 0x36, 0x34, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x46, 0x61, 0x69, 0x6C, 
  0x73, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 
  0x69, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x33, 0x32, 0x2E, 0xDA, 0x87, 0xD3, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0x95, 0x01, 0xDA, 0x06, 0xDA, 
  0x87, 0xD4, 0xDA, 0x08, 0xCE, 0x81, 0x1F, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 
  0x6C, 0x69, 0x74, 0x20, 0x64, 0x65, 0x73, 0x74, 0x20, 0x73, 0x72, 0x63, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x64, 0x65, 0x73, 0x74, 0x2D, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x73, 0x72, 0x63, 
  0x2D, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x73, 0x72, 0x63, 0x2D, 0x65, 0x6E, 0x64, 0x29, 0x0A, 
  0x0A, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x73, 0x72, 0x63, 0x60, 0x20, 0x69, 0x6E, 
  0x74, 0x6F, 0x20, 0x60, 0x64, 0x65, 0x73, 0x74, 0x60, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x6F, 
  0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x69, 
  0x6E, 0x64, 0x69, 0x63, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x69, 
  0x63, 0x61, 0x74, 0x65, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 
  0x6F, 0x66, 0x20, 0x60, 0x73, 0x72, 0x63, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x70, 0x79, 
  0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x70, 0x61, 0x72, 0x74, 
  0x20, 0x6F, 0x66, 0x20, 0x60, 0x64, 0x65, 0x73, 0x74, 0x60, 0x2E, 0x20, 0x49, 0x6E, 0x64, 0x69, 
  0x63, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 
  0x69, 0x76, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 
  0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 
  0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x73, 0x72, 0x63, 0x60, 0x20, 0x6F, 0x72, 0x20, 0x60, 
  0x64, 0x65, 0x73, 0x74, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x60, 
  0x64, 0x65, 0x73, 0x74, 0x60, 0x2E, 0xDA, 0x87, 0xD5, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x80, 0xA4, 0x81, 0x0A, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xD6, 0xDA, 0x08, 0xCE, 0x2B, 0x28, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x63, 0x74, 0x61, 0x6E, 
  0x67, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x87, 0xD7, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0x82, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xD8, 0xDA, 0x08, 
  0xCE, 0x63, 0x28, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x21, 0x20, 0x74, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x64, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x0A, 0x6D, 0x75, 0x74, 
  0x61, 0x74, 0x65, 0x64, 0x2E, 0xDA, 0x87, 0xDA, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x04, 0x88, 0x93, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xDB, 0xDA, 0x08, 0xCE, 0x80, 0xC5, 0x28, 0x6F, 
  0x73, 0x2F, 0x70, 0x69, 0x70, 0x65, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 
  0x61, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 
  0x6D, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x77, 0x72, 0x69, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 
  0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x65, 0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x74, 0x77, 0x6F, 0x2D, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x74, 
  0x72, 0x65, 0x61, 0x6D, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 
  0x6F, 0x6E, 0x64, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 
  0x61, 0x6D, 0x2E, 0xDA, 0x87, 0xDC, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 
  0x82, 0x1E, 0x01, 0xDA, 0x06, 0xDA, 0x1C, 0xDA, 0x08, 0xCE, 0x81, 0x02, 0x28, 0x74, 0x79, 0x70, 
  0x65, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x78, 0x60, 0x20, 0x61, 0x73, 
  0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2E, 0x20, 0x60, 0x78, 0x60, 0x20, 
  0x69, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6E, 
  0x69, 0x6C, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x0A, 0x0A, 
  0x2A, 0x20, 0x3A, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x0A, 0x0A, 0x2A, 
  0x20, 0x3A, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x0A, 0x0A, 0x2A, 
  0x20, 0x3A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x79, 0x6D, 
  0x62, 0x6F, 0x6C, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x0A, 
  0x0A, 0x2A, 0x20, 0x3A, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x0A, 0x2A, 0x20, 
  0x3A, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x0A, 0x0A, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x6F, 0x74, 0x68, 0x65, 0x72, 
  0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0xDA, 0x87, 
  0xDD, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x82, 0x6E, 0x01, 0xDA, 0x06, 
  0xDA, 0x84, 0xEB, 0xDA, 0x08, 0xCE, 0x69, 0x28, 0x6E, 0x61, 0x74, 0x3F, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x62, 0x65, 0x20, 0x65, 0x78, 0x61, 0x63, 0x74, 0x6C, 0x79, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 
  0x73, 0x65, 0x6E, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 
  0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x33, 0x32, 0x20, 0x62, 0x69, 0x74, 0x20, 
  0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x74, 0x77, 0x6F, 0x27, 0x73, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 
  0xDA, 0x87, 0xDE, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 0xFA, 0x01, 0xDA, 
  0x06, 0xDA, 0x87, 0xDF, 0xDA, 0x08, 0xCE, 0x83, 0xA6, 0x28, 0x6F, 0x73, 0x2F, 0x6F, 0x70, 0x65, 
  0x6E, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x66, 0x6C, 0x61, 0x67, 
  0x73, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x50, 
  0x4F, 0x53, 0x49, 0x58, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 
  0x20, 0x63, 0x61, 0x6C, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0x20, 0x60, 0x6D, 0x6F, 
  0x64, 0x65, 0x60, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x6C, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x61, 0x73, 0x20, 0x70, 0x61, 0x73, 
  0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x6F, 0x73, 0x2F, 0x63, 0x68, 0x6D, 0x6F, 0x64, 
  0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x69, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x20, 0x69, 
  0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 
  0x61, 0x75, 0x6C, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x73, 0x20, 0x38, 0x72, 0x36, 
  0x36, 0x36, 0x2E, 0x20, 0x41, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x20, 0x66, 0x6C, 0x61, 0x67, 
  0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 
  0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x72, 0x20, 0x2D, 0x20, 0x6F, 0x70, 0x65, 0x6E, 
  0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x72, 
  0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x77, 0x20, 0x2D, 0x20, 
  0x6F, 0x70, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6E, 0x67, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 
  0x63, 0x20, 0x2D, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x28, 0x4F, 0x5C, 0x5F, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 
  0x29, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x65, 0x20, 0x2D, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x20, 
  0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x65, 0x78, 0x69, 0x73, 
  0x74, 0x73, 0x20, 0x28, 0x4F, 0x5C, 0x5F, 0x45, 0x58, 0x43, 0x4C, 0x29, 0x0A, 0x20, 0x20, 0x2A, 
  0x20, 0x3A, 0x74, 0x20, 0x2D, 0x20, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x65, 0x6E, 0x20, 0x61, 0x6E, 
  0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x74, 
  0x6F, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x30, 0x20, 0x28, 0x4F, 0x5C, 0x5F, 0x54, 
  0x52, 0x55, 0x4E, 0x43, 0x29, 0x0A, 0x0A, 0x50, 0x6F, 0x73, 0x69, 0x78, 0x2D, 0x6F, 0x6E, 0x6C, 
  0x79, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x61, 
  0x20, 0x2D, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x20, 0x28, 0x4F, 0x5C, 0x5F, 0x41, 0x50, 0x50, 0x45, 0x4E, 0x44, 0x29, 0x0A, 
  0x20, 0x20, 0x2A, 0x20, 0x3A, 0x78, 0x20, 0x2D, 0x20, 0x4F, 0x5C, 0x5F, 0x53, 0x59, 0x4E, 0x43, 
  0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x43, 0x20, 0x2D, 0x20, 0x4F, 0x5C, 0x5F, 0x4E, 0x4F, 0x43, 
  0x54, 0x54, 0x59, 0x0A, 0x0A, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2D, 0x6F, 0x6E, 0x6C, 
  0x79, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x52, 
  0x20, 0x2D, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x73, 0x20, 0x28, 
  0x46, 0x49, 0x4C, 0x45, 0x5C, 0x5F, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5C, 0x5F, 0x52, 0x45, 0x41, 
  0x44, 0x29, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x57, 0x20, 0x2D, 0x20, 0x73, 0x68, 0x61, 0x72, 
  0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x73, 0x20, 0x28, 0x46, 0x49, 0x4C, 0x45, 0x5C, 0x5F, 
  0x53, 0x48, 0x41, 0x52, 0x45, 0x5C, 0x5F, 0x57, 0x52, 0x49, 0x54, 0x45, 0x29, 0x0A, 0x20, 0x20, 
  0x2A, 0x20, 0x3A, 0x44, 0x20, 0x2D, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x20, 0x64, 0x65, 0x6C, 
  0x65, 0x74, 0x65, 0x73, 0x20, 0x28, 0x46, 0x49, 0x4C, 0x45, 0x5C, 0x5F, 0x53, 0x48, 0x41, 0x52, 
  0x45, 0x5C, 0x5F, 0x44, 0x45, 0x4C, 0x45, 0x54, 0x45, 0x29, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 
  0x48, 0x20, 0x2D, 0x20, 0x46, 0x49, 0x4C, 0x45, 0x5C, 0x5F, 0x41, 0x54, 0x54, 0x52, 0x49, 0x42, 
  0x55, 0x54, 0x45, 0x5C, 0x5F, 0x48, 0x49, 0x44, 0x44, 0x45, 0x4E, 0x0A, 0x20, 0x20, 0x2A, 0x20, 
  0x3A, 0x4F, 0x20, 0x2D, 0x20, 0x46, 0x49, 0x4C, 0x45, 0x5C, 0x5F, 0x41, 0x54, 0x54, 0x52, 0x49, 
  0x42, 0x55, 0x54, 0x45, 0x5C, 0x5F, 0x52, 0x45, 0x41, 0x44, 0x4F, 0x4E, 0x4C, 0x59, 0x0A, 0x20, 
  0x20, 0x2A, 0x20, 0x3A, 0x46, 0x20, 0x2D, 0x20, 0x46, 0x49, 0x4C, 0x45, 0x5C, 0x5F, 0x41, 0x54, 
  0x54, 0x52, 0x49, 0x42, 0x55, 0x54, 0x45, 0x5C, 0x5F, 0x4F, 0x46, 0x46, 0x4C, 0x49, 0x4E, 0x45, 
  0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x54, 0x20, 0x2D, 0x20, 0x46, 0x49, 0x4C, 0x45, 0x5C, 0x5F, 
  0x41, 0x54, 0x54, 0x52, 0x49, 0x42, 0x55, 0x54, 0x45, 0x5C, 0x5F, 0x54, 0x45, 0x4D, 0x50, 0x4F, 
  0x52, 0x41, 0x52, 0x59, 0x0A, 0x20, 0x20, 0x2A, 0x20, 0x3A, 0x64, 0x20, 0x2D, 0x20, 0x46, 0x49, 
  0x4C, 0x45, 0x5C, 0x5F, 0x46, 0x4C, 0x41, 0x47, 0x5C, 0x5F, 0x44, 0x45, 0x4C, 0x45, 0x54, 0x45, 
  0x5C, 0x5F, 0x4F, 0x4E, 0x5C, 0x5F, 0x43, 0x4C, 0x4F, 0x53, 0x45, 0x0A, 0x20, 0x20, 0x2A, 0x20, 
  0x3A, 0x62, 0x20, 0x2D, 0x20, 0x46, 0x49, 0x4C, 0x45, 0x5C, 0x5F, 0x46, 0x4C, 0x41, 0x47, 0x5C, 
  0x5F, 0x4E, 0x4F, 0x5C, 0x5F, 0x42, 0x55, 0x46, 0x46, 0x45, 0x52, 0x49, 0x4E, 0x47, 0x0A, 0xDA, 
  0x87, 0xE0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0x25, 0x01, 0xDA, 
  0x06, 0xDA, 0x87, 0xE1, 0xDA, 0x08, 0xCE, 0x81, 0x28, 0x28, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x29, 0x0A, 
  0x0A, 0x4C, 0x6F, 0x61, 0x64, 0x20, 0x61, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6D, 
  0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 
  0x69, 0x76, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x74, 0x68, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x61, 
  0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 
  0x69, 0x76, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x6C, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2C, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x61, 0x20, 0x2E, 0x73, 
  0x6F, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x6E, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x73, 
  0x79, 0x73, 0x74, 0x65, 0x6D, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x2E, 0x64, 
  0x6C, 0x6C, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 
  0x77, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x74, 0x68, 
  0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x2E, 0xDA, 0x87, 0xE2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0xBF, 0x01, 
  0xDA, 0x06, 0xDA, 0x87, 0xE3, 0xDA, 0x08, 0xCE, 0x81, 0x1B, 0x28, 0x75, 0x70, 0x64, 0x61, 0x74, 
  0x65, 0x2D, 0x69, 0x6E, 0x20, 0x64, 0x73, 0x20, 0x6B, 0x73, 0x20, 0x66, 0x20, 0x26, 0x20, 0x61, 
  0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 0x74, 0x65, 0x64, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 
  0x60, 0x64, 0x73, 0x60, 0x2E, 0x20, 0x4C, 0x6F, 0x6F, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 
  0x20, 0x60, 0x64, 0x73, 0x60, 0x20, 0x76, 0x69, 0x61, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 
  0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x2C, 0x0A, 0x61, 0x6E, 
  0x64, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x66, 0x60, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x65, 
  0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 
  0x0A, 0x4D, 0x69, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 
  0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x0A, 0x74, 
  0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2C, 0x20, 0x6F, 0x72, 0x69, 
  0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x87, 0xE6, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x40, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xE7, 0xDA, 0x08, 0xCE, 0x49, 0x28, 0x64, 0x65, 0x66, 
  0x6E, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 
  0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 
  0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6F, 
  0x72, 0x74, 0x65, 0x64, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x87, 0xE9, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x8D, 0xDF, 0x03, 0xDA, 0x06, 0xDA, 0x87, 0xEA, 0xDA, 0x08, 0xCE, 0x29, 
  0x28, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 
  0x6D, 0x29, 0x0A, 0x0A, 0x41, 0x6C, 0x69, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x65, 
  0x76, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x60, 0x2E, 0xDA, 0x87, 0xED, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x88, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xEE, 0xDA, 0x08, 0xCE, 
  0x80, 0xDC, 0x28, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x32, 0x20, 0x66, 
  0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x32, 0x2D, 0x61, 0x72, 0x67, 
  0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 
  0x20, 0x60, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x60, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x61, 0x6B, 0x65, 
  0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x69, 0x6E, 
  0x64, 0x60, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x64, 0x64, 0x65, 0x64, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x61, 0x73, 
  0x20, 0x69, 0x73, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 
  0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0A, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x60, 
  0x28, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x60, 0x2E, 0xDA, 0x87, 
  0xF0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x82, 0x92, 0x01, 0xDA, 0x06, 
  0xDA, 0x87, 0xF1, 0xDA, 0x08, 0xCE, 0x81, 0x32, 0x28, 0x6D, 0x65, 0x6D, 0x63, 0x6D, 0x70, 0x20, 
  0x61, 0x20, 0x62, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6C, 0x65, 0x6E, 0x20, 0x6F, 0x66, 0x66, 
  0x73, 0x65, 0x74, 0x2D, 0x61, 0x20, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x2D, 0x62, 0x29, 0x0A, 
  0x0A, 0x43, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x2E, 
  0x20, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 
  0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x60, 0x61, 0x60, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x60, 0x62, 0x60, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x30, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 
  0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 
  0x74, 0x73, 0x2C, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 
  0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x61, 0x20, 0x69, 0x73, 0x20, 0x6C, 
  0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x62, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x61, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x61, 0x20, 0x69, 0x73, 0x20, 0x67, 0x72, 0x65, 0x61, 0x74, 
  0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x62, 0x2E, 0x20, 0x4F, 0x70, 0x74, 0x69, 
  0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x61, 0x20, 0x6C, 0x65, 
  0x6E, 0x67, 0x74, 0x68, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x73, 
  0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x73, 0x6C, 0x69, 0x63, 
  0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 
  0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x2E, 0xDA, 0x87, 0xF2, 0xD3, 0x04, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x4F, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xF3, 0xDA, 0x08, 0xCE, 
  0x56, 0x28, 0x74, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 
  0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 
  0x69, 0x74, 0x73, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x76, 0x65, 
  0x72, 0x73, 0x65, 0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x73, 
  0x65, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x29, 0x29, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x87, 0xF5, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x83, 0x09, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xF6, 0xDA, 
  0x08, 0xCE, 0x19, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 
  0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x87, 0xF7, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x67, 0x01, 0xDA, 0x06, 0xDA, 0x83, 
  0xC4, 0xDA, 0x08, 0xCE, 0x3F, 0x28, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x66, 0x20, 0x66, 0x6D, 0x74, 
  0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x4C, 0x69, 0x6B, 0x65, 0x20, 0x60, 0x65, 0x70, 
  0x72, 0x69, 0x6E, 0x74, 0x66, 0x60, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x6E, 0x6F, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 0x6C, 
  0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x87, 0xF8, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 
  0xB0, 0x81, 0x72, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xF9, 0xDA, 0x08, 0xCE, 0x6C, 0x28, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x2F, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x2D, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 
  0x6E, 0x20, 0x74, 0x61, 0x62, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 
  0x20, 0x6D, 0x65, 0x72, 0x67, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x87, 0xFA, 0xD3, 0x02, 0xDA, 0x06, 
  0xDA, 0x87, 0xFB, 0xDA, 0x08, 0xCE, 0x80, 0xAD, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x6F, 0x77, 0x73, 0x20, 0x61, 
  0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x75, 0x67, 0x68, 0x74, 
  0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 
  0x6E, 0x73, 0x70, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 
  0x6E, 0x67, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x79, 0x20, 0x72, 0x65, 
  0x73, 0x75, 0x6D, 0x65, 0x2E, 0xDA, 0x87, 0xFD, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x2E, 0x8B, 0xCD, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xFE, 0xDA, 0x08, 0xCE, 0x81, 0xC8, 0x28, 0x65, 
  0x76, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x6E, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x6F, 0x75, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x61, 0x64, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 
  0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x61, 0x73, 0x79, 0x6E, 0x63, 0x68, 0x72, 0x6F, 0x6E, 
  0x6F, 0x75, 0x73, 0x6C, 0x79, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 
  0x65, 0x61, 0x6D, 0x2E, 0x20, 0x60, 0x6E, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 
  0x6F, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 
  0x20, 0x60, 0x3A, 0x61, 0x6C, 0x6C, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 
  0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x74, 0x72, 
  0x65, 0x61, 0x6D, 0x2E, 0x20, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 
  0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 
  0x73, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x6F, 0x75, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x61, 
  0x66, 0x74, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x61, 
  0x6E, 0x63, 0x65, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x77, 0x61, 0x73, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 
  0x73, 0x66, 0x75, 0x6C, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x65, 
  0x6E, 0x64, 0x2D, 0x6F, 0x66, 0x2D, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x72, 0x65, 0x61, 
  0x63, 0x68, 0x65, 0x64, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 
  0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x62, 0x6C, 0x65, 0x6D, 0x73, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x4F, 0x20, 0x6F, 0x70, 0x65, 0x72, 
  0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x87, 0xFF, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x04, 0x84, 0x72, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x00, 0xDA, 0x08, 0xCE, 0x47, 0x28, 0x6F, 
  0x73, 0x2F, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x50, 0x61, 
  0x73, 0x73, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x72, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6C, 0x79, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x73, 
  0x68, 0x65, 0x6C, 0x6C, 0x2E, 0xDA, 0x88, 0x01, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x7D, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x02, 0xDA, 0x08, 0xCE, 0x20, 0x28, 0x66, 0x61, 0x6C, 
  0x73, 0x65, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 
  0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x2E, 0xDA, 0x88, 0x04, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x80, 0xEB, 0x01, 0xDA, 0x06, 0xDA, 0x88, 
  0x05, 0xDA, 0x08, 0xCE, 0x80, 0x96, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x72, 
  0x6F, 0x6D, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x20, 0x62, 0x79, 0x74, 0x65, 0x2D, 
  0x76, 0x61, 0x6C, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x69, 0x6E, 0x74, 
  0x65, 0x67, 0x65, 0x72, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x73, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 
  0x2E, 0x20, 0x41, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x73, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x6F, 0x65, 0x72, 0x63, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x31, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x30, 0x2D, 0x32, 0x35, 0x35, 0x2E, 0xDA, 0x88, 0x06, 0xD3, 
  0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8E, 0x28, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x07, 
  0xDA, 0x08, 0xCE, 0x80, 0xBE, 0x28, 0x64, 0x65, 0x6C, 0x61, 0x79, 0x20, 0x26, 0x20, 0x66, 0x6F, 
  0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x4C, 0x61, 0x7A, 0x69, 0x6C, 0x79, 0x20, 0x65, 0x76, 0x61, 
  0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x20, 0x6F, 
  0x66, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 
  0x6E, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x65, 0x76, 0x61, 
  0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 
  0x6F, 0x6E, 0x63, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x6D, 
  0x65, 0x6D, 0x6F, 0x69, 0x7A, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 
  0x6C, 0x74, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x88, 0x09, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x81, 0x01, 0x81, 0xFB, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x55, 0xDA, 0x08, 0xCE, 0x5C, 0x28, 
  0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x61, 
  0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x60, 0x2C, 0x20, 0x62, 
  0x75, 0x74, 0x20, 0x75, 0x73, 0x65, 0x73, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x65, 
  0x72, 0x72, 0x20, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0x29, 0x60, 0x20, 0x69, 0x6E, 0x73, 0x74, 
  0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x6F, 0x75, 
  0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x60, 0x2E, 0xDA, 0x88, 0x0A, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0x88, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x0B, 
  0xDA, 0x08, 0xCE, 0x67, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 
  0x74, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x29, 0x0A, 0x0A, 0x54, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x62, 0x69, 0x74, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 
  0x65, 0x6E, 0x20, 0x62, 0x69, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x69, 0x6E, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x88, 0x0C, 0xD3, 0x02, 
  0xDA, 0x06, 0xDA, 0x80, 0xD7, 0xDA, 0x08, 0xCE, 0x81, 0x53, 0x28, 0x70, 0x72, 0x6F, 0x70, 0x61, 
  0x67, 0x61, 0x74, 0x65, 0x20, 0x78, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x50, 
  0x72, 0x6F, 0x70, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 
  0x6C, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 
  0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x69, 
  0x6E, 0x67, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 
  0x64, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x64, 
  0x2C, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 
  0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 
  0x74, 0x6F, 0x20, 0x72, 0x65, 0x2D, 0x72, 0x61, 0x69, 0x73, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x6C, 0x6F, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 
  0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x74, 0x72, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x88, 0x0D, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x0E, 0x01, 0xDA, 0x06, 0xDA, 
  0x88, 0x0E, 0xDA, 0x08, 0xCE, 0x24, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x69, 0x6E, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x88, 0x0F, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x80, 0xD4, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x10, 0xDA, 
  0x08, 0xCE, 0x7E, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 
  0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 
  0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x2E, 0xDA, 0x88, 0x11, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x88, 0x12, 0xDA, 0x08, 0xCE, 0x80, 0xF4, 
  0x28, 0x62, 0x72, 0x75, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x78, 0x20, 0x26, 0x20, 0x73, 0x68, 
  0x69, 0x66, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x20, 0x62, 0x69, 
  0x74, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x65, 0x64, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 
  0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 
  0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 
  0x74, 0x73, 0x2E, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 
  0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x20, 0x6F, 0x66, 0x20, 
  0x78, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 
  0x65, 0x64, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 
  0x69, 0x76, 0x65, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x61, 0x6C, 0x77, 0x61, 0x79, 0x73, 0x20, 0x62, 0x65, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 
  0x69, 0x76, 0x65, 0x2E, 0xDA, 0x88, 0x14, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 
  0x8E, 0xA2, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x15, 0xDA, 0x08, 0xCE, 0x81, 0x3D, 0x28, 0x66, 0x6C, 
  0x79, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6B, 0x65, 0x79, 
  0x73, 0x20, 0x6B, 0x77, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 
  0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x46, 0x6F, 0x75, 
  0x6E, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 
  0x65, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x74, 0x64, 
  0x65, 0x72, 0x72, 0x0A, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x75, 0x61, 0x6C, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x2E, 0x20, 0x4D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x74, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 
  0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x2C, 0x20, 0x68, 0x6F, 0x77, 0x65, 0x76, 0x65, 0x72, 0x2C, 
  0x20, 0x73, 0x6F, 0x0A, 0x61, 0x72, 0x62, 0x69, 0x74, 0x72, 0x61, 0x72, 0x79, 0x20, 0x65, 0x78, 
  0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x70, 0x6F, 0x73, 0x73, 0x69, 
  0x62, 0x6C, 0x65, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 
  0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x64, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x60, 0x2E, 0x20, 0x60, 
  0x70, 0x61, 0x74, 0x68, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 
  0x65, 0x0A, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x73, 
  0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x73, 0x74, 0x64, 0x69, 0x6E, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x88, 0x36, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x82, 0x4E, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x37, 0xDA, 
  0x08, 0xCE, 0x80, 0xA1, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 
  0x6C, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x65, 0x74, 0x29, 0x0A, 
  0x0A, 0x54, 0x72, 0x69, 0x6D, 0x20, 0x6C, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x68, 
  0x69, 0x74, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2E, 0x20, 0x49, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x60, 
  0x73, 0x65, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 
  0x2C, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 
  0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x73, 
  0x65, 0x74, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x77, 0x68, 0x69, 0x74, 0x65, 0x73, 
  0x70, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x88, 0x38, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xB3, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x03, 0xDA, 0x08, 0xCE, 
  0x6A, 0x57, 0x68, 0x65, 0x6E, 0x20, 0x73, 0x65, 0x74, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x6C, 0x65, 0x74, 0x65, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 
  0x74, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x72, 
  0x65, 0x70, 0x6C, 0x20, 0x28, 0x6F, 0x72, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x29, 0x2C, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0xDA, 0x88, 0x39, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x82, 0x58, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x3A, 
  0xDA, 0x08, 0xCE, 0x80, 0xA2, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 
  0x6D, 0x72, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x65, 0x74, 0x29, 
  0x0A, 0x0A, 0x54, 0x72, 0x69, 0x6D, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 
  0x77, 0x68, 0x69, 0x74, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2E, 
  0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x20, 0x60, 0x73, 0x65, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 
  0x65, 0x64, 0x2C, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x6F, 0x6E, 0x6C, 
  0x79, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x60, 0x73, 0x65, 0x74, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x77, 0x68, 0x69, 0x74, 
  0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x82, 0xC8, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x84, 0xC1, 0x81, 0x16, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x5B, 0xDA, 0x08, 0xCE, 0x39, 
  0x28, 0x73, 0x65, 0x74, 0x64, 0x79, 0x6E, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 
  0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x88, 0x3B, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x82, 0xA1, 0x80, 0xD7, 0x01, 0xDA, 0x06, 0xDA, 0x80, 0xE2, 0xDA, 0x08, 
  0xCE, 0x81, 0x86, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 
  0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 
  0x74, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 
  0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 
  0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x60, 0x73, 0x74, 
  0x61, 0x72, 0x74, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x65, 0x6E, 0x64, 0x60, 0x2E, 0x20, 0x54, 
  0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x68, 0x61, 0x6C, 0x66, 
  0x20, 0x6F, 0x70, 0x65, 0x6E, 0x2C, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 
  0x6E, 0x64, 0x29, 0x2E, 0x20, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x2C, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x60, 0x73, 
  0x74, 0x61, 0x72, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 
  0x65, 0x6E, 0x64, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 
  0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 
  0x20, 0x4E, 0x6F, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 
  0x20, 0x2D, 0x31, 0x20, 0x69, 0x73, 0x20, 0x73, 0x79, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 
  0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x60, 0x28, 0x6C, 
  0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x29, 0x60, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x20, 0x6E, 
  0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x72, 0x61, 
  0x6E, 0x67, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x88, 0x3C, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8A, 0xB0, 0x01, 0xDA, 0x06, 0xDA, 0x3A, 0xDA, 0x08, 0xCE, 0x81, 
  0xD4, 0x28, 0x65, 0x76, 0x2F, 0x67, 0x6F, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2D, 0x6F, 0x72, 
  0x2D, 0x66, 0x75, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x73, 0x75, 0x70, 0x65, 0x72, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x29, 0x0A, 0x0A, 0x50, 0x75, 0x74, 
  0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x65, 0x76, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 
  0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x64, 0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 0x2E, 0x20, 
  0x49, 0x66, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 
  0x20, 0x75, 0x73, 0x65, 0x64, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x77, 0x72, 0x61, 
  0x70, 0x70, 0x65, 0x64, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 
  0x6E, 0x65, 0x77, 0x60, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x2E, 0x20, 0x4F, 0x70, 0x74, 0x69, 
  0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x61, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 
  0x73, 0x75, 0x6D, 0x65, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2E, 0x20, 0x41, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x60, 
  0x63, 0x6F, 0x72, 0x65, 0x2F, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x60, 0x20, 0x63, 0x61, 
  0x6E, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x61, 0x73, 
  0x20, 0x61, 0x20, 0x73, 0x75, 0x70, 0x65, 0x72, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x2E, 0x20, 0x57, 
  0x68, 0x65, 0x6E, 0x20, 0x76, 0x61, 0x72, 0x69, 0x6F, 0x75, 0x73, 0x20, 0x65, 0x76, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x6F, 0x63, 0x63, 0x75, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x65, 0x77, 0x6C, 0x79, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6C, 0x65, 0x64, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2C, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x70, 0x75, 0x73, 0x68, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x70, 0x65, 0x72, 0x76, 0x69, 0x73, 0x6F, 0x72, 
  0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 
  0x64, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x68, 0x65, 0x72, 0x69, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x75, 0x70, 0x65, 0x72, 0x76, 
  0x69, 0x73, 0x6F, 0x72, 0x2E, 0xDA, 0x88, 0x3D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x80, 0xA4, 0x81, 0x20, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x3E, 0xDA, 0x08, 0xCE, 0x31, 0x28, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 
  0x72, 0x20, 0x6E, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x78, 0x2E, 0xDA, 
  0x88, 0x3F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x8D, 0x01, 0xDA, 
  0x06, 0xDA, 0x82, 0xB7, 0xDA, 0x08, 0xCE, 0x49, 0x28, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x29, 0x0A, 
  0x0A, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x6F, 0x75, 
  0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x60, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 
  0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x68, 0x69, 0x6E, 0x67, 
  0x2E, 0xDA, 0x88, 0x40, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x83, 0x11, 
  0x01, 0xDA, 0x06, 0xDA, 0x88, 0x41, 0xDA, 0x08, 0xCE, 0x18, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 
  0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x66, 0x69, 0x6C, 
  0x65, 0x2E, 0xDA, 0x88, 0x42, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 
  0x9E, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x52, 0xDA, 0x08, 0xCE, 0x81, 0x0D, 0x28, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0x20, 
  0x70, 0x61, 0x74, 0x74, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x73, 
  0x74, 0x61, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x70, 0x61, 0x74, 0x74, 0x60, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x73, 0x75, 0x62, 0x73, 0x74, 0x60, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x73, 0x74, 0x72, 
  0x60, 0x2E, 0x20, 0x4F, 0x76, 0x65, 0x72, 0x6C, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x6D, 
  0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x62, 0x65, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x64, 0x2C, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 
  0x20, 0x69, 0x6E, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x20, 0x73, 0x70, 0x61, 0x6E, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 
  0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x66, 0x20, 
  0x60, 0x70, 0x61, 0x74, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 
  0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x60, 0x73, 0x74, 0x72, 0x60, 0x2E, 0xDA, 0x88, 0x43, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x0C, 0x81, 0xC4, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x44, 0xDA, 0x08, 0xCE, 
  0x6E, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x26, 0x20, 0x74, 
  0x79, 0x70, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 
  0x6E, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x6E, 0x61, 0x74, 
  0x69, 0x76, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0xDA, 
  0x88, 0x45, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x2F, 0x01, 0xDA, 
  0x06, 0xDA, 0x88, 0x46, 0xDA, 0x08, 0xCE, 0x48, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 
  0x61, 0x6E, 0x32, 0x20, 0x79, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x63, 0x74, 0x61, 0x6E, 0x67, 0x65, 0x6E, 0x74, 
  0x20, 0x6F, 0x66, 0x20, 0x79, 0x2F, 0x78, 0x2E, 0x20, 0x57, 0x6F, 0x72, 0x6B, 0x73, 0x20, 0x65, 
  0x76, 0x65, 0x6E, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x30, 0x2E, 
  0xDA, 0x87, 0x61, 0xDA, 0x86, 0x91, 0xDA, 0x88, 0x47, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x8C, 0xAB, 0x80, 0xF9, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x48, 0xDA, 0x08, 0xCE, 0x81, 0xAC, 
  0x28, 0x69, 0x6E, 0x74, 0x2F, 0x74, 0x6F, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x69, 0x61, 0x6E, 0x6E, 
  0x65, 0x73, 0x73, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x57, 0x72, 0x69, 
  0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 
  0x61, 0x6E, 0x20, 0x60, 0x69, 0x6E, 0x74, 0x2F, 0x73, 0x36, 0x34, 0x60, 0x20, 0x6F, 0x72, 0x20, 
  0x60, 0x69, 0x6E, 0x74, 0x2F, 0x75, 0x36, 0x34, 0x60, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x60, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x60, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x20, 
  0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x69, 
  0x73, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 
  0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x2C, 0x20, 0x69, 0x66, 0x20, 0x75, 0x6E, 0x73, 
  0x65, 0x74, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x2E, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 
  0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x0A, 0x54, 0x68, 
  0x65, 0x20, 0x60, 0x65, 0x6E, 0x64, 0x69, 0x61, 0x6E, 0x6E, 0x65, 0x73, 0x73, 0x60, 0x20, 0x70, 
  0x61, 0x72, 0x61, 0x6D, 0x61, 0x74, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 
  0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x6F, 0x72, 0x64, 0x65, 
  0x72, 0x3A, 0x0A, 0x2D, 0x20, 0x60, 0x6E, 0x69, 0x6C, 0x60, 0x20, 0x28, 0x75, 0x6E, 0x73, 0x65, 
  0x74, 0x29, 0x3A, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 
  0x6F, 0x72, 0x64, 0x65, 0x72, 0x0A, 0x2D, 0x20, 0x60, 0x3A, 0x6C, 0x65, 0x60, 0x3A, 0x20, 0x6C, 
  0x69, 0x74, 0x74, 0x6C, 0x65, 0x2D, 0x65, 0x6E, 0x64, 0x69, 0x61, 0x6E, 0x2C, 0x20, 0x6C, 0x65, 
  0x61, 0x73, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x66, 0x69, 0x63, 0x61, 0x6E, 0x74, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x0A, 0x2D, 0x20, 0x60, 0x3A, 0x62, 
  0x65, 0x60, 0x3A, 0x20, 0x62, 0x69, 0x67, 0x2D, 0x65, 0x6E, 0x64, 0x69, 0x61, 0x6E, 0x2C, 0x20, 
  0x6D, 0x6F, 0x73, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x66, 0x69, 0x63, 0x61, 0x6E, 0x74, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x0A, 0xDA, 0x88, 0x49, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x89, 0x2C, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x3E, 
  0xDA, 0x08, 0xCE, 0x80, 0xA2, 0x28, 0x63, 0x75, 0x72, 0x65, 0x6E, 0x76, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 
  0x20, 0x60, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 0x76, 0x20, 
  0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x29, 0x29, 
  0x60, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x6E, 0x60, 0x0A, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 
  0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x67, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x74, 0x68, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x88, 0x4A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x8A, 0x53, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x2B, 0xDA, 0x08, 0xCE, 0x82, 0x09, 
  0x54, 0x68, 0x65, 0x20, 0x6C, 0x69, 0x73, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x73, 0x20, 0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6D, 0x6F, 
  0x64, 0x75, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x64, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x65, 0x78, 0x70, 
  0x61, 0x6E, 0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x60, 0x2E, 0x0A, 0x45, 0x61, 0x63, 0x68, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x77, 0x6F, 
  0x2D, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2C, 0x20, 
  0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x74, 0x68, 0x0A, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x2C, 0x20, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2C, 0x20, 0x6F, 0x72, 0x20, 
  0x3A, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x68, 0x6F, 0x77, 0x0A, 0x60, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x60, 0x20, 
  0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 
  0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x2E, 0x0A, 0x0A, 0x41, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x0A, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 
  0x6E, 0x20, 0x61, 0x20, 0x74, 0x68, 0x69, 0x72, 0x64, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x2C, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x70, 0x72, 0x65, 0x76, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 
  0x64, 0x60, 0x0A, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x69, 0x6E, 
  0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x65, 0x6D, 0x70, 
  0x6C, 0x61, 0x74, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x74, 
  0x65, 0x72, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x6E, 0x27, 0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x0A, 0x70, 0x61, 0x74, 0x68, 0x2E, 
  0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x62, 0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 0x20, 0x61, 
  0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x0A, 0x69, 0x73, 0x20, 0x6F, 0x66, 0x74, 0x65, 
  0x6E, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 
  0x6F, 0x6E, 0x2C, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x65, 0x72, 0x69, 0x6F, 0x64, 0x2E, 0xDA, 0x88, 0x4B, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x89, 0xFB, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x4C, 0xDA, 0x08, 0xCE, 
  0x80, 0x88, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x50, 
  0x61, 0x72, 0x73, 0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 
  0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x63, 0x6F, 
  0x6D, 0x70, 0x6C, 0x65, 0x78, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x73, 
  0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 
  0x6C, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x68, 0x61, 0x6E, 
  0x64, 0x6C, 0x69, 0x6E, 0x67, 0x2C, 0x0A, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x61, 0x70, 0x69, 0x2E, 0xDA, 0x88, 0x4F, 0xD3, 0x04, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0xF6, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x50, 0xDA, 0x08, 
  0xCE, 0x80, 0x9C, 0x28, 0x66, 0x6F, 0x72, 0x76, 0x20, 0x69, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x20, 0x73, 0x74, 0x6F, 0x70, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x44, 
  0x6F, 0x20, 0x61, 0x20, 0x43, 0x2D, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x2D, 
  0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x65, 0x66, 
  0x66, 0x65, 0x63, 0x74, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x60, 0x69, 
  0x60, 0x0A, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x6D, 0x75, 0x74, 0x61, 0x74, 0x65, 0x64, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2C, 0x20, 0x75, 0x6E, 
  0x6C, 0x69, 0x6B, 0x65, 0x20, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x20, 0x60, 0x66, 0x6F, 0x72, 
  0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 
  0x2B, 0xCB, 0xDA, 0x88, 0x52, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x0A, 
  0x01, 0xDA, 0x06, 0xDA, 0x82, 0xD9, 0xDA, 0x08, 0xCE, 0x80, 0x8E, 0x28, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x2D, 0x61, 0x6C, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x50, 0x61, 0x72, 0x73, 
  0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x64, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x6C, 0x65, 0x78, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x73, 0x75, 
  0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 0x6C, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x68, 0x61, 0x6E, 0x64, 
  0x6C, 0x69, 0x6E, 0x67, 0x2C, 0x0A, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x20, 0x61, 0x70, 0x69, 0x2E, 0xDA, 0x88, 0x53, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x80, 0xF9, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x54, 0xDA, 0x08, 
  0xCE, 0x80, 0xBE, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 0x69, 
  0x2D, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0x63, 0x61, 0x73, 
  0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x6D, 0x73, 0x65, 0x6C, 0x76, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x41, 0x53, 0x43, 0x49, 0x49, 
  0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x61, 0x20, 0x76, 0x65, 
  0x72, 0x79, 0x20, 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x63, 
  0x68, 0x65, 0x63, 0x6B, 0x2C, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x6F, 
  0x20, 0x75, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 
  0x2E, 0xDA, 0x88, 0x55, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x34, 
  0x01, 0xDA, 0x06, 0xDA, 0x73, 0xDA, 0x08, 0xCE, 0x2A, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 
  0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x78, 0x2E, 0xDA, 0x88, 0x56, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x84, 
  0x85, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x57, 0xDA, 0x08, 0xCE, 0x35, 0x28, 0x6F, 0x73, 0x2F, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x20, 0x63, 
  0x6F, 0x70, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4F, 0x53, 0x20, 0x65, 0x6E, 
  0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 
  0xDA, 0x88, 0x58, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x84, 0x26, 0x01, 0xDA, 
  0x06, 0xDA, 0x88, 0x59, 0xDA, 0x08, 0xCE, 0x4B, 0x28, 0x65, 0x76, 0x2F, 0x63, 0x6F, 0x75, 0x6E, 
  0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x69, 0x74, 
  0x65, 0x6D, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x77, 0x61, 
  0x69, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 
  0x65, 0x6C, 0x2E, 0xDA, 0x88, 0x5A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 
  0x91, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x29, 0xDA, 0x08, 0xCE, 0x81, 0x01, 0x28, 0x6D, 0x6F, 0x64, 
  0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 
  0x54, 0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 0x20, 0x6D, 
  0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6E, 0x61, 
  0x6D, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x74, 
  0x65, 0x72, 0x6E, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 
  0x70, 0x61, 0x74, 0x68, 0x73, 0x60, 0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x28, 0x66, 0x75, 0x6C, 0x6C, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x6B, 0x69, 0x6E, 0x64, 0x29, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6B, 0x69, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2C, 0x20, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x2C, 0x0A, 0x6F, 0x72, 0x20, 0x3A, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x69, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 
  0x75, 0x6E, 0x64, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x61, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6E, 0x69, 0x6C, 0x20, 
  0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x20, 0x62, 0x79, 0x0A, 0x61, 0x6E, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2E, 0xDA, 0x88, 0x5B, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x80, 0xE0, 0x01, 0xDA, 0x06, 0xDA, 
  0x84, 0x79, 0xDA, 0x08, 0xCE, 0x64, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x77, 0x72, 0x69, 0x74, 
  0x65, 0x20, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x57, 0x72, 0x69, 0x74, 
  0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x27, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x27, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2C, 0x20, 0x6F, 0x72, 
  0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x88, 0x5C, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 0x85, 0xB4, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x5D, 0xDA, 0x08, 
  0xCE, 0x80, 0x85, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x6E, 0x61, 
  0x74, 0x69, 0x76, 0x65, 0x29, 0x0A, 0x0A, 0x46, 0x72, 0x65, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x61, 
  0x74, 0x69, 0x76, 0x65, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2E, 0x20, 0x44, 0x65, 0x72, 
  0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 
  0x65, 0x72, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 0x69, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x75, 0x6E, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x64, 
  0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6F, 0x72, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 
  0x66, 0x72, 0x65, 0x65, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x88, 0x5E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x04, 0x82, 0x50, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x5F, 0xDA, 0x08, 0xCE, 0x80, 
  0xF7, 0x28, 0x6F, 0x73, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x2D, 0x6B, 0x69, 0x6C, 0x6C, 0x20, 0x70, 
  0x72, 0x6F, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x77, 0x61, 0x69, 0x74, 0x29, 0x0A, 0x0A, 
  0x4B, 0x69, 0x6C, 0x6C, 0x20, 0x61, 0x20, 0x73, 0x75, 0x62, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 
  0x73, 0x20, 0x62, 0x79, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x49, 0x47, 
  0x4B, 0x49, 0x4C, 0x4C, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 0x20, 0x6F, 0x6E, 0x20, 0x70, 0x6F, 
  0x73, 0x69, 0x78, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x73, 0x2C, 0x20, 0x6F, 0x72, 0x20, 
  0x62, 0x79, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x20, 0x6F, 0x6E, 
  0x20, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x77, 0x61, 
  0x69, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x77, 0x61, 0x69, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x69, 
  0x73, 0x68, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x2E, 0x20, 0x4F, 0x74, 
  0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x60, 0x70, 0x72, 0x6F, 0x63, 0x60, 0x2E, 0xDA, 0x88, 0x60, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x81, 0x6F, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x61, 0xDA, 0x08, 0xCE, 0x7B, 
  0x28, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 0x62, 0x6F, 
  0x64, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x20, 0x6C, 0x61, 0x62, 0x65, 0x6C, 
  0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6C, 
  0x65, 0x78, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x73, 0x63, 0x6F, 0x70, 0x65, 0x64, 0x2E, 
  0x20, 0x60, 0x6E, 0x61, 0x6D, 0x65, 0x60, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 
  0x65, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x0A, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x88, 
  0x64, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8B, 0x80, 0x01, 0xDA, 0x06, 0xDA, 
  0x88, 0x65, 0xDA, 0x08, 0xCE, 0x81, 0x2C, 0x28, 0x65, 0x76, 0x2F, 0x67, 0x69, 0x76, 0x65, 0x2D, 
  0x73, 0x75, 0x70, 0x65, 0x72, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x20, 0x74, 0x61, 0x67, 0x20, 0x26, 
  0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x6E, 0x64, 0x20, 
  0x61, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x75, 0x70, 0x65, 0x72, 0x76, 0x69, 
  0x6F, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 
  0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 
  0x63, 0x6F, 0x6D, 0x62, 0x69, 0x6E, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 
  0x73, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2C, 0x20, 
  0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x61, 0x67, 0x2E, 0x20, 
  0x42, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x6E, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x74, 
  0x61, 0x67, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x6B, 
  0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x6D, 0x65, 
  0x73, 0x73, 0x61, 0x67, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 
  0x69, 0x6C, 0x2E, 0xDA, 0x88, 0x66, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 
  0x81, 0x13, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x67, 0xDA, 0x08, 0xCE, 0x37, 0x28, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 
  0x69, 0x63, 0x20, 0x61, 0x72, 0x63, 0x74, 0x61, 0x6E, 0x67, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 
  0x20, 0x78, 0x2E, 0xDA, 0x88, 0x68, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 
  0xD8, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x6B, 0xDA, 0x08, 0xCE, 0x80, 0x8A, 0x28, 0x66, 0x69, 0x6C, 
  0x74, 0x65, 0x72, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 
  0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 
  0x2C, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x0A, 
  0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x60, 0x28, 0x70, 0x72, 0x65, 0x64, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x29, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x88, 0x69, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x8D, 0xF9, 0x03, 0xDA, 0x06, 0xDA, 0x88, 0x6A, 0xDA, 0x08, 0xCE, 0x80, 0x9F, 0x28, 
  0x65, 0x76, 0x2F, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x64, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x65, 
  0x20, 0x64, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 
  0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x6F, 0x66, 
  0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x64, 0x65, 0x61, 
  0x64, 0x6C, 0x69, 0x6E, 0x65, 0x2C, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x64, 0x6F, 0x65, 
  0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x20, 0x62, 
  0x65, 0x66, 0x6F, 0x72, 0x65, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x61, 0x64, 0x6C, 0x69, 
  0x6E, 0x65, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x65, 0x64, 0x2E, 0xDA, 0x2B, 
  0xCB, 0xDA, 0x84, 0x33, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0x8E, 
  0x01, 0xDA, 0x06, 0xDA, 0x78, 0xDA, 0x08, 0xCE, 0x50, 0x28, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 
  0x26, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 
  0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x65, 0x6D, 
  0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0xDA, 0x88, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x7B, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x6D, 0xDA, 0x08, 0xCE, 0x22, 
  0x28, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 
  0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 
  0x79, 0x2E, 0xDA, 0x88, 0x6F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x80, 
  0xFA, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x70, 0xDA, 0x08, 0xCE, 0x80, 0x90, 0x28, 0x66, 0x69, 0x6C, 
  0x65, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x20, 0x66, 0x29, 0x0A, 0x0A, 0x46, 0x6C, 0x75, 0x73, 
  0x68, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x65, 0x64, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x20, 0x49, 0x6E, 0x20, 0x6D, 0x6F, 0x73, 0x74, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x73, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6E, 0x63, 0x79, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6F, 
  0x6E, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x6C, 0x65, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x2E, 0xDA, 0x88, 0x71, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8C, 0x0F, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x72, 
  0xDA, 0x08, 0xCE, 0x33, 0x28, 0x65, 0x76, 0x2F, 0x6C, 0x6F, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x43, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 
  0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6F, 0x72, 0x64, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x20, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x2E, 0xDA, 0x86, 0x97, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x88, 0x1C, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x98, 0xDA, 0x08, 0xCE, 0x80, 0x81, 
  0x28, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x61, 
  0x6C, 0x6C, 0x20, 0x60, 0x78, 0x73, 0x60, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x61, 0x6C, 0x73, 
  0x65, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 
  0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0A, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 
  0x63, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x60, 0x28, 0x70, 0x72, 0x65, 0x64, 0x20, 0x78, 0x29, 0x60, 
  0x2E, 0xDA, 0x88, 0x73, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x2B, 0x82, 0x86, 
  0x01, 0xDA, 0x06, 0xDA, 0x83, 0x35, 0xDA, 0x08, 0xCE, 0x4B, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x2F, 0x6C, 0x61, 0x73, 0x74, 0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x47, 0x65, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x69, 0x67, 
  0x6E, 0x61, 0x6C, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x88, 0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x80, 0xB0, 0x81, 0x40, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x32, 0xDA, 0x08, 0xCE, 0x5B, 0x28, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x20, 0x74, 0x61, 
  0x62, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x60, 0x74, 0x61, 0x62, 0x60, 0x2E, 0xDA, 0x88, 0x75, 0xD3, 0x02, 0xDA, 0x06, 
  0xDA, 0x88, 0x76, 0xDA, 0x08, 0xCE, 0x42, 0x28, 0x25, 0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 
  0x6E, 0x64, 0x20, 0x64, 0x69, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6D, 0x61, 0x69, 0x6E, 0x64, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x6E, 0x64, 0x20, 0x2F, 
  0x20, 0x64, 0x69, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x2E, 0xDA, 0x88, 0x78, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xDF, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x79, 0xDA, 0x08, 0xCE, 
  0x44, 0x28, 0x6D, 0x61, 0x78, 0x2D, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x65, 
  0x72, 0x69, 0x63, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x65, 0x71, 0x75, 
  0x65, 0x6E, 0x63, 0x65, 0x2E, 0xDA, 0x88, 0x7B, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x88, 0x7C, 0xDA, 
  0x08, 0xCE, 0x4F, 0x28, 0x2A, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 
  0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x31, 0x2E, 0xDA, 0x88, 0x7D, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x27, 0xDA, 0x08, 0xCE, 0x68, 0x28, 
  0x2B, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 
  0x78, 0x73, 0x2E, 0x20, 0x78, 0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x69, 
  0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x73, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x2E, 0x20, 0x49, 0x66, 
  0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x20, 0x30, 0x2E, 0xDA, 0x88, 0x7E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x04, 0x84, 0xE2, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x7F, 0xDA, 0x08, 0xCE, 0x59, 0x28, 
  0x6F, 0x73, 0x2F, 0x73, 0x6C, 0x65, 0x65, 0x70, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x75, 0x73, 
  0x70, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x6E, 0x60, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 
  0x2E, 0x20, 0x60, 0x6E, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x72, 
  0x65, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x88, 0x80, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 
  0x80, 0x9F, 0xDA, 0x08, 0xCE, 0x80, 0xDB, 0x28, 0x2D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x66, 
  0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x73, 0x2E, 0x20, 0x49, 
  0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x30, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 
  0x68, 0x61, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x67, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x4F, 0x74, 0x68, 
  0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x20, 0x6D, 0x69, 0x6E, 0x75, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x2E, 0xDA, 0x88, 0x81, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x81, 0x9B, 0xDA, 0x08, 0xCE, 0x80, 
  0xC7, 0x28, 0x2F, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x71, 0x75, 0x6F, 0x74, 0x69, 0x65, 0x6E, 0x74, 0x20, 
  0x6F, 0x66, 0x20, 0x78, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 
  0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x31, 
  0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x78, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x63, 0x69, 0x70, 0x72, 0x6F, 0x63, 0x61, 0x6C, 0x20, 
  0x6F, 0x66, 0x20, 0x78, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x73, 0x20, 0x72, 0x65, 0x70, 
  0x65, 0x61, 0x74, 0x65, 0x64, 0x6C, 0x79, 0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 
  0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6D, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0xDA, 0x88, 0x82, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x82, 0x1B, 0x86, 0x5D, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x83, 0xDA, 0x08, 0xCE, 
  0x81, 0x01, 0x28, 0x70, 0x65, 0x67, 0x2F, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x70, 
  0x65, 0x67, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x20, 
  0x70, 0x65, 0x67, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 
  0x20, 0x3C, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x70, 0x65, 0x67, 0x3E, 0x2E, 0x20, 0x54, 0x68, 0x69, 
  0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x70, 0x65, 0x65, 0x64, 0x20, 0x75, 0x70, 0x20, 
  0x6D, 0x61, 0x74, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x61, 0x6D, 0x65, 0x20, 0x70, 0x65, 0x67, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 
  0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x74, 
  0x69, 0x6D, 0x65, 0x73, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 
  0x75, 0x73, 0x65, 0x20, 0x60, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x70, 0x65, 0x67, 0x2D, 0x67, 
  0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0x29, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x75, 0x70, 0x70, 
  0x6C, 0x69, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x72, 0x61, 0x6D, 0x6D, 
  0x61, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x65, 0x67, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x75, 0x6E, 0x64, 0x65, 
  0x66, 0x69, 0x6E, 0x65, 0x64, 0x20, 0x70, 0x65, 0x67, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 
  0x64, 0x73, 0x2E, 0xDA, 0x88, 0x84, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 
  0x13, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x1E, 0xDA, 0x08, 0xCE, 0x80, 0xC0, 0x28, 0x61, 0x6C, 0x6C, 
  0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x60, 0x28, 0x70, 0x72, 0x65, 
  0x64, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x29, 0x60, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x20, 0x69, 
  0x6E, 0x20, 0x60, 0x78, 0x73, 0x60, 0x2E, 0x0A, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 
  0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x20, 0x60, 0x28, 0x70, 0x72, 
  0x65, 0x64, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x29, 0x60, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 
  0x20, 0x65, 0x6E, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x2E, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x60, 0x78, 
  0x73, 0x60, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2E, 0xDA, 0x88, 0x85, 0xD3, 
  0x02, 0xDA, 0x06, 0xDA, 0x81, 0x47, 0xDA, 0x08, 0xCE, 0x3F, 0x28, 0x3C, 0x20, 0x26, 0x20, 0x78, 
  0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x73, 0x20, 
  0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x73, 0x63, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 
  0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x80, 0xD5, 0xD3, 0x02, 0xDA, 0x06, 
  0xDA, 0x83, 0x1D, 0xDA, 0x08, 0xCE, 0x41, 0x28, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 
  0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x65, 
  0x71, 0x75, 0x61, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x87, 0x8D, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 
  0x84, 0xE5, 0xDA, 0x08, 0xCE, 0x40, 0x28, 0x3E, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 
  0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x69, 
  0x6E, 0x20, 0x64, 0x65, 0x73, 0x63, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 0x64, 
  0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x6F, 
  0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x88, 0x86, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x84, 0xC1, 0x82, 0x79, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x76, 0xDA, 0x08, 0xCE, 0x30, 0x28, 
  0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x77, 0x68, 0x61, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x52, 0x61, 0x69, 0x73, 0x65, 0x20, 0x61, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x78, 0x2E, 0x20, 0xDA, 
  0x88, 0x87, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x68, 0x01, 0xDA, 0x06, 
  0xDA, 0x88, 0x88, 0xDA, 0x08, 0xCE, 0x50, 0x28, 0x63, 0x68, 0x72, 0x20, 0x63, 0x29, 0x0A, 0x0A, 
  0x43, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x6F, 0x66, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x31, 0x20, 0x74, 0x6F, 0x20, 
  0x69, 0x74, 0x73, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x28, 0x61, 0x73, 0x63, 0x69, 0x69, 0x29, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 
  0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x88, 0x8B, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0x67, 0x81, 0x0C, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x8C, 0xDA, 
  0x08, 0xCE, 0x81, 0x2E, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x6C, 0x69, 0x6E, 0x65, 0x61, 
  0x67, 0x65, 0x20, 0x66, 0x69, 0x62, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 
  0x20, 0x63, 0x68, 0x69, 0x6C, 0x64, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x73, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x61, 0x20, 0x72, 0x6F, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 
  0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 
  0x73, 0x20, 0x75, 0x73, 0x65, 0x66, 0x75, 0x6C, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x6F, 0x72, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x6E, 
  0x63, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x55, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x6E, 
  0x64, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 
  0x63, 0x61, 0x6E, 0x20, 0x73, 0x65, 0x65, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x69, 0x67, 0x6E, 0x61, 0x6C, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 
  0x73, 0x65, 0x64, 0x20, 0x6D, 0x6F, 0x73, 0x74, 0x6C, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 
  0x65, 0x62, 0x75, 0x67, 0x67, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6F, 0x73, 0x65, 
  0x73, 0x2E, 0xDA, 0x88, 0x8D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x6A, 
  0x01, 0xDA, 0x06, 0xDA, 0x88, 0x8E, 0xDA, 0x08, 0xCE, 0x70, 0x28, 0x66, 0x6C, 0x61, 0x74, 0x74, 
  0x65, 0x6E, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x28, 0x74, 0x72, 
  0x65, 0x65, 0x29, 0x20, 0x60, 0x78, 0x73, 0x60, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x70, 0x74, 0x68, 0x20, 0x66, 
  0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 0x61, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x20, 0x6F, 
  0x66, 0x0A, 0x69, 0x74, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x88, 0x90, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x85, 0xFE, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x91, 0xDA, 0x08, 
  0xCE, 0x4C, 0x28, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0x64, 0x69, 0x72, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x29, 0x0A, 0x0A, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x20, 0x61, 0x20, 0x64, 0x69, 0x72, 0x65, 
  0x63, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 
  0x74, 0x6F, 0x72, 0x79, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x65, 0x6D, 0x70, 
  0x74, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x65, 0x64, 0x2E, 0xDA, 0x88, 
  0x92, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x15, 0x85, 0xC2, 0x01, 0xDA, 0x06, 
  0xDA, 0x88, 0x93, 0xDA, 0x08, 0xCE, 0x80, 0xC0, 0x28, 0x65, 0x6E, 0x76, 0x2D, 0x6C, 0x6F, 0x6F, 
  0x6B, 0x75, 0x70, 0x20, 0x65, 0x6E, 0x76, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 
  0x73, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 0x77, 0x61, 0x72, 0x64, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 
  0x75, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x75, 0x6E, 0x6D, 
  0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 
  0x54, 0x6F, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x72, 0x65, 0x76, 0x65, 
  0x72, 0x73, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x2C, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x74, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x77, 0x61, 
  0x70, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 
  0x64, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x88, 0x94, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x8B, 0x1B, 0x80, 0xD2, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x95, 0xDA, 0x08, 0xCE, 
  0x7F, 0x28, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2F, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x70, 0x72, 
  0x6F, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x20, 0x26, 0x20, 0x6B, 0x76, 0x73, 0x29, 
  0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x75, 0x72, 0x65, 0x2C, 0x20, 0x61, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x75, 0x73, 0x75, 0x61, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x63, 
  0x6F, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x62, 0x75, 0x74, 0x20, 0x73, 
  0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x70, 0x72, 
  0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x2E, 
  0xDA, 0x88, 0x96, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x84, 0x1B, 0x01, 0xDA, 
  0x06, 0xDA, 0x88, 0x97, 0xDA, 0x08, 0xCE, 0x5C, 0x28, 0x65, 0x76, 0x2F, 0x63, 0x61, 0x70, 0x61, 
  0x63, 0x69, 0x74, 0x79, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x29, 0x0A, 0x0A, 0x47, 
  0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x20, 0x61, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x74, 0x6F, 0x72, 0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 
  0x72, 0x65, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x72, 0x69, 0x74, 
  0x65, 0x72, 0x73, 0x2E, 0xDA, 0x88, 0x98, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 
  0x86, 0x24, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x99, 0xDA, 0x08, 0xCE, 0x5C, 0x28, 0x66, 0x72, 0x65, 
  0x71, 0x75, 0x65, 0x6E, 0x63, 0x69, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 
  0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x6F, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 
  0x65, 0x61, 0x63, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x88, 0x9B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x12, 0x81, 0x7C, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x9C, 0xDA, 0x08, 0xCE, 0x81, 
  0xBE, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x20, 0x68, 0x6F, 
  0x73, 0x74, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x79, 0x70, 
  0x65, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x70, 
  0x6F, 0x72, 0x74, 0x29, 0x0A, 0x0A, 0x4F, 0x70, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6E, 
  0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x75, 
  0x6E, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x73, 0x65, 
  0x72, 0x76, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x64, 0x75, 0x70, 0x6C, 0x65, 0x78, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2E, 0x20, 0x54, 
  0x79, 0x70, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 
  0x61, 0x6C, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x70, 
  0x65, 0x63, 0x69, 0x66, 0x79, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2C, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 
  0x3A, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x6F, 0x72, 0x20, 0x3A, 0x64, 0x61, 0x74, 0x61, 
  0x67, 0x72, 0x61, 0x6D, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x3A, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0x20, 0x42, 0x69, 
  0x6E, 0x64, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 
  0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 
  0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x77, 0x68, 0x61, 0x74, 
  0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B, 0x65, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x75, 0x74, 0x67, 0x6F, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 
  0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x75, 0x73, 0x69, 
  0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4F, 0x53, 0x27, 0x73, 0x20, 0x70, 0x72, 0x65, 0x66, 
  0x65, 0x72, 0x72, 0x65, 0x64, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2E, 0x20, 0xDA, 
  0x88, 0x9D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8C, 0x24, 0x01, 0xDA, 0x06, 
  0xDA, 0x88, 0x9E, 0xDA, 0x08, 0xCE, 0x4E, 0x28, 0x65, 0x76, 0x2F, 0x72, 0x65, 0x6C, 0x65, 0x61, 
  0x73, 0x65, 0x2D, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x20, 0x61, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x73, 0x75, 
  0x63, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 
  0x72, 0x65, 0x61, 0x64, 0x73, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72, 
  0x65, 0x20, 0x69, 0x74, 0x2E, 0xDA, 0x88, 0x9F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x7E, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x26, 0xDA, 0x08, 0xCE, 0x1C, 0x28, 0x6E, 0x69, 0x6C, 
  0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 
  0x20, 0x69, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x88, 0xA0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x80, 0xAA, 0x6F, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x2D, 0xDA, 0x08, 0xCE, 0x73, 
  0x28, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x70, 0x20, 0x74, 0x75, 
  0x70, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x29, 0x0A, 0x0A, 
  0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 0x61, 
  0x70, 0x20, 0x6D, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 
  0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 
  0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 
  0x72, 0x73, 0x2E, 0xDA, 0x88, 0xA1, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x89, 
  0xE9, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xA2, 0xDA, 0x08, 0xCE, 0x80, 0xF6, 0x28, 0x71, 0x75, 0x69, 
  0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x54, 
  0x72, 0x69, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x72, 0x65, 
  0x70, 0x6C, 0x20, 0x6F, 0x72, 0x20, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 
  0x74, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x6C, 0x77, 0x61, 
  0x79, 0x73, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6C, 
  0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x57, 0x6F, 0x72, 0x6B, 0x73, 0x20, 0x62, 
  0x79, 0x20, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x65, 
  0x78, 0x69, 0x74, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0x20, 0x50, 0x61, 0x73, 
  0x73, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x6E, 0x69, 0x6C, 0x20, 0x60, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x60, 0x20, 0x68, 0x65, 0x72, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x75, 0x74, 0x65, 0x72, 
  0x0A, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x74, 0x6F, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x2E, 0xDA, 0x88, 0xA4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x84, 0xB4, 
  0x01, 0xDA, 0x06, 0xDA, 0x88, 0xA5, 0xDA, 0x08, 0xCE, 0x38, 0x28, 0x6F, 0x73, 0x2F, 0x73, 0x65, 
  0x74, 0x65, 0x6E, 0x76, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 
  0x65, 0x2E, 0xDA, 0x88, 0xA6, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xE3, 
  0x01, 0xDA, 0x06, 0xDA, 0x88, 0xA7, 0xDA, 0x08, 0xCE, 0x44, 0x28, 0x6D, 0x69, 0x6E, 0x2D, 0x6F, 
  0x66, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x69, 0x63, 0x20, 0x6D, 0x69, 0x6E, 
  0x69, 0x6D, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2E, 0xDA, 0x88, 
  0xA9, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x84, 0x1F, 0x01, 0xDA, 0x06, 
  0xDA, 0x82, 0xDF, 0xDA, 0x08, 0xCE, 0x81, 0x28, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 
  0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x77, 0x72, 0x61, 0x70, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x71, 0x75, 0x65, 
  0x75, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x71, 
  0x75, 0x65, 0x75, 0x65, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 
  0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x64, 0x65, 0x71, 0x75, 0x65, 
  0x75, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x77, 0x72, 0x61, 0x70, 0x60, 0x20, 0x69, 0x73, 0x20, 
  0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x31, 0x2D, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x72, 0x61, 0x70, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x69, 
  0x73, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 
  0x73, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2D, 0x6D, 
  0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6F, 0x73, 0x65, 0x73, 0x2E, 
  0xDA, 0x88, 0xAA, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x44, 0x01, 0xDA, 
  0x06, 0xDA, 0x85, 0x7B, 0xDA, 0x08, 0xCE, 0x52, 0x28, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 0x6D, 
  0x61, 0x67, 0x65, 0x20, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 
  0x69, 0x6E, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 
  0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 
  0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x85, 0xE4, 0xD3, 0x04, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x13, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xAB, 0xDA, 0x08, 
  0xCE, 0x80, 0x85, 0x28, 0x61, 0x6E, 0x64, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 
  0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x72, 0x65, 0x63, 0x65, 0x64, 0x69, 0x6E, 
  0x67, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 
  0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 
  0x0A, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x20, 0x61, 
  0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x88, 0xAD, 0xD3, 0x04, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0xE9, 0x03, 0xDA, 0x06, 0xDA, 0x88, 0xAE, 0xDA, 
  0x08, 0xCE, 0x5F, 0x28, 0x65, 0x76, 0x2F, 0x73, 0x70, 0x61, 0x77, 0x6E, 0x20, 0x26, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x63, 
  0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x68, 0x6F, 0x72, 
  0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x28, 0x65, 0x76, 0x2F, 0x67, 
  0x6F, 0x20, 0x28, 0x66, 0x6E, 0x20, 0x5B, 0x5D, 0x20, 0x3B, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x29, 
  0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x88, 0xB1, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x04, 0x85, 0x94, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xB2, 0xDA, 0x08, 0xCE, 0x81, 0x31, 0x28, 0x6F, 
  0x73, 0x2F, 0x6D, 0x6B, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x64, 0x61, 0x74, 0x65, 0x2D, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x29, 
  0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x72, 0x6F, 0x6B, 0x65, 0x6E, 
  0x20, 0x64, 0x6F, 0x77, 0x6E, 0x20, 0x64, 0x61, 0x74, 0x65, 0x2D, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 
  0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6E, 0x63, 0x65, 0x20, 
  0x4A, 0x61, 0x6E, 0x75, 0x61, 0x72, 0x79, 0x20, 0x31, 0x2C, 0x20, 0x31, 0x39, 0x37, 0x30, 0x2C, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x65, 0x70, 0x6F, 0x63, 0x68, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x44, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x55, 0x54, 0x43, 0x20, 0x75, 0x6E, 0x6C, 
  0x65, 0x73, 0x73, 0x20, 0x60, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 
  0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x69, 0x6E, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 
  0x63, 0x61, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x75, 0x74, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x7A, 0x6F, 0x6E, 0x65, 
  0x2E, 0x0A, 0x0A, 0x49, 0x6E, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x6F, 0x73, 0x2F, 0x64, 0x61, 0x74, 0x65, 0x2E, 0xDA, 
  0x88, 0xB3, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x84, 0x10, 0x01, 0xDA, 0x06, 
  0xDA, 0x88, 0xB4, 0xDA, 0x08, 0xCE, 0x35, 0x28, 0x65, 0x76, 0x2F, 0x66, 0x75, 0x6C, 0x6C, 0x20, 
  0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 
  0x69, 0x66, 0x20, 0x61, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x69, 0x73, 0x20, 
  0x66, 0x75, 0x6C, 0x6C, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x6F, 0x74, 0x2E, 0xDA, 0x88, 0xB5, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0x94, 0x01, 0xDA, 0x06, 0xDA, 0x88, 
  0xB6, 0xDA, 0x08, 0xCE, 0x4F, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x26, 0x20, 0x69, 0x74, 
  0x65, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 
  0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2E, 0xDA, 0x88, 0xB7, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 
  0x84, 0xCC, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xB8, 0xDA, 0x08, 0xCE, 0x80, 0x86, 0x28, 0x6F, 0x73, 
  0x2F, 0x74, 0x69, 0x6D, 0x65, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x65, 0x78, 0x70, 
  0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 
  0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x77, 0x68, 0x6F, 0x6C, 0x65, 0x20, 0x73, 0x65, 
  0x63, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6E, 0x63, 0x65, 0x20, 0x4A, 0x61, 0x6E, 0x75, 
  0x61, 0x72, 0x79, 0x20, 0x31, 0x2C, 0x20, 0x31, 0x39, 0x37, 0x30, 0x2C, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x65, 0x70, 0x6F, 0x63, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x2E, 0xDA, 0x88, 0x23, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x2D, 
  0x01, 0xDA, 0x06, 0xDA, 0x88, 0xB9, 0xDA, 0x08, 0xCE, 0x27, 0x28, 0x64, 0x65, 0x66, 0x6D, 0x61, 
  0x63, 0x72, 0x6F, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 
  0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 
  0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x88, 0xBB, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x84, 0xBF, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x14, 0xDA, 0x08, 0xCE, 0x7A, 
  0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 
  0x72, 0x64, 0x20, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x73, 0x20, 0x64, 0x65, 0x6E, 0x6F, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x6C, 
  0x69, 0x6E, 0x74, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x62, 
  0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 
  0x65, 0x64, 0x20, 0x63, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x65, 
  0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x69, 0x63, 0x20, 0x6C, 0x69, 
  0x6E, 0x74, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x73, 0x2E, 0xDA, 0x88, 0xBC, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x83, 0x82, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0xDB, 0xDA, 
  0x08, 0xCE, 0x80, 0x89, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0x29, 
  0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2E, 0x20, 0x50, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x6D, 0x61, 0x63, 
  0x68, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x72, 
  0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 
  0x61, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0xDA, 0x88, 0xBD, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 0xCB, 0x01, 0xDA, 0x06, 0xDA, 0x88, 
  0xBE, 0xDA, 0x08, 0xCE, 0x81, 0x52, 0x28, 0x6F, 0x73, 0x2F, 0x70, 0x65, 0x72, 0x6D, 0x2D, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x74, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6E, 0x76, 
  0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x6F, 0x63, 0x74, 0x61, 0x6C, 
  0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 
  0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x60, 0x6F, 0x73, 0x2F, 0x73, 
  0x74, 0x61, 0x74, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x68, 0x75, 0x6D, 0x61, 0x6E, 0x20, 
  0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x20, 
  0x55, 0x6E, 0x69, 0x78, 0x20, 0x74, 0x6F, 0x6F, 0x6C, 0x73, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 
  0x60, 0x6C, 0x73, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x39, 0x2D, 
  0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x6F, 0x66, 0x20, 0x72, 0x2C, 0x20, 0x77, 0x2C, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x2D, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x2E, 0x20, 0x44, 0x6F, 
  0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 
  0x79, 0x2F, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 
  0x74, 0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x72, 0x65, 0x6E, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20, 
  0x62, 0x79, 0x20, 0x60, 0x6C, 0x73, 0x60, 0x2E, 0xDA, 0x88, 0xBF, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x2E, 0x83, 0xD6, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xC0, 0xDA, 0x08, 0xCE, 0x82, 
  0x81, 0x28, 0x65, 0x76, 0x2F, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x20, 0x26, 0x20, 0x63, 0x6C, 
  0x61, 0x75, 0x73, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x42, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x75, 0x6E, 
  0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6F, 0x66, 
  0x20, 0x73, 0x65, 0x76, 0x65, 0x72, 0x61, 0x6C, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 
  0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x6F, 0x63, 0x63, 0x75, 
  0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 
  0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x5B, 
  0x3A, 0x67, 0x69, 0x76, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x5D, 0x2C, 0x20, 0x5B, 0x3A, 0x74, 
  0x61, 0x6B, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x20, 0x78, 0x5D, 0x2C, 0x20, 0x6F, 0x72, 0x20, 
  0x5B, 0x3A, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x5D, 0x2C, 0x20, 0x77, 
  0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x20, 0x3A, 0x67, 0x69, 0x76, 0x65, 0x20, 0x74, 0x75, 0x70, 
  0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x3A, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x72, 
  0x65, 0x61, 0x64, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x63, 0x6C, 0x61, 0x75, 0x73, 0x65, 
  0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 
  0x61, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x28, 0x66, 0x6F, 0x72, 0x20, 0x61, 
  0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x6F, 0x70, 
  0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x5B, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x78, 0x5D, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x67, 0x69, 
  0x76, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x4F, 0x70, 
  0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x72, 0x69, 
  0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2C, 0x20, 0x73, 0x75, 0x63, 
  0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 
  0x20, 0x63, 0x6C, 0x61, 0x75, 0x73, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x61, 
  0x6B, 0x65, 0x20, 0x70, 0x72, 0x65, 0x63, 0x65, 0x64, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x76, 
  0x65, 0x72, 0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 0x20, 0x63, 0x6C, 0x61, 0x75, 0x73, 0x65, 0x73, 
  0x2E, 0x20, 0x42, 0x6F, 0x74, 0x68, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x67, 0x69, 0x76, 0x65, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 
  0x20, 0x5B, 0x3A, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x5D, 0x20, 0x74, 
  0x75, 0x70, 0x6C, 0x65, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x6E, 0x64, 0x69, 
  0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 
  0x20, 0x77, 0x61, 0x73, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x64, 0x20, 0x77, 0x68, 0x69, 0x6C, 
  0x65, 0x20, 0x77, 0x61, 0x69, 0x74, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x77, 
  0x61, 0x73, 0x20, 0x61, 0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 
  0x64, 0x2E, 0xDA, 0x88, 0xC1, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x84, 0x4E, 
  0x01, 0xDA, 0x06, 0xDA, 0x88, 0xC2, 0xDA, 0x08, 0xCE, 0x80, 0xC2, 0x28, 0x65, 0x76, 0x2F, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x2D, 0x63, 0x68, 0x61, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x6C, 0x69, 0x6D, 0x69, 0x74, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 
  0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x65, 0x64, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 
  0x6C, 0x2E, 0x20, 0x41, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x65, 0x64, 0x20, 0x63, 0x68, 
  0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 
  0x65, 0x6C, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x73, 
  0x68, 0x61, 0x72, 0x65, 0x64, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x74, 0x68, 
  0x72, 0x65, 0x61, 0x64, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 
  0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x20, 0x6F, 0x66, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x79, 
  0x73, 0x74, 0x65, 0x6D, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x2E, 0xDA, 0x88, 0xC3, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x83, 0xC6, 0x01, 0xDA, 0x06, 0xDA, 0x87, 
  0xB3, 0xDA, 0x08, 0xCE, 0x5E, 0x28, 0x65, 0x76, 0x2F, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x63, 0x68, 
  0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x61, 0x64, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x61, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x2C, 0x20, 0x73, 0x75, 0x73, 
  0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 
  0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 
  0x6C, 0x65, 0x2E, 0xDA, 0x88, 0xC4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 
  0x82, 0x5A, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xC5, 0xDA, 0x08, 0xCE, 0x45, 0x28, 0x75, 0x6E, 0x74, 
  0x72, 0x61, 0x63, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x29, 0x0A, 0x0A, 0x44, 0x69, 0x73, 0x61, 
  0x62, 0x6C, 0x65, 0x73, 0x20, 0x74, 0x72, 0x61, 0x63, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x6E, 0x20, 
  0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x2E, 0xDA, 0x88, 0xC6, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x33, 0x01, 0xDA, 
  0x06, 0xDA, 0x88, 0xC7, 0xDA, 0x08, 0xCE, 0x80, 0xFE, 0x28, 0x61, 0x73, 0x2D, 0x6D, 0x61, 0x63, 
  0x72, 0x6F, 0x20, 0x66, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x55, 0x73, 
  0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x72, 0x20, 
  0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x6C, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6C, 0x20, 0x60, 0x66, 
  0x60, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x54, 0x68, 
  0x69, 0x73, 0x20, 0x6C, 0x65, 0x74, 0x73, 0x0A, 0x61, 0x6E, 0x79, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 
  0x61, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x49, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 
  0x61, 0x20, 0x71, 0x75, 0x61, 0x73, 0x69, 0x71, 0x75, 0x6F, 0x74, 0x65, 0x2C, 0x20, 0x74, 0x68, 
  0x65, 0x0A, 0x69, 0x64, 0x69, 0x6F, 0x6D, 0x20, 0x60, 0x28, 0x61, 0x73, 0x2D, 0x6D, 0x61, 0x63, 
  0x72, 0x6F, 0x20, 0x2C, 0x6D, 0x79, 0x2D, 0x63, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x2D, 0x6D, 0x61, 
  0x63, 0x72, 0x6F, 0x20, 0x61, 0x72, 0x67, 0x31, 0x20, 0x61, 0x72, 0x67, 0x32, 0x2E, 0x2E, 0x2E, 
  0x29, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x0A, 0x74, 
  0x6F, 0x20, 0x61, 0x76, 0x6F, 0x69, 0x64, 0x20, 0x75, 0x6E, 0x77, 0x61, 0x6E, 0x74, 0x65, 0x64, 
  0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x6D, 0x79, 0x2D, 0x63, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x2D, 
  0x6D, 0x61, 0x63, 0x72, 0x6F, 0x60, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x88, 0xC9, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x2D, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xCA, 0xDA, 0x08, 
  0xCE, 0x81, 0x40, 0x28, 0x67, 0x72, 0x6F, 0x75, 0x70, 0x2D, 0x62, 0x79, 0x20, 0x66, 0x20, 0x69, 
  0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 0x72, 0x6F, 0x75, 0x70, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x69, 0x6E, 0x64, 0x60, 0x20, 0x62, 0x79, 0x20, 
  0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x60, 0x66, 0x60, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x70, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 
  0x74, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x6F, 0x66, 
  0x0A, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6E, 0x63, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x63, 
  0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x66, 0x60, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x69, 
  0x6E, 0x64, 0x60, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x0A, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x61, 0x72, 0x65, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x69, 0x6E, 0x64, 0x60, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x60, 0x66, 0x60, 0x20, 0x63, 
  0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x73, 0x0A, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x63, 0x6F, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6B, 
  0x65, 0x79, 0x2E, 0xDA, 0x88, 0xCC, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 
  0x84, 0x2D, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xCD, 0xDA, 0x08, 0xCE, 0x80, 0xE3, 0x28, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x2E, 0x20, 0x43, 0x61, 0x6E, 
  0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x65, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 
  0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 0x61, 0x73, 0x20, 0x65, 0x6E, 0x63, 
  0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x72, 0x65, 0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x69, 0x6E, 
  0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x63, 0x6F, 0x75, 
  0x6E, 0x74, 0x65, 0x72, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x67, 0x69, 
  0x6E, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x2C, 0x20, 0x63, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 
  0xDA, 0x88, 0xCE, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x8B, 0x01, 0xDA, 
  0x06, 0xDA, 0x88, 0xCF, 0xDA, 0x08, 0xCE, 0x43, 0x28, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 
  0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x73, 0x2E, 
  0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x31, 0x2E, 0xDA, 0x88, 0xD1, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 0xB4, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xD2, 0xDA, 
  0x08, 0xCE, 0x80, 0xA2, 0x28, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x61, 0x6C, 0x70, 0x61, 0x74, 0x68, 
  0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x61, 0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2C, 0x20, 
  0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x20, 0x2E, 0x2E, 0x2F, 0x2C, 0x20, 0x2E, 
  0x2F, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x73, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x6F, 
  0x6C, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x61, 0x69, 0x73, 
  0x65, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 
  0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0xDA, 0x88, 0xD3, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x84, 0x54, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xD4, 0xDA, 0x08, 0xCE, 0x7E, 0x28, 0x74, 
  0x61, 0x6B, 0x65, 0x20, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6E, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x2C, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x6F, 0x72, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x72, 
  0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x2E, 0xDA, 0x88, 0xDA, 0xD3, 
  0x02, 0xDA, 0x06, 0xDA, 0x84, 0x34, 0xDA, 0x08, 0xCE, 0x81, 0x5C, 0x28, 0x61, 0x70, 0x70, 0x6C, 
  0x79, 0x20, 0x66, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x41, 0x70, 0x70, 
  0x6C, 0x69, 0x65, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x74, 0x6F, 0x20, 0x61, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6E, 0x75, 
  0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x73, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 
  0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 
  0x6F, 0x20, 0x66, 0x2C, 0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x72, 0x67, 0x73, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x65, 
  0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2D, 0x6C, 0x69, 0x6B, 0x65, 0x2E, 0x20, 0x45, 0x61, 0x63, 
  0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x69, 
  0x73, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x70, 0x75, 0x73, 
  0x68, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 
  0x6D, 0x70, 0x6C, 0x65, 0x3A, 0x0A, 0x0A, 0x09, 0x28, 0x61, 0x70, 0x70, 0x6C, 0x79, 0x20, 0x2B, 
  0x20, 0x31, 0x30, 0x30, 0x30, 0x20, 0x28, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x31, 0x30, 0x29, 
  0x29, 0x0A, 0x0A, 0x73, 0x75, 0x6D, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 
  0x74, 0x20, 0x31, 0x30, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x73, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x31, 0x30, 0x30, 0x30, 0x2E, 0xDA, 0x88, 0xDB, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x80, 0xAA, 0x3C, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x86, 0xDA, 0x08, 0xCE, 0x50, 0x28, 
  0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x20, 0x26, 
  0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x65, 0x64, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x78, 0x73, 0x2E, 0xDA, 
  0x88, 0xDC, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x6C, 0x01, 0xDA, 0x06, 0xDA, 
  0x88, 0xDD, 0xDA, 0x08, 0xCE, 0x27, 0x28, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 
  0x20, 0x61, 0x20, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x88, 0xE0, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x8C, 0xAB, 0x80, 0xC6, 0x01, 0xDA, 0x06, 0xDA, 
  0x88, 0xE1, 0xDA, 0x08, 0xCE, 0x4A, 0x28, 0x69, 0x6E, 0x74, 0x2F, 0x73, 0x36, 0x34, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 
  0x62, 0x6F, 0x78, 0x65, 0x64, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x36, 0x34, 0x20, 
  0x62, 0x69, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 
  0xDA, 0x88, 0xE2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 0x85, 0x80, 0x01, 0xDA, 
  0x06, 0xDA, 0x88, 0xE3, 0xDA, 0x08, 0xCE, 0x81, 0xF1, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x74, 0x72, 
  0x61, 0x6D, 0x70, 0x6F, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x63, 0x29, 0x0A, 0x0A, 0x47, 0x65, 
  0x74, 0x20, 0x61, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 
  0x61, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 
  0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x43, 0x20, 0x6C, 0x69, 0x62, 0x72, 0x61, 
  0x72, 0x69, 0x65, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 
  0x61, 0x63, 0x6B, 0x20, 0x74, 0x72, 0x61, 0x6D, 0x70, 0x6F, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x68, 
  0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 
  0x20, 0x60, 0x76, 0x6F, 0x69, 0x64, 0x20, 0x74, 0x72, 0x61, 0x6D, 0x70, 0x6F, 0x6C, 0x69, 0x6E, 
  0x65, 0x28, 0x76, 0x6F, 0x69, 0x64, 0x20, 0x5C, 0x2A, 0x63, 0x74, 0x78, 0x2C, 0x20, 0x76, 0x6F, 
  0x69, 0x64, 0x20, 0x5C, 0x2A, 0x75, 0x73, 0x65, 0x72, 0x64, 0x61, 0x74, 0x61, 0x29, 0x60, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x63, 0x61, 0x6C, 
  0x6C, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x6E, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 
  0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 
  0x79, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 
  0x74, 0x75, 0x72, 0x65, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0x20, 
  0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x6E, 
  0x73, 0x75, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x75, 
  0x73, 0x65, 0x72, 0x64, 0x61, 0x74, 0x61, 0x60, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x2C, 0x20, 0x60, 0x63, 0x74, 0x78, 0x60, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x61, 0x71, 0x75, 0x65, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 
  0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x66, 0x75, 0x72, 0x74, 0x68, 0x65, 0x72, 0x20, 
  0x69, 0x6E, 0x73, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 
  0x66, 0x66, 0x69, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x60, 0x2E, 0xDA, 0x88, 0xE4, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 0x39, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xE5, 0xDA, 0x08, 
  0xCE, 0x80, 0xC7, 0x28, 0x66, 0x72, 0x65, 0x65, 0x7A, 0x65, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x46, 
  0x72, 0x65, 0x65, 0x7A, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 
  0x28, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x69, 0x74, 0x20, 0x69, 0x6D, 0x6D, 0x75, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x29, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x64, 0x6F, 0x20, 0x61, 0x20, 0x64, 0x65, 0x65, 
  0x70, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x2C, 0x20, 0x6D, 0x61, 0x6B, 0x69, 0x6E, 0x67, 0x0A, 0x63, 
  0x68, 0x69, 0x6C, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 
  0x20, 0x69, 0x6D, 0x6D, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x43, 0x6C, 0x6F, 0x73, 
  0x75, 0x72, 0x65, 0x73, 0x2C, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x73, 0x2C, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 
  0x0A, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x63, 
  0x75, 0x72, 0x73, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x20, 0x66, 0x72, 0x6F, 0x7A, 0x65, 0x6E, 0x2C, 
  0x20, 0x62, 0x75, 0x74, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 
  0x79, 0x70, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x2E, 0xDA, 0x88, 0xE7, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x84, 0x50, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xE8, 0xDA, 0x08, 
  0xCE, 0x83, 0x04, 0x28, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x61, 
  0x72, 0x67, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x65, 
  0x6E, 0x76, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x61, 0x20, 0x70, 
  0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x79, 
  0x73, 0x74, 0x65, 0x6D, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x69, 0x74, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x2E, 0x20, 0x60, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 
  0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6D, 0x6F, 0x64, 
  0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x68, 0x6F, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 
  0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 
  0x74, 0x65, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x65, 0x20, 0x2D, 0x20, 0x65, 0x6E, 0x61, 0x62, 0x6C, 
  0x65, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 
  0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0x20, 0x57, 0x69, 0x74, 0x68, 0x6F, 0x75, 
  0x74, 0x20, 0x3A, 0x65, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x69, 0x6E, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x70, 
  0x20, 0x2D, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 
  0x50, 0x41, 0x54, 0x48, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x6E, 
  0x61, 0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x2E, 0x20, 
  0x57, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x6C, 0x61, 
  0x67, 0x2C, 0x20, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x69, 0x65, 0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 
  0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 
  0x74, 0x68, 0x73, 0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x78, 0x20, 0x2D, 0x20, 0x72, 0x61, 0x69, 0x73, 
  0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 
  0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x7A, 0x65, 0x72, 0x6F, 
  0x2E, 0x0A, 0x2A, 0x20, 0x3A, 0x64, 0x20, 0x2D, 0x20, 0x44, 0x6F, 0x6E, 0x27, 0x74, 0x20, 0x74, 
  0x72, 0x79, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x65, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x6F, 0x6E, 0x20, 
  0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x28, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x73, 0x70, 0x61, 0x77, 0x6E, 0x69, 
  0x6E, 0x67, 0x20, 0x7A, 0x6F, 0x6D, 0x62, 0x69, 0x65, 0x73, 0x29, 0x2E, 0x0A, 0x60, 0x65, 0x6E, 
  0x76, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 
  0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 
  0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 
  0x61, 0x62, 0x6C, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 
  0x20, 0x49, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x63, 0x6F, 0x6E, 
  0x74, 0x61, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x3A, 0x69, 
  0x6E, 0x2C, 0x20, 0x3A, 0x6F, 0x75, 0x74, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x3A, 0x65, 0x72, 
  0x72, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x72, 
  0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x64, 0x69, 0x6F, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 0x70, 0x72, 0x6F, 0x63, 0x65, 
  0x73, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x63, 0x6F, 
  0x72, 0x65, 0x2F, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x69, 0x74, 
  0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 0x88, 0xE9, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x83, 0x49, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xE5, 0xDA, 0x08, 0xCE, 0x80, 0xC7, 
  0x28, 0x73, 0x6F, 0x72, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 
  0x65, 0x66, 0x6F, 0x72, 0x65, 0x3F, 0x29, 0x0A, 0x0A, 0x53, 0x6F, 0x72, 0x74, 0x73, 0x20, 0x60, 
  0x69, 0x6E, 0x64, 0x60, 0x20, 0x69, 0x6E, 0x2D, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x2E, 0x20, 0x55, 
  0x73, 0x65, 0x73, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6B, 0x2D, 0x73, 0x6F, 0x72, 0x74, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x73, 0x6F, 0x72, 0x74, 0x2E, 0x0A, 0x49, 0x66, 0x20, 0x61, 0x20, 0x60, 0x62, 
  0x65, 0x66, 0x6F, 0x72, 0x65, 0x3F, 0x60, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 
  0x6F, 0x72, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x70, 
  0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x73, 0x6F, 0x72, 0x74, 0x73, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x2C, 0x0A, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x75, 0x73, 
  0x65, 0x73, 0x20, 0x60, 0x3C, 0x60, 0x2E, 0xDA, 0x88, 0xEA, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x84, 0xC1, 0x82, 0x63, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xEB, 0xDA, 0x08, 0xCE, 0x5C, 
  0x28, 0x69, 0x6E, 0x74, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 
  0x69, 0x66, 0x20, 0x78, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 0x61, 0x63, 
  0x74, 0x6C, 0x79, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x65, 0x64, 0x20, 
  0x61, 0x73, 0x20, 0x61, 0x20, 0x33, 0x32, 0x20, 0x62, 0x69, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 
  0x65, 0x64, 0x20, 0x74, 0x77, 0x6F, 0x27, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0xDA, 0x88, 0xEC, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x80, 0x91, 0x01, 0xDA, 0x06, 0xDA, 0x88, 
  0xED, 0xDA, 0x08, 0xCE, 0x51, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x75, 
  0x6E, 0x69, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x72, 0x6E, 0x67, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x74, 
  0x72, 0x61, 0x63, 0x74, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x6E, 0x75, 
  0x6D, 0x62, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 
  0x65, 0x20, 0x5B, 0x30, 0x2C, 0x20, 0x31, 0x29, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x52, 0x4E, 0x47, 0x2E, 0xDA, 0x88, 0xEE, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8B, 0xAE, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x1C, 0xDA, 0x08, 
  0xCE, 0x42, 0x57, 0x69, 0x64, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 
  0x6E, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x64, 0x6F, 0x63, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x65, 
  0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x64, 0x6F, 0x63, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 
  0x61, 0x74, 0x60, 0x2E, 0xDA, 0x88, 0xEF, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 
  0xA4, 0x80, 0x9B, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xF0, 0xDA, 0x08, 0xCE, 0x80, 0x8D, 0x28, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x69, 0x6E, 0x74, 0x20, 0x72, 0x6E, 0x67, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x6D, 0x61, 0x78, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x74, 0x72, 0x61, 
  0x63, 0x74, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x72, 0x61, 0x6E, 0x64, 
  0x6F, 0x6D, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x5B, 0x30, 0x2C, 0x20, 0x6D, 0x61, 0x78, 0x5D, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x52, 0x4E, 0x47, 0x2E, 0x20, 0x49, 
  0x66, 0x20, 0x6E, 0x6F, 0x20, 0x6D, 0x61, 0x78, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 
  0x6E, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 
  0x73, 0x20, 0x32, 0x5E, 0x33, 0x31, 0x20, 0x2D, 0x20, 0x31, 0x2E, 0xDA, 0x88, 0xF1, 0xD3, 0x04, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x8D, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xF2, 0xDA, 
  0x08, 0xCE, 0x80, 0xD0, 0x28, 0x69, 0x66, 0x2D, 0x77, 0x69, 0x74, 0x68, 0x20, 0x5B, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x64, 0x74, 0x6F, 0x72, 0x5D, 
  0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x66, 0x61, 0x6C, 
  0x73, 0x65, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 
  0x20, 0x60, 0x77, 0x69, 0x74, 0x68, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x69, 0x66, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 
  0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 
  0x65, 0x73, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x20, 0x70, 0x61, 
  0x74, 0x68, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x65, 
  0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x72, 0x75, 
  0x74, 0x68, 0x79, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 0x49, 0x6E, 0x20, 0x62, 0x6F, 0x74, 
  0x68, 0x20, 0x63, 0x61, 0x73, 0x65, 0x73, 0x2C, 0x0A, 0x60, 0x63, 0x74, 0x6F, 0x72, 0x60, 0x20, 
  0x69, 0x73, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x69, 0x6E, 0x64, 
  0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x88, 0xF4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x04, 0x84, 0xA4, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0xF5, 0xDA, 0x08, 0xCE, 0x50, 0x28, 
  0x6F, 0x73, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 0x76, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x47, 
  0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 
  0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 
  0x88, 0xF6, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x08, 0x01, 0xDA, 
  0x06, 0xDA, 0x88, 0xF7, 0xDA, 0x08, 0xCE, 0x2A, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x63, 
  0x6F, 0x73, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x61, 0x72, 0x63, 0x63, 0x6F, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x78, 0x2E, 0xDA, 0x88, 0xF8, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x88, 0xF9, 0xDA, 0x08, 0xCE, 0x80, 
  0x99, 0x28, 0x63, 0x6D, 0x70, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x2D, 0x31, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x63, 0x74, 0x6C, 0x79, 0x20, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 
  0x6E, 0x20, 0x79, 0x2C, 0x20, 0x31, 0x20, 0x69, 0x66, 0x20, 0x79, 0x20, 0x69, 0x73, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x63, 0x74, 0x6C, 0x79, 0x20, 0x67, 0x72, 0x65, 0x61, 0x74, 0x65, 0x72, 0x20, 
  0x74, 0x68, 0x61, 0x6E, 0x20, 0x78, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x30, 0x20, 0x6F, 0x74, 
  0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2E, 0x20, 0x54, 0x6F, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x30, 0x2C, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x79, 0x20, 0x6D, 0x75, 
  0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x61, 0x63, 0x74, 0x20, 
  0x73, 0x61, 0x6D, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0xDA, 0x88, 0xFB, 0xD3, 0x02, 0xDA, 
  0x06, 0xDA, 0x85, 0xF4, 0xDA, 0x08, 0xCE, 0x81, 0x30, 0x28, 0x67, 0x65, 0x74, 0x20, 0x64, 0x73, 
  0x20, 0x6B, 0x65, 0x79, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6D, 
  0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x6E, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x64, 
  0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x64, 0x66, 
  0x6C, 0x74, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x74, 
  0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0x20, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 
  0x74, 0x6F, 0x20, 0x69, 0x6E, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x73, 
  0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 
  0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 0x49, 
  0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x73, 0x65, 0x2C, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x67, 
  0x65, 0x74, 0x74, 0x65, 0x72, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 
  0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x88, 0xFC, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x4F, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x2E, 0xDA, 0x08, 0xCE, 
  0x41, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 
  0x67, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x64, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 
  0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x69, 0x72, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x2E, 0xDA, 0x88, 0xFD, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x67, 0x01, 
  0xDA, 0x06, 0xDA, 0x82, 0x3D, 0xDA, 0x08, 0xCE, 0x24, 0x28, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 
  0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0xDA, 0x88, 0xFE, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x25, 0x01, 0xDA, 0x06, 0xDA, 
  0x88, 0xFF, 0xDA, 0x08, 0xCE, 0x3D, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 0x66, 0x63, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x72, 0x79, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 
  0x20, 0x78, 0x2E, 0xDA, 0x89, 0x00, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 
  0xA0, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x01, 0xDA, 0x08, 0xCE, 0x81, 0x61, 0x28, 0x64, 0x65, 0x66, 
  0x64, 0x79, 0x6E, 0x20, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 
  0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x69, 
  0x61, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 
  0x20, 0x61, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x0A, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x20, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x2C, 0x20, 0x6C, 0x65, 0x78, 0x69, 0x63, 
  0x61, 0x6C, 0x6C, 0x79, 0x20, 0x73, 0x63, 0x6F, 0x70, 0x65, 0x64, 0x20, 0x62, 0x69, 0x6E, 0x64, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 
  0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x0A, 
  0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x65, 
  0x76, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x79, 0x70, 0x6F, 0x73, 0x2E, 0x20, 0x60, 0x64, 0x65, 0x66, 
  0x64, 0x79, 0x6E, 0x60, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x73, 0x65, 
  0x74, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x0A, 
  0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x60, 0x64, 0x79, 0x6E, 0x60, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x60, 0x73, 0x65, 0x74, 0x64, 0x79, 0x6E, 0x60, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x61, 0x6C, 0x69, 0x61, 0x73, 0x20, 0x5F, 0x6D, 0x75, 0x73, 0x74, 0x5F, 0x20, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x60, 0x2A, 0x60, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 
  0x72, 0x2C, 0x20, 0x75, 0x73, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x0A, 0x63, 0x61, 0x6C, 0x6C, 0x65, 
  0x64, 0x20, 0x22, 0x65, 0x61, 0x72, 0x6D, 0x75, 0x66, 0x66, 0x73, 0x22, 0x2E, 0xDA, 0x2B, 0xCB, 
  0xDA, 0x89, 0x07, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x81, 0x7C, 0x01, 0xDA, 
  0x06, 0xDA, 0x89, 0x08, 0xDA, 0x08, 0xCE, 0x81, 0x41, 0x28, 0x77, 0x69, 0x74, 0x68, 0x20, 0x5B, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x64, 0x74, 0x6F, 
  0x72, 0x5D, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 
  0x75, 0x61, 0x74, 0x65, 0x20, 0x60, 0x62, 0x6F, 0x64, 0x79, 0x60, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2C, 0x20, 
  0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x75, 
  0x74, 0x6F, 0x6D, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x63, 0x6C, 0x65, 0x61, 
  0x6E, 0x65, 0x64, 0x20, 0x75, 0x70, 0x0A, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 
  0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x60, 
  0x62, 0x6F, 0x64, 0x79, 0x60, 0x2E, 0x20, 0x60, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x60, 
  0x20, 0x69, 0x73, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x60, 0x63, 0x74, 0x6F, 
  0x72, 0x60, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x0A, 0x60, 0x64, 0x74, 0x6F, 0x72, 0x60, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x72, 0x20, 
  0x63, 0x61, 0x6C, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x6E, 0x64, 
  0x69, 0x6E, 0x67, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x64, 0x65, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x6F, 0x72, 0x0A, 0x28, 0x60, 0x64, 0x74, 0x6F, 0x72, 0x60, 0x29, 0x20, 0x69, 
  0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x63, 0x61, 
  0x6C, 0x6C, 0x20, 0x3A, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0x0A, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xB0, 0x81, 0x58, 0x01, 0xDA, 0x06, 0xDA, 
  0x89, 0x0B, 0xDA, 0x08, 0xCE, 0x80, 0xE8, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x72, 0x61, 
  0x77, 0x67, 0x65, 0x74, 0x20, 0x74, 0x61, 0x62, 0x20, 0x6B, 0x65, 0x79, 0x29, 0x0A, 0x0A, 0x47, 
  0x65, 0x74, 0x73, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x60, 0x74, 0x61, 0x62, 0x60, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x61, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x74, 0x61, 0x62, 0x60, 0x20, 
  0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6C, 
  0x79, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 
  0x89, 0x0C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8B, 0x5F, 0x01, 0xDA, 0x06, 
  0xDA, 0x87, 0x43, 0xDA, 0x08, 0xCE, 0x81, 0x4F, 0x28, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x2D, 0x6D, 
  0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x73, 0x6F, 0x75, 
  0x72, 0x63, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 
  0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0x29, 0x0A, 0x0A, 0x4D, 0x65, 0x72, 0x67, 0x65, 0x20, 0x61, 
  0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 
  0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x60, 
  0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x61, 0x20, 0x60, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x60, 0x2C, 0x20, 0x61, 0x73, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x69, 0x6D, 0x70, 0x6F, 0x72, 
  0x74, 0x60, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x0A, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6C, 
  0x65, 0x74, 0x73, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x20, 0x65, 0x6D, 0x75, 0x6C, 0x61, 0x74, 
  0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6F, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x60, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x60, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x61, 0x20, 0x63, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x0A, 0x49, 0x66, 0x20, 0x60, 0x65, 0x78, 0x70, 0x6F, 0x72, 
  0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x74, 0x68, 
  0x65, 0x6E, 0x20, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x64, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x61, 0x72, 0x6B, 
  0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 
  0x69, 0x65, 0x64, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 
  0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x89, 0x0D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x82, 0xC4, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0x45, 0xDA, 0x08, 0xCE, 0x33, 0x28, 
  0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x74, 0x79, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x41, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x73, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x2E, 0xDA, 0x89, 0x0E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 
  0x0F, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x0F, 0xDA, 0x08, 0xCE, 0x30, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x73, 0x69, 0x6E, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 0x63, 
  0x20, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x89, 0x10, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x87, 0xA0, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x11, 0xDA, 
  0x08, 0xCE, 0x80, 0xAF, 0x28, 0x6D, 0x61, 0x63, 0x6C, 0x69, 0x6E, 0x74, 0x66, 0x20, 0x6C, 0x65, 
  0x76, 0x65, 0x6C, 0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 
  0x0A, 0x57, 0x68, 0x65, 0x6E, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x61, 0x20, 0x6D, 
  0x61, 0x63, 0x72, 0x6F, 0x2C, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x64, 0x64, 0x20, 
  0x61, 0x20, 0x6C, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x77, 0x61, 0x72, 0x6E, 0x69, 0x6E, 0x67, 
  0x2E, 0x20, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x0A, 0x61, 0x20, 0x60, 0x66, 0x6D, 0x74, 0x60, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x60, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x60, 0x2C, 0x20, 0x77, 
  0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 
  0x67, 0x65, 0x2E, 0xDA, 0x89, 0x13, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 
  0x3E, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x14, 0xDA, 0x08, 0xCE, 0x72, 0x28, 0x6D, 0x61, 0x6B, 0x65, 
  0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 
  0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x60, 0x72, 0x65, 
  0x71, 0x75, 0x69, 0x72, 0x65, 0x60, 0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 
  0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x89, 0x17, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x86, 0x31, 0x01, 0xDA, 0x06, 0xDA, 0x89, 
  0x18, 0xDA, 0x08, 0xCE, 0x29, 0x28, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x29, 0x0A, 0x0A, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x89, 
  0x19, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x57, 0x01, 0xDA, 0x06, 
  0xDA, 0x89, 0x1A, 0xDA, 0x08, 0xCE, 0x3D, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x63, 0x6D, 
  0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x65, 0x61, 0x73, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E, 0x20, 
  0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x79, 0x2E, 0xDA, 0x89, 0x1B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 
  0x83, 0xCF, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x1C, 0xDA, 0x08, 0xCE, 0x79, 0x28, 0x6D, 0x61, 0x70, 
  0x63, 0x61, 0x74, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x70, 0x20, 
  0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 
  0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 
  0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 
  0x6C, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x0A, 0x75, 0x73, 0x65, 0x20, 0x60, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2F, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6E, 
  0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 
  0x75, 0x6C, 0x74, 0x73, 0x2E, 0xDA, 0x89, 0x1F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x80, 0xA4, 0x81, 0x18, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x20, 0xDA, 0x08, 0xCE, 0x2D, 0x28, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x30, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x67, 0x20, 0x62, 0x61, 
  0x73, 0x65, 0x20, 0x31, 0x30, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x89, 0x21, 0xD3, 0x04, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x01, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x22, 0xDA, 
  0x08, 0xCE, 0x3D, 0x28, 0x65, 0x61, 0x63, 0x68, 0x6B, 0x20, 0x78, 0x20, 0x64, 0x73, 0x20, 0x26, 
  0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 
  0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x64, 
  0x73, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 
  0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0x1E, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x8E, 0x3B, 0x03, 0xDA, 0x06, 0xDA, 0x85, 0xC7, 0xDA, 0x08, 0xCE, 0x37, 0x20, 
  0x43, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6C, 
  0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x66, 0x66, 0x69, 0x2F, 0x62, 
  0x69, 0x6E, 0x64, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x73, 0x65, 
  0x74, 0x74, 0x69, 0x6E, 0x67, 0x73, 0xDA, 0x89, 0x24, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x87, 0x0E, 
  0xDA, 0x08, 0xCE, 0x81, 0x69, 0x28, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x64, 0x73, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 
  0x43, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 
  0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 
  0x6E, 0x20, 0x75, 0x6E, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x6F, 0x72, 
  0x64, 0x65, 0x72, 0x2E, 0x20, 0x4B, 0x65, 0x79, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x67, 0x75, 
  0x61, 0x72, 0x61, 0x6E, 0x74, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x73, 
  0x65, 0x65, 0x6E, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x6F, 0x6E, 0x63, 0x65, 0x20, 0x70, 0x65, 
  0x72, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x79, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 
  0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x75, 0x74, 0x61, 0x74, 0x65, 
  0x64, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x69, 
  0x6C, 0x2C, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x2E, 0x20, 0x49, 
  0x66, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 
  0x69, 0x6C, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 
  0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 
  0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x2E, 0xDA, 0x89, 
  0x25, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 0x85, 0x42, 0x01, 0xDA, 0x06, 0xDA, 
  0x85, 0xC2, 0xDA, 0x08, 0xCE, 0x80, 0xB1, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x61, 0x6C, 0x6C, 
  0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 
  0x72, 0x65, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x61, 0x6C, 0x6C, 
  0x20, 0x61, 0x20, 0x72, 0x61, 0x77, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x61, 
  0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x70, 0x6F, 0x69, 
  0x6E, 0x74, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 0x73, 0x70, 0x65, 
  0x63, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x68, 0x6F, 0x77, 0x20, 0x4A, 0x61, 0x6E, 0x65, 0x74, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x61, 0x72, 0x67, 0x73, 
  0x60, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 
  0x74, 0x6F, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 
  0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2E, 0xDA, 0x89, 0x26, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x8C, 0x07, 0x83, 0xBF, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x27, 0xDA, 0x08, 0xCE, 
  0x80, 0xF0, 0x28, 0x61, 0x73, 0x6D, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x72, 0x65, 
  0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x65, 
  0x6D, 0x62, 0x6C, 0x79, 0x2E, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x73, 0x79, 0x6E, 0x74, 0x61, 0x78, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 
  0x79, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x6F, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x77, 0x65, 0x62, 0x73, 
  0x69, 0x74, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 
  0x63, 0x6F, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x0A, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 
  0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x0A, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 
  0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 
  0x79, 0x2E, 0xDA, 0x89, 0x28, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x06, 
  0x01, 0xDA, 0x06, 0xDA, 0x89, 0x29, 0xDA, 0x08, 0xCE, 0x4B, 0x28, 0x65, 0x61, 0x63, 0x68, 0x70, 
  0x20, 0x78, 0x20, 0x64, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 
  0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x28, 0x6B, 
  0x65, 0x79, 0x2C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x20, 0x70, 0x61, 0x69, 0x72, 0x20, 
  0x69, 0x6E, 0x20, 0x60, 0x64, 0x73, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0x2B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x83, 0x25, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x2C, 0xDA, 0x08, 0xCE, 0x23, 
  0x28, 0x6F, 0x6E, 0x65, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 
  0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x74, 0x6F, 
  0x20, 0x31, 0x2E, 0xDA, 0x89, 0x2E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 
  0x71, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x2F, 0xDA, 0x08, 0xCE, 0x66, 0x28, 0x65, 0x76, 0x65, 0x72, 
  0x79, 0x3F, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x69, 0x6E, 0x64, 0x60, 0x20, 0x69, 0x73, 0x20, 
  0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 
  0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x0A, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x2E, 0xDA, 0x89, 0x31, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x01, 0x82, 0x6D, 
  0x01, 0xDA, 0x06, 0xDA, 0x89, 0x32, 0xDA, 0x08, 0xCE, 0x5F, 0x28, 0x78, 0x70, 0x72, 0x69, 0x6E, 
  0x74, 0x66, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 
  0x0A, 0x4C, 0x69, 0x6B, 0x65, 0x20, 0x60, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x60, 0x20, 0x62, 
  0x75, 0x74, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x78, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x60, 0x74, 0x6F, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x89, 0x33, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0x9D, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xBD, 0xDA, 0x08, 
  0xCE, 0x5C, 0x28, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x78, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x74, 0x72, 
  0x61, 0x63, 0x74, 0x20, 0x61, 0x20, 0x73, 0x75, 0x62, 0x2D, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 
  0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 
  0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x6F, 0x72, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2E, 0xDA, 0x89, 
  0x34, 0xD3, 0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8E, 0xD2, 
  0x01, 0xDA, 0x06, 0xDA, 0x89, 0x35, 0xDA, 0x08, 0xCE, 0x36, 0x50, 0x61, 0x74, 0x68, 0x20, 0x74, 
  0x6F, 0x20, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6C, 
  0x6F, 0x61, 0x64, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x69, 0x6E, 0x67, 0x20, 0x75, 0x70, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x2E, 
  0xDA, 0x87, 0xB0, 0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x85, 0xD2, 0xDA, 0x08, 0xCE, 0x82, 0x57, 0x28, 
  0x70, 0x75, 0x74, 0x20, 0x64, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x29, 0x0A, 0x0A, 0x41, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6B, 
  0x65, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6D, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x61, 
  0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x49, 0x6E, 0x64, 0x65, 0x78, 
  0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 
  0x65, 0x73, 0x20, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x29, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x61, 0x63, 0x63, 
  0x65, 0x70, 0x74, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 0x69, 
  0x66, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x75, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x6F, 0x75, 0x6E, 
  0x64, 0x73, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 
  0x69, 0x64, 0x65, 0x64, 0x2E, 0x20, 0x49, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2C, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x20, 0x6E, 0x69, 0x6C, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2C, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x20, 
  0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x66, 0x69, 
  0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x30, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x2E, 0x20, 0x49, 0x6E, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x70, 
  0x75, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x65, 0x64, 0x20, 0x69, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 
  0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x68, 0x69, 0x64, 0x65, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x2E, 0x20, 0x50, 0x75, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 
  0x72, 0x65, 0x20, 0x64, 0x73, 0x2E, 0xDA, 0x89, 0x36, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x8C, 0xAB, 0x80, 0xCD, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x37, 0xDA, 0x08, 0xCE, 0x4C, 0x28, 
  0x69, 0x6E, 0x74, 0x2F, 0x75, 0x36, 0x34, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 
  0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x78, 0x65, 0x64, 0x20, 0x75, 
  0x6E, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x36, 0x34, 0x20, 0x62, 0x69, 0x74, 0x20, 0x69, 
  0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x89, 0x38, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xE8, 0x81, 0xD2, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x39, 
  0xDA, 0x08, 0xCE, 0x80, 0xD6, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x63, 0x68, 0x65, 
  0x63, 0x6B, 0x2D, 0x73, 0x65, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 
  0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x73, 0x74, 0x72, 0x60, 0x20, 0x6F, 0x6E, 
  0x6C, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x73, 0x65, 0x74, 
  0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 
  0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x60, 0x73, 0x74, 0x72, 0x60, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x20, 0x69, 0x6E, 0x20, 
  0x60, 0x73, 0x65, 0x74, 0x60, 0x2C, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x69, 0x66, 0x20, 
  0x73, 0x6F, 0x6D, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x73, 
  0x74, 0x72, 0x60, 0x20, 0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 
  0x72, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x73, 0x65, 0x74, 0x60, 0x2E, 0xDA, 0x88, 0x22, 0xD3, 0x04, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x88, 0x59, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x3A, 0xDA, 
  0x08, 0xCE, 0x81, 0x01, 0x28, 0x76, 0x61, 0x72, 0x66, 0x6E, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 
  0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 
  0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0x20, 
  0x60, 0x76, 0x61, 0x72, 0x66, 0x6E, 0x60, 0x20, 0x68, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x61, 0x6D, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x0A, 0x61, 
  0x73, 0x20, 0x60, 0x64, 0x65, 0x66, 0x6E, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x64, 0x65, 
  0x66, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x61, 0x73, 0x20, 0x76, 0x61, 0x72, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 
  0x20, 0x76, 0x61, 0x72, 0x20, 0x60, 0x6E, 0x61, 0x6D, 0x65, 0x60, 0x0A, 0x61, 0x6C, 0x72, 0x65, 
  0x61, 0x64, 0x79, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x69, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x0A, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0x3F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x2E, 0x8B, 0xE1, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x40, 0xDA, 0x08, 0xCE, 0x80, 
  0xC8, 0x28, 0x65, 0x76, 0x2F, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 
  0x6D, 0x20, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 
  0x73, 0x20, 0x65, 0x76, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x65, 
  0x61, 0x72, 0x6C, 0x79, 0x20, 0x69, 0x66, 0x20, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 
  0x6E, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x76, 
  0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x69, 0x73, 0x20, 
  0x72, 0x65, 0x61, 0x63, 0x68, 0x65, 0x64, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x61, 0x6C, 
  0x73, 0x6F, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x65, 0x61, 0x72, 0x6C, 0x79, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 
  0x65, 0x64, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2E, 0xDA, 0x89, 0x41, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0x5F, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x06, 0xDA, 0x08, 
  0xCE, 0x80, 0xB9, 0x28, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x26, 0x20, 0x78, 0x73, 
  0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 
  0x77, 0x6F, 0x72, 0x64, 0x20, 0x62, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 
  0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x78, 0x73, 0x60, 0x20, 0x74, 0x6F, 0x67, 0x65, 0x74, 
  0x68, 0x65, 0x72, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x79, 
  0x74, 0x65, 0x73, 0x20, 0x76, 0x69, 0x61, 0x20, 0x60, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 
  0x65, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2E, 0xDA, 0x89, 0x42, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xF3, 0x01, 0xDA, 0x06, 0xDA, 0x82, 0xF8, 
  0xDA, 0x08, 0xCE, 0x81, 0x3D, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x78, 0x20, 
  0x79, 0x29, 0x0A, 0x0A, 0x50, 0x6F, 0x6C, 0x79, 0x6D, 0x6F, 0x72, 0x70, 0x68, 0x69, 0x63, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x2D, 0x31, 0x2C, 0x20, 0x30, 0x2C, 0x20, 0x31, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x78, 0x20, 
  0x3C, 0x20, 0x79, 0x2C, 0x20, 0x78, 0x20, 0x3D, 0x20, 0x79, 0x2C, 0x20, 0x78, 0x20, 0x3E, 0x20, 
  0x79, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x2E, 0x0A, 
  0x44, 0x69, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 
  0x72, 0x61, 0x74, 0x6F, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 
  0x74, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x73, 0x20, 0x74, 
  0x6F, 0x0A, 0x73, 0x65, 0x65, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x65, 0x69, 
  0x74, 0x68, 0x65, 0x72, 0x20, 0x78, 0x20, 0x6F, 0x72, 0x20, 0x79, 0x20, 0x69, 0x6D, 0x70, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x20, 0x60, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 
  0x60, 0x20, 0x6D, 0x65, 0x74, 0x68, 0x6F, 0x64, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 
  0x61, 0x6E, 0x0A, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x79, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x73, 0x6F, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x75, 0x73, 
  0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6D, 0x65, 0x74, 0x68, 0x6F, 0x64, 0x2E, 0x20, 
  0x49, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x2C, 0x20, 0x69, 0x74, 0x0A, 0x64, 0x65, 0x6C, 0x65, 0x67, 
  0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6D, 
  0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 
  0x73, 0x2E, 0xDA, 0x89, 0x43, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x85, 0x2A, 
  0x01, 0xDA, 0x06, 0xDA, 0x89, 0x44, 0xDA, 0x08, 0xCE, 0x82, 0x84, 0x28, 0x6F, 0x73, 0x2F, 0x64, 
  0x61, 0x74, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x6C, 0x6F, 
  0x63, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 
  0x61, 0x20, 0x64, 0x61, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2C, 0x20, 0x6F, 
  0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x69, 
  0x6D, 0x65, 0x20, 0x69, 0x66, 0x20, 0x60, 0x74, 0x69, 0x6D, 0x65, 0x60, 0x20, 0x69, 0x73, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x73, 0x20, 0x61, 0x72, 0x65, 
  0x20, 0x30, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x2E, 0x20, 0x44, 0x61, 0x74, 0x65, 
  0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x55, 0x54, 0x43, 
  0x20, 0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x60, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x60, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x69, 0x6E, 0x20, 0x77, 0x68, 
  0x69, 0x63, 0x68, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 
  0x65, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x65, 0x64, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 
  0x65, 0x7A, 0x6F, 0x6E, 0x65, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x65, 0x63, 0x6F, 0x6E, 
  0x64, 0x73, 0x20, 0x2D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x73, 
  0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x5B, 0x30, 0x2D, 0x36, 0x31, 0x5D, 0x0A, 0x0A, 0x2A, 
  0x20, 0x3A, 0x6D, 0x69, 0x6E, 0x75, 0x74, 0x65, 0x73, 0x20, 0x2D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x6D, 0x69, 0x6E, 0x75, 0x74, 0x65, 0x73, 0x20, 0x5B, 0x30, 
  0x2D, 0x35, 0x39, 0x5D, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x68, 0x6F, 0x75, 0x72, 0x73, 0x20, 0x2D, 
  0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x68, 0x6F, 0x75, 0x72, 0x73, 
  0x20, 0x5B, 0x30, 0x2D, 0x32, 0x33, 0x5D, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6D, 0x6F, 0x6E, 0x74, 
  0x68, 0x2D, 0x64, 0x61, 0x79, 0x20, 0x2D, 0x20, 0x64, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x6D, 
  0x6F, 0x6E, 0x74, 0x68, 0x20, 0x5B, 0x30, 0x2D, 0x33, 0x30, 0x5D, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 
  0x6D, 0x6F, 0x6E, 0x74, 0x68, 0x20, 0x2D, 0x20, 0x6D, 0x6F, 0x6E, 0x74, 0x68, 0x20, 0x6F, 0x66, 
  0x20, 0x79, 0x65, 0x61, 0x72, 0x20, 0x5B, 0x30, 0x2C, 0x20, 0x31, 0x31, 0x5D, 0x0A, 0x0A, 0x2A, 
  0x20, 0x3A, 0x79, 0x65, 0x61, 0x72, 0x20, 0x2D, 0x20, 0x79, 0x65, 0x61, 0x72, 0x73, 0x20, 0x73, 
  0x69, 0x6E, 0x63, 0x65, 0x20, 0x79, 0x65, 0x61, 0x72, 0x20, 0x30, 0x20, 0x28, 0x65, 0x2E, 0x67, 
  0x2E, 0x20, 0x32, 0x30, 0x31, 0x39, 0x29, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x77, 0x65, 0x65, 0x6B, 
  0x2D, 0x64, 0x61, 0x79, 0x20, 0x2D, 0x20, 0x64, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x77, 0x65, 0x65, 0x6B, 0x20, 0x5B, 0x30, 0x2D, 0x36, 0x5D, 0x0A, 0x0A, 0x2A, 0x20, 
  0x3A, 0x79, 0x65, 0x61, 0x72, 0x2D, 0x64, 0x61, 0x79, 0x20, 0x2D, 0x20, 0x64, 0x61, 0x79, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x79, 0x65, 0x61, 0x72, 0x20, 0x5B, 0x30, 0x2D, 0x33, 
  0x36, 0x35, 0x5D, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x64, 0x73, 0x74, 0x20, 0x2D, 0x20, 0x69, 0x66, 
  0x20, 0x44, 0x61, 0x79, 0x20, 0x4C, 0x69, 0x67, 0x68, 0x74, 0x20, 0x53, 0x61, 0x76, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0xDA, 
  0x89, 0x45, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x4C, 0x01, 0xDA, 0x06, 
  0xDA, 0x89, 0x46, 0xDA, 0x08, 0xCE, 0x67, 0x28, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6C, 0x65, 0x61, 
  0x76, 0x65, 0x20, 0x26, 0x20, 0x63, 0x6F, 0x6C, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x63, 0x6F, 0x6C, 0x2C, 0x20, 
  0x74, 0x68, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x65, 0x74, 0x63, 0x2E, 0xDA, 0x89, 
  0x48, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0x05, 0x83, 0xB4, 0x01, 0xDA, 0x06, 
  0xDA, 0x89, 0x49, 0xDA, 0x08, 0xCE, 0x80, 0xF2, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 
  0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x6D, 0x61, 
  0x6E, 0x69, 0x70, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x65, 0x74, 
  0x77, 0x65, 0x65, 0x6E, 0x20, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x77, 0x6F, 0x75, 0x6C, 0x64, 
  0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x74, 0x6F, 
  0x20, 0x61, 0x64, 0x64, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 
  0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 0xDA, 0x89, 0x4A, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0x54, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0xDF, 0xDA, 
  0x08, 0xCE, 0x80, 0xB6, 0x28, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x26, 0x20, 0x78, 0x73, 
  0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 
  0x62, 0x6F, 0x6C, 0x20, 0x62, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 
  0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x78, 0x73, 0x60, 0x20, 0x74, 0x6F, 0x67, 0x65, 0x74, 0x68, 
  0x65, 0x72, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 
  0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 
  0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x76, 0x69, 0x61, 0x20, 0x60, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 
  0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0xDA, 0x89, 0x4B, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x1C, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x6F, 0xDA, 
  0x08, 0xCE, 0x51, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x65, 0x69, 0x6C, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6D, 
  0x61, 0x6C, 0x6C, 0x65, 0x73, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 
  0x6E, 0x20, 0x78, 0x2E, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6E, 0x61, 0x6E, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0xA2, 0x01, 0xDA, 0x06, 0xC8, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F, 0xDA, 0x08, 0xCE, 0x1B, 0x4E, 0x6F, 0x74, 0x20, 0x61, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x28, 0x49, 0x45, 0x45, 0x45, 0x2D, 0x37, 0x35, 0x34, 
  0x20, 0x4E, 0x61, 0x4E, 0x29, 0xDA, 0x89, 0x4C, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x86, 0x81, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x6E, 0xDA, 0x08, 0xCE, 0x69, 0x28, 0x69, 0x6E, 
  0x74, 0x65, 0x72, 0x70, 0x6F, 0x73, 0x65, 0x20, 0x73, 0x65, 0x70, 0x20, 0x69, 0x6E, 0x64, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 
  0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x69, 0x6E, 0x64, 0x60, 0x20, 0x73, 0x65, 
  0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x0A, 0x60, 0x73, 0x65, 0x70, 0x60, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x89, 0x4D, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x80, 0xA4, 0x81, 0x23, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x4E, 0xDA, 0x08, 0xCE, 0x55, 0x28, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x70, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x28, 0x6C, 0x6F, 0x67, 0x20, 0x62, 0x61, 0x73, 0x65, 
  0x20, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x29, 0x20, 0x2B, 0x20, 0x31, 0x20, 0x6D, 0x6F, 0x72, 
  0x65, 0x20, 0x61, 0x63, 0x63, 0x75, 0x72, 0x61, 0x74, 0x65, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x61, 
  0x6E, 0x20, 0x28, 0x2B, 0x20, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x20, 0x78, 
  0x29, 0x20, 0x31, 0x29, 0xDA, 0x89, 0x4F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 
  0x13, 0x81, 0x73, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x50, 0xDA, 0x08, 0xCE, 0x5B, 0x28, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 
  0x65, 0x61, 0x72, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x74, 0x20, 0x61, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 0x69, 0x74, 0x2D, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xCF, 0x06, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x94, 0x01, 0xDA, 0x06, 0xC8, 
  0x69, 0x57, 0x14, 0x8B, 0x0A, 0xBF, 0x05, 0x40, 0xDA, 0x08, 0xCE, 0x1C, 0x54, 0x68, 0x65, 0x20, 
  0x62, 0x61, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x61, 0x74, 0x75, 
  0x72, 0x61, 0x6C, 0x20, 0x6C, 0x6F, 0x67, 0x2E, 0xDA, 0x89, 0x51, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x84, 0x67, 0x80, 0xE9, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x52, 0xDA, 0x08, 0xCE, 
  0x80, 0x9C, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 0x6E, 0x62, 0x72, 0x65, 0x61, 0x6B, 
  0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 
  0x75, 0x6D, 0x6E, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x61, 0x20, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 
  0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x61, 0x74, 0x20, 0x61, 
  0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 
  0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x63, 0x61, 
  0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0xDA, 0x89, 
  0x53, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0x27, 0x01, 0xDA, 0x06, 0xDA, 
  0x89, 0x16, 0xDA, 0x08, 0xCE, 0x80, 0x8D, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x75, 
  0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x62, 0x69, 0x6E, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 
  0x60, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x63, 0x6F, 0x64, 
  0x65, 0x20, 0x28, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x73, 0x29, 0x2C, 0x20, 0x73, 0x75, 0x63, 0x68, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x0A, 0x60, 0x28, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 
  0x67, 0x65, 0x20, 0x78, 0x29, 0x60, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 
  0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 
  0x78, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x64, 0x69, 0x63, 
  0x74, 0x29, 0x60, 0x2E, 0xDA, 0x89, 0x54, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 
  0x80, 0x80, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x55, 0xDA, 0x08, 0xCE, 0x81, 0x11, 0x28, 0x6F, 0x73, 
  0x2F, 0x77, 0x68, 0x69, 0x63, 0x68, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 
  0x74, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 
  0x3A, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6D, 0x61, 0x63, 
  0x6F, 0x73, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x77, 0x65, 0x62, 0x20, 0x2D, 0x20, 0x57, 0x65, 0x62, 
  0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x20, 0x28, 0x65, 0x6D, 0x73, 0x63, 0x72, 
  0x69, 0x70, 0x74, 0x65, 0x6E, 0x29, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6C, 0x69, 0x6E, 0x75, 0x78, 
  0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x66, 0x72, 0x65, 0x65, 0x62, 0x73, 0x64, 0x0A, 0x0A, 0x2A, 0x20, 
  0x3A, 0x6F, 0x70, 0x65, 0x6E, 0x62, 0x73, 0x64, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6E, 0x65, 0x74, 
  0x62, 0x73, 0x64, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x70, 0x6F, 0x73, 0x69, 0x78, 0x20, 0x2D, 0x20, 
  0x41, 0x20, 0x50, 0x4F, 0x53, 0x49, 0x58, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x74, 0x69, 0x62, 
  0x6C, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x28, 0x64, 0x65, 0x66, 0x61, 0x75, 
  0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x79, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x63, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x6B, 0x65, 
  0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 
  0x61, 0x74, 0x20, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0xDA, 0x89, 
  0x56, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0xA1, 0x80, 0xE6, 0x01, 0xDA, 0x06, 
  0xDA, 0x80, 0xE3, 0xDA, 0x08, 0xCE, 0x81, 0x41, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 
  0x6F, 0x6E, 0x63, 0x61, 0x74, 0x20, 0x61, 0x72, 0x72, 0x20, 0x26, 0x20, 0x70, 0x61, 0x72, 0x74, 
  0x73, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 0x74, 0x65, 0x73, 
  0x20, 0x61, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x20, 0x28, 0x61, 0x6E, 
  0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x29, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 
  0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 
  0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x74, 0x73, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 
  0x6C, 0x65, 0x73, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 
  0x65, 0x61, 0x63, 0x68, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x70, 0x61, 
  0x72, 0x74, 0x73, 0x60, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x70, 0x70, 
  0x65, 0x6E, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x61, 0x72, 0x72, 0x60, 0x20, 0x69, 
  0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x60, 0x61, 0x72, 0x72, 0x60, 0x2E, 0xDA, 0x89, 0x57, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8E, 0x41, 0x03, 0xDA, 0x06, 0xDA, 0x89, 0x58, 0xDA, 0x08, 0xCE, 
  0x80, 0xB6, 0x28, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x20, 
  0x26, 0x6E, 0x61, 0x6D, 0x65, 0x64, 0x20, 0x6D, 0x61, 0x70, 0x2D, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x73, 0x20, 0x6C, 0x61, 0x7A, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x79, 
  0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x6C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x20, 0x74, 0x6F, 
  0x20, 0x69, 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x74, 0x6C, 0x79, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x2C, 
  0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x73, 0x20, 
  0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x73, 0x74, 0x61, 
  0x74, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x61, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x63, 
  0x72, 0x65, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x62, 
  0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2E, 0xDA, 0x89, 0x5B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x8E, 0xD5, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x5C, 0xDA, 0x08, 0xCE, 0x80, 
  0xA1, 0x28, 0x63, 0x6C, 0x69, 0x2D, 0x6D, 0x61, 0x69, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 
  0x0A, 0x0A, 0x45, 0x6E, 0x74, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x4A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x43, 0x4C, 0x49, 0x20, 0x74, 0x6F, 0x6F, 
  0x6C, 0x2E, 0x20, 0x43, 0x61, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 
  0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x0A, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x76, 0x6F, 0x6B, 0x65, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x43, 0x4C, 0x49, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 
  0x65, 0x2E, 0xDA, 0x89, 0x8F, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 
  0x31, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x90, 0xDA, 0x08, 0xCE, 0x3E, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x68, 0x79, 0x70, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x62, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x63, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x65, 0x71, 0x75, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x5E, 0x32, 0x20, 0x3D, 0x20, 0x61, 
  0x5E, 0x32, 0x20, 0x2B, 0x20, 0x62, 0x5E, 0x32, 0x2E, 0xDA, 0x89, 0x91, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 0x54, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0x69, 0xDA, 0x08, 0xCE, 
  0x83, 0xB2, 0x28, 0x6F, 0x73, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x61, 0x62, 0x7C, 0x6B, 0x65, 0x79, 0x29, 0x0A, 0x0A, 0x47, 
  0x65, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 
  0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2C, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x73, 0x74, 0x61, 0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 
  0x72, 0x79, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x69, 0x73, 
  0x74, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x61, 0x72, 0x65, 0x3A, 0x0A, 0x0A, 0x2A, 
  0x20, 0x3A, 0x64, 0x65, 0x76, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 
  0x63, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x69, 0x73, 0x20, 0x6F, 0x6E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6D, 0x6F, 0x64, 0x65, 0x20, 
  0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 
  0x6C, 0x65, 0x2C, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x3A, 0x66, 0x69, 0x6C, 0x65, 
  0x2C, 0x20, 0x3A, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x2C, 0x20, 0x3A, 0x62, 
  0x6C, 0x6F, 0x63, 0x6B, 0x2C, 0x20, 0x3A, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 
  0x2C, 0x20, 0x3A, 0x66, 0x69, 0x66, 0x6F, 0x2C, 0x20, 0x3A, 0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 
  0x2C, 0x20, 0x3A, 0x6C, 0x69, 0x6E, 0x6B, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x3A, 0x6F, 0x74, 0x68, 
  0x65, 0x72, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x69, 0x6E, 0x74, 0x2D, 0x70, 0x65, 0x72, 0x6D, 0x69, 
  0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x2D, 0x20, 0x41, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 
  0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x38, 0x72, 0x37, 0x34, 0x34, 0x0A, 0x0A, 0x2A, 
  0x20, 0x3A, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x2D, 0x20, 
  0x41, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 
  0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x22, 0x72, 
  0x77, 0x78, 0x72, 0x2D, 0x2D, 0x72, 0x2D, 0x2D, 0x22, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x75, 0x69, 
  0x64, 0x20, 0x2D, 0x20, 0x46, 0x69, 0x6C, 0x65, 0x20, 0x75, 0x69, 0x64, 0x0A, 0x0A, 0x2A, 0x20, 
  0x3A, 0x67, 0x69, 0x64, 0x20, 0x2D, 0x20, 0x46, 0x69, 0x6C, 0x65, 0x20, 0x67, 0x69, 0x64, 0x0A, 
  0x0A, 0x2A, 0x20, 0x3A, 0x6E, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x2D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x6C, 0x69, 0x6E, 0x6B, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x72, 0x64, 0x65, 0x76, 0x20, 0x2D, 0x20, 0x52, 
  0x65, 0x61, 0x6C, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 
  0x6C, 0x65, 0x2E, 0x20, 0x30, 0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 
  0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x2D, 0x20, 0x73, 0x69, 0x7A, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20, 0x2D, 0x20, 0x6E, 
  0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x30, 0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 
  0x6E, 0x64, 0x6F, 0x77, 0x73, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 
  0x69, 0x7A, 0x65, 0x20, 0x2D, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x6C, 
  0x6F, 0x63, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x30, 0x20, 
  0x6F, 0x6E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x61, 
  0x63, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x74, 
  0x61, 0x6D, 0x70, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6C, 0x61, 
  0x73, 0x74, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 
  0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x74, 
  0x61, 0x6D, 0x70, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6C, 0x61, 
  0x73, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x64, 0x20, 0x28, 0x70, 0x65, 0x72, 0x6D, 
  0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x64, 0x29, 
  0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x2D, 0x20, 
  0x74, 0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 
  0x64, 0x20, 0x28, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 
  0x65, 0x64, 0x29, 0x0A, 0xDA, 0x89, 0x92, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 
  0xE8, 0x81, 0x61, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x93, 0xDA, 0x08, 0xCE, 0x81, 0x1F, 0x28, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x61, 0x6C, 0x6C, 0x20, 0x70, 
  0x61, 0x74, 0x74, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x61, 0x72, 0x63, 
  0x68, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x74, 
  0x61, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 
  0x20, 0x60, 0x70, 0x61, 0x74, 0x74, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x20, 0x60, 0x73, 0x74, 0x72, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 
  0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x6F, 0x75, 0x6E, 
  0x64, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x73, 0x2E, 0x20, 0x4F, 0x76, 0x65, 0x72, 
  0x6C, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 
  0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 
  0x69, 0x76, 0x69, 0x64, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x2C, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x69, 
  0x6E, 0x67, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x73, 0x74, 
  0x72, 0x60, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 
  0x65, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x66, 0x6F, 
  0x75, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x73, 0x2E, 0xDA, 0x89, 0x94, 
  0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x80, 0xBC, 0xDA, 0x08, 0xCE, 0x81, 0x62, 0x28, 0x72, 0x65, 0x73, 
  0x75, 0x6D, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x78, 
  0x29, 0x0A, 0x0A, 0x52, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 
  0x6F, 0x72, 0x20, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x64, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 
  0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 
  0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 
  0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 
  0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 
  0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x64, 0x69, 0x73, 0x70, 
  0x61, 0x74, 0x63, 0x68, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x6F, 
  0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 
  0x63, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x89, 
  0x95, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8C, 0x55, 0x01, 0xDA, 0x06, 0xDA, 
  0x89, 0x96, 0xDA, 0x08, 0xCE, 0x43, 0x28, 0x65, 0x76, 0x2F, 0x72, 0x65, 0x6C, 0x65, 0x61, 0x73, 
  0x65, 0x2D, 0x72, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x72, 0x77, 0x6C, 0x6F, 0x63, 0x6B, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 
  0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2D, 0x77, 
  0x72, 0x69, 0x74, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x6B, 0xDA, 0x89, 0x97, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xC9, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x0F, 0xDA, 0x08, 0xCE, 
  0x4A, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x89, 0x99, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0xE1, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0xD7, 0xDA, 
  0x08, 0xCE, 0x81, 0x15, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2D, 0x6F, 0x6E, 
  0x2D, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x65, 0x6E, 0x76, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x69, 0x73, 0x2D, 0x72, 0x65, 0x70, 0x6C, 0x29, 0x0A, 
  0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x70, 
  0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x60, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 
  0x6E, 0x74, 0x65, 0x78, 0x74, 0x60, 0x27, 0x73, 0x20, 0x60, 0x3A, 0x6F, 0x6E, 0x2D, 0x73, 0x74, 
  0x61, 0x74, 0x75, 0x73, 0x60, 0x20, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x64, 0x72, 0x6F, 0x70, 0x20, 0x69, 
  0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x20, 0x6F, 
  0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x65, 
  0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x20, 0x6F, 0x6E, 0x6C, 
  0x79, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x62, 0x6E, 0x6F, 0x72, 
  0x6D, 0x61, 0x6C, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x69, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x68, 0x61, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x3A, 0x64, 0x65, 0x62, 0x75, 0x67, 0x60, 0x20, 0x64, 0x79, 
  0x6E, 0x20, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x72, 0x75, 0x74, 
  0x68, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x89, 0x98, 0xD3, 0x03, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x1A, 0x01, 0xDA, 0x06, 0xDA, 0x85, 0xEB, 0xDA, 0x08, 0xCE, 
  0x44, 0x28, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 0x61, 
  0x69, 0x72, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x89, 0x9A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x6E, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x9B, 0xDA, 0x08, 0xCE, 0x21, 0x28, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 
  0x66, 0x20, 0x78, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 0xDA, 0x89, 0x9D, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0xEC, 0x01, 0xDA, 0x06, 0xDA, 0x89, 
  0x9E, 0xDA, 0x08, 0xCE, 0x81, 0x0E, 0x28, 0x6B, 0x65, 0x65, 0x70, 0x20, 0x70, 0x72, 0x65, 0x64, 
  0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x70, 
  0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x60, 0x70, 0x72, 0x65, 0x64, 0x60, 0x2C, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 
  0x73, 0x0A, 0x6F, 0x66, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x79, 0x69, 0x6E, 0x67, 0x20, 0x60, 0x70, 
  0x72, 0x65, 0x64, 0x60, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 
  0x78, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x60, 
  0x69, 0x6E, 0x64, 0x60, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x0A, 0x64, 0x69, 
  0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x60, 0x66, 0x69, 
  0x6C, 0x74, 0x65, 0x72, 0x60, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x0A, 0x74, 0x68, 0x65, 0x20, 
  0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 
  0x74, 0x68, 0x79, 0x2E, 0xDA, 0x89, 0xA0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 
  0xC1, 0x82, 0x36, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x0D, 0xDA, 0x08, 0xCE, 0x81, 0x1C, 0x28, 0x67, 
  0x65, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x6D, 
  0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x20, 0x65, 0x6E, 0x76, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x61, 
  0x64, 0x73, 0x20, 0x61, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x69, 0x6E, 0x70, 
  0x75, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x2C, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 
  0x72, 0x2C, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x6D, 0x70, 
  0x74, 0x2E, 0x20, 0x41, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x6F, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 
  0x74, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0x20, 0x55, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x61, 0x20, 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 
  0x63, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x61, 
  0x6C, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 0x89, 0xA1, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xAA, 0x63, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x21, 0xDA, 0x08, 
  0xCE, 0x71, 0x28, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 
  0x61, 0x70, 0x20, 0x74, 0x75, 0x70, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 0x61, 0x70, 0x20, 0x6D, 
  0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 
  0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2C, 0x20, 0x77, 0x68, 0x69, 
  0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x28, 0x6C, 0x69, 0x6E, 0x65, 0x2C, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 
  0x6E, 0x29, 0x2E, 0xDA, 0x89, 0xA2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 
  0x81, 0x07, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0xBB, 0xDA, 0x08, 0xCE, 0x80, 0xD5, 0x28, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x50, 
  0x75, 0x73, 0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 
  0x65, 0x73, 0x20, 0x6F, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 
  0x6F, 0x66, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x69, 0x6C, 
  0x6C, 0x20, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6F, 0x66, 0x20, 
  0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x2C, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 
  0x73, 0x2C, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 
  0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 
  0x73, 0x2E, 0xDA, 0x89, 0xA3, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x7A, 
  0x01, 0xDA, 0x06, 0xDA, 0x85, 0x65, 0xDA, 0x08, 0xCE, 0x83, 0x15, 0x28, 0x6D, 0x6F, 0x64, 0x75, 
  0x6C, 0x65, 0x2F, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x20, 0x70, 
  0x61, 0x74, 0x68, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x29, 0x0A, 0x0A, 0x45, 
  0x78, 0x70, 0x61, 0x6E, 0x64, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x65, 
  0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 
  0x69, 0x6E, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 
  0x60, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 
  0x6E, 0x64, 0x60, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x28, 0x74, 0x68, 0x65, 0x20, 0x61, 
  0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 
  0x72, 0x65, 0x29, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 
  0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 
  0x70, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x6F, 
  0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x6D, 0x70, 
  0x6F, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x2E, 0x20, 0x54, 0x68, 
  0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 0x3A, 0x0A, 0x0A, 
  0x2A, 0x20, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x20, 0x2D, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x76, 0x65, 0x72, 
  0x62, 0x61, 0x74, 0x69, 0x6D, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x40, 0x61, 0x6C, 0x6C, 0x3A, 
  0x20, 0x2D, 0x2D, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x3A, 0x61, 0x6C, 0x6C, 
  0x3A, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x69, 0x66, 0x20, 0x60, 0x70, 0x61, 0x74, 0x68, 0x60, 
  0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x40, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x2C, 0x0A, 0x20, 0x20, 
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 
  0x73, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x73, 0x65, 0x67, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x61, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x28, 
  0x64, 0x79, 0x6E, 0x20, 0x3C, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 
  0x73, 0x65, 0x67, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 
  0x72, 0x64, 0x3E, 0x29, 0x60, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x63, 0x75, 0x72, 0x3A, 0x20, 
  0x2D, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x2D, 0x66, 0x69, 0x6C, 0x65, 0x29, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 
  0x64, 0x69, 0x72, 0x3A, 0x20, 0x2D, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x72, 0x65, 
  0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 
  0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x3A, 0x20, 0x2D, 0x2D, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6F, 0x6E, 0x65, 0x6E, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2C, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x66, 0x20, 0x67, 0x69, 0x76, 
  0x65, 0x6E, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0x20, 0x2D, 
  0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20, 
  0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x6E, 0x61, 0x74, 
  0x69, 0x76, 0x65, 0x73, 0x2C, 0x20, 0x2E, 0x73, 0x6F, 0x20, 0x6F, 0x72, 0x20, 0x2E, 0x64, 0x6C, 
  0x6C, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x73, 0x79, 0x73, 0x3A, 0x20, 0x2D, 0x2D, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2C, 0x20, 0x6F, 
  0x72, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x73, 0x79, 0x73, 0x70, 0x61, 0x74, 0x68, 0x29, 
  0xDA, 0x89, 0xA4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x84, 0xF6, 0x01, 0xDA, 
  0x06, 0xDA, 0x89, 0xA5, 0xDA, 0x08, 0xCE, 0x30, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x77, 0x64, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x77, 0x6F, 0x72, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x69, 
  0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0xDA, 0x88, 0x2A, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x8A, 0xF6, 0x01, 0xDA, 0x06, 0xDA, 0x88, 0x2E, 0xDA, 0x08, 0xCE, 0x81, 
  0x69, 0x28, 0x64, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6E, 
  0x61, 0x6D, 0x65, 0x64, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x20, 0x73, 0x6F, 
  0x75, 0x72, 0x63, 0x65, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 0x72, 0x20, 0x65, 0x76, 
  0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x61, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x2C, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 
  0x74, 0x69, 0x6E, 0x67, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 
  0x2E, 0x20, 0x3A, 0x65, 0x6E, 0x76, 0x2C, 0x20, 0x3A, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 
  0x72, 0x2C, 0x0A, 0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2C, 0x20, 0x3A, 0x65, 0x76, 0x61, 
  0x6C, 0x75, 0x61, 0x74, 0x6F, 0x72, 0x2C, 0x20, 0x3A, 0x72, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x3A, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 
  0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x6E, 0x64, 0x65, 0x72, 0x6C, 0x79, 0x69, 0x6E, 0x67, 0x0A, 
  0x60, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x60, 0x20, 0x63, 0x61, 
  0x6C, 0x6C, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x60, 0x65, 0x78, 0x69, 0x74, 0x60, 0x20, 0x69, 0x73, 
  0x20, 0x74, 0x72, 0x75, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x74, 0x6F, 0x70, 0x20, 0x6C, 
  0x65, 0x76, 0x65, 0x6C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x74, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x20, 0x61, 0x0A, 0x63, 0x61, 0x6C, 0x6C, 0x20, 
  0x74, 0x6F, 0x20, 0x60, 0x28, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x69, 0x74, 0x20, 0x31, 0x29, 0x60, 
  0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x89, 0xA6, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x86, 0x1B, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xA7, 0xDA, 0x08, 
  0xCE, 0x80, 0x8A, 0x28, 0x6F, 0x73, 0x2F, 0x74, 0x6F, 0x75, 0x63, 0x68, 0x20, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x6D, 0x6F, 
  0x64, 0x74, 0x69, 0x6D, 0x65, 0x29, 0x0A, 0x0A, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x74, 0x69, 0x6D, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x73, 0x65, 
  0x74, 0x73, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0xDA, 0x89, 0xA9, 
  0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x11, 0x01, 0xDA, 0x06, 0xDA, 0x89, 
  0xAA, 0xDA, 0x08, 0xCE, 0x4E, 0x28, 0x66, 0x6F, 0x72, 0x65, 0x76, 0x65, 0x72, 0x20, 0x26, 0x20, 
  0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 
  0x62, 0x6F, 0x64, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x65, 0x76, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 
  0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0xAC, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x78, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0x0A, 0xDA, 0x08, 0xCE, 0x2E, 0x28, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x65, 0x64, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0xDA, 0x89, 0xAD, 0xD3, 0x04, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0x9C, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xAE, 0xDA, 
  0x08, 0xCE, 0x28, 0x28, 0x25, 0x3D, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 
  0x72, 0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x28, 0x73, 0x65, 0x74, 0x20, 
  0x78, 0x20, 0x28, 0x25, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x29, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x89, 
  0xB0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x22, 0x01, 0xDA, 0x06, 
  0xDA, 0x89, 0xB1, 0xDA, 0x08, 0xCE, 0x26, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x67, 0x61, 
  0x6D, 0x6D, 0x61, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x6C, 0x6F, 0x67, 0x2D, 0x67, 0x61, 0x6D, 0x6D, 0x61, 0x28, 0x78, 0x29, 0x2E, 0xDA, 0x89, 0xB2, 
  0xD3, 0x02, 0xDA, 0x06, 0xDA, 0x89, 0xB3, 0xDA, 0x08, 0xCE, 0x34, 0x28, 0x62, 0x6E, 0x6F, 0x74, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x69, 0x74, 0x2D, 0x77, 0x69, 0x73, 0x65, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x73, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x78, 0x2E, 0xDA, 
  0x89, 0xB5, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0xA1, 0x80, 0x80, 0x01, 0xDA, 
  0x06, 0xDA, 0x84, 0x70, 0xDA, 0x08, 0xCE, 0x80, 0xA8, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 
  0x6E, 0x65, 0x77, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x29, 0x0A, 0x0A, 0x43, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x65, 0x6D, 0x70, 
  0x74, 0x79, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 
  0x70, 0x72, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x63, 0x61, 
  0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 
  0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x29, 0x60, 0x20, 0x62, 0x75, 
  0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x65, 0x66, 
  0x66, 0x69, 0x63, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 
  0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 
  0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 
  0x2E, 0xDA, 0x84, 0x8D, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x1B, 0x01, 
  0xDA, 0x06, 0xDA, 0x89, 0xB6, 0xDA, 0x08, 0xCE, 0x88, 0xF2, 0x28, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 
  0x68, 0x65, 0x61, 0x64, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x41, 0x20, 
  0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x6C, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6F, 0x73, 0x65, 0x20, 
  0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 
  0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x69, 0x73, 0x20, 0x73, 0x69, 0x6D, 0x69, 0x6C, 0x61, 
  0x72, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E, 0x20, 
  0x4C, 0x69, 0x73, 0x70, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x0A, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2C, 
  0x20, 0x61, 0x6C, 0x74, 0x68, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x6E, 0x74, 
  0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x6D, 0x75, 0x63, 0x68, 0x20, 0x73, 0x6D, 0x61, 
  0x6C, 0x6C, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x63, 0x6F, 0x70, 0x65, 0x2E, 0x20, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x68, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6C, 0x6F, 0x6F, 0x70, 0x0A, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 
  0x61, 0x69, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 
  0x6F, 0x66, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x6F, 0x72, 0x0A, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 
  0x6C, 0x73, 0x2E, 0x20, 0x41, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x72, 0x65, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x68, 0x69, 0x6E, 
  0x67, 0x0A, 0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x2E, 0x20, 
  0x42, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, 0x72, 0x69, 
  0x74, 0x74, 0x65, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x61, 0x74, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x20, 0x3A, 0x76, 0x65, 0x72, 0x62, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2F, 0x65, 0x78, 
  0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x0A, 0x0A, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 
  0x60, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x62, 
  0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 
  0x20, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x66, 0x2C, 0x20, 0x60, 0x3A, 0x76, 0x65, 0x72, 0x62, 0x60, 
  0x20, 0x69, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x73, 0x65, 0x74, 
  0x20, 0x6F, 0x66, 0x0A, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x73, 0x2C, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x60, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 
  0x79, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x45, 0x61, 
  0x63, 0x68, 0x20, 0x73, 0x75, 0x62, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x74, 0x20, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x0A, 
  0x6E, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x63, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 
  0x6F, 0x75, 0x73, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x0A, 0x0A, 0x54, 0x68, 
  0x65, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x76, 0x65, 0x72, 0x62, 
  0x73, 0x20, 0x61, 0x72, 0x65, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x69, 0x74, 0x65, 0x72, 
  0x61, 0x74, 0x65, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 
  0x6C, 0x79, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x70, 0x72, 
  0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x74, 0x20, 
  0x69, 0x73, 0x0A, 0x20, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 
  0x60, 0x3A, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 
  0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2E, 0x20, 0x54, 
  0x68, 0x65, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 
  0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x74, 0x77, 0x6F, 0x2D, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0A, 0x20, 0x20, 0x61, 
  0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 
  0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x73, 
  0x74, 0x65, 0x70, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 
  0x73, 0x20, 0x68, 0x61, 0x6C, 0x66, 0x0A, 0x20, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x2C, 0x20, 0x5B, 
  0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 
  0x60, 0x3A, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2D, 0x74, 0x6F, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x73, 
  0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x3A, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2C, 0x20, 0x62, 
  0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x69, 0x6E, 0x63, 0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x2C, 0x20, 0x65, 0x6E, 0x64, 0x5D, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x64, 0x6F, 0x77, 
  0x6E, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 
  0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2C, 0x20, 0x73, 0x74, 0x65, 0x70, 0x70, 0x69, 0x6E, 
  0x67, 0x20, 0x64, 0x6F, 0x77, 0x6E, 0x77, 0x61, 0x72, 0x64, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 
  0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 
  0x65, 0x20, 0x61, 0x0A, 0x20, 0x20, 0x74, 0x77, 0x6F, 0x2D, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x73, 
  0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x28, 0x65, 0x78, 0x63, 0x6C, 0x75, 0x73, 
  0x69, 0x76, 0x65, 0x29, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x0A, 
  0x20, 0x20, 0x28, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x21, 0x29, 0x20, 0x73, 0x74, 
  0x65, 0x70, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x64, 0x6F, 
  0x77, 0x6E, 0x2D, 0x74, 0x6F, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 
  0x73, 0x20, 0x3A, 0x64, 0x6F, 0x77, 0x6E, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x73, 
  0x69, 0x76, 0x65, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 0x6E, 0x64, 0x5D, 
  0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x6B, 0x65, 0x79, 0x73, 0x60, 0x20, 0x2D, 0x2D, 0x20, 
  0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 
  0x70, 0x61, 0x69, 0x72, 0x73, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 
  0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x2D, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x61, 0x73, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 
  0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x69, 
  0x6E, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x76, 
  0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 
  0x65, 0x20, 0x6F, 0x72, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x0A, 0x0A, 0x60, 0x6C, 0x6F, 
  0x6F, 0x70, 0x60, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x73, 
  0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x72, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 
  0x69, 0x6E, 0x67, 0x20, 0x66, 0x75, 0x72, 0x74, 0x68, 0x65, 0x72, 0x2E, 0x20, 0x43, 0x6F, 0x6E, 
  0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6F, 0x66, 
  0x0A, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x20, 0x20, 
  0x3A, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 
  0x6E, 0x74, 0x0A, 0x0A, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x60, 0x3A, 0x6D, 0x6F, 0x64, 0x69, 
  0x66, 0x69, 0x65, 0x72, 0x60, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 
  0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x60, 0x20, 0x69, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2D, 0x64, 0x65, 0x70, 
  0x65, 0x6E, 0x64, 0x65, 0x6E, 0x74, 0x2E, 0x0A, 0x60, 0x3A, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 
  0x65, 0x72, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 
  0x66, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x65, 0x78, 
  0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x62, 0x72, 0x65, 
  0x61, 0x6B, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x69, 0x66, 0x20, 0x60, 0x65, 0x78, 
  0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x60, 0x20, 0x69, 0x73, 0x0A, 0x20, 0x20, 0x66, 
  0x61, 0x6C, 0x73, 0x65, 0x79, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x75, 0x6E, 0x74, 0x69, 
  0x6C, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x60, 0x20, 0x2D, 0x2D, 
  0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x69, 0x66, 
  0x20, 0x60, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x60, 0x20, 0x69, 0x73, 
  0x0A, 0x20, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 
  0x6C, 0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x60, 0x20, 0x2D, 0x2D, 
  0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x73, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x61, 0x73, 0x20, 0x70, 0x61, 0x73, 
  0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x0A, 0x20, 0x20, 0x60, 0x6C, 0x65, 
  0x74, 0x60, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x62, 
  0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x60, 0x20, 0x2D, 0x2D, 0x20, 0x65, 
  0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 
  0x74, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 
  0x74, 0x20, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x0A, 0x20, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2E, 0x0A, 
  0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x60, 
  0x20, 0x2D, 0x2D, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x3A, 0x62, 0x65, 
  0x66, 0x6F, 0x72, 0x65, 0x60, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x69, 0x64, 0x65, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 
  0x6E, 0x73, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x0A, 0x20, 0x20, 0x6E, 
  0x65, 0x78, 0x74, 0x20, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2E, 0x0A, 
  0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x20, 0x6E, 0x60, 0x20, 0x2D, 
  0x2D, 0x20, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 
  0x78, 0x74, 0x20, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x60, 0x6E, 
  0x60, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x2E, 0x0A, 0x0A, 0x2A, 0x20, 0x60, 0x3A, 0x77, 0x68, 
  0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x60, 0x20, 0x2D, 0x2D, 
  0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 
  0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x60, 0x63, 0x6F, 0x6E, 0x64, 
  0x69, 0x74, 0x69, 0x6F, 0x6E, 0x60, 0x0A, 0x20, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 
  0x2E, 0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x60, 0x6C, 0x6F, 0x6F, 0x70, 0x60, 0x20, 0x6D, 0x61, 
  0x63, 0x72, 0x6F, 0x20, 0x61, 0x6C, 0x77, 0x61, 0x79, 0x73, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 
  0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 
  0x89, 0xD0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0x86, 0x01, 0xDA, 0x06, 
  0xDA, 0x89, 0xD1, 0xDA, 0x08, 0xCE, 0x39, 0x28, 0x6D, 0x65, 0x61, 0x6E, 0x20, 0x78, 0x73, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x65, 
  0x61, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x65, 0x6D, 0x70, 
  0x74, 0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x4E, 0x61, 0x4E, 0x2E, 
  0xDA, 0x89, 0xD3, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x0D, 0x01, 
  0xDA, 0x06, 0xDA, 0x89, 0xD4, 0xDA, 0x08, 0xCE, 0x36, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 
  0x63, 0x6F, 0x73, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x20, 
  0x61, 0x72, 0x63, 0x63, 0x6F, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 
  0x89, 0xD5, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xB0, 0x81, 0x61, 0x01, 0xDA, 
  0x06, 0xDA, 0x88, 0x17, 0xDA, 0x08, 0xCE, 0x74, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x63, 
  0x6C, 0x6F, 0x6E, 0x65, 0x20, 0x74, 0x61, 0x62, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 
  0x65, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x2E, 0x20, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6F, 0x6C, 0x64, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x76, 0x69, 0x63, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x61, 0x2E, 0xDA, 0x89, 0xD6, 0xD3, 
  0x04, 0xDA, 0x81, 0x07, 0xCB, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x84, 0xAD, 0x01, 0xDA, 
  0x06, 0xDA, 0x89, 0x05, 0xDA, 0x08, 0xCE, 0x80, 0x87, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 
  0x6C, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x70, 0x72, 0x65, 0x66, 
  0x69, 0x78, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x64, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6B, 0x65, 0x79, 
  0x77, 0x6F, 0x72, 0x64, 0x73, 0x20, 0x64, 0x65, 0x63, 0x6C, 0x61, 0x72, 0x65, 0x64, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x60, 0x64, 0x65, 0x66, 0x64, 0x79, 0x6E, 0x60, 0x2E, 0x0A, 0x20, 0x20, 
  0x55, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x76, 
  0x65, 0x6E, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 
  0x69, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x64, 
  0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2E, 
  0xDA, 0x89, 0xD7, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x69, 0x01, 0xDA, 0x06, 
  0xDA, 0x89, 0xD8, 0xDA, 0x08, 0xCE, 0x24, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x3F, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x89, 0xDA, 0xD3, 0x02, 
  0xDA, 0x06, 0xDA, 0x00, 0xDA, 0x08, 0xCE, 0x41, 0x54, 0x68, 0x65, 0x20, 0x72, 0x6F, 0x6F, 0x74, 
  0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x75, 0x73, 0x65, 
  0x64, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 
  0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x28, 0x6D, 
  0x61, 0x6B, 0x65, 0x2D, 0x65, 0x6E, 0x76, 0x29, 0x2E, 0xDA, 0x88, 0x29, 0xD3, 0x04, 0xDA, 0x03, 
  0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8B, 0x7A, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xDB, 0xDA, 0x08, 0xCE, 
  0x82, 0x2E, 0x28, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 
  0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x49, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x61, 
  0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2E, 0x20, 0x46, 0x69, 0x72, 0x73, 0x74, 0x20, 0x72, 
  0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 
  0x6C, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x6D, 0x65, 0x72, 
  0x67, 0x65, 0x73, 0x20, 0x69, 0x74, 0x73, 0x0A, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 
  0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 
  0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x70, 0x72, 
  0x65, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 
  0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 0x61, 0x73, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x65, 
  0x64, 0x2E, 0x0A, 0x28, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x61, 0x73, 0x20, 
  0x6F, 0x72, 0x20, 0x3A, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 
  0x78, 0x29, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 
  0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x0A, 0x75, 0x73, 
  0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 
  0x65, 0x66, 0x69, 0x78, 0x2E, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 
  0x73, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x20, 0x22, 0x60, 0x3A, 0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 
  0x20, 0x74, 0x72, 0x75, 0x65, 0x60, 0x22, 0x0A, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x2D, 0x65, 0x78, 
  0x70, 0x6F, 0x72, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x65, 
  0x64, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x22, 0x60, 
  0x3A, 0x65, 0x78, 0x69, 0x74, 0x20, 0x74, 0x72, 0x75, 0x65, 0x60, 0x22, 0x20, 0x69, 0x73, 0x20, 
  0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x0A, 0x61, 0x6E, 0x79, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 
  0x20, 0x65, 0x6E, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x74, 0x6F, 0x70, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x60, 0x28, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x69, 0x74, 
  0x20, 0x31, 0x29, 0x60, 0x0A, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 
  0x64, 0x2E, 0x20, 0x44, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x4E, 0x4F, 0x54, 0x20, 0x62, 0x65, 0x20, 
  0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x20, 0x3A, 0x66, 
  0x72, 0x65, 0x73, 0x68, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x79, 0x70, 0x61, 0x73, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x0A, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x2E, 
  0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0xDD, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x87, 
  0x63, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xDE, 0xDA, 0x08, 0xCE, 0x81, 0x9E, 0x28, 0x6F, 0x73, 0x2F, 
  0x63, 0x68, 0x6D, 0x6F, 0x64, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x65, 
  0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x2C, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x60, 0x6D, 0x6F, 0x64, 0x65, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 
  0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 
  0x73, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x60, 0x6F, 
  0x73, 0x2F, 0x70, 0x65, 0x72, 0x6D, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x60, 0x2C, 0x20, 
  0x6F, 0x72, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x61, 0x73, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x60, 0x6F, 0x73, 
  0x2F, 0x70, 0x65, 0x72, 0x6D, 0x2D, 0x69, 0x6E, 0x74, 0x60, 0x2E, 0x20, 0x57, 0x68, 0x65, 0x6E, 
  0x20, 0x60, 0x6D, 0x6F, 0x64, 0x65, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x67, 0x65, 0x72, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x74, 
  0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x55, 0x6E, 
  0x69, 0x78, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x2C, 0x20, 0x62, 0x65, 0x73, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 
  0x69, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x6F, 0x63, 0x74, 0x61, 0x6C, 0x2C, 0x20, 0x6C, 0x69, 
  0x6B, 0x65, 0x20, 0x38, 0x72, 0x36, 0x36, 0x36, 0x20, 0x6F, 0x72, 0x20, 0x38, 0x72, 0x34, 0x30, 
  0x30, 0x2E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x69, 0x61, 0x74, 
  0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2C, 0x20, 
  0x67, 0x72, 0x6F, 0x75, 0x70, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 
  0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x2C, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x74, 0x68, 0x75, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x63, 0x6F, 0x6D, 0x62, 
  0x69, 0x6E, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 
  0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x89, 0xDF, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0xD5, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x3D, 0xDA, 0x08, 
  0xCE, 0x80, 0xCD, 0x28, 0x70, 0x75, 0x74, 0x2D, 0x69, 0x6E, 0x20, 0x64, 0x73, 0x20, 0x6B, 0x73, 
  0x20, 0x76, 0x29, 0x0A, 0x0A, 0x50, 0x75, 0x74, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x64, 
  0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x60, 0x64, 
  0x73, 0x60, 0x2E, 0x20, 0x4C, 0x6F, 0x6F, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x60, 
  0x64, 0x73, 0x60, 0x20, 0x76, 0x69, 0x61, 0x0A, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 
  0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x2E, 0x20, 0x4D, 0x69, 0x73, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 
  0x72, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 
  0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 
  0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2C, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 
  0xDA, 0x89, 0xE0, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x99, 0x01, 0xDA, 
  0x06, 0xDA, 0x82, 0x48, 0xDA, 0x08, 0xCE, 0x67, 0x28, 0x6D, 0x61, 0x70, 0x20, 0x66, 0x20, 0x26, 
  0x20, 0x69, 0x6E, 0x64, 0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x70, 0x20, 0x61, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x65, 0x76, 0x65, 0x72, 
  0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x0A, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x73, 0x2E, 0xDA, 
  0x89, 0xE1, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0xF9, 0x01, 0xDA, 0x06, 
  0xDA, 0x89, 0xE2, 0xDA, 0x08, 0xCE, 0x81, 0x48, 0x28, 0x74, 0x72, 0x79, 0x20, 0x62, 0x6F, 0x64, 
  0x79, 0x20, 0x63, 0x61, 0x74, 0x63, 0x68, 0x29, 0x0A, 0x0A, 0x54, 0x72, 0x79, 0x20, 0x73, 0x6F, 
  0x6D, 0x65, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 0x74, 0x63, 
  0x68, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x2E, 0x20, 0x60, 0x62, 0x6F, 0x64, 0x79, 0x60, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 
  0x6F, 0x6E, 0x2C, 0x0A, 0x61, 0x6E, 0x64, 0x20, 0x60, 0x63, 0x61, 0x74, 0x63, 0x68, 0x60, 0x20, 
  0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x0A, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 
  0x69, 0x6E, 0x20, 0x61, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x6F, 
  0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 
  0x66, 0x6F, 0x72, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x72, 
  0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 
  0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x62, 0x6F, 0x64, 0x79, 0x60, 0x20, 0x69, 0x66, 
  0x20, 0x6E, 0x6F, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2C, 0x0A, 0x6F, 0x72, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x63, 0x61, 0x74, 
  0x63, 0x68, 0x60, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 
  0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0xE4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x2E, 0x8B, 
  0xBF, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0xEC, 0xDA, 0x08, 0xCE, 0x66, 0x28, 0x65, 0x76, 0x2F, 0x63, 
  0x6C, 0x6F, 0x73, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 
  0x6F, 0x73, 0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0x20, 0x54, 0x68, 
  0x69, 0x73, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 
  0x20, 0x28, 0x3A, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x29, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x73, 
  0x2E, 0xDA, 0x89, 0xE5, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0x35, 0x01, 
  0xDA, 0x06, 0xDA, 0x89, 0xE6, 0xDA, 0x08, 0xCE, 0x80, 0xA1, 0x28, 0x61, 0x73, 0x2D, 0x3E, 0x20, 
  0x78, 0x20, 0x61, 0x73, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x54, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x20, 0x74, 0x6F, 0x67, 0x65, 
  0x74, 0x68, 0x65, 0x72, 0x2C, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x69, 0x6E, 0x67, 0x20, 
  0x60, 0x61, 0x73, 0x60, 0x20, 0x69, 0x6E, 0x20, 0x60, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x60, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x0A, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6F, 0x75, 0x73, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x78, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x0A, 
  0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x89, 
  0xE8, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x82, 0xD7, 0x01, 0xDA, 0x06, 0xDA, 
  0x84, 0xE3, 0xDA, 0x08, 0xCE, 0x3B, 0x28, 0x6D, 0x61, 0x78, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 
  0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x75, 0x6D, 0x65, 0x72, 0x69, 0x63, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 
  0x2E, 0xDA, 0x89, 0xE9, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0x7E, 
  0x01, 0xDA, 0x06, 0xDA, 0x89, 0xEA, 0xDA, 0x08, 0xCE, 0x6D, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2F, 0x62, 0x69, 0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 
  0x65, 0x78, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 
  0x74, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 
  0x69, 0x74, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2C, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 
  0x69, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x2E, 0xDA, 0x89, 0xEB, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x18, 0x82, 0x7A, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xEC, 0xDA, 0x08, 0xCE, 0x60, 0x28, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2D, 0x66, 0x6E, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x26, 
  0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x41, 0x20, 0x77, 0x72, 0x61, 0x70, 0x70, 0x65, 
  0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6D, 0x61, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x73, 0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x60, 0x28, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0x20, 0x28, 0x66, 0x6E, 0x20, 0x5B, 0x5D, 0x20, 
  0x3B, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x29, 0x60, 0x2E, 0xDA, 
  0x2B, 0xCB, 0xDA, 0x89, 0xEE, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x82, 
  0x51, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xEF, 0xDA, 0x08, 0xCE, 0x41, 0x28, 0x74, 0x72, 0x61, 0x63, 
  0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x29, 0x0A, 0x0A, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x20, 
  0x74, 0x72, 0x61, 0x63, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x89, 0xF0, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8A, 0xC2, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x37, 
  0xDA, 0x08, 0xCE, 0x42, 0x41, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 
  0x20, 0x64, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x65, 0x64, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x67, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x89, 0xF1, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x84, 0xC1, 0x81, 0x7E, 0x01, 0xDA, 0x06, 0xDA, 0x84, 0xEA, 0xDA, 0x08, 0xCE, 0x81, 0x54, 
  0x28, 0x73, 0x63, 0x61, 0x6E, 0x2D, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x61, 0x73, 0x65, 0x29, 0x0A, 0x0A, 0x50, 0x61, 0x72, 
  0x73, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2C, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 
  0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 
  0x72, 0x65, 0x61, 0x6C, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x61, 0x6D, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x61, 0x73, 0x20, 0x6E, 
  0x75, 0x6D, 0x62, 0x65, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 
  0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x2E, 0x20, 0x57, 0x69, 0x6C, 
  0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x6F, 0x6E, 0x20, 
  0x61, 0x6E, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 
  0x72, 0x2E, 0x20, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x70, 0x72, 
  0x6F, 0x76, 0x69, 0x64, 0x65, 0x20, 0x61, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x2D, 0x20, 0x69, 
  0x66, 0x20, 0x61, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 
  0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x6E, 0x6F, 0x20, 0x72, 0x61, 0x64, 0x69, 0x78, 0x20, 0x73, 
  0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78, 0x70, 0x65, 
  0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x65, 0x67, 0x69, 
  0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x2E, 0xDA, 0x89, 0xF2, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x0C, 
  0x85, 0x12, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xF3, 0xDA, 0x08, 0xCE, 0x80, 0xCB, 0x28, 0x66, 0x66, 
  0x69, 0x2F, 0x6A, 0x69, 0x74, 0x66, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x29, 0x0A, 0x0A, 
  0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 
  0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x20, 0x74, 0x6F, 0x20, 0x60, 0x66, 0x66, 0x69, 0x2F, 0x63, 0x61, 0x6C, 0x6C, 0x60, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x60, 
  0x62, 0x79, 0x74, 0x65, 0x73, 0x60, 0x20, 0x69, 0x73, 0x20, 0x61, 0x72, 0x63, 0x68, 0x69, 0x74, 
  0x65, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 
  0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x6F, 0x70, 0x69, 0x65, 0x64, 
  0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x2E, 0xDA, 0x88, 0x2B, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x8B, 0x6A, 0x01, 0xDA, 0x06, 0xDA, 0x87, 0x3C, 0xDA, 0x08, 0xCE, 0x80, 
  0x86, 0x28, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x2A, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 
  0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 
  0x60, 0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 
  0x72, 0x73, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x0A, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x73, 0x20, 0x73, 0x68, 0x6F, 
  0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x69, 
  0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2E, 0xDA, 0x89, 0xF4, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x81, 0x01, 0x80, 0xB5, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0x53, 0xDA, 0x08, 0xCE, 0x81, 
  0xAA, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x20, 0x77, 0x68, 
  0x61, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x61, 0x64, 0x20, 0x61, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x60, 0x66, 0x60, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2E, 0x20, 0x41, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x60, 0x62, 0x75, 
  0x66, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 
  0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 
  0x6C, 0x20, 0x74, 0x68, 0x69, 0x72, 0x64, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 
  0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x63, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x64, 0x2E, 0x20, 0x60, 0x77, 0x68, 0x61, 0x74, 0x60, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 
  0x65, 0x67, 0x65, 0x72, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 
  0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x20, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x73, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x60, 0x77, 0x68, 0x61, 0x74, 0x60, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 
  0x3A, 0x61, 0x6C, 0x6C, 0x20, 0x2D, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x77, 0x68, 0x6F, 0x6C, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x6C, 
  0x69, 0x6E, 0x65, 0x20, 0x2D, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x20, 
  0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x0A, 0x0A, 0x2A, 0x20, 0x6E, 0x20, 0x28, 
  0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x29, 0x20, 0x2D, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 
  0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0xDA, 0x89, 0xF5, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x89, 0x06, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0xF7, 0xDA, 
  0x08, 0xCE, 0x54, 0x28, 0x77, 0x61, 0x72, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 
  0x20, 0x6D, 0x73, 0x67, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x29, 0x0A, 
  0x0A, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x77, 
  0x61, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x89, 0xF6, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 
  0x00, 0xDA, 0x82, 0xA1, 0x80, 0xB5, 0x01, 0xDA, 0x06, 0xDA, 0x81, 0x4C, 0xDA, 0x08, 0xCE, 0x66, 
  0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x20, 0x61, 0x72, 0x72, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x4D, 0x6F, 
  0x64, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x69, 0x74, 0x2E, 0xDA, 0x89, 0xF7, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 
  0xDA, 0x18, 0x82, 0xB6, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xF8, 0xDA, 0x08, 0xCE, 0x6F, 0x28, 0x63, 
  0x6F, 0x6D, 0x70, 0x20, 0x26, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x29, 
  0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 
  0x6D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x6F, 
  0x73, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0xDA, 0x88, 0x24, 
  0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x4A, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xFA, 
  0xDA, 0x08, 0xCE, 0x43, 0x28, 0x76, 0x61, 0x72, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 
  0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 
  0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x72, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 
  0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0xFC, 0xD3, 0x03, 0xDA, 
  0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x66, 0x01, 0xDA, 0x06, 0xDA, 0x83, 0xF0, 0xDA, 0x08, 0xCE, 
  0x24, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 
  0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x89, 0xFD, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x85, 0x9D, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0xFE, 0xDA, 0x08, 0xCE, 0x81, 0x07, 0x28, 0x69, 
  0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 0x64, 0x73, 0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 0x65, 0x6E, 
  0x20, 0x61, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x60, 
  0x64, 0x73, 0x60, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x0A, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x64, 0x73, 0x60, 0x20, 
  0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2C, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 
  0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x0A, 0x69, 0x6E, 
  0x20, 0x60, 0x64, 0x73, 0x60, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x2C, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x6F, 0x73, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x0A, 0x62, 0x65, 0x63, 0x6F, 0x6D, 0x65, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x8A, 0x04, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 
  0x18, 0x80, 0xC6, 0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x05, 0xDA, 0x08, 0xCE, 0x81, 0x0A, 0x28, 0x63, 
  0x6F, 0x6E, 0x64, 0x20, 0x26, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x76, 
  0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 
  0x6E, 0x73, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x74, 0x69, 0x61, 0x6C, 0x6C, 0x79, 0x20, 
  0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 
  0x74, 0x72, 0x75, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x69, 
  0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 
  0x6E, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 
  0x6F, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x62, 0x6F, 0x64, 
  0x79, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 
  0x61, 0x6E, 0x0A, 0x6F, 0x64, 0x64, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6E, 0x6F, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 
  0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 
  0x73, 0x73, 0x69, 0x6F, 0x6E, 0x0A, 0x69, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 
  0x64, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 
  0x6E, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x89, 0xA8, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0xBE, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x7C, 0xDA, 
  0x08, 0xCE, 0x81, 0x88, 0x28, 0x72, 0x65, 0x70, 0x6C, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x63, 
  0x68, 0x75, 0x6E, 0x6B, 0x73, 0x20, 0x6F, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x65, 
  0x6E, 0x76, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x29, 0x0A, 
  0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x2E, 0x20, 0x54, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x61, 0x6C, 0x6C, 
  0x20, 0x74, 0x6F, 0x0A, 0x67, 0x65, 0x74, 0x20, 0x61, 0x20, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0x20, 
  0x6F, 0x66, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 
  0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x61, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 
  0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x20, 
  0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x69, 0x73, 0x0A, 0x63, 0x61, 0x75, 0x67, 0x68, 0x74, 
  0x2E, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 
  0x65, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x65, 0x6E, 
  0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 
  0x74, 0x6F, 0x20, 0x72, 0x75, 0x6E, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x20, 
  0x69, 0x6E, 0x2C, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x20, 0x61, 0x73, 0x20, 0x61, 
  0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x20, 0x6F, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x61, 0x73, 0x73, 0x0A, 0x74, 0x6F, 0x20, 0x60, 0x72, 
  0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x60, 0x2E, 0xDA, 0x8A, 0x07, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x82, 0x41, 0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x08, 
  0xDA, 0x08, 0xCE, 0x5E, 0x28, 0x6F, 0x73, 0x2F, 0x70, 0x72, 0x6F, 0x63, 0x2D, 0x77, 0x61, 0x69, 
  0x74, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x29, 0x0A, 0x0A, 0x42, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x75, 
  0x6E, 0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 0x70, 0x72, 0x6F, 0x63, 
  0x65, 0x73, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 0x70, 0x72, 
  0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x63, 0x6F, 0x64, 
  0x65, 0x2E, 0xDA, 0x8A, 0x09, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x85, 0x6B, 
  0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x0A, 0xDA, 0x08, 0xCE, 0x31, 0x28, 0x70, 0x61, 0x72, 0x74, 0x69, 
  0x61, 0x6C, 0x20, 0x66, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x50, 0x61, 
  0x72, 0x74, 0x69, 0x61, 0x6C, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 
  0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x8A, 0x00, 0xD3, 0x04, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x8D, 0xEE, 0x03, 0xDA, 0x06, 0xDA, 0x8A, 0x01, 0xDA, 
  0x08, 0xCE, 0x80, 0x84, 0x28, 0x65, 0x76, 0x2F, 0x64, 0x6F, 0x2D, 0x74, 0x68, 0x72, 0x65, 0x61, 
  0x64, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x73, 
  0x6F, 0x6D, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 
  0x77, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2E, 0x20, 0x53, 0x75, 0x73, 0x70, 0x65, 0x6E, 
  0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 
  0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x0A, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 
  0x20, 0x74, 0x6F, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x8A, 0x0C, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x80, 0xA4, 0x81, 0x1D, 0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x0D, 
  0xDA, 0x08, 0xCE, 0x2D, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x62, 0x73, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x62, 0x73, 
  0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 
  0x2E, 0xDA, 0x8A, 0x0E, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x50, 0x01, 
  0xDA, 0x06, 0xDA, 0x8A, 0x0F, 0xDA, 0x08, 0xCE, 0x72, 0x28, 0x73, 0x6F, 0x72, 0x74, 0x2D, 0x62, 
  0x79, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x53, 0x6F, 0x72, 0x74, 0x73, 0x20, 
  0x60, 0x69, 0x6E, 0x64, 0x60, 0x20, 0x69, 0x6E, 0x2D, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x62, 
  0x79, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x60, 0x66, 0x60, 0x20, 0x6F, 0x6E, 0x20, 0x65, 0x61, 0x63, 0x68, 
  0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x0A, 0x63, 0x6F, 0x6D, 
  0x70, 0x61, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 
  0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x3C, 0x60, 0x2E, 0xDA, 0x8A, 0x11, 0xD3, 0x02, 
  0xDA, 0x06, 0xDA, 0x8A, 0x12, 0xDA, 0x08, 0xCE, 0x5B, 0x28, 0x62, 0x61, 0x6E, 0x64, 0x20, 0x26, 
  0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x62, 0x69, 0x74, 0x2D, 0x77, 0x69, 0x73, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 
  0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x78, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x78, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 
  0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x67, 0x65, 0x72, 0x2E, 0xDA, 0x8A, 0x14, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 
  0x83, 0x5D, 0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x15, 0xDA, 0x08, 0xCE, 0x80, 0x92, 0x28, 0x73, 0x6F, 
  0x72, 0x74, 0x65, 0x64, 0x2D, 0x62, 0x79, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x6F, 
  0x72, 0x74, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x73, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x20, 0x62, 0x79, 0x20, 0x69, 0x6E, 0x76, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x0A, 0x61, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x60, 0x66, 0x60, 0x20, 0x6F, 0x6E, 0x20, 
  0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 
  0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x3C, 0x60, 0x2E, 0xDA, 
  0x8A, 0x17, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x81, 0x13, 0x81, 0x3C, 0x01, 0xDA, 
  0x06, 0xDA, 0x8A, 0x18, 0xDA, 0x08, 0xCE, 0x60, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 
  0x70, 0x6F, 0x70, 0x6E, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 
  0x20, 0x60, 0x6E, 0x60, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x8A, 0x19, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x80, 0x9A, 0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x1A, 0xDA, 0x08, 0xCE, 0x29, 
  0x28, 0x2A, 0x3D, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x68, 
  0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x28, 0x73, 0x65, 0x74, 0x20, 0x78, 0x20, 0x28, 
  0x5C, 0x2A, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x29, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x8A, 0x1C, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x83, 0x6F, 0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x1D, 
  0xDA, 0x08, 0xCE, 0x80, 0xA3, 0x28, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x32, 0x20, 0x66, 0x20, 
  0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x32, 0x2D, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 
  0x60, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x60, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6F, 
  0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 
  0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x2E, 0x0A, 0x49, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 
  0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 
  0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x8A, 0x1F, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 
  0x03, 0x00, 0xDA, 0x18, 0x82, 0x6F, 0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x20, 0xDA, 0x08, 0xCE, 0x80, 
  0xA7, 0x28, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x68, 0x65, 0x61, 0x64, 0x20, 
  0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 
  0x61, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 
  0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x60, 0x6C, 0x6F, 0x6F, 0x70, 0x60, 0x20, 0x73, 0x79, 0x6E, 0x74, 0x61, 0x78, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x0A, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x69, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 
  0x20, 0x53, 0x65, 0x65, 0x20, 0x60, 0x6C, 0x6F, 0x6F, 0x70, 0x60, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x64, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x8A, 0x22, 0xD3, 0x03, 
  0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x04, 0x80, 0xA4, 0x01, 0xDA, 0x06, 0xDA, 0x89, 0x77, 0xDA, 
  0x08, 0xCE, 0x80, 0x89, 0x28, 0x6F, 0x73, 0x2F, 0x61, 0x72, 0x63, 0x68, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x53, 0x41, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x77, 0x61, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 
  0x69, 0x6C, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x78, 0x38, 
  0x36, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x78, 0x36, 0x34, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x61, 0x72, 
  0x6D, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x61, 0x61, 0x72, 0x63, 0x68, 0x36, 0x34, 0x0A, 0x0A, 0x2A, 
  0x20, 0x3A, 0x73, 0x70, 0x61, 0x72, 0x63, 0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x77, 0x61, 0x73, 0x6D, 
  0x0A, 0x0A, 0x2A, 0x20, 0x3A, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x0A, 0xDA, 0x8A, 0x23, 
  0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x86, 0x10, 0x01, 0xDA, 0x06, 0xDA, 0x88, 
  0x20, 0xDA, 0x08, 0xCE, 0x3C, 0x28, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 
  0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 
  0x2E, 0xDA, 0x8A, 0x24, 0xD3, 0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x82, 0xA1, 0x80, 0x98, 
  0x01, 0xDA, 0x06, 0xDA, 0x8A, 0x25, 0xDA, 0x08, 0xCE, 0x80, 0xA4, 0x28, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2F, 0x66, 0x69, 0x6C, 0x6C, 0x20, 0x61, 0x72, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 
  0x61, 0x6C, 0x6C, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 
  0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x60, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x60, 0x20, 0x28, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x69, 0x6C, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 
  0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 
  0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 
  0x8A, 0x26, 0xD3, 0x04, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x18, 0x80, 0x96, 0x01, 0xDA, 0x06, 
  0xDA, 0x8A, 0x27, 0xDA, 0x08, 0xCE, 0x22, 0x28, 0x2B, 0x2B, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x49, 
  0x6E, 0x63, 0x72, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 
  0x72, 0x20, 0x78, 0x20, 0x62, 0x79, 0x20, 0x31, 0x2E, 0xDA, 0x2B, 0xCB, 0xDA, 0x8A, 0x29, 0xD3, 
  0x03, 0xDA, 0x03, 0xD2, 0x03, 0x00, 0xDA, 0x84, 0xC1, 0x81, 0x49, 0x01, 0xDA, 0x06, 0xDA, 0x81, 
  0x38, 0xDA, 0x08, 0xCE, 0x80, 0xB6, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x26, 0x20, 
  0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x62, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 
  0x6E, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x60, 0x78, 0x73, 0x60, 0x20, 0x74, 0x6F, 0x67, 0x65, 
  0x74, 0x68, 0x65, 0x72, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 
  0x73, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x20, 0x76, 0x69, 0x61, 0x20, 0x60, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 
  0x62, 0x65, 0x60, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 
  0
};

const unsigned char *janet_core_image = janet_core_image_bytes;
size_t janet_core_image_size = sizeof(janet_core_image_bytes);
